
=> Detection & Bypass Mechanisms

SafetyNet / Play Integrity API:
- Google’s service that checks device integrity, bootloader state, system modifications.
- Apps (banking, payments, streaming) use it to decide if they should run.
- Rooted/unlocked devices often fail this check.
- MagiskHide / Zygisk tries to spoof a clean state.

Root Detection & Bypass:
- How Apps Detect Root:
    - Apps look for indicators such as: Presence of su binary.
    - Unlocked bootloader state.
    - Modified or missing Verified Boot keys.
    - Magisk files or root manager packages.
    - Writable system partitions.
    - Debuggable build tags.
    - Hooked processes (via Xposed, Zygisk).
- Bypassing Root Detection:
    - Magisk Features:
        - Zygisk (Magisk in Zygote) -> injects code at app launch.
        - DenyList -> hides Magisk & root from selected apps.
        - Shamiko module -> stronger hiding, bypasses stricter checks.
    - File/Path Hiding:
        - Rename/remove su and Magisk-related files.
        - Use modules like MagiskHide Props Config.
    - SafetyNet / Play Integrity Workarounds:
        - Universal SafetyNet Fix module.
        - Custom props (fingerprint spoofing).
        - Work with spoofed device profile.
    - App-Specific Workarounds:
        - Patching the APK (smali edits, Frida hooks).
        - Using LSPosed/Xposed modules for targeted bypass.
- Limitations:
    - Google is tightening Play Integrity API -> harder to bypass.
    - Some banking/UPI apps now detect even Zygisk or Shamiko.
    - There’s no 100% universal method; bypass depends on:
        - Device.
        - Android version.
        - Security patches.
        - Detection logic of the app.

Bootloader Unlock Detection:
- How It’s Detected:
    - Apps (especially banking/DRM/enterprise) check if your bootloader is unlocked by looking at:
    - OEM flags: ro.boot.verifiedbootstate, ro.boot.flash.locked, ro.boot.vbmeta.device_state.
    - dm-verity state (Orange/Yellow/Red boot screen).
    - AVB (Android Verified Boot) integrity.
    - SafetyNet / Play Integrity API -> reports bootloader unlock status.
- Why Apps Care:
    - Unlocked bootloader = system could be modified.
    - Even without root, apps assume device is insecure.
    - Some apps outright block usage (banking, UPI, Widevine L1 -> L3 downgrade).
- Bootloader Unlock Detection Bypass:
    - Magisk Props / Property Spoofing:
        - Use MagiskHide Props Config to override values:
            ro.boot.flash.locked=1
            ro.boot.vbmeta.device_state=locked
            ro.boot.verifiedbootstate=green
        - Makes the system “report” as locked.
    - Play Integrity Fixes:
        - Install modules like Universal SafetyNet Fix + Play Integrity Fix.
        - Helps pass device integrity checks that report bootloader state.
    - Zygisk + DenyList:
        - Use Magisk’s DenyList (or Shamiko) to hide Magisk/Zygisk itself.
        - Some apps combine bootloader + root detection -> both must be hidden.
    - Custom Patching / Hooks:
        - Advanced: Hook APIs with LSPosed/Frida to intercept calls that query bootloader state.
        - Example: Hook KeyAttestation or SafetyNet calls and return spoofed values.
    - Relocking Bootloader (Fake / Real):
        - Real relock: Flash stock firmware and lock again (may brick if system modified).
        - Fake relock: Some OEMs can be tricked by patched vbmeta images, but risky.
- Limitations:
    - Google’s Play Integrity API is server-side -> spoofing properties may not always work.
    - Some apps use hardware-backed key attestation (TEE/TrustZone) -> much harder to bypass.
    - Bypass success depends on device + Android version + app’s detection logic.
- Bootloader unlock detection is usually bypassed by spoofing boot properties (ro.boot.*), using Magisk modules (Props, SafetyNet/Play Integrity fixes), or hooking attestation APIs.
- But hardware-backed checks are making this harder on modern devices.

Developer Options Detection:
- Some apps (banking, UPI, streaming, exam apps) check if Developer Options is enabled.
- Because Dev Options allows:
    - USB debugging (ADB) -> potential for reverse engineering, data extraction.
    - Mock locations -> GPS spoofing.
    - OEM unlocking -> signals tampering risk.
- How Apps Detect It:
    - Apps read certain system settings:
        Settings.Global.DEVELOPMENT_SETTINGS_ENABLED
        Settings.Global.ADB_ENABLED
        Settings.Secure.ALLOW_MOCK_LOCATION
    - Or by checking if ADB daemon is running.
- Developer Options Bypass:
    - Settings Spoofing:
        - Use LSPosed / Xposed modules or Frida hooks to override these values.
        - Example: Hook the Settings.Global.getInt() call and force return 0 (disabled).
    - Magisk Modules:
        - Some Magisk modules can spoof system properties to hide dev options / USB debugging.
        - Custom modules can patch settings.db values at runtime.
    - Manual (Temporary) Bypass:
        - Simply disable Developer Options in Settings -> System -> Developer Options -> toggle off before launching the app.
        - But not always convenient if you rely on ADB/USB debugging.
    - Advanced Hooking:
        - For stricter apps, use Frida / LSPosed scripts to intercept method calls inside the app’s code that check developer options.
        - Example: If app calls isDevelopmentSettingsEnabled(), hook it to always return false.
- Limitations:
    - Some apps combine Dev Options + Root + Bootloader unlock detection -> need multi-layer bypass.
    - On newer Android versions, hiding ADB debugging while keeping it active is trickier (apps can detect daemon).

SSL Pinning:
- SSL Pinning (a.k.a. Certificate Pinning) is a security technique where an app is programmed to only trust a specific SSL/TLS certificate (or public key) when connecting to a server — instead of trusting all certificates in the device’s system trust store.
- Why It’s Used:
    - Normally:
        - Android apps trust hundreds of CA root certificates (built into the OS).
        - If a malicious actor installs a custom CA on the device, they could perform a Man-in-the-Middle (MITM) attack with a fake certificate.
    - With SSL Pinning:
        - The app has the server’s certificate or public key “pinned” inside its code.
        - When connecting, it verifies:
            - “Does this cert/key match the pinned one?”
            - If yes -> connection allowed.
            - If no -> connection blocked, even if the cert is valid globally.
- Example:
    - Without pinning:
        - App -> Trusts any cert signed by a trusted CA.
    - With pinning:
        - App -> Only trusts yourbank.com’s exact certificate/key.
        - Stops MITM attacks with fake certs (even if attacker has a trusted CA).
- How It’s Done:
    - Certificate pinning: App stores full server certificate.
    - Public key pinning: App stores server’s public key (safer across certificate renewals).
    - Implemented via libraries like OkHttp, TrustManager, or Android’s Network Security Config.
- Downsides:
    - Cert/key changes -> app must update or it breaks connectivity.
    - Harder during server migrations.
    - Adds maintenance overhead.
- In Short: SSL Pinning = hardcoding the server’s cert/key in the app, so it only trusts that and rejects all others.
It protects against MITM attacks, but can cause issues if the certificate changes and the app isn’t updated.
- Bypass SSL Pinning:
    - Frida Hooks:
        - Frida = dynamic instrumentation tool (attach to running process, hook methods).
        - Write a script to override SSL/TLS validation functions.
        - Example: Hook Java classes like checkServerTrusted() or OkHttp’s CertificatePinner.
        - Effect: Always return “valid” regardless of certificate.
    - Objection (Frida-based tool):
        - Ready-made toolkit built on Frida.
        - Run:
            objection --gadget <app> explore
            android sslpinning disable
        - Quickly disables SSL pinning in many apps without writing custom code.
    - Xposed / LSPosed Modules:
        - Install modules like:
            - JustTrustMe -> bypass SSL pinning by overriding trust checks.
            - SSLUnpinning -> hooks known libraries.
        - Works system-wide once installed.
    - Magisk Modules:
        - TrustMeAlready (for Magisk/Zygisk) patches SSL functions at runtime.
        - Integrates with modern Magisk hiding techniques.
    - Manual Patching:
        - Smali code patching: Decompile the APK with tools like Apktool.
        - Find SSL pinning logic (e.g., checkServerTrusted).
        - Modify it to skip validation or always return true.
        - Recompile & sign the app.
    - Network Security Config Override:
        - If app uses Android’s network_security_config.xml, sometimes you can modify or inject your own config to accept custom CAs.
        - Easier if app isn’t heavily obfuscated.
- Challenges:
    - Newer apps use native libraries (C/C++ with OpenSSL, BoringSSL, custom checks).
    - Stronger obfuscation = harder to hook.
    - Some apps combine SSL pinning with root/jailbreak detection, so bypassing both may be required.
- In Short: To bypass SSL pinning, pentesters use runtime hooking (Frida/Objection/Xposed/Magisk) or static patching (smali/native) to disable certificate validation. This allows intercepting traffic via Burp, MITMproxy, etc.

Debugger Checks (Anti-Debugging):
- Apps (especially banking, exam, and gaming apps) often check if a debugger is attached to prevent reverse engineering or runtime tampering.
- Common Ways Apps Detect Debuggers:
    - Java-based checks:
        - Debug.isDebuggerConnected()
        - Debug.waitingForDebugger()
    - System property checks:
        - android.os.Debug APIs
        - adb presence (checking ro.debuggable or ro.secure)
    - Native (NDK) checks:
        - Using ptrace() to detect if a debugger is attached.
        - Checking /proc/self/status -> field TracerPid (non-zero = being debugged).
    - Timing checks:
        - Measure execution time of loops; debuggers slow down execution -> triggers detection.
- Bypassing Debugger Checks:
    - Frida Hooking:
        - Hook Java methods:
            Java.perform(function() {
                var Debug = Java.use("android.os.Debug");
                Debug.isDebuggerConnected.implementation = function() {
                    return false; // Always say "no debugger"
                };
            });
        - Works for both isDebuggerConnected() and waitingForDebugger().
    - Objection (Frida wrapper):
        - Has built-in scripts for bypassing debugger checks.
        - Example: android hooking watch class android.os.Debug
    - Xposed / LSPosed Modules:
        - Modules like Hide My Applist or custom hooks override Debug APIs.
        - Force them to always return “not being debugged.”
    - Magisk Modules:
        - Kernel-level hooking modules can hide debugging flags and TracerPid.
    - Native (ptrace / TracerPid) Bypass:
        - Use Frida’s Interceptor.attach to hook libc functions (ptrace, open, read).
        - Example: Hook ptrace() and force return 0 so app thinks no debugger attached.
        - Patch /proc/self/status reads to always return TracerPid: 0.
    - Static Patching:
        - Decompile with Apktool -> find where Debug.isDebuggerConnected() is used.
        - Replace with const/4 v0, 0x0 (false).
        - Rebuild and sign APK.
- Limitations:
    - Some apps combine anti-debugging + root detection + SSL pinning.
    - Need multi-layer bypass (Frida + Magisk + network hooks).
- In Short:
    - Debugger checks look for attached debuggers (Java, system props, ptrace, TracerPid).
    - Bypass = hooking, patching, or spoofing values to make the app always think no debugger is attached.

Summary:
- SafetyNet/Play Integrity = detect compromise
- Rooting = gains admin control but bypasses protections
- Bootloader + Verified Boot = prevent tampering
- SELinux = control access


=> Hooking / Bypass Frameworks

Xposed Framework:
- A runtime hooking framework for Android.
- Lets you modify Java methods of apps/system without modifying APKs.
- Needs: Root + (old) Xposed installer.
- Use case: Hooking methods system-wide, modifying app logic.
- Downside: Outdated, limited support on modern Android.
- You install modules (like Magisk modules, but for runtime hooking) that can:
    - Bypass root detection
    - Disable SSL pinning
    - Modify app behavior (ads, UI tweaks, etc.)

Riru:
- A Magisk module that injects code into Android’s zygote process (the parent of all app processes).
- This allows frameworks like Xposed to run on modern Android versions.
- Think of Riru as the bridge between Magisk (root layer) and Xposed (runtime hooking layer).

LSPosed (a.k.a. LXposed):
- Modern, actively maintained Xposed variant that works with Riru.
- Runs via: Riru (older) or Zygisk (newer Magisk).
- More stable and secure than older Xposed.
- Features:
    - Per-app module scope (hook only specific apps instead of global).
    - Better compatibility with modern Android (10+).
    - Works seamlessly with Magisk.
- Use case: Install modules like JustTrustMe (SSL pinning bypass), RootCloak, debugger bypass, etc.

Frida:
- Type: Dynamic instrumentation toolkit.
- Needs: Root OR non-root with Frida gadget injected.
- Strengths:
    - Write custom scripts in JavaScript.
    - Hook both Java & native (C/C++) methods.
    - Works even on obfuscated apps.
- Use case: On-the-fly debugging, SSL pinning bypass, root detection bypass, native library patching.
- Downside: Needs more manual work than Xposed modules.

How They Work Together:
Magisk -> Root access & systemless modifications.
Riru -> Injects code into zygote (via Magisk).
LSPosed/Xposed -> Uses that injection point to hook into app methods.
Modules -> Do the actual bypass/tweaks (e.g., JustTrustMe, SSLUnpinning, RootCloak).

Summary:
- Xposed = Hooking framework.
- LSPosed (LXposed) = Modern implementation of Xposed using Riru, supports Android 10+.
- Riru = Bridge that allows hooking in zygote via Magisk.
- Frida = Full control with custom hooks (powerful, works on native code too).
- Together, they enable runtime method hooking to bypass root detection, SSL pinning, debugger checks, etc.
