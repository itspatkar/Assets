
=> Boot & Low-Level Layers

Bootloader:
- The first program that runs when the device powers on.
- Initializes hardware, verifies system integrity, and loads the OS kernel.
- Can decide whether to boot into Android OS, Recovery, or Fastboot/Download Mode.
- Locked -> secure & stock firmware only.
- Unlocked -> allows flashing custom ROMs, kernels, recovery, etc.
- Root usually requires unlocking bootloader.

Fastboot / Download Mode:
- A diagnostic and flashing interface accessed before Android boots.
- Communicates with a PC via ADB/Fastboot commands (or manufacturer-specific tools).
- Lets you:
    - Unlock/lock bootloader.
    - Flash system images (boot.img, recovery.img, etc.).
    - Repair a bricked device.
- Some OEMs (Samsung, etc.) use Download Mode (Odin) instead of Fastboot.

Recovery:
- A separate lightweight runtime from the main Android OS.
- Runs on its own partition (/recovery).
- Used for system maintenance, such as:
    - Factory reset / wipe data.
    - Applying official OTA updates.
    - Flashing updates or custom ROMs (if custom recovery like TWRP is installed).
    - Clearing cache, repairing partitions.
- Stock Recovery = very limited, official only.
- Custom Recovery (e.g., TWRP) = advanced flashing, backups, root access.


=> Verified Boot & Integrity

Verified Boot (dm-verity & AVB):
- Android checks system partitions at boot to ensure no tampering.
- Ensures the integrity of Android’s boot process and system partitions.
- dm-verity: Checks blocks on /system against cryptographic hashes (introduced Android 4.4).
- AVB (Android Verified Boot 2.0): Introduced in Android 7.0+, strengthens by chaining trust from bootloader -> kernel -> system.
- Prevents:
    - Persistent malware modifying /system or /vendor.
    - Booting a tampered image.
- Why it matters: Guarantees that only trusted OS images run.
- If modified -> device may refuse to boot or go into “Orange/Red state.”
- Rooting with system modifications (SuperSU) breaks this.
- Magisk (systemless root) bypasses it by patching only boot.img, leaving system partition intact.

Android Verified Boot (AVB):
- Android Verified Boot (AVB) is a security feature that ensures the device boots only trusted software by verifying the integrity of each stage of the boot process.
- It’s the evolution of dm-verity (introduced in Android 4.4) and was fully standardized as AVB 2.0 in Android 7.0+.
- How It Works:
    - Root of Trust -> Starts with the bootloader (signed by the device manufacturer).
    - Chain of Trust -> Each stage (bootloader -> kernel -> system -> vendor) verifies the integrity and authenticity of the next stage using cryptographic signatures.
    - dm-verity -> Continuously checks system partition blocks against a signed hash tree, preventing silent tampering.
    - Rollback Protection -> Prevents downgrading to older, vulnerable OS versions.
- Why It Matters:
    - Prevents persistent malware from modifying system partitions (/system, /vendor).
    - Stops rootkits from injecting themselves at boot.
    - Ensures OS integrity across reboots.
    - Protects against downgrade attacks where an attacker flashes an older, exploitable image.
- Quick Example:
    - Without AVB -> Attacker modifies /system/bin/sh to run malicious code -> persists after reboot.
    - With AVB -> Modified block fails verification -> device refuses to boot (or boots in a warning mode).

DM-Verity:
- DM-Verity (short for device-mapper verity, often written dm-verity) is a kernel feature in Android that provides verified boot functionality (AVB).
- It’s a block-level integrity checker built into the Linux device-mapper framework. Ensures that system partitions (like /system, /vendor) have not been modified.
- Uses a hash tree (Merkle tree) of cryptographic checksums stored in the boot image. If a block of data doesn’t match the expected hash, the kernel refuses to read it.
- Purpose of dm-verity:
    - Prevent attackers (or even the user) from tampering with system files.
    - Stops persistence malware from modifying /system binaries.
    - Enforces system partition integrity across reboots.
- How It Works:
    - When the device boots, dm-verity is initialized by the kernel.
    - Each block of the verified partition is hashed and checked against a precomputed hash tree.
    - The root hash of that tree is signed by the manufacturer and verified during Verified Boot.
    - If a mismatch is found:
        - On most devices -> the device refuses to boot (bootloop).
        - Some devices -> the block is replaced with zeros (device runs, but with corrupted/missing functionality).
- Why It Matters (for Pentesting & Rooting):
    - Prevents modification of /system -> stops attackers from placing backdoors, rootkits, or malware.
    - Obstacles for Root/Custom ROMs:
        - To root or install a custom ROM, you often need to disable dm-verity.
        - Tools like Magisk achieve systemless root by keeping /system intact and modifying things in /boot or /vendor.

SELinux:
- SELinux (Security-Enhanced Linux) is a kernel-level security module that enforces Mandatory Access Control (MAC) policies.
- Introduced in Android 4.3 (2013) and made enforcing by default in Android 5.0 (2014).
- Instead of just traditional Linux Discretionary Access Control (DAC) (where the owner decides who can access a resource), SELinux centrally enforces strict rules about which process can access what.
- Even root apps must respect SELinux policies (in enforcing mode).
- Prevents root malware from completely taking over.
- Some custom ROMs allow switching to permissive for tweaks, but this reduces security.
- How It Works in Android:
    - Every process, file, and resource has a security context (label).
    - SELinux policies define what actions are allowed between contexts.
- Example:
    - untrusted_app (your downloaded apps) -> cannot read /data/system/ or kernel memory.
    - Even if an app is compromised, SELinux confines the attack.
- Modes:
    - Permissive -> Logs policy violations but doesn’t block them.
    - Enforcing -> Actively blocks anything outside the defined policy. (default in modern Android).
    - Protects sensitive services like mediaserver, which was historically exploited.

SafetyNet / Play Integrity API:
- Google’s service that checks device integrity, bootloader state, system modifications.
- Apps (banking, payments, streaming) use it to decide if they should run.
- Rooted/unlocked devices often fail this check.
- MagiskHide / Zygisk tries to spoof a clean state.

Generic System Image (GSI):
- A Generic System Image (GSI) is a pure Android implementation, built directly from the Android Open Source Project (AOSP), designed to run on any device that supports Project Treble.
- Introduced in Android 8.0 (Oreo) with Project Treble.
- It’s a system image with unmodified AOSP code (no OEM customizations like MIUI, OneUI, ColorOS).
- Used mainly for:
    - Testing: Developers and security researchers can test apps and compatibility on a clean Android environment.
    - Pentesting: Provides a “stock” Android system without vendor bloat or modifications.
    - Device validation: OEMs use GSIs to ensure Treble compliance.

BusyBox:
- BusyBox is a lightweight software package that provides a collection of Unix/Linux command-line utilities in a single small executable.
- Often called the "Swiss Army Knife of Embedded Linux."
- Designed for systems with limited resources (like Android, routers, IoT devices).
- Combines many standard commands (like ls, cat, grep, find, ifconfig) into one binary.
- BusyBox in Android:
    - Android is based on Linux but does not include many standard Linux utilities by default.
    - BusyBox fills this gap by giving access to a wide set of Linux commands.
    - Essential for rooting, custom ROMs, and pentesting because many root tools rely on these commands.
- Examples of what BusyBox enables:
    - Advanced file operations (find, cp, mv).
    - Network utilities (ifconfig, netstat, ping).
    - System administration commands (top, ps).
    - Running custom shell scripts.
- Why It Matters (Pentesting & Rooting):
    - Many root-based security tools (like Kali NetHunter, Metasploit modules, privilege escalation scripts) require BusyBox.
    - Lets you execute advanced commands that Android’s built-in toolbox can’t handle.
    - Common in custom recoveries (like TWRP) and rooted environments.

Zygote:
- Zygote is a special daemon process in Android that acts as the parent of all app processes.
- It’s started very early during the boot sequence by the init process.
- It loads and initializes the Android Runtime (ART/Dalvik), core libraries, and common system classes once, then forks itself to start new apps.
- How It Works:
    - Boot -> init launches the zygote process.
    - Preloading -> Zygote loads Java classes, resources, and ART runtime into memory.
    - Forking model -> When a new app starts, instead of creating a fresh process from scratch, Zygote forks itself:
        - The new app inherits the preloaded classes and runtime.
        - Saves huge startup time and memory.
    - App Process -> The forked process is customized (changes UID, loads the app’s code, assigns permissions).
- Example:
    - Without Zygote -> Every app would need to initialize the ART runtime separately -> slow + memory heavy.
    - With Zygote -> One preloaded runtime, forked quickly -> fast app launches, efficient memory use.
- Security Angle:
    - Since all apps come from Zygote, SELinux and sandboxing policies apply as soon as the fork happens.
    - Attackers sometimes target Zygote (e.g., exploit Zygote vulnerabilities) since controlling it means controlling all app spawns.

Rooting:
- Rooting in Android means gaining privileged (root/administrator) access to the device’s operating system.
- By default, Android runs apps with limited permissions for security.
- Rooting unlocks the root user (superuser) account, similar to Administrator in Windows or root in Linux.
- Once rooted, you can modify system files, apps, and settings that are normally restricted.
- Rooting allows:
    - Remove pre-installed bloatware.
    - Install custom ROMs/kernels.
    - Run powerful apps that need system access (firewall apps, backup tools like Titanium Backup).
    - Customize performance (overclock/underclock CPU, battery tweaks).
    - Advanced theming and UI modifications.
- Risks of Rooting:
    - Security risk: Malicious apps could gain full control.
    - Warranty void: Most manufacturers void warranty if rooted.
    - Updates blocked: OTA updates may fail or break.
    - Bricking risk: Incorrect rooting can make the device unusable.
    - SafetyNet/Play Integrity fail: Some apps (banking, Google Pay, Netflix, etc.) may refuse to run.
- Root vs Bootloader Unlock:
    - Unlocking bootloader -> lets you flash custom images/ROMs.
    - Rooting -> gives you admin-level control inside Android.
    - Usually, you need an unlocked bootloader before rooting.
- Rooting Methods in Android:
    - Older Method – System Modifying Root:
        - Tools like SuperSU directly modified system partitions (/system) to insert the su binary (superuser command).
        - Risky, as it:
            - Permanently changed system files.
            - Broke OTA updates.
            - Could be detected easily by apps.
    - Modern Method – Systemless Root (Magisk):
        - Magisk is the most popular rooting tool today.
        - Works by modifying the boot image (not /system), then loading root at boot.
        - Benefits:
            - Systemless -> Doesn’t touch system partition, safer and easier to undo.
            - Magisk Modules -> Plugins to add features (e.g., ad-blocking, theming, performance tweaks).
            - Magisk Hide / Zygisk -> Lets you hide root from apps (like banking or Google Pay).
            - Easier to keep OTA updates working (patch boot.img after update).
- Steps (Typical Magisk Root Flow):
    - Unlock bootloader (required on most devices).
    - Extract the device’s boot.img (from firmware).
    - Patch the boot image using Magisk Manager app.
    - Flash the patched boot.img via fastboot/odin.
    - Device boots with Magisk -> root access enabled.
- Root Detection & Security:
    - Google uses SafetyNet / Play Integrity API to check for rooting.
    - Rooted devices may fail checks -> apps like banking, Netflix, UPI may not work.
    - Magisk tries to bypass these with hiding techniques.
- Technically, What Rooting Does in Android:
    - Linux Base:
        - Android is built on Linux.
        - In Linux/Unix systems, the root user (UID 0) has unrestricted permissions.
        - Normal Android apps run as isolated users (sandboxed with their own UID).
    - Root Binary (su):
        - Root account is disabled by default.
        - There’s no su binary in /system/bin or /system/xbin.
        - Apps always run inside a sandbox with their own UID, managed by Zygote + SELinux. This ensures apps can’t just escalate privileges.
        - Rooting installs the su binary (short for switch user) in the system.
        - This binary lets processes switch to UID 0 (root) when needed.
        - Example: An app calls su -> permission prompt -> app runs with root privileges.
    - Superuser Manager:
        - Tools like SuperSU or Magisk act as root access managers.
        - They intercept calls to su and ask the user whether to allow or deny.
        - Without this, any app could silently gain full control.
    - Systemless Root (Magisk):
        - Instead of modifying /system, Magisk patches the boot image.
        - During boot, Magisk injects itself into the process that starts Android (Zygote) to enable root.
        - This avoids breaking Verified Boot and allows easier updates.
    - Effect on Android Security:
        - With root enabled, apps can:
            - Mount partitions as read-write (/system, /vendor).
            - Modify SELinux state (permissive/enforcing).
            - Hook into system services (e.g., Location, Camera, Play Services).
        - Basically bypassing the sandboxing model of Android.

Root Detection & Bypass:
- How Apps Detect Root:
    - Apps look for indicators such as: Presence of su binary.
    - Unlocked bootloader state.
    - Modified or missing Verified Boot keys.
    - Magisk files or root manager packages.
    - Writable system partitions.
    - Debuggable build tags.
    - Hooked processes (via Xposed, Zygisk).
- Bypassing Root Detection:
    - Magisk Features:
        - Zygisk (Magisk in Zygote) -> injects code at app launch.
        - DenyList -> hides Magisk & root from selected apps.
        - Shamiko module -> stronger hiding, bypasses stricter checks.
    - File/Path Hiding:
        - Rename/remove su and Magisk-related files.
        - Use modules like MagiskHide Props Config.
    - SafetyNet / Play Integrity Workarounds:
        - Universal SafetyNet Fix module.
        - Custom props (fingerprint spoofing).
        - Work with spoofed device profile.
    - App-Specific Workarounds:
        - Patching the APK (smali edits, Frida hooks).
        - Using LSPosed/Xposed modules for targeted bypass.
- Limitations:
    - Google is tightening Play Integrity API -> harder to bypass.
    - Some banking/UPI apps now detect even Zygisk or Shamiko.
    - There’s no 100% universal method; bypass depends on:
        - Device.
        - Android version.
        - Security patches.
        - Detection logic of the app.

Bootloader Unlock Detection:
- How It’s Detected:
    - Apps (especially banking/DRM/enterprise) check if your bootloader is unlocked by looking at:
    - OEM flags: ro.boot.verifiedbootstate, ro.boot.flash.locked, ro.boot.vbmeta.device_state.
    - dm-verity state (Orange/Yellow/Red boot screen).
    - AVB (Android Verified Boot) integrity.
    - SafetyNet / Play Integrity API -> reports bootloader unlock status.
- Why Apps Care:
    - Unlocked bootloader = system could be modified.
    - Even without root, apps assume device is insecure.
    - Some apps outright block usage (banking, UPI, Widevine L1 -> L3 downgrade).
- Bootloader Unlock Detection Bypass:
    - Magisk Props / Property Spoofing:
        - Use MagiskHide Props Config to override values:
            ro.boot.flash.locked=1
            ro.boot.vbmeta.device_state=locked
            ro.boot.verifiedbootstate=green
        - Makes the system “report” as locked.
    - Play Integrity Fixes:
        - Install modules like Universal SafetyNet Fix + Play Integrity Fix.
        - Helps pass device integrity checks that report bootloader state.
    - Zygisk + DenyList:
        - Use Magisk’s DenyList (or Shamiko) to hide Magisk/Zygisk itself.
        - Some apps combine bootloader + root detection -> both must be hidden.
    - Custom Patching / Hooks:
        - Advanced: Hook APIs with LSPosed/Frida to intercept calls that query bootloader state.
        - Example: Hook KeyAttestation or SafetyNet calls and return spoofed values.
    - Relocking Bootloader (Fake / Real):
        - Real relock: Flash stock firmware and lock again (may brick if system modified).
        - Fake relock: Some OEMs can be tricked by patched vbmeta images, but risky.
- Limitations:
    - Google’s Play Integrity API is server-side -> spoofing properties may not always work.
    - Some apps use hardware-backed key attestation (TEE/TrustZone) -> much harder to bypass.
    - Bypass success depends on device + Android version + app’s detection logic.
- Bootloader unlock detection is usually bypassed by spoofing boot properties (ro.boot.*), using Magisk modules (Props, SafetyNet/Play Integrity fixes), or hooking attestation APIs.
- But hardware-backed checks are making this harder on modern devices.

Developer Options Detection:
- Some apps (banking, UPI, streaming, exam apps) check if Developer Options is enabled.
- Because Dev Options allows:
    - USB debugging (ADB) -> potential for reverse engineering, data extraction.
    - Mock locations -> GPS spoofing.
    - OEM unlocking -> signals tampering risk.
- How Apps Detect It:
    - Apps read certain system settings:
        Settings.Global.DEVELOPMENT_SETTINGS_ENABLED
        Settings.Global.ADB_ENABLED
        Settings.Secure.ALLOW_MOCK_LOCATION
    - Or by checking if ADB daemon is running.
- Developer Options Bypass:
    - Settings Spoofing:
        - Use LSPosed / Xposed modules or Frida hooks to override these values.
        - Example: Hook the Settings.Global.getInt() call and force return 0 (disabled).
    - Magisk Modules:
        - Some Magisk modules can spoof system properties to hide dev options / USB debugging.
        - Custom modules can patch settings.db values at runtime.
    - Manual (Temporary) Bypass:
        - Simply disable Developer Options in Settings -> System -> Developer Options -> toggle off before launching the app.
        - But not always convenient if you rely on ADB/USB debugging.
    - Advanced Hooking:
        - For stricter apps, use Frida / LSPosed scripts to intercept method calls inside the app’s code that check developer options.
        - Example: If app calls isDevelopmentSettingsEnabled(), hook it to always return false.
- Limitations:
    - Some apps combine Dev Options + Root + Bootloader unlock detection -> need multi-layer bypass.
    - On newer Android versions, hiding ADB debugging while keeping it active is trickier (apps can detect daemon).

SSL Pinning:
- SSL Pinning (a.k.a. Certificate Pinning) is a security technique where an app is programmed to only trust a specific SSL/TLS certificate (or public key) when connecting to a server — instead of trusting all certificates in the device’s system trust store.
- Why It’s Used:
    - Normally:
        - Android apps trust hundreds of CA root certificates (built into the OS).
        - If a malicious actor installs a custom CA on the device, they could perform a Man-in-the-Middle (MITM) attack with a fake certificate.
    - With SSL Pinning:
        - The app has the server’s certificate or public key “pinned” inside its code.
        - When connecting, it verifies:
            - “Does this cert/key match the pinned one?”
            - If yes -> connection allowed.
            - If no -> connection blocked, even if the cert is valid globally.
- Example:
    - Without pinning:
        - App -> Trusts any cert signed by a trusted CA.
    - With pinning:
        - App -> Only trusts yourbank.com’s exact certificate/key.
        - Stops MITM attacks with fake certs (even if attacker has a trusted CA).
- How It’s Done:
    - Certificate pinning: App stores full server certificate.
    - Public key pinning: App stores server’s public key (safer across certificate renewals).
    - Implemented via libraries like OkHttp, TrustManager, or Android’s Network Security Config.
- Downsides:
    - Cert/key changes -> app must update or it breaks connectivity.
    - Harder during server migrations.
    - Adds maintenance overhead.
- In Short: SSL Pinning = hardcoding the server’s cert/key in the app, so it only trusts that and rejects all others.
It protects against MITM attacks, but can cause issues if the certificate changes and the app isn’t updated.
- Bypass SSL Pinning:
    - Frida Hooks:
        - Frida = dynamic instrumentation tool (attach to running process, hook methods).
        - Write a script to override SSL/TLS validation functions.
        - Example: Hook Java classes like checkServerTrusted() or OkHttp’s CertificatePinner.
        - Effect: Always return “valid” regardless of certificate.
    - Objection (Frida-based tool):
        - Ready-made toolkit built on Frida.
        - Run:
            objection --gadget <app> explore
            android sslpinning disable
        - Quickly disables SSL pinning in many apps without writing custom code.
    - Xposed / LSPosed Modules:
        - Install modules like:
            - JustTrustMe -> bypass SSL pinning by overriding trust checks.
            - SSLUnpinning -> hooks known libraries.
        - Works system-wide once installed.
    - Magisk Modules:
        - TrustMeAlready (for Magisk/Zygisk) patches SSL functions at runtime.
        - Integrates with modern Magisk hiding techniques.
    - Manual Patching:
        - Smali code patching: Decompile the APK with tools like Apktool.
        - Find SSL pinning logic (e.g., checkServerTrusted).
        - Modify it to skip validation or always return true.
        - Recompile & sign the app.
    - Network Security Config Override:
        - If app uses Android’s network_security_config.xml, sometimes you can modify or inject your own config to accept custom CAs.
        - Easier if app isn’t heavily obfuscated.
- Challenges:
    - Newer apps use native libraries (C/C++ with OpenSSL, BoringSSL, custom checks).
    - Stronger obfuscation = harder to hook.
    - Some apps combine SSL pinning with root/jailbreak detection, so bypassing both may be required.
- In Short: To bypass SSL pinning, pentesters use runtime hooking (Frida/Objection/Xposed/Magisk) or static patching (smali/native) to disable certificate validation. This allows intercepting traffic via Burp, MITMproxy, etc.

Debugger Checks (Anti-Debugging):
- Apps (especially banking, exam, and gaming apps) often check if a debugger is attached to prevent reverse engineering or runtime tampering.
- Common Ways Apps Detect Debuggers:
    - Java-based checks:
        - Debug.isDebuggerConnected()
        - Debug.waitingForDebugger()
    - System property checks:
        - android.os.Debug APIs
        - adb presence (checking ro.debuggable or ro.secure)
    - Native (NDK) checks:
        - Using ptrace() to detect if a debugger is attached.
        - Checking /proc/self/status -> field TracerPid (non-zero = being debugged).
    - Timing checks:
        - Measure execution time of loops; debuggers slow down execution -> triggers detection.
- Bypassing Debugger Checks:
    - Frida Hooking:
        - Hook Java methods:
            Java.perform(function() {
                var Debug = Java.use("android.os.Debug");
                Debug.isDebuggerConnected.implementation = function() {
                    return false; // Always say "no debugger"
                };
            });
        - Works for both isDebuggerConnected() and waitingForDebugger().
    - Objection (Frida wrapper):
        - Has built-in scripts for bypassing debugger checks.
        - Example: android hooking watch class android.os.Debug
    - Xposed / LSPosed Modules:
        - Modules like Hide My Applist or custom hooks override Debug APIs.
        - Force them to always return “not being debugged.”
    - Magisk Modules:
        - Kernel-level hooking modules can hide debugging flags and TracerPid.
    - Native (ptrace / TracerPid) Bypass:
        - Use Frida’s Interceptor.attach to hook libc functions (ptrace, open, read).
        - Example: Hook ptrace() and force return 0 so app thinks no debugger attached.
        - Patch /proc/self/status reads to always return TracerPid: 0.
    - Static Patching:
        - Decompile with Apktool -> find where Debug.isDebuggerConnected() is used.
        - Replace with const/4 v0, 0x0 (false).
        - Rebuild and sign APK.
- Limitations:
    - Some apps combine anti-debugging + root detection + SSL pinning.
    - Need multi-layer bypass (Frida + Magisk + network hooks).
- In Short:
    - Debugger checks look for attached debuggers (Java, system props, ptrace, TracerPid).
    - Bypass = hooking, patching, or spoofing values to make the app always think no debugger is attached.

Summary:
- Bootloader + Verified Boot = prevent tampering
- SELinux = control access
- SafetyNet/Play Integrity = detect compromise
- Rooting = gains admin control but bypasses protections

Magisk:
- Magisk is a modern systemless rooting framework for Android. It was created by topjohnwu and is the standard way to root devices today.
- Key Points:
    - Systemless Root
    - Unlike older methods (SuperSU) that modified /system, Magisk patches the boot image instead.
    - This means root is injected during boot, without touching system partitions.
- Benefits:
    - Easier OTA updates.
    - Can pass Verified Boot checks.
    - Easier to uninstall/disable.
- Magisk Manager:
    - Magisk Manager was the companion app for Magisk (the systemless root solution).
    - It provided a user interface to manage everything related to Magisk.
    - Today, its features are integrated directly into the Magisk app (the manager isn’t separate anymore).
- Root Access (su):
    - Magisk installs the su binary and manages root requests.
    - Apps that request root get a prompt, controlled by the Magisk app.
- Modules System:
    - Magisk supports modules (similar to plugins).
    - Modules can change system behavior, add features (ad-block, theming, performance tweaks).
- MagiskHide / Zygisk:
    - Magisk used to include MagiskHide to hide root from banking/DRM apps.
    - Modern Magisk uses Zygisk (Magisk inside Zygote) + DenyList for finer control.
- SafetyNet / Play Integrity Bypass:
    - Many apps check if the device is rooted.
    - Magisk tries to “mask” modifications so these apps continue working.
    - Success depends on Google’s updates and tricks used by the user.

Xposed Framework:
- A runtime hooking framework for Android.
- Lets you modify Java methods of apps/system without modifying APKs.
- Needs: Root + (old) Xposed installer.
- Use case: Hooking methods system-wide, modifying app logic.
- Downside: Outdated, limited support on modern Android.
- You install modules (like Magisk modules, but for runtime hooking) that can:
    - Bypass root detection
    - Disable SSL pinning
    - Modify app behavior (ads, UI tweaks, etc.)

Riru:
- A Magisk module that injects code into Android’s zygote process (the parent of all app processes).
- This allows frameworks like Xposed to run on modern Android versions.
- Think of Riru as the bridge between Magisk (root layer) and Xposed (runtime hooking layer).

LSPosed (a.k.a. LXposed):
- Modern, actively maintained Xposed variant that works with Riru.
- Runs via: Riru (older) or Zygisk (newer Magisk).
- More stable and secure than older Xposed.
- Features:
    - Per-app module scope (hook only specific apps instead of global).
    - Better compatibility with modern Android (10+).
    - Works seamlessly with Magisk.
- Use case: Install modules like JustTrustMe (SSL pinning bypass), RootCloak, debugger bypass, etc.

Frida:
- Type: Dynamic instrumentation toolkit.
- Needs: Root OR non-root with Frida gadget injected.
- Strengths:
    - Write custom scripts in JavaScript.
    - Hook both Java & native (C/C++) methods.
    - Works even on obfuscated apps.
- Use case: On-the-fly debugging, SSL pinning bypass, root detection bypass, native library patching.
- Downside: Needs more manual work than Xposed modules.

How They Work Together:
Magisk -> Root access & systemless modifications.
Riru -> Injects code into zygote (via Magisk).
LSPosed/Xposed -> Uses that injection point to hook into app methods.
Modules -> Do the actual bypass/tweaks (e.g., JustTrustMe, SSLUnpinning, RootCloak).

Summary:
- Xposed = Hooking framework.
- LSPosed (LXposed) = Modern implementation of Xposed using Riru, supports Android 10+.
- Riru = Bridge that allows hooking in zygote via Magisk.
- Frida = Full control with custom hooks (powerful, works on native code too).
- Together, they enable runtime method hooking to bypass root detection, SSL pinning, debugger checks, etc.
