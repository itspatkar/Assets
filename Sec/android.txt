
=> Android

- Android is an open-source operating system (OS) primarily designed for mobile devices (smartphones, tablets, TVs, wearables, IoT). It’s based on the Linux kernel and developed by Google.
- Android provides:
    - A middleware framework
    - A runtime environment
    - Application support, so developers can build apps in Java, Kotlin, or C/C++.

Android Components:
- Linux Kernel (Lowest Layer):
    - Serves as the base layer of Android.
    - Directly communicates with device hardware via drivers.
    - Hardware abstraction -> device drivers, power, memory, security.
    - Handles:
        - Security
        - Memory Management
        - Process Management
        - Networking
        - Drivers (camera, display, Wi-Fi, Bluetooth, USB, Binder (IPC) etc.)
    - Android adds Binder IPC driver for communication between processes.
- Hardware Abstraction Layer (HAL):
    - Sits above the kernel.
    - Provides standard interfaces and APIs that allow the Android framework to interact with hardware-specific drivers.
    - Acts like a translator between Android framework (Java/Kotlin world) and hardware drivers (C/C++ world).
    - Ensures that apps and system services don’t need to know hardware details.
    - Example: A camera app -> HAL -> hardware driver -> physical camera.
- Android Runtime & Native Libraries:
    - Android Runtime (ART/Dalvik):
        - Executes apps.
        - Dalvik VM (older versions) and now ART (Android Runtime) (Replaced Dalvik VM from Android 5.0+).
        - Uses Just-In-Time (JIT) and Ahead-Of-Time (AOT) compilation.
        - Garbage Collection
        - Each app runs in its own sandboxed process for security.
    - Libraries (C/C++ libraries):
        - Pre-built native C/C++ libraries providing core functionalities:
        - Examples:
            - SQLite -> for databases
            - OpenGL ES -> for graphics
            - WebKit -> for browsing
            - SSL -> for secure networking
            - Media Framework -> Audio/Video playback
- Application Framework:
    - Provides high-level APIs and services for apps.
    - Examples:
        - Activity Manager: manages app lifecycles
        - Package Manager -> App installation & permissions
        - Resource Manager: handles layouts, strings, images
        - Notification Manager: manages system notifications
        - Location Manager -> GPS
        - Telephony Manager -> Calls, SMS
        - View System: UI components like buttons, text, etc
        - Content Providers: share data between apps
- Applications:
    - System apps (Phone, Contacts, Camera, etc.) + user-installed apps (WhatsApp, Instagram, etc.).
    - Built using Java/Kotlin (sometimes C/C++ for native parts).

Components of Android Applications:
- Android apps are made of four main components (declared in the AndroidManifest.xml).
- All four are connected by Intents (messaging objects that pass data or actions between components).
- Activities:
    - An Activity is a single screen with a UI. Manages user interaction.
    - Example: WhatsApp’s chat screen is one Activity, and status screen is another.
- Services:
    - A Service runs in the background without UI.
    - Example: Music player running while you browse other apps, or Firebase push notification service.
- Broadcast Receivers:
    - Respond to system-wide messages/events.
    - Example: Low battery notification, incoming SMS, Wi-Fi connected.
- Content Providers:
    - Manage and share data between apps.
    - Example: Contacts app provides contact data that WhatsApp can read to show your friends list.

Android File System Structure:
- Android uses a Linux-like directory structure, but with some mobile-specific differences.
- Root Directory (/): Contains essential system folders:
    - /system -> Core Android OS files (read-only for apps)
        - /system/app -> Pre-installed system apps
        - /system/framework -> Android frameworks (.jar files)
        - /system/lib or /system/lib64 -> Shared libraries (.so files)
        - /system/bin -> Core binaries (sh, toolbox, etc.)
    - /vendor -> Device-specific files (drivers, firmware, HAL)
    - /boot -> Kernel + ramdisk
    - /recovery -> Separate boot partition for system recovery
    - /data -> User data (writable)
        - /data/app -> Installed apps (APK files)
        - /data/data/<package_name> -> App-specific data (databases, cache, prefs)
        - /data/dalvik-cache -> Compiled code cache
    - /cache -> Temporary data, OTA updates
    - /sdcard or /storage/emulated/0 -> User files (media, downloads, documents)
    - /dev -> Device nodes for hardware
    - /proc -> Runtime kernel/system info
    - /etc -> Config files

WebView:
- WebView is an Android system component that allows apps to display web content inside an app, without opening a browser.
- It’s basically a mini browser engine (based on Chromium) embedded in Android.
- Developers use it when they want to load a webpage, HTML, or run JavaScript inside their app’s UI.
- Packaged as a system app: Android System WebView.
- How WebView Works:
    - Exposes an API (android.webkit.WebView) that developers can add to their app.
    - The app can then:
        - Load a remote webpage (https://example.com).
        - Render local HTML/JS files stored inside the app.
        - Interact with JavaScript via JavaScript Interfaces (bridge between app code and web code).
- Why WebView Matters (Pentesting):
    - WebView is a common attack surface because it mixes web security with mobile app security.
    - Vulnerabilities include:
        - JavaScript Injection -> if developer uses addJavascriptInterface() insecurely.
        - Insecure URL loading -> if app loads arbitrary user-controlled URLs.
        - Phishing / XSS inside apps -> if input isn’t sanitized.
        - Man-in-the-middle (MITM) risks -> if HTTPS validation is weak or bypassed.

Verified Boot (dm-verity & AVB):
- Ensures the integrity of Android’s boot process and system partitions.
- dm-verity: Checks blocks on /system against cryptographic hashes (introduced Android 4.4).
- AVB (Android Verified Boot 2.0): Introduced in Android 7.0+, strengthens by chaining trust from bootloader -> kernel -> system.
- Prevents:
    - Persistent malware modifying /system or /vendor.
    - Booting a tampered image.
- Why it matters: Guarantees that only trusted OS images run.

Android Verified Boot (AVB):
- Android Verified Boot (AVB) is a security feature that ensures the device boots only trusted software by verifying the integrity of each stage of the boot process.
- It’s the evolution of dm-verity (introduced in Android 4.4) and was fully standardized as AVB 2.0 in Android 7.0+.
- How It Works:
    - Root of Trust -> Starts with the bootloader (signed by the device manufacturer).
    - Chain of Trust -> Each stage (bootloader -> kernel -> system -> vendor) verifies the integrity and authenticity of the next stage using cryptographic signatures.
    - dm-verity -> Continuously checks system partition blocks against a signed hash tree, preventing silent tampering.
    - Rollback Protection -> Prevents downgrading to older, vulnerable OS versions.
- Why It Matters:
    - Prevents persistent malware from modifying system partitions (/system, /vendor).
    - Stops rootkits from injecting themselves at boot.
    - Ensures OS integrity across reboots.
    - Protects against downgrade attacks where an attacker flashes an older, exploitable image.
- Quick Example:
    - Without AVB -> Attacker modifies /system/bin/sh to run malicious code -> persists after reboot.
    - With AVB -> Modified block fails verification -> device refuses to boot (or boots in a warning mode).

DM-Verity:
- DM-Verity (short for device-mapper verity, often written dm-verity) is a kernel feature in Android that provides verified boot functionality (AVB).
- It’s a block-level integrity checker built into the Linux device-mapper framework. Ensures that system partitions (like /system, /vendor) have not been modified.
- Uses a hash tree (Merkle tree) of cryptographic checksums stored in the boot image. If a block of data doesn’t match the expected hash, the kernel refuses to read it.
- Purpose of dm-verity:
    - Prevent attackers (or even the user) from tampering with system files.
    - Stops persistence malware from modifying /system binaries.
    - Enforces system partition integrity across reboots.
- How It Works:
    - When the device boots, dm-verity is initialized by the kernel.
    - Each block of the verified partition is hashed and checked against a precomputed hash tree.
    - The root hash of that tree is signed by the manufacturer and verified during Verified Boot.
    - If a mismatch is found:
        - On most devices -> the device refuses to boot (bootloop).
        - Some devices -> the block is replaced with zeros (device runs, but with corrupted/missing functionality).
- Why It Matters (for Pentesting & Rooting):
    - Prevents modification of /system -> stops attackers from placing backdoors, rootkits, or malware.
    - Obstacles for Root/Custom ROMs:
        - To root or install a custom ROM, you often need to disable dm-verity.
        - Tools like Magisk achieve systemless root by keeping /system intact and modifying things in /boot or /vendor.

SELinux in Android:
- SELinux (Security-Enhanced Linux) is a kernel-level security module that enforces Mandatory Access Control (MAC) policies.
- Introduced in Android 4.3 (2013) and made enforcing by default in Android 5.0 (2014).
- Instead of just traditional Linux Discretionary Access Control (DAC) (where the owner decides who can access a resource), SELinux centrally enforces strict rules about which process can access what.
- How It Works in Android:
    - Every process, file, and resource has a security context (label).
    - SELinux policies define what actions are allowed between contexts.
- Example:
    - untrusted_app (your downloaded apps) -> cannot read /data/system/ or kernel memory.
    - Even if an app is compromised, SELinux confines the attack.
- Modes:
    - Permissive -> Logs policy violations but doesn’t block them.
    - Enforcing -> Actively blocks anything outside the defined policy. (default in modern Android).
    - Protects sensitive services like mediaserver, which was historically exploited.

Generic System Image (GSI):
- A Generic System Image (GSI) is a pure Android implementation, built directly from the Android Open Source Project (AOSP), designed to run on any device that supports Project Treble.
- Introduced in Android 8.0 (Oreo) with Project Treble.
- It’s a system image with unmodified AOSP code (no OEM customizations like MIUI, OneUI, ColorOS).
- Used mainly for:
    - Testing: Developers and security researchers can test apps and compatibility on a clean Android environment.
    - Pentesting: Provides a “stock” Android system without vendor bloat or modifications.
    - Device validation: OEMs use GSIs to ensure Treble compliance.

BusyBox:
- BusyBox is a lightweight software package that provides a collection of Unix/Linux command-line utilities in a single small executable.
- Often called the "Swiss Army Knife of Embedded Linux."
- Designed for systems with limited resources (like Android, routers, IoT devices).
- Combines many standard commands (like ls, cat, grep, find, ifconfig) into one binary.
- BusyBox in Android:
    - Android is based on Linux but does not include many standard Linux utilities by default.
    - BusyBox fills this gap by giving access to a wide set of Linux commands.
    - Essential for rooting, custom ROMs, and pentesting because many root tools rely on these commands.
- Examples of what BusyBox enables:
    - Advanced file operations (find, cp, mv).
    - Network utilities (ifconfig, netstat, ping).
    - System administration commands (top, ps).
    - Running custom shell scripts.
- Why It Matters (Pentesting & Rooting):
    - Many root-based security tools (like Kali NetHunter, Metasploit modules, privilege escalation scripts) require BusyBox.
    - Lets you execute advanced commands that Android’s built-in toolbox can’t handle.
    - Common in custom recoveries (like TWRP) and rooted environments.

Zygote in Android:
- Zygote is a special daemon process in Android that acts as the parent of all app processes.
- It’s started very early during the boot sequence by the init process.
- It loads and initializes the Android Runtime (ART/Dalvik), core libraries, and common system classes once, then forks itself to start new apps.
- How It Works:
    - Boot -> init launches the zygote process.
    - Preloading -> Zygote loads Java classes, resources, and ART runtime into memory.
    - Forking model -> When a new app starts, instead of creating a fresh process from scratch, Zygote forks itself:
        - The new app inherits the preloaded classes and runtime.
        - Saves huge startup time and memory.
    - App Process -> The forked process is customized (changes UID, loads the app’s code, assigns permissions).
- Example:
    - Without Zygote -> Every app would need to initialize the ART runtime separately -> slow + memory heavy.
    - With Zygote -> One preloaded runtime, forked quickly -> fast app launches, efficient memory use.
- Security Angle:
    - Since all apps come from Zygote, SELinux and sandboxing policies apply as soon as the fork happens.
    - Attackers sometimes target Zygote (e.g., exploit Zygote vulnerabilities) since controlling it means controlling all app spawns.

----

Bootloader Unlock Detection Bypass
Developer Option Enable Bypass
Root detection bypass
SSL pinning bypass
Debugger checks bypass

Magisk Manager
Xposed Mod / LXposed Riru
