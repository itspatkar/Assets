
=> Boot & Low-Level Layers

Bootloader:
- The first program that runs when the device powers on.
- Initializes hardware, verifies system integrity, and loads the OS kernel.
- Can decide whether to boot into Android OS, Recovery, or Fastboot/Download Mode.
- Locked -> secure & stock firmware only.
- Unlocked -> allows flashing custom ROMs, kernels, recovery, etc.
- Root usually requires unlocking bootloader.

Fastboot / Download Mode:
- A diagnostic and flashing interface accessed before Android boots.
- Communicates with a PC via ADB/Fastboot commands (or manufacturer-specific tools).
- Lets you:
    - Unlock/lock bootloader.
    - Flash system images (boot.img, recovery.img, etc.).
    - Repair a bricked device.
- Some OEMs (Samsung, etc.) use Download Mode (Odin) instead of Fastboot.

Recovery:
- A separate lightweight runtime from the main Android OS.
- Runs on its own partition (/recovery).
- Used for system maintenance, such as:
    - Factory reset / wipe data.
    - Applying official OTA updates.
    - Flashing updates or custom ROMs (if custom recovery like TWRP is installed).
    - Clearing cache, repairing partitions.
- Stock Recovery = very limited, official only.
- Custom Recovery (e.g., TWRP) = advanced flashing, backups, root access.


=> Verified Boot & Integrity

Android Verified Boot (AVB):
- Android Verified Boot (AVB) is a security feature that ensures the device boots only trusted software by verifying the integrity of each stage of the boot process.
- It’s the evolution of dm-verity (introduced in Android 4.4) and was fully standardized as AVB 2.0 in Android 7.0+.
- How It Works:
    - Root of Trust -> Starts with the bootloader (signed by the device manufacturer).
    - Chain of Trust -> Each stage (bootloader -> kernel -> system -> vendor) verifies the integrity and authenticity of the next stage using cryptographic signatures.
    - dm-verity -> Continuously checks system partition blocks against a signed hash tree, preventing silent tampering.
    - Rollback Protection -> Prevents downgrading to older, vulnerable OS versions.
- Why It Matters:
    - Prevents persistent malware from modifying system partitions (/system, /vendor).
    - Stops rootkits from injecting themselves at boot.
    - Ensures OS integrity across reboots.
    - Protects against downgrade attacks where an attacker flashes an older, exploitable image.
- Quick Example:
    - Without AVB -> Attacker modifies /system/bin/sh to run malicious code -> persists after reboot.
    - With AVB -> Modified block fails verification -> device refuses to boot (or boots in a warning mode).

DM-Verity:
- DM-Verity (short for device-mapper verity, often written dm-verity) is a kernel feature in Android that provides verified boot functionality (AVB).
- It’s a block-level integrity checker built into the Linux device-mapper framework. Ensures that system partitions (like /system, /vendor) have not been modified.
- Uses a hash tree (Merkle tree) of cryptographic checksums stored in the boot image. If a block of data doesn’t match the expected hash, the kernel refuses to read it.
- Purpose of dm-verity:
    - Prevent attackers (or even the user) from tampering with system files.
    - Stops persistence malware from modifying /system binaries.
    - Enforces system partition integrity across reboots.
- How It Works:
    - When the device boots, dm-verity is initialized by the kernel.
    - Each block of the verified partition is hashed and checked against a precomputed hash tree.
    - The root hash of that tree is signed by the manufacturer and verified during Verified Boot.
    - If a mismatch is found:
        - On most devices -> the device refuses to boot (bootloop).
        - Some devices -> the block is replaced with zeros (device runs, but with corrupted/missing functionality).
- Why It Matters (for Pentesting & Rooting):
    - Prevents modification of /system -> stops attackers from placing backdoors, rootkits, or malware.
    - Obstacles for Root/Custom ROMs:
        - To root or install a custom ROM, you often need to disable dm-verity.
        - Tools like Magisk achieve systemless root by keeping /system intact and modifying things in /boot or /vendor.

Verified Boot (dm-verity & AVB):
- Android checks system partitions at boot to ensure no tampering.
- Ensures the integrity of Android’s boot process and system partitions.
- dm-verity: Checks blocks on /system against cryptographic hashes (introduced Android 4.4).
- AVB (Android Verified Boot 2.0): Introduced in Android 7.0+, strengthens by chaining trust from bootloader -> kernel -> system.
- Prevents:
    - Persistent malware modifying /system or /vendor.
    - Booting a tampered image.
- Why it matters: Guarantees that only trusted OS images run.
- If modified -> device may refuse to boot or go into “Orange/Red state.”
- Rooting with system modifications (SuperSU) breaks this.
- Magisk (systemless root) bypasses it by patching only boot.img, leaving system partition intact.


=> OS Security & Enforcement

SELinux:
- SELinux (Security-Enhanced Linux) is a kernel-level security module that enforces Mandatory Access Control (MAC) policies.
- Introduced in Android 4.3 (2013) and made enforcing by default in Android 5.0 (2014).
- Instead of just traditional Linux Discretionary Access Control (DAC) (where the owner decides who can access a resource), SELinux centrally enforces strict rules about which process can access what.
- Even root apps must respect SELinux policies (in enforcing mode).
- Prevents root malware from completely taking over.
- Some custom ROMs allow switching to permissive for tweaks, but this reduces security.
- How It Works in Android:
    - Every process, file, and resource has a security context (label).
    - SELinux policies define what actions are allowed between contexts.
- Example:
    - untrusted_app (your downloaded apps) -> cannot read /data/system/ or kernel memory.
    - Even if an app is compromised, SELinux confines the attack.
- Modes:
    - Permissive -> Logs policy violations but doesn’t block them.
    - Enforcing -> Actively blocks anything outside the defined policy. (default in modern Android).
    - Protects sensitive services like mediaserver, which was historically exploited.

Zygote:
- Zygote is a special daemon process in Android that acts as the parent of all app processes.
- It’s started very early during the boot sequence by the init process.
- It loads and initializes the Android Runtime (ART/Dalvik), core libraries, and common system classes once, then forks itself to start new apps.
- How It Works:
    - Boot -> init launches the zygote process.
    - Preloading -> Zygote loads Java classes, resources, and ART runtime into memory.
    - Forking model -> When a new app starts, instead of creating a fresh process from scratch, Zygote forks itself:
        - The new app inherits the preloaded classes and runtime.
        - Saves huge startup time and memory.
    - App Process -> The forked process is customized (changes UID, loads the app’s code, assigns permissions).
- Example:
    - Without Zygote -> Every app would need to initialize the ART runtime separately -> slow + memory heavy.
    - With Zygote -> One preloaded runtime, forked quickly -> fast app launches, efficient memory use.
- Security Angle:
    - Since all apps come from Zygote, SELinux and sandboxing policies apply as soon as the fork happens.
    - Attackers sometimes target Zygote (e.g., exploit Zygote vulnerabilities) since controlling it means controlling all app spawns.

Generic System Image (GSI):
- A Generic System Image (GSI) is a pure Android implementation, built directly from the Android Open Source Project (AOSP), designed to run on any device that supports Project Treble.
- Introduced in Android 8.0 (Oreo) with Project Treble.
- It’s a system image with unmodified AOSP code (no OEM customizations like MIUI, OneUI, ColorOS).
- Used mainly for:
    - Testing: Developers and security researchers can test apps and compatibility on a clean Android environment.
    - Pentesting: Provides a “stock” Android system without vendor bloat or modifications.
    - Device validation: OEMs use GSIs to ensure Treble compliance.

BusyBox:
- BusyBox is a lightweight software package that provides a collection of Unix/Linux command-line utilities in a single small executable.
- Often called the "Swiss Army Knife of Embedded Linux."
- Designed for systems with limited resources (like Android, routers, IoT devices).
- Combines many standard commands (like ls, cat, grep, find, ifconfig) into one binary.
- BusyBox in Android:
    - Android is based on Linux but does not include many standard Linux utilities by default.
    - BusyBox fills this gap by giving access to a wide set of Linux commands.
    - Essential for rooting, custom ROMs, and pentesting because many root tools rely on these commands.
- Examples of what BusyBox enables:
    - Advanced file operations (find, cp, mv).
    - Network utilities (ifconfig, netstat, ping).
    - System administration commands (top, ps).
    - Running custom shell scripts.
- Why It Matters (Pentesting & Rooting):
    - Many root-based security tools (like Kali NetHunter, Metasploit modules, privilege escalation scripts) require BusyBox.
    - Lets you execute advanced commands that Android’s built-in toolbox can’t handle.
    - Common in custom recoveries (like TWRP) and rooted environments.


=> Root

Rooting:
- Rooting in Android means gaining privileged (root/administrator) access to the device’s operating system.
- By default, Android runs apps with limited permissions for security.
- Rooting unlocks the root user (superuser) account, similar to Administrator in Windows or root in Linux.
- Once rooted, you can modify system files, apps, and settings that are normally restricted.
- Rooting allows:
    - Remove pre-installed bloatware.
    - Install custom ROMs/kernels.
    - Run powerful apps that need system access (firewall apps, backup tools like Titanium Backup).
    - Customize performance (overclock/underclock CPU, battery tweaks).
    - Advanced theming and UI modifications.
- Risks of Rooting:
    - Security risk: Malicious apps could gain full control.
    - Warranty void: Most manufacturers void warranty if rooted.
    - Updates blocked: OTA updates may fail or break.
    - Bricking risk: Incorrect rooting can make the device unusable.
    - SafetyNet/Play Integrity fail: Some apps (banking, Google Pay, Netflix, etc.) may refuse to run.
- Root vs Bootloader Unlock:
    - Unlocking bootloader -> lets you flash custom images/ROMs.
    - Rooting -> gives you admin-level control inside Android.
    - Usually, you need an unlocked bootloader before rooting.
- Rooting Methods in Android:
    - Older Method – System Modifying Root:
        - Tools like SuperSU directly modified system partitions (/system) to insert the su binary (superuser command).
        - Risky, as it:
            - Permanently changed system files.
            - Broke OTA updates.
            - Could be detected easily by apps.
    - Modern Method – Systemless Root (Magisk):
        - Magisk is the most popular rooting tool today.
        - Works by modifying the boot image (not /system), then loading root at boot.
        - Benefits:
            - Systemless -> Doesn’t touch system partition, safer and easier to undo.
            - Magisk Modules -> Plugins to add features (e.g., ad-blocking, theming, performance tweaks).
            - Magisk Hide / Zygisk -> Lets you hide root from apps (like banking or Google Pay).
            - Easier to keep OTA updates working (patch boot.img after update).
- Steps (Typical Magisk Root Flow):
    - Unlock bootloader (required on most devices).
    - Extract the device’s boot.img (from firmware).
    - Patch the boot image using Magisk Manager app.
    - Flash the patched boot.img via fastboot/odin.
    - Device boots with Magisk -> root access enabled.
- Root Detection & Security:
    - Google uses SafetyNet / Play Integrity API to check for rooting.
    - Rooted devices may fail checks -> apps like banking, Netflix, UPI may not work.
    - Magisk tries to bypass these with hiding techniques.
- Technically, What Rooting Does in Android:
    - Linux Base:
        - Android is built on Linux.
        - In Linux/Unix systems, the root user (UID 0) has unrestricted permissions.
        - Normal Android apps run as isolated users (sandboxed with their own UID).
    - Root Binary (su):
        - Root account is disabled by default.
        - There’s no su binary in /system/bin or /system/xbin.
        - Apps always run inside a sandbox with their own UID, managed by Zygote + SELinux. This ensures apps can’t just escalate privileges.
        - Rooting installs the su binary (short for switch user) in the system.
        - This binary lets processes switch to UID 0 (root) when needed.
        - Example: An app calls su -> permission prompt -> app runs with root privileges.
    - Superuser Manager:
        - Tools like SuperSU or Magisk act as root access managers.
        - They intercept calls to su and ask the user whether to allow or deny.
        - Without this, any app could silently gain full control.
    - Systemless Root (Magisk):
        - Instead of modifying /system, Magisk patches the boot image.
        - During boot, Magisk injects itself into the process that starts Android (Zygote) to enable root.
        - This avoids breaking Verified Boot and allows easier updates.
    - Effect on Android Security:
        - With root enabled, apps can:
            - Mount partitions as read-write (/system, /vendor).
            - Modify SELinux state (permissive/enforcing).
            - Hook into system services (e.g., Location, Camera, Play Services).
        - Basically bypassing the sandboxing model of Android.

Magisk:
- Magisk is a modern systemless rooting framework for Android. It was created by topjohnwu and is the standard way to root devices today.
- Key Points:
    - Systemless Root
    - Unlike older methods (SuperSU) that modified /system, Magisk patches the boot image instead.
    - This means root is injected during boot, without touching system partitions.
- Benefits:
    - Easier OTA updates.
    - Can pass Verified Boot checks.
    - Easier to uninstall/disable.
- Magisk Manager:
    - Magisk Manager was the companion app for Magisk (the systemless root solution).
    - It provided a user interface to manage everything related to Magisk.
    - Today, its features are integrated directly into the Magisk app (the manager isn’t separate anymore).
- Root Access (su):
    - Magisk installs the su binary and manages root requests.
    - Apps that request root get a prompt, controlled by the Magisk app.
- Modules System:
    - Magisk supports modules (similar to plugins).
    - Modules can change system behavior, add features (ad-block, theming, performance tweaks).
- MagiskHide / Zygisk:
    - Magisk used to include MagiskHide to hide root from banking/DRM apps.
    - Modern Magisk uses Zygisk (Magisk inside Zygote) + DenyList for finer control.
- SafetyNet / Play Integrity Bypass:
    - Many apps check if the device is rooted.
    - Magisk tries to “mask” modifications so these apps continue working.
    - Success depends on Google’s updates and tricks used by the user.
