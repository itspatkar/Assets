
How to Defend Against Injection Attacks:

▪ SQL Injection Attacks
o Limit the length of user input.
o Use custom error messages.
o Monitor DB traffic using an IDS and a WAF.
o Disable commands such as xp_cmdshell.
o Isolate the database server and web server.
o Always use a method attribute set for POST and a low-privileged account for DB connections.
o Run a database service account with minimal rights.
o Move extended stored procedures to an isolated server.
o Use typesafe variables or functions such as isNumeric() to ensure typesafety.
o Validate and sanitize user inputs passed to the database.
o Avoid using dynamic SQL or constructing queries with user input.
o Use prepared statements, parameterized queries, or stored procedures to access the database.
o Display the minimum required information and use the “RemoteOnly” customErrors mode to display verbose error messages on the local machine.
o Perform proper escaping and character filtering to avoid special string characters and symbols such as single quotes (’).
o Always set the whitelist logically instead of the blacklist to avoid bad code.
o Use object–relational mapping (ORM) frameworks to make the conversion of SQL result sets into code objects more consistent.
o Use vulnerability scanners to identify possible entry points.
o Avoid using shared databases and the same account for multiple databases.
o Insist that the individuals involved in application development consider all the risks associated with SQL injection.
o Always use the latest versions of programming languages and technologies for development.
o Regularly update and patch applications and database servers.
o Harden OSes and applications by following the guidelines issued by vendors.
o Disable unnecessary functionalities of the database.
o Audit databases, logs, privileges, and binding terms regularly.
o Scan applications with a dynamic web vulnerability scanner to prevent code injection.
o Enumerate the authorized values within a conditional statement.
o Properly escape all user-supplied input. However, escaping should not be relied upon solely; it should be used in conjunction with other measures.
o Use Object-Relational Mapping (ORM) tools to automatically parameterize queries, reducing the risk of SQL injection.
o Grant the minimum necessary privileges to database accounts.
o Avoid using accounts with admin privileges for everyday application operations.


▪ Command Injection Flaws
The simplest way to defend against command injection flaws is to avoid them wherever possible. Some language-specific libraries perform identical functions for many shell commands and some system calls. These libraries do not contain the operating system shell interpreter and hence ignore maximum shell command problems. For those calls that must still be used, such as calls to backend databases, one must carefully validate the data to ensure that it does not contain malicious content. One can also arrange various requests in a pattern, which ensures that all the given parameters are treated as data instead of potentially executable content. Most systems call and use stored procedures with parameters that accept valid input strings to access a database or prepared statements to provide significant protection, ensuring that the supplied input is treated as data, which reduces but does not completely eliminate the risk involved in these external calls. One can always authorize the input to ensure the protection of the application in question. For this reason, it is important to use the least-privileged accounts to access a database to minimize the attack possibility.
Another robust measure against command injection is to run web applications with the privileges required to carry out their functions. Therefore, one should avoid running the web server as a root or accessing a database as a DBADMIN; otherwise, an attacker may be able to misuse administrative rights. The use of Java sandbox in the J2EE environment stops the execution of system commands. External commands are used to check the user information when he/she provides it. Create a mechanism for handling all possible errors, timeouts, or blockages during the calls. Check all the output, return, and error codes from the call to ensure that it performs as expected. Doing so allows users to determine whether something has gone wrong. Otherwise, an attack might occur and never be detected.
Some countermeasures against command injection flaws are as follows:
o Perform input validation.
o Escape dangerous characters.
o Use language-specific libraries that avoid problems due to shell commands.
o Perform input and output encoding.
o Use a safe API that avoids use of the interpreter entirely.
o Structure requests so that all supplied parameters are treated as data rather than potentially executable content.
o Use parameterized SQL queries.
o Use modular shell disassociation from the kernel.
o Use built-in library functions and avoid calling OS commands directly.
o Implement the least privileges to restrict the permissions to execute the OS commands.
o Avoid executing commands such as exec or system without proper validation and sanitization.
o Implement Python as a web framework instead of PHP for application development.
o Scan the applications with a dynamic web vulnerability scanner to prevent code injection.
o Enumerate the authorized values within a conditional statement.
o Use whitelists for allowed characters for input data.
o Utilize content security policy headers.
o Properly escape any input that will be used in shell commands to prevent injection. However, escaping should be used cautiously and not as the sole protection mechanism.
o Utilize security libraries and frameworks designed to handle command execution safely.
o Avoid using shell commands altogether when there are safer alternatives available within the programming language or framework.


▪ LDAP Injection Attacks
An LDAP injection attack is similar to an SQL injection: attacks on web applications co-opt the user input to create LDAP queries. Execution of malicious LDAP queries in the applications creates arbitrary queries that disclose information such as username and password, thus granting attackers unauthorized access and admin privileges. Some countermeasures against LDAP injection attacks are as follows:
o Perform type, pattern, and domain value validation on all input data.
o Make the LDAP filter as specific as possible.
o Validate and restrict the amount of data returned to the user.
o Implement tight access control on the data in the LDAP directory.
o Perform dynamic testing and source code analysis.
o Sanitize all the user-end inputs and escape any special characters.
o Avoid constructing LDAP search filters by concatenating strings.
o Use the AND filter to enforce restrictions on similar entries.
o Use LDAPS (LDAP over SSL) for encrypting and securing the communication on the web servers.
o Establish the LDAP binding account in the environment with the least privileges possible.
o Configure LDAP with bind authentication.
o Use SaaS-based testing services for combating LDAP injection attacks.
o Enforce RBAC mechanisms to restrict users access to LDAP directory objects.
o Monitor LDAP traffic and audit logs for suspicious or unauthorized LDAP query activities.
o Enable input validation to identify and intercept unauthorized input before incorporating into LDAP queries.
o Remove or escape any special characters that have special meaning in LDAP queries, such as *, (, ), \, &, and |.
o Properly escape special characters in user inputs that are included in LDAP queries. 
o Use libraries and frameworks that provide built-in protection against LDAP injection attacks.
o Follow the principle of least privilege by ensuring the LDAP service account used by the application has the minimum necessary privileges.
o Avoid using highly privileged accounts for LDAP queries.


▪ File Injection Attacks
Attackers use scripts to inject malicious files into the server, allowing them to exploit vulnerable parameters and execute malicious code. Such an attack allows temporary data theft and data manipulation, and it can provide attackers with persistent control of the server.
Some countermeasures against file injection attacks are as follows:
o Strongly validate the user input.
o Consider implementing a chroot jail.
o PHP: Disable allow_url_fopen and allow_url_include in php.ini.
o PHP: Disable register_globals and use E_STRICT to find uninitialized variables.
o PHP: Ensure that all file and stream functions (stream_*) are carefully vetted.
o Configure a separate database for the files and file paths, along with a unique identifier/ID for each path, to avoid MITM attacks.
o Avoid the execution of files in default directories and enable the auto-download header option for server-side communications.
o Check for PHP wrappers such as PHP filter and PHP ZIP to prevent access to sensitive files in the local server’s file system.
o Maintain a whitelist for the allowable file types and file size limits before execution.
o Employ a WAF security layer for monitoring the file injection attacks at the server.
o Use content security policy (CSP) headers to reduce the risk of XSS attacks which could facilitate file injection.
o Configure the application to disable remote file inclusion capabilities if not required.
o Limit the types of files that can be uploaded to a server.
o Ensure that the uploaded file content matches its declared file type by checking the file’s MIME type.
o Store uploaded files in a directory outside the web root to prevent direct access via a URL.
o Rename files on upload to avoid direct access using predictable naming conventions.
o Use secure random functions to generate file names or paths.
o Apply the principle of least privilege by ensuring that the application and users have the minimum necessary permissions to files and directories.
o Use secure methods to construct file paths, avoiding concatenation of user inputs with file paths.
o Implement file size limits to prevent denial-of-service (DoS) attacks by uploading excessively large files. Validate the file size both on the client side and the server side.
o Use antivirus or anti-malware scanners to check uploaded files for malicious content. Integrate these scanners into the file upload handling process.


▪ Server-Side JS Injection
o Ensure that user inputs are strictly validated on the server side before processing.
o Sanitize inputs to remove or escape characters that can be used in JS injection (e.g., <, >, &, |, ;).
o Avoid using the eval() function to parse the user input.
o Never use commands having identical effects, such as setTimeOut(), setInterval(), and Function().
o Use JSON.parse() instead of eval() to parse the JSON input.
o Make sure to include “use strict” at the beginning of the function to enable the strict mode inside the function scope.
o Ensure that only short alphanumeric strings are accepted as user input.
o Do not use code serialization.
o Use context-sensitive escaping features in template engines.
o Execute user-supplied code in a sandboxed environment, isolated from the server’s execution environment and sensitive data.
o Use parameterized queries or prepared statements to avoid injecting JS code into SQL queries.
o Implement CSP headers to restrict sources from which scripts can be loaded and executed.
o Properly escape and encode data before inserting it into JavaScript contexts.
o Use libraries or built-in functions to escape characters that can break out of the context and execute unintended code.
o Disable or limit the use of potentially dangerous features in the server-side environment, such as inline scripts or dynamic code evaluation.


▪ Server-Side Include Injection
o Validate the user input and ensure that it does not include characters used in SSI directives.
o Apply HTML encoding to the user input before executing it in the web pages.
o Ensure that directives are confined only to the web pages where they are required.
o Avoid using pages with file name extensions such as .stm, .shtm, and .shtml to prevent attacks.
o Implement SUExec for the execution of pages as the file owner.
o Configure the global access.conf file using OPTIONS IncludesNOEXEC to restrict the execution of SSI inside the directories.
o Limit the use of SSI directives to only trusted and necessary parts of the application.
o Configure the server to disallow SSI directives in user-controlled content or inputs.
o Properly escape any user inputs that might be included in SSI directives. Remove or encode characters such as <!--#, which are used to initiate SSI directives.


▪ Server-Side Template Injection
o Do not create templates from user inputs or pass user inputs as parameters into the templates.
o Review the template engine’s documentation for hardening tips.
o Execute the template inside a sandboxed environment.
o Utilize security features provided by the template engine, such as sandboxing or limited execution contexts. Example in Jinja2 (Python): from jinja2.sandbox import SandboxedEnvironment env = SandboxedEnvironment()
o Consider loading static template files wherever possible.
o Ensure that dynamic data are passed to a template using the template engine’s built-in functionality.
o Use predefined payloads along with in-built template expressions to examine the server responses periodically.
o Ensure that the template strings and variables are never combined.
o Properly escape user inputs before including them in templates to prevent injection. Use built-in template engine functions or libraries to handle escaping.
o Use template engines that automatically escape user inputs and provide security features to prevent injection. Examples include Jinja2 for Python, Handlebars for JavaScript, and Thymeleaf for Java.
o Avoid using template engines that support dynamic code execution or disable such features if not needed.
o Refrain from using constructs that allow execution of arbitrary code within templates.
o Apply contextual encoding to user inputs based on where they will be used in the template (e.g., HTML, JavaScript, URL).
o Use the appropriate encoding functions provided by the template engine.
o Harden the configuration of the template engine to minimize the risk of SSTI.
o Disable features that allow direct execution of code within templates if not required.


▪ Log Injection
o Pass log codes instead of messages through parameters.
o Use correct error codes and easily recognizable error messages.
o Avoid using API calls to log actions due to their visibility in browser network calls.
o Make sure to pass user IDs or publicly non-identifiable inputs as the parameters at logging endpoints.
o Validate inputs at both the server side and the client side and sanitize and replace the malicious characters.
o Examine the application carefully for any vulnerabilities that are used to render logs.
o Separate legitimate and fake log entries by using a prefix for every log entry with additional metadata.
o Restrict access to log files to authorized personnel only.
o Use file permissions and access control lists (ACLs) to protect log files from unauthorized access and modification.
o Control execution flow by using proper synchronization.
o Scan log injection vulnerabilities proactively with static analysis tools.
o Avoid viewing logs with tools having the ability to interpret control characters within a file.
o Use structured formats such as JSON or XML for logging. These formats make it harder to inject malicious content.
o Implement regular expressions to detect and block potentially harmful sequences in log entries, such as script tags or SQL code.
o Continuously monitor log files for signs of tampering or unusual entries.
o Use logging libraries to automatically handle input sanitization.
o Encrypt log files or log messages to protect sensitive information from being exposed.
o Implement log rotation to manage log file sizes and ensure old logs are archived.
o Use cryptographic checksums or hashes to verify the integrity of log files and detect tampering.
o Use well-established logging libraries that provide built-in mechanisms for escaping and sanitizing log entries. Examples include Log4j for Java, Winston for Node.js, and the logging module for Python.
o Use centralized logging solutions to aggregate logs from multiple sources and provide a unified view of log data.


▪ HTML Injection
o Validate all the user inputs to remove the HTML-syntax substrings from user-supplied text.
o Check the inputs for unwanted script or HTML code such as <script></script>, <html></html>.
o Employ security solutions that avoid false positives and detect possible injections.
o Ensure that user outputs are also encoded, examined, and validated along with user inputs by maintaining a complete data validation process.
o Educate the developer teams along with the security teams regarding the most prevalent HTML injection attacks and its preventive measures.
o Enable the HttpOnly flag on the server side to ensure that all the cookies generated by the application are not available to the client user.
o Use safe DOM manipulation techniques and libraries (e.g., jQuery's .text() instead of .html()) to dynamically update HTML content.
o Remove or escape any potentially dangerous characters from user inputs, such as <, >, &, ", and '.
o Utilize libraries specifically designed for input sanitization, such as OWASP Java HTML Sanitizer or DOMPurify for JavaScript.
o Use template engines that automatically escape user inputs to prevent HTML injection. Examples include Handlebars for JavaScript, Thymeleaf for Java, and Jinja2 for Python.
o Avoid dynamically generating or manipulating HTML with user inputs directly within the code.
o Use safe methods provided by the framework or library to update the DOM.
o Configure the web server to enforce strict MIME type checking to prevent the browser from interpreting files as HTML if they are not intended to be.


▪ CRLF Injection
o Use any function to encode CRLF special characters and avoid using the user input in the response headers.
o Replace instances of %0d and %0a in URL-encoded data, and \r and \n in standard input.
o Update the version of the programming language that disallows the injection of CR (carriage return) and LF (line feed) characters.
o Rewrite the code so that the user’s content is not directly used in the HTTP stream.
o Check and remove any newline strings in the content before passing it to the HTTP header.
o Encrypt the data that is passed to the HTTP headers to hide the CR and LF codes.
o Disable unwanted headers.
o Configure XSSUrlFilter in the web application to prevent CRLF injection attacks.
o Utilize tools such as htmlcleaner (http://htmlcleaner.sourceforge.net) to remove script tags and defend against CRLF injection attacks.
o Utilize safe APIs and libraries for handling HTTP responses to prevent unintentional injection of CRLF sequences.
o Ensure all user inputs conform to expected formats and types. Use whitelisting to allow only acceptable input values.
o Use language-specific libraries and functions to set HTTP headers, ensuring that they properly handle CRLF characters.
o Do not directly include user inputs in HTTP headers. Validate and sanitize any data that must be included.
o Properly escape CRLF characters when including user inputs in logs, HTTP headers, or any other context where CRLF could be interpreted as a command separator.
o Leverage security features provided by web frameworks that automatically handle header setting and prevent injection. Examples include Django for Python and Spring for Java.


▪ XSS Attacks
XSS is another type of input validation attacks that target the flawed input validation mechanism of web applications for the purpose of malicious activities. Attackers embed a malicious script into web application input gates, which allows them to bypass the security measures imposed by the applications. Some countermeasures against XSS attacks are as follows:
o Validate all headers, cookies, query strings, form fields, and hidden fields (i.e., all parameters) against a rigorous specification.
o Use testing tools extensively during the design phase to eliminate such XSS holes in the application before it goes into use.
o Use a web application firewall to block the execution of a malicious script.
o Convert all non-alphanumeric characters into HTML character entities before displaying the user input in search engines and forums.
o Encode the input and output and filter metacharacters in the input.
o Check the website’s URL thoroughly even if it has HTTPS.
o Filtering the script output can also defeat XSS vulnerabilities by preventing them from being transmitted to users.
o Deploy public key infrastructure (PKI) for authentication, which checks to ascertain that the script introduced is actually authenticated.
o Implement a stringent security policy.
o Web servers, application servers, and web application environments are vulnerable to cross-site scripting. It is difficult to identify and remove XSS flaws from web applications. The best way to find flaws is to perform a security review of the code and search in all the places where the input from an HTTP request comes as an output through HTML.
o Attacker uses a variety of HTML tags to transmit a malicious JavaScript. Nessus, Nikto, and other tools can help to some extent in scanning websites for these flaws. If the scanning discovers a vulnerability in a website, it is highly likely to be vulnerable to other attacks.
o Review the website code to defend against XSS attacks. Check the robustness of the code by reviewing it and comparing it against exact specifications. Check the following areas: headers, cookies, query string form fields, and hidden fields. During the validation process, there must be no attempt to recognize the active content, either by removing the filter or by sanitizing it.
o There are many ways to encode known filters for active content. A “positive security policy” is highly recommended, which specifies what is allowed and what must be removed. Negative or attack signature-based policies are difficult to maintain, as they are incomplete.
o Input fields should be limited to a maximum size since most script attacks need several characters to initiate.
o Implement Content Security Policy (CSP) to prevent the browser from executing XSS attacks.
o Escape untrusted HTTP request data built on the context in the HTML output to resolve Reflected and Stored XSS vulnerabilities.
o Employ context-sensitive encoding when altering the browser document on the client side, which acts against the DOM-XSS.
o Use session IDs and timestamps to prevent attackers from accessing client account information using session cookies.
o Employ automated VAPT tools during the source-code development phase of a web application to ensure that the application is free of known vulnerabilities.
o Use browsers that are capable of in-built security filtering from the client side to obstruct the execution of malicious scripts.
o Deploy WAFs or anti-XSS filters to automatically detect and block malicious XSS payloads.
o Utilize safe DOM manipulation techniques and libraries to dynamically update HTML content without introducing XSS vulnerabilities.
o Encode data before displaying it on a web page to prevent it from being interpreted as executable code.
o Use appropriate encoding based on the context where the data will be inserted, such as HTML, JavaScript, CSS, or URL encoding. For example, in Java: String safeInput = StringEscapeUtils.escapeHtml4(userInput);
o Use frameworks and libraries that automatically handle escaping and sanitization. Examples include Django for Python, Ruby on Rails for Ruby, and React for JavaScript.
o Avoid using inline JavaScript, inline event handlers, and eval() to minimize the risk of script injection. Use external scripts and event listeners instead.
o Apply appropriate encoding based on the context where user data will be placed: 
• HTML: Use HTML entity encoding. 
• JavaScript: Use JavaScript escaping. 
• URL: Use URL encoding. 
• CSS: Use CSS escaping.
